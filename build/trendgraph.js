(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["trendgraph"] = factory();
	else
		root["trendgraph"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/trendgraph.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/billboard.js/dist/billboard.css":
/*!******************************************************!*\
  !*** ./node_modules/billboard.js/dist/billboard.css ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../css-loader/dist/cjs.js!./billboard.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/billboard.js/dist/billboard.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/billboard.js/dist/billboard.js":
/*!*****************************************************!*\
  !*** ./node_modules/billboard.js/dist/billboard.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*!
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * 
 * billboard.js, JavaScript chart library
 * https://naver.github.io/billboard.js/
 * 
 * @version 1.12.11
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/index.js"), __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js"), __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js"), __webpack_require__(/*! d3-axis */ "./node_modules/d3-axis/src/index.js"), __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/index.js"), __webpack_require__(/*! d3-brush */ "./node_modules/d3-brush/src/index.js"), __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/index.js"), __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/index.js"), __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/index.js"), __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js"), __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js"), __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js"), __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/index.js"));
	else { var i, a; }
})(this, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__, __WEBPACK_EXTERNAL_MODULE__4__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__6__, __WEBPACK_EXTERNAL_MODULE__7__, __WEBPACK_EXTERNAL_MODULE__8__, __WEBPACK_EXTERNAL_MODULE__9__, __WEBPACK_EXTERNAL_MODULE__10__, __WEBPACK_EXTERNAL_MODULE__11__, __WEBPACK_EXTERNAL_MODULE__12__, __WEBPACK_EXTERNAL_MODULE__13__, __WEBPACK_EXTERNAL_MODULE__14__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1);
module.exports = __webpack_require__(15);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__2__;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__3__;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__4__;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__5__;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__6__;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__7__;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__8__;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__9__;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__10__;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__11__;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__12__;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__13__;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__14__;

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "bb", function() { return /* binding */ bb; });

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
// EXTERNAL MODULE: external {"commonjs":"d3-time-format","commonjs2":"d3-time-format","amd":"d3-time-format","root":"d3"}
var external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_ = __webpack_require__(2);

// EXTERNAL MODULE: external {"commonjs":"d3-selection","commonjs2":"d3-selection","amd":"d3-selection","root":"d3"}
var external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_ = __webpack_require__(3);

// EXTERNAL MODULE: external {"commonjs":"d3-transition","commonjs2":"d3-transition","amd":"d3-transition","root":"d3"}
var external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_ = __webpack_require__(4);

// EXTERNAL MODULE: external {"commonjs":"d3-axis","commonjs2":"d3-axis","amd":"d3-axis","root":"d3"}
var external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_ = __webpack_require__(5);

// EXTERNAL MODULE: external {"commonjs":"d3-scale","commonjs2":"d3-scale","amd":"d3-scale","root":"d3"}
var external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_ = __webpack_require__(6);

// CONCATENATED MODULE: ./src/config/classes.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * CSS class names definition
 * @private
 */
/* harmony default export */ var config_classes = ({
  arc: "bb-arc",
  arcLabelLine: "bb-arc-label-line",
  arcs: "bb-arcs",
  area: "bb-area",
  areas: "bb-areas",
  axis: "bb-axis",
  axisX: "bb-axis-x",
  axisXLabel: "bb-axis-x-label",
  axisY: "bb-axis-y",
  axisY2: "bb-axis-y2",
  axisY2Label: "bb-axis-y2-label",
  axisYLabel: "bb-axis-y-label",
  bar: "bb-bar",
  bars: "bb-bars",
  brush: "bb-brush",
  button: "bb-button",
  buttonZoomReset: "bb-zoom-reset",
  chart: "bb-chart",
  chartArc: "bb-chart-arc",
  chartArcs: "bb-chart-arcs",
  chartArcsBackground: "bb-chart-arcs-background",
  chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
  chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
  chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
  chartArcsTitle: "bb-chart-arcs-title",
  chartArcsGaugeTitle: "bb-chart-arcs-gauge-title",
  chartBar: "bb-chart-bar",
  chartBars: "bb-chart-bars",
  chartLine: "bb-chart-line",
  chartLines: "bb-chart-lines",
  chartRadar: "bb-chart-radar",
  chartRadars: "bb-chart-radars",
  chartText: "bb-chart-text",
  chartTexts: "bb-chart-texts",
  circle: "bb-circle",
  circles: "bb-circles",
  colorPattern: "bb-color-pattern",
  colorScale: "bb-colorscale",
  defocused: "bb-defocused",
  dragarea: "bb-dragarea",
  empty: "bb-empty",
  eventRect: "bb-event-rect",
  eventRects: "bb-event-rects",
  eventRectsMultiple: "bb-event-rects-multiple",
  eventRectsSingle: "bb-event-rects-single",
  focused: "bb-focused",
  gaugeValue: "bb-gauge-value",
  grid: "bb-grid",
  gridLines: "bb-grid-lines",
  legendBackground: "bb-legend-background",
  legendItem: "bb-legend-item",
  legendItemEvent: "bb-legend-item-event",
  legendItemFocused: "bb-legend-item-focused",
  legendItemHidden: "bb-legend-item-hidden",
  legendItemPoint: "bb-legend-item-point",
  legendItemTile: "bb-legend-item-tile",
  level: "bb-level",
  levels: "bb-levels",
  line: "bb-line",
  lines: "bb-lines",
  region: "bb-region",
  regions: "bb-regions",
  selectedCircle: "bb-selected-circle",
  selectedCircles: "bb-selected-circles",
  shape: "bb-shape",
  shapes: "bb-shapes",
  stanfordElements: "bb-stanford-elements",
  stanfordLine: "bb-stanford-line",
  stanfordLines: "bb-stanford-lines",
  stanfordRegion: "bb-stanford-region",
  stanfordRegions: "bb-stanford-regions",
  target: "bb-target",
  text: "bb-text",
  texts: "bb-texts",
  title: "bb-title",
  tooltip: "bb-tooltip",
  tooltipContainer: "bb-tooltip-container",
  tooltipName: "bb-tooltip-name",
  xgrid: "bb-xgrid",
  xgridFocus: "bb-xgrid-focus",
  xgridLine: "bb-xgrid-line",
  xgridLines: "bb-xgrid-lines",
  xgrids: "bb-xgrids",
  ygrid: "bb-ygrid",
  ygridFocus: "bb-ygrid-focus",
  ygridLine: "bb-ygrid-line",
  ygridLines: "bb-ygrid-lines",
  ygrids: "bb-ygrids",
  zoomBrush: "bb-zoom-brush",
  zoomRect: "bb-zoom-rect",
  EXPANDED: "_expanded_",
  SELECTED: "_selected_",
  INCLUDED: "_included_",
  TextOverlapping: "text-overlapping"
});
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}
// EXTERNAL MODULE: external {"commonjs":"d3-brush","commonjs2":"d3-brush","amd":"d3-brush","root":"d3"}
var external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_ = __webpack_require__(7);

// CONCATENATED MODULE: ./src/internals/browser.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Window object
 * @module
 * @ignore
 */

/* eslint-disable no-new-func, no-undef */
var win = function () {
  var def = function (o) {
    return typeof o !== "undefined" && o;
  };

  return def(self) || def(window) || def(global) || def(globalThis) || Function("return this")();
}(),
    browser_doc = win && win.document;
/* eslint-enable no-new-func, no-undef */



// CONCATENATED MODULE: ./src/internals/util.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */





var isValue = function (v) {
  return v || v === 0;
},
    isFunction = function (v) {
  return typeof v === "function";
},
    isString = function (v) {
  return typeof v === "string";
},
    isNumber = function (v) {
  return typeof v === "number";
},
    isUndefined = function (v) {
  return typeof v === "undefined";
},
    isDefined = function (v) {
  return typeof v !== "undefined";
},
    isBoolean = function (v) {
  return typeof v === "boolean";
},
    ceil10 = function (v) {
  return Math.ceil(v / 10) * 10;
},
    asHalfPixel = function (n) {
  return Math.ceil(n) + .5;
},
    diffDomain = function (d) {
  return d[1] - d[0];
},
    isObjectType = function (v) {
  return _typeof(v) === "object";
},
    isEmpty = function (o) {
  return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0 || isNumber(o) && isNaN(o);
},
    notEmpty = function (o) {
  return !isEmpty(o);
},
    isArray = function (arr) {
  return arr && arr.constructor === Array;
},
    isObject = function (obj) {
  return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
},
    getOption = function (options, key, defaultValue) {
  return isDefined(options[key]) ? options[key] : defaultValue;
},
    util_hasValue = function (dict, value) {
  var found = !1;
  return Object.keys(dict).forEach(function (key) {
    return dict[key] === value && (found = !0);
  }), found;
},
    callFn = function (fn) {
  for (var isFn = isFunction(fn), _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

  return isFn && fn.call.apply(fn, args), isFn;
},
    sanitise = function (str) {
  return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
},
    setTextValue = function (node, text) {
  var dy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [-1, 1],
      toMiddle = !!(arguments.length > 3 && arguments[3] !== undefined) && arguments[3];
  if (node && isString(text)) if (text.indexOf("\n") === -1) node.text(text);else {
    var diff = [node.text(), text].map(function (v) {
      return v.replace(/[\s\n]/g, "");
    });

    if (diff[0] !== diff[1]) {
      var multiline = text.split("\n"),
          len = toMiddle ? multiline.length - 1 : 1;
      node.html(""), multiline.forEach(function (v, i) {
        node.append("tspan").attr("x", 0).attr("dy", "".concat(i === 0 ? dy[0] * len : dy[1], "em")).text(v);
      });
    }
  }
},
    getRectSegList = function (path) {
  /*
   * seg1 ---------- seg2
   *   |               |
   *   |               |
   *   |               |
   * seg0 ---------- seg3
   * */
  var _path$getBBox = path.getBBox(),
      x = _path$getBBox.x,
      y = _path$getBBox.y,
      width = _path$getBBox.width,
      height = _path$getBBox.height;

  return [{
    x: x,
    y: y + height
  }, // seg0
  {
    x: x,
    y: y
  }, // seg1
  {
    x: x + width,
    y: y
  }, // seg2
  {
    x: x + width,
    y: y + height
  } // seg3
  ];
},
    getPathBox = function (path) {
  var _path$getBoundingClie = path.getBoundingClientRect(),
      width = _path$getBoundingClie.width,
      height = _path$getBoundingClie.height,
      items = getRectSegList(path),
      x = items[0].x,
      y = Math.min(items[0].y, items[1].y);

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
},
    getBrushSelection = function (ctx) {
  var selection = null,
      event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
      main = ctx.context || ctx.main;
  return event && event.constructor.name === "BrushEvent" ? selection = event.selection : main && (selection = main.select(".".concat(config_classes.brush)).node()) && (selection = Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection)), selection;
},
    getBoundingRect = function (node) {
  return node.rect || (node.rect = node.getBoundingClientRect());
},
    getRandom = function () {
  var asStr = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0];
  return Math.random() + (asStr ? "" : 0);
},
    brushEmpty = function (ctx) {
  var selection = getBrushSelection(ctx);
  return !selection || selection[0] === selection[1];
},
    extend = function () {
  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      source = arguments.length > 1 ? arguments[1] : undefined;

  for (var p in source) target[p] = source[p];

  return target;
},
    capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
},
    toArray = function (v) {
  return [].slice.call(v);
},
    getCssRules = function (styleSheets) {
  var rules = [];
  return styleSheets.forEach(function (sheet) {
    try {
      sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
    } catch (e) {
      console.error("Error while reading rules from ".concat(sheet.href, ": ").concat(e.toString()));
    }
  }), rules;
},
    getTranslation = function (node) {
  var transform = node ? node.transform : null,
      baseVal = transform && transform.baseVal;
  return baseVal && baseVal.numberOfItems ? baseVal.getItem(0).matrix : {
    a: 0,
    b: 0,
    c: 0,
    d: 0,
    e: 0,
    f: 0
  };
},
    getUnique = function (data) {
  var isDate = data[0] instanceof Date,
      d = (isDate ? data.map(Number) : data).filter(function (v, i, self) {
    return self.indexOf(v) === i;
  });
  return isDate ? d.map(function (v) {
    return new Date(v);
  }) : d;
},
    mergeArray = function (arr) {
  return arr && arr.length ? arr.reduce(function (p, c) {
    return p.concat(c);
  }) : [];
},
    mergeObj = function (_mergeObj) {
  function mergeObj() {
    return _mergeObj.apply(this, arguments);
  }

  return mergeObj.toString = function () {
    return _mergeObj.toString();
  }, mergeObj;
}(function (target) {
  for (var _len2 = arguments.length, objectN = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) objectN[_key2 - 1] = arguments[_key2];

  if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;
  var source = objectN.shift();
  return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
    var value = source[key];
    isObject(value) ? (!target[key] && (target[key] = {}), target[key] = mergeObj(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
  }), mergeObj.apply(void 0, [target].concat(objectN));
}),
    sortValue = function (data) {
  var fn,
      isAsc = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1];
  return data[0] instanceof Date ? fn = isAsc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  } : isAsc && !data.every(isNaN) ? fn = function (a, b) {
    return a - b;
  } : !isAsc && (fn = function (a, b) {
    return a > b && -1 || a < b && 1 || a === b && 0;
  }), data.concat().sort(fn);
},
    getMinMax = function (type, data) {
  var res = data.filter(function (v) {
    return notEmpty(v);
  });
  return res.length ? isNumber(res[0]) ? res = Math[type].apply(Math, _toConsumableArray(res)) : res[0] instanceof Date && (res = sortValue(res, type === "min")[0]) : res = undefined, res;
},
    getRange = function (start, end) {
  for (var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1, res = [], n = Math.max(0, Math.ceil((end - start) / step)) | 0, i = start; i < n; i++) res.push(start + i * step);

  return res;
},
    emulateEvent = {
  mouse: function () {
    var getParams = function () {
      return {
        bubbles: !1,
        cancelable: !1,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0
      };
    };

    try {
      return new MouseEvent("t"), function (el, eventType) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getParams();
        el.dispatchEvent(new MouseEvent(eventType, params));
      };
    } catch (e) {
      // Polyfills DOM4 MouseEvent
      return function (el, eventType) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getParams(),
            mouseEvent = browser_doc.createEvent("MouseEvent");
        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, win, 0, // the event's mouse click count
        params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), el.dispatchEvent(mouseEvent);
      };
    }
  }(),
  touch: function touch(el, eventType, params) {
    var touchObj = new Touch(mergeObj({
      identifier: Date.now(),
      target: el,
      radiusX: 2.5,
      radiusY: 2.5,
      rotationAngle: 10,
      force: .5
    }, params));
    el.dispatchEvent(new TouchEvent(eventType, {
      cancelable: !0,
      bubbles: !0,
      shiftKey: !0,
      touches: [touchObj],
      targetTouches: [],
      changedTouches: [touchObj]
    }));
  }
},
    tplProcess = function (tpl, data) {
  var res = tpl;

  for (var x in data) res = res.replace(new RegExp("{=".concat(x, "}"), "g"), data[x]);

  return res;
};


// CONCATENATED MODULE: ./src/axis/AxisRendererHelper.js





/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */



var AxisRendererHelper_AxisRendererHelper = /*#__PURE__*/function () {
  function AxisRendererHelper(owner) {
    _classCallCheck(this, AxisRendererHelper);

    var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])(),
        config = owner.config,
        params = owner.params;
    this.owner = owner, this.config = config, this.scale = scale, (config.noTransition || !params.config.transition_duration) && (config.withoutTransition = !0), config.range = scale.rangeExtent ? scale.rangeExtent() : this.scaleExtent((params.orgXScale || scale).range());
  }
  /**
   * Compute a character dimension
   * @param {d3.selection} node
   * @return {{w: number, h: number}}
   * @private
   */


  return _createClass(AxisRendererHelper, [{
    key: "getTickTransformSetter",

    /**
     * Get tick transform setter function
     * @param {String} id Axis id
     * @private
     */
    value: function getTickTransformSetter(id) {
      var config = this.config,
          fn = id === "x" ? function (value) {
        return "translate(".concat(value + config.tickOffset, ",0)");
      } : function (value) {
        return "translate(0,".concat(value, ")");
      };
      return function (selection, scale) {
        selection.attr("transform", function (d) {
          return fn(Math.ceil(scale(d)));
        });
      };
    }
  }, {
    key: "scaleExtent",
    value: function scaleExtent(domain) {
      var start = domain[0],
          stop = domain[domain.length - 1];
      return start < stop ? [start, stop] : [stop, start];
    }
  }, {
    key: "generateTicks",
    value: function generateTicks(scale, isYAxes) {
      var tickStepSize = this.owner.params.tickStepSize,
          ticks = [];
      // When 'axis[y|y2].tick.stepSize' option is set
      if (isYAxes && tickStepSize) for (var _scale$domain = scale.domain(), _scale$domain2 = _slicedToArray(_scale$domain, 2), start = _scale$domain2[0], end = _scale$domain2[1], interval = start; interval <= end;) ticks.push(interval), interval += tickStepSize;else if (scale.ticks) ticks = scale.ticks.apply(scale, _toConsumableArray(this.config.tickArguments || [])).map(function (v) {
        return (// round the tick value if is number
          isString(v) && isNumber(v) && !isNaN(v) && Math.round(v * 10) / 10 || v
        );
      });else {
        for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

        ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
      }
      return ticks;
    }
  }, {
    key: "copyScale",
    value: function copyScale() {
      var newScale = this.scale.copy();
      return newScale.domain().length || newScale.domain(this.scale.domain()), newScale;
    }
  }, {
    key: "textFormatted",
    value: function textFormatted(v) {
      var tickFormat = this.config.tickFormat,
          value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
          formatted = tickFormat ? tickFormat(value) : value; // to round float numbers from 'binary floating point'
      // https://en.wikipedia.org/wiki/Double-precision_floating-point_format
      // https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand

      return isDefined(formatted) ? formatted : "";
    }
  }, {
    key: "transitionise",
    value: function transitionise(selection) {
      var config = this.config;
      return config.withoutTransition ? selection.interrupt() : selection.transition(config.transition);
    }
  }], [{
    key: "getSizeFor1Char",
    value: function getSizeFor1Char(node) {
      // default size for one character
      var size = {
        w: 5.5,
        h: 11.5
      };
      return node.empty() || node.select("text").text("0").call(function (el) {
        try {
          var _el$node$getBBox = el.node().getBBox(),
              width = _el$node$getBBox.width,
              height = _el$node$getBBox.height;

          width && height && (size.w = width, size.h = height);
        } catch (e) {} finally {
          el.text("");
        }
      }), this.getSizeFor1Char = function () {
        return size;
      }, size;
    }
  }]), AxisRendererHelper;
}();


// CONCATENATED MODULE: ./src/axis/AxisRenderer.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */




var AxisRenderer_AxisRenderer = /*#__PURE__*/function () {
  function AxisRenderer() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AxisRenderer);

    var config = {
      innerTickSize: 6,
      outerTickSize: params.outerTick ? 6 : 0,
      orient: "bottom",
      range: [],
      tickArguments: null,
      tickCentered: null,
      tickCulling: !0,
      tickFormat: null,
      tickLength: 9,
      tickOffset: 0,
      tickPadding: 3,
      tickValues: null,
      transition: null,
      noTransition: params.noTransition
    };
    config.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding, this.config = config, this.params = params, this.helper = new AxisRendererHelper_AxisRendererHelper(this);
  }
  /**
   * Create axis element
   * @param {d3.selection} g
   * @private
   */


  return _createClass(AxisRenderer, [{
    key: "create",
    value: function create(g) {
      var ctx = this,
          config = this.config,
          helper = this.helper,
          params = this.params,
          scale = helper.scale,
          orient = config.orient,
          splitTickText = this.splitTickText.bind(this),
          isLeftRight = /^(left|right)$/.test(orient),
          isTopBottom = /^(top|bottom)$/.test(orient),
          tickTransform = helper.getTickTransformSetter(isTopBottom ? "x" : "y"),
          axisPx = tickTransform === helper.axisX ? "y" : "x",
          sign = /^(top|left)$/.test(orient) ? -1 : 1,
          rotate = params.tickTextRotate;
      this.config.range = scale.rangeExtent ? scale.rangeExtent() : helper.scaleExtent((params.orgXScale || scale).range());
      var _config2 = config,
          innerTickSize = _config2.innerTickSize,
          tickLength = _config2.tickLength,
          range = _config2.range,
          name = params.name,
          tickTextPos = name && /^(x|y|y2)$/.test(name) ? params.config["axis_".concat(name, "_tick_text_position")] : {
        x: 0,
        y: 0
      },
          prefix = name === "subX" ? "subchart_axis_x" : "axis_".concat(name),
          axisShow = params.config["".concat(prefix, "_show")],
          tickShow = {
        tick: !!axisShow && params.config["".concat(prefix, "_tick_show")],
        text: !!axisShow && params.config["".concat(prefix, "_tick_text_show")]
      },
          $g = null; // // get the axis' tick position configuration

      g.each(function () {
        var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            scale0 = this.__chart__ || scale,
            scale1 = helper.copyScale();
        $g = g, this.__chart__ = scale1, config.tickOffset = params.isCategory ? Math.ceil((scale1(1) - scale1(0)) / 2) : 0;
        // update selection - data join
        var path = g.selectAll(".domain").data([0]); // enter + update selection

        if (path.enter().append("path").attr("class", "domain").merge(helper.transitionise(path)).attr("d", function () {
          var outerTickSized = config.outerTickSize * sign;
          return isTopBottom ? "M".concat(range[0], ",").concat(outerTickSized, "V0H").concat(range[1], "V").concat(outerTickSized) : "M".concat(outerTickSized, ",").concat(range[0], "H0V").concat(range[1], "H").concat(outerTickSized);
        }), tickShow.tick || tickShow.text) {
          // count of tick data in array
          var ticks = config.tickValues || helper.generateTicks(scale1, isLeftRight),
              tick = g.selectAll(".tick").data(ticks, scale1),
              tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
              tickExit = tick.exit().remove(); // update selection

          tick = tickEnter.merge(tick), tickShow.tick && tickEnter.append("line"), tickShow.text && tickEnter.append("text");
          var sizeFor1Char = AxisRendererHelper_AxisRendererHelper.getSizeFor1Char(tick),
              counts = [],
              tspan = tick.select("text").selectAll("tspan").data(function (d, index) {
            var split = params.tickMultiline ? splitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) : isArray(helper.textFormatted(d)) ? helper.textFormatted(d).concat() : [helper.textFormatted(d)];
            return counts[index] = split.length, split.map(function (splitted) {
              return {
                index: index,
                splitted: splitted
              };
            });
          });
          tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
            return d.splitted;
          }), tspan.attr("x", isTopBottom ? 0 : tickLength * sign).attr("dx", function () {
            var dx = 0;
            return /(top|bottom)/.test(orient) && rotate && (dx = 8 * Math.sin(Math.PI * (rotate / 180)) * (orient === "top" ? -1 : 1)), dx + (tickTextPos.x || 0);
          }()).attr("dy", function (d, i) {
            var dy = 0;
            return orient !== "top" && (dy = sizeFor1Char.h, i === 0 && (dy = isLeftRight ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : tickTextPos.y === 0 ? ".71em" : 0)), isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || ".71em";
          });
          var lineUpdate = tick.select("line"),
              textUpdate = tick.select("text");

          // Append <title> for tooltip display
          if (tickEnter.select("line").attr("".concat(axisPx, "2"), innerTickSize * sign), tickEnter.select("text").attr(axisPx, tickLength * sign), ctx.setTickLineTextPosition(lineUpdate, textUpdate), params.tickTitle) {
            var title = textUpdate.select("title");
            (title.empty() ? textUpdate.append("title") : title).text(function (index) {
              return params.tickTitle[index];
            });
          }

          if (scale1.bandwidth) {
            var x = scale1,
                dx = x.bandwidth() / 2;
            scale0 = function (d) {
              return x(d) + dx;
            }, scale1 = scale0;
          } else scale0.bandwidth ? scale0 = scale1 : tickTransform(tickExit, scale1);

          tickTransform(tickEnter, scale0), tickTransform(helper.transitionise(tick).style("opacity", "1"), scale1);
        }
      }), this.g = $g;
    }
    /**
     * Get tick x/y coordinate
     * @return {{x: number, y: number}}
     * @private
     */

  }, {
    key: "getTickXY",
    value: function getTickXY() {
      var config = this.config,
          pos = {
        x: 0,
        y: 0
      };
      return this.params.isCategory && (pos.x = config.tickCentered ? 0 : config.tickOffset, pos.y = config.tickCentered ? config.tickOffset : 0), pos;
    }
    /**
     * Get tick size
     * @param d
     * @return {number}
     * @private
     */

  }, {
    key: "getTickSize",
    value: function getTickSize(d) {
      var scale = this.helper.scale,
          config = this.config,
          innerTickSize = config.innerTickSize,
          range = config.range,
          tickPosition = scale(d) + (config.tickCentered ? 0 : config.tickOffset);
      return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
    }
    /**
     * Set tick's line & text position
     * @param lineUpdate
     * @param textUpdate
     * @param scale
     * @private
     */

  }, {
    key: "setTickLineTextPosition",
    value: function setTickLineTextPosition(lineUpdate, textUpdate) {
      var tickPos = this.getTickXY(),
          _this$config = this.config,
          innerTickSize = _this$config.innerTickSize,
          orient = _this$config.orient,
          tickLength = _this$config.tickLength,
          tickOffset = _this$config.tickOffset,
          rotate = this.params.tickTextRotate,
          textAnchorForText = function (r) {
        var value = ["start", "end"];
        return orient === "top" && value.reverse(), r ? r > 0 ? value[0] : value[1] : "middle";
      },
          textTransform = function (r) {
        return r ? "rotate(".concat(r, ")") : null;
      },
          yForText = function (r) {
        var r2 = r / (orient === "bottom" ? 15 : 23);
        return r ? 11.5 - 2.5 * r2 * (r > 0 ? 1 : -1) : tickLength;
      };

      orient === "bottom" ? (lineUpdate.attr("x1", tickPos.x).attr("x2", tickPos.x).attr("y2", this.getTickSize.bind(this)), textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "top" ? (lineUpdate.attr("x2", 0).attr("y2", -innerTickSize), textUpdate.attr("x", 0).attr("y", -yForText(rotate) * 2).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "left" ? (lineUpdate.attr("x2", -innerTickSize).attr("y1", tickPos.y).attr("y2", tickPos.y), textUpdate.attr("x", -tickLength).attr("y", tickOffset).style("text-anchor", "end")) : orient === "right" ? (lineUpdate.attr("x2", innerTickSize).attr("y2", 0), textUpdate.attr("x", tickLength).attr("y", 0).style("text-anchor", "start")) : void 0;
    } // this should be called only when category axis

  }, {
    key: "splitTickText",
    value: function splitTickText(d, scale, ticks, isLeftRight, charWidth) {
      function split(splitted, text) {
        for (var subtext, spaceIndex, textWidth, i = 1; i < text.length; i++) // if text width gets over tick width, split by space index or current index
        if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = charWidth * subtext.length, tickWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

        return splitted.concat(text);
      }

      var params = this.params,
          tickText = this.helper.textFormatted(d),
          splitted = isString(tickText) && tickText.indexOf("\n") > -1 ? tickText.split("\n") : [];
      if (splitted.length) return splitted;
      if (isArray(tickText)) return tickText;
      var tickWidth = params.tickWidth;
      return (!tickWidth || tickWidth <= 0) && (tickWidth = isLeftRight ? 95 : params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110), split(splitted, tickText + "");
    }
  }, {
    key: "scale",
    value: function scale(x) {
      return arguments.length ? (this.helper.scale = x, this) : this.helper.scale;
    }
  }, {
    key: "orient",
    value: function orient(x) {
      return arguments.length ? (this.config.orient = x in {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
      } ? x + "" : "bottom", this) : this.config.orient;
    }
  }, {
    key: "tickFormat",
    value: function tickFormat(format) {
      return arguments.length ? (this.config.tickFormat = format, this) : this.config.tickFormat;
    }
  }, {
    key: "tickCentered",
    value: function tickCentered(isCentered) {
      var config = this.config;
      return arguments.length ? (config.tickCentered = isCentered, this) : config.tickCentered;
    }
    /**
     * Return tick's offset value.
     * The value will be set for 'category' axis type.
     * @return {number}
     * @private
     */

  }, {
    key: "tickOffset",
    value: function tickOffset() {
      return this.config.tickOffset;
    }
    /**
     * Get tick interval count
     * @private
     * @param {Number} size Total data size
     * @return {number}
     */

  }, {
    key: "tickInterval",
    value: function tickInterval(size) {
      var interval;
      if (this.params.isCategory) interval = this.config.tickOffset * 2;else {
        var length = this.g.select("path.domain").node().getTotalLength() - this.config.outerTickSize * 2;
        interval = length / (size || this.g.selectAll("line").size());
      }
      return interval === Infinity ? 0 : interval;
    }
  }, {
    key: "ticks",
    value: function ticks() {
      for (var config = this.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

      return args.length ? (config.tickArguments = toArray(args), this) : config.tickArguments;
    }
  }, {
    key: "tickCulling",
    value: function tickCulling(culling) {
      var config = this.config;
      return arguments.length ? (config.tickCulling = culling, this) : config.tickCulling;
    }
  }, {
    key: "tickValues",
    value: function tickValues(x) {
      var _this = this,
          config = this.config;

      if (isFunction(x)) config.tickValues = function () {
        return x(_this.helper.scale.domain());
      };else {
        if (!arguments.length) return config.tickValues;
        config.tickValues = x;
      }
      return this;
    }
  }, {
    key: "setTransition",
    value: function setTransition(t) {
      return this.config.transition = t, this;
    }
  }]), AxisRenderer;
}();


// CONCATENATED MODULE: ./src/axis/Axis.js




/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






var isHorizontal = function ($$, forHorizontal) {
  var isRotated = $$.config.axis_rotated;
  return forHorizontal ? isRotated : !isRotated;
},
    getAxisClassName = function (id) {
  return "".concat(config_classes.axis, " ").concat(config_classes["axis".concat(capitalize(id))]);
};

var Axis_Axis = /*#__PURE__*/function () {
  function Axis(owner) {
    _classCallCheck(this, Axis), this.owner = owner, this.setOrient();
  }

  return _createClass(Axis, [{
    key: "init",
    value: function init() {
      var _this = this,
          $$ = this.owner,
          config = $$.config,
          isRotated = config.axis_rotated,
          main = $$.main,
          target = ["x", "y"];

      config.axis_y2_show && target.push("y2"), $$.axesList = {}, target.forEach(function (v) {
        var classAxis = getAxisClassName(v),
            classLabel = config_classes["axis".concat(v.toUpperCase(), "Label")];
        $$.axes[v] = main.append("g").attr("class", classAxis).attr("clip-path", function () {
          var res = null;
          return v === "x" ? res = $$.clipPathForXAxis : v === "y" && config.axis_y_inner && (res = $$.clipPathForYAxis), res;
        }).attr("transform", $$.getTranslate(v)).style("visibility", config["axis_".concat(v, "_show")] ? "visible" : "hidden"), $$.axes[v].append("text").attr("class", classLabel).attr("transform", ["rotate(-90)", null][v === "x" ? +!isRotated : +isRotated]).style("text-anchor", function () {
          return _this.textAnchorForAxisLabel(v);
        }), _this.generateAxes(v);
      });
    }
    /**
     * Set axis orient according option value
     * @private
     */

  }, {
    key: "setOrient",
    value: function setOrient() {
      var $$ = this.owner,
          config = $$.config,
          isRotated = config.axis_rotated,
          yInner = config.axis_y_inner,
          y2Inner = config.axis_y2_inner;
      $$.xOrient = isRotated ? "left" : "bottom", $$.yOrient = isRotated ? yInner ? "top" : "bottom" : yInner ? "right" : "left", $$.y2Orient = isRotated ? y2Inner ? "bottom" : "top" : y2Inner ? "left" : "right", $$.subXOrient = isRotated ? "left" : "bottom";
    }
    /**
     * Generate axes
     * It's used when axis' axes option is set
     * @param {String} id Axis id
     * @private
     */

  }, {
    key: "generateAxes",
    value: function generateAxes(id) {
      var d3Axis,
          $$ = this.owner,
          config = $$.config,
          axes = [],
          axesConfig = config["axis_".concat(id, "_axes")],
          isRotated = config.axis_rotated;
      id === "x" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : id === "y" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : id === "y2" && (d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisTop"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisRight"]), axesConfig.length && axesConfig.forEach(function (v) {
        var tick = v.tick || {},
            scale = $$[id].copy();
        v.domain && scale.domain(v.domain), axes.push(d3Axis(scale).ticks(tick.count).tickFormat(tick.format || function (x) {
          return x;
        }).tickValues(tick.values).tickSizeOuter(tick.outer === !1 ? 0 : 6));
      }), $$.axesList[id] = axes;
    }
    /**
     * Update axes nodes
     * @private
     */

  }, {
    key: "updateAxes",
    value: function updateAxes() {
      var $$ = this.owner,
          config = $$.config;
      Object.keys($$.axesList).forEach(function (id) {
        var axesConfig = config["axis_".concat(id, "_axes")],
            scale = $$[id].copy(),
            range = scale.range();
        $$.axesList[id].forEach(function (v, i) {
          var axisRange = v.scale().range(); // adjust range value with the current
          // https://github.com/naver/billboard.js/issues/859

          range.every(function (v, i) {
            return v === axisRange[i];
          }) || v.scale().range(range);
          var className = "".concat(getAxisClassName(id), "-").concat(i + 1),
              g = $$.main.select(".".concat(className.replace(/\s/, ".")));
          g.empty() ? g = $$.main.append("g").attr("class", className).style("visibility", config["axis_".concat(id, "_show")] ? "visible" : "hidden").call(v) : (axesConfig[i].domain && scale.domain(axesConfig[i].domain), $$.xAxis.helper.transitionise(g).call(v.scale(scale))), g.attr("transform", $$.getTranslate(id, i + 1));
        });
      });
    } // called from : updateScales() & getMaxTickWidth()

  }, {
    key: "getAxis",
    value: function getAxis(name, scale, outerTick, noTransition, noTickTextRotate) {
      var $$ = this.owner,
          config = $$.config,
          isX = /^(x|subX)$/.test(name),
          type = isX ? "x" : name,
          isCategory = isX && $$.isCategorized(),
          orient = $$["".concat(name, "Orient")],
          tickFormat = isX ? $$.xAxisTickFormat : config["axis_".concat(name, "_tick_format")],
          tickTextRotate = noTickTextRotate ? 0 : $$.getAxisTickRotate(type),
          tickValues = isX ? $$.xAxisTickValues : $$["".concat(name, "AxisTickValues")],
          axisParams = mergeObj({
        outerTick: outerTick,
        noTransition: noTransition,
        config: config,
        name: name,
        tickTextRotate: tickTextRotate
      }, isX && {
        isCategory: isCategory,
        tickMultiline: config.axis_x_tick_multiline,
        tickWidth: config.axis_x_tick_width,
        tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
        orgXScale: $$.x
      });
      isX || (axisParams.tickStepSize = config["axis_".concat(type, "_tick_stepSize")]);
      var axis = new AxisRenderer_AxisRenderer(axisParams).scale(isX && $$.zoomScale || scale).orient(orient);
      isX && $$.isTimeSeries() && tickValues && !isFunction(tickValues) ? tickValues = tickValues.map(function (v) {
        return $$.parseDate(v);
      }) : !isX && $$.isTimeSeriesY() && (axis.ticks(config.axis_y_tick_time_value), tickValues = null), tickValues && axis.tickValues(tickValues), axis.tickFormat(tickFormat || !isX && $$.isStackNormalized() && function (x) {
        return "".concat(x, "%");
      }), isCategory && (axis.tickCentered(config.axis_x_tick_centered), isEmpty(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1));
      var tickCount = config["axis_".concat(type, "_tick_count")];
      return tickCount && axis.ticks(tickCount), axis;
    }
  }, {
    key: "updateXAxisTickValues",
    value: function updateXAxisTickValues(targets, axis) {
      var values,
          $$ = this.owner,
          config = $$.config,
          fit = config.axis_x_tick_fit,
          count = config.axis_x_tick_count;
      return (fit || count && fit) && (values = $$.mapTargetsToUniqueXs(targets), $$.isCategorized() && count > values.length && (count = values.length), values = this.generateTickValues(values, count, $$.isTimeSeries())), axis ? axis.tickValues(values) : $$.xAxis && ($$.xAxis.tickValues(values), $$.subXAxis.tickValues(values)), values;
    }
  }, {
    key: "getId",
    value: function getId(id) {
      var config = this.owner.config;
      return id in config.data_axes ? config.data_axes[id] : "y";
    }
  }, {
    key: "getXAxisTickFormat",
    value: function getXAxisTickFormat() {
      var format,
          $$ = this.owner,
          config = $$.config,
          tickFormat = config.axis_x_tick_format,
          isTimeSeries = $$.isTimeSeries(),
          isCategorized = $$.isCategorized();
      return tickFormat ? isFunction(tickFormat) ? format = tickFormat : isTimeSeries && (format = function (date) {
        return date ? $$.axisTimeFormat(tickFormat)(date) : "";
      }) : format = isTimeSeries ? $$.defaultAxisTimeFormat : isCategorized ? $$.categoryName : function (v) {
        return v < 0 ? v.toFixed(0) : v;
      }, isFunction(format) ? function (v) {
        return format.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
      } : format;
    }
  }, {
    key: "getTickValues",
    value: function getTickValues(id) {
      var $$ = this.owner,
          tickValues = $$.config["axis_".concat(id, "_tick_values")],
          axis = $$["".concat(id, "Axis")];
      return (isFunction(tickValues) ? tickValues() : tickValues) || (axis ? axis.tickValues() : undefined);
    }
  }, {
    key: "getLabelOptionByAxisId",
    value: function getLabelOptionByAxisId(id) {
      return this.owner.config["axis_".concat(id, "_label")];
    }
  }, {
    key: "getLabelText",
    value: function getLabelText(id) {
      var option = this.getLabelOptionByAxisId(id);
      return isString(option) ? option : option ? option.text : null;
    }
  }, {
    key: "setLabelText",
    value: function setLabelText(id, text) {
      var $$ = this.owner,
          config = $$.config,
          option = this.getLabelOptionByAxisId(id);
      isString(option) ? config["axis_".concat(id, "_label")] = text : option && (option.text = text);
    }
  }, {
    key: "getLabelPosition",
    value: function getLabelPosition(id, defaultPosition) {
      var isRotated = this.owner.config.axis_rotated,
          option = this.getLabelOptionByAxisId(id),
          position = isObjectType(option) && option.position ? option.position : defaultPosition[+!isRotated],
          has = function (v) {
        return !!~position.indexOf(v);
      };

      return {
        isInner: has("inner"),
        isOuter: has("outer"),
        isLeft: has("left"),
        isCenter: has("center"),
        isRight: has("right"),
        isTop: has("top"),
        isMiddle: has("middle"),
        isBottom: has("bottom")
      };
    }
  }, {
    key: "getAxisLabelPosition",
    value: function getAxisLabelPosition(id) {
      return this.getLabelPosition(id, id === "x" ? ["inner-top", "inner-right"] : ["inner-right", "inner-top"]);
    }
  }, {
    key: "getLabelPositionById",
    value: function getLabelPositionById(id) {
      return this.getAxisLabelPosition(id);
    }
  }, {
    key: "xForAxisLabel",
    value: function xForAxisLabel(id) {
      var $$ = this.owner,
          position = this.getAxisLabelPosition(id),
          x = position.isMiddle ? -$$.height / 2 : 0;
      return isHorizontal($$, id !== "x") ? x = position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width : position.isBottom && (x = -$$.height), x;
    }
  }, {
    key: "dxForAxisLabel",
    value: function dxForAxisLabel(id) {
      var $$ = this.owner,
          position = this.getAxisLabelPosition(id),
          dx = position.isBottom ? "0.5em" : "0";
      return isHorizontal($$, id !== "x") ? dx = position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop && (dx = "-0.5em"), dx;
    }
  }, {
    key: "textAnchorForAxisLabel",
    value: function textAnchorForAxisLabel(id) {
      var $$ = this.owner,
          position = this.getAxisLabelPosition(id),
          anchor = position.isMiddle ? "middle" : "end";
      return isHorizontal($$, id !== "x") ? anchor = position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom && (anchor = "start"), anchor;
    }
  }, {
    key: "dyForAxisLabel",
    value: function dyForAxisLabel(id) {
      var dy,
          $$ = this.owner,
          config = $$.config,
          isRotated = config.axis_rotated,
          isInner = this.getAxisLabelPosition(id).isInner,
          tickRotate = config["axis_".concat(id, "_tick_rotate")] ? $$.getHorizontalAxisHeight(id) : 0,
          maxTickWidth = this.getMaxTickWidth(id);

      if (id === "x") {
        var xHeight = config.axis_x_height;
        dy = isRotated ? isInner ? "1.2em" : -25 - maxTickWidth : isInner ? "-0.5em" : xHeight ? xHeight - 10 : tickRotate ? tickRotate - 10 : "3em";
      } else dy = {
        y: ["-0.5em", 10, "3em", "1.2em", 10],
        y2: ["1.2em", -20, "-2.2em", "-0.5em", 15]
      }[id], dy = isRotated ? isInner ? dy[0] : tickRotate ? tickRotate * (id === "y2" ? -1 : 1) - dy[1] : dy[2] : isInner ? dy[3] : (dy[4] + (config["axis_".concat(id, "_inner")] ? 0 : maxTickWidth + dy[4])) * (id === "y" ? -1 : 1);

      return dy;
    }
  }, {
    key: "getMaxTickWidth",
    value: function getMaxTickWidth(id, withoutRecompute) {
      var $$ = this.owner,
          config = $$.config,
          currentTickMax = $$.currentMaxTickWidths[id],
          maxWidth = 0;
      if (withoutRecompute || !config["axis_".concat(id, "_show")] || $$.filterTargetsToShow().length === 0) return currentTickMax.size;

      if ($$.svg) {
        var isYAxis = /^y2?$/.test(id),
            targetsToShow = $$.filterTargetsToShow($$.data.targets),
            scale = $$[id].copy().domain($$["get".concat(isYAxis ? "Y" : "X", "Domain")](targetsToShow, id)),
            domain = scale.domain();
        // do not compute if domain is same
        if (domain[0] === domain[1] && domain.every(function (v) {
          return v > 0;
        }) || isArray(currentTickMax.domain) && currentTickMax.domain[0] === currentTickMax.domain[1]) return currentTickMax.size;
        currentTickMax.domain = domain;
        var axis = this.getAxis(id, scale, !1, !1, !0),
            tickCount = config["axis_".concat(id, "_tick_count")],
            tickValues = config["axis_".concat(id, "_tick_values")];
        !tickValues && tickCount && axis.tickValues(this.generateTickValues(domain, tickCount, isYAxis ? $$.isTimeSeriesY() : $$.isTimeSeries())), isYAxis || this.updateXAxisTickValues(targetsToShow, axis);
        var dummy = $$.selectChart.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px");
        axis.create(dummy), dummy.selectAll("text").each(function (d, i) {
          var currentTextWidth = this.getBoundingClientRect().width;
          maxWidth = Math.max(maxWidth, currentTextWidth), id === "x" && ($$.currentMaxTickWidths.x.ticks[i] = currentTextWidth);
        }), dummy.remove();
      }

      return maxWidth > 0 && (currentTickMax.size = maxWidth), currentTickMax.size;
    }
  }, {
    key: "getXAxisTickTextY2Overflow",
    value: function getXAxisTickTextY2Overflow(defaultPadding) {
      var $$ = this.owner,
          config = $$.config,
          xAxisTickRotate = $$.getAxisTickRotate("x");

      if (($$.isCategorized() || $$.isTimeSeries()) && config.axis_x_tick_fit && !config.axis_x_tick_culling && !config.axis_x_tick_multiline && xAxisTickRotate > 0 && xAxisTickRotate < 90) {
        var widthWithoutCurrentPaddingLeft = $$.currentWidth - $$.getCurrentPaddingLeft(),
            maxOverflow = this.getXAxisTickMaxOverflow(xAxisTickRotate, widthWithoutCurrentPaddingLeft - defaultPadding),
            xAxisTickTextY2Overflow = Math.max(0, maxOverflow) + defaultPadding;
        // for display inconsistencies between browsers
        return Math.min(xAxisTickTextY2Overflow, widthWithoutCurrentPaddingLeft / 2);
      }

      return 0;
    }
  }, {
    key: "getXAxisTickMaxOverflow",
    value: function getXAxisTickMaxOverflow(xAxisTickRotate, widthWithoutCurrentPaddingLeft) {
      for (var $$ = this.owner, config = $$.config, isTimeSeries = $$.isTimeSeries(), tickTextWidths = $$.currentMaxTickWidths.x.ticks, tickCount = tickTextWidths.length, _this$x$padding = this.x.padding, left = _this$x$padding.left, right = _this$x$padding.right, maxOverflow = 0, remaining = tickCount - (isTimeSeries && config.axis_x_tick_fit ? .5 : 0), i = 0; i < tickCount; i++) {
        var tickIndex = i + 1,
            rotatedTickTextWidth = Math.cos(Math.PI * xAxisTickRotate / 180) * tickTextWidths[i],
            ticksBeforeTickText = tickIndex - (isTimeSeries ? 1 : .5) + left;

        // Skip ticks if there are no ticks before them
        if (!(ticksBeforeTickText <= 0)) {
          var tickLength = (widthWithoutCurrentPaddingLeft - rotatedTickTextWidth) / ticksBeforeTickText;
          maxOverflow = Math.max(maxOverflow, rotatedTickTextWidth - tickLength / 2 - ((remaining - tickIndex) * tickLength + right * tickLength));
        }
      }

      var tickOffset = 0;

      if (!isTimeSeries) {
        var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])().domain([left * -1, $$.getXDomainMax($$.data.targets) + 1 + right]).range([0, widthWithoutCurrentPaddingLeft - maxOverflow]);
        tickOffset = Math.ceil((scale(1) - scale(0)) / 2);
      }

      return maxOverflow + tickOffset;
    }
    /**
     * Get x Axis padding
     * @param {Number} tickCount Tick count
     * @return {Object} Padding object values with 'left' & 'right' key
     * @private
     */

  }, {
    key: "getXAxisPadding",
    value: function getXAxisPadding(tickCount) {
      var $$ = this.owner,
          padding = $$.config.axis_x_padding;

      if (isEmpty(padding) ? padding = {
        left: 0,
        right: 0
      } : (padding.left = padding.left || 0, padding.right = padding.right || 0), $$.isTimeSeries()) {
        var firstX = +$$.getXDomainMin($$.data.targets),
            lastX = +$$.getXDomainMax($$.data.targets),
            timeDiff = lastX - firstX,
            range = timeDiff + padding.left + padding.right,
            relativeTickWidth = timeDiff / tickCount / range,
            left = padding.left / range / relativeTickWidth || 0,
            _right = padding.right / range / relativeTickWidth || 0;

        padding = {
          left: left,
          right: _right
        };
      }

      return padding;
    }
  }, {
    key: "updateLabels",
    value: function updateLabels(withTransition) {
      var _this2 = this,
          $$ = this.owner,
          labels = {
        x: $$.main.select(".".concat(config_classes.axisX, " .").concat(config_classes.axisXLabel)),
        y: $$.main.select(".".concat(config_classes.axisY, " .").concat(config_classes.axisYLabel)),
        y2: $$.main.select(".".concat(config_classes.axisY2, " .").concat(config_classes.axisY2Label))
      };

      Object.keys(labels).filter(function (id) {
        return !labels[id].empty();
      }).forEach(function (v) {
        var node = labels[v];
        (withTransition ? node.transition() : node).attr("x", function () {
          return _this2.xForAxisLabel(v);
        }).attr("dx", function () {
          return _this2.dxForAxisLabel(v);
        }).attr("dy", function () {
          return _this2.dyForAxisLabel(v);
        }).text(function () {
          return _this2.getLabelText(v);
        });
      });
    }
  }, {
    key: "getPadding",
    value: function getPadding(padding, key, defaultValue, domainLength) {
      var p = isNumber(padding) ? padding : padding[key];
      return isValue(p) ? this.convertPixelsToAxisPadding(p, domainLength) : defaultValue;
    }
  }, {
    key: "convertPixelsToAxisPadding",
    value: function convertPixelsToAxisPadding(pixels, domainLength) {
      var $$ = this.owner,
          length = $$.config.axis_rotated ? $$.width : $$.height;
      return domainLength * (pixels / length);
    }
  }, {
    key: "generateTickValues",
    value: function generateTickValues(values, tickCount, forTimeSeries) {
      var tickValues = values;

      if (tickCount) {
        var targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount

        if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {
          var tickValue,
              isCategorized = this.owner.isCategorized(),
              count = targetCount - 2,
              start = values[0],
              end = values[values.length - 1];
          tickValues = [start];

          for (var i = 0; i < count; i++) tickValue = +start + (end - start) / (count + 1) * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : isCategorized ? Math.round(tickValue) : tickValue);

          tickValues.push(end);
        }
      }

      return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
        return a - b;
      })), tickValues;
    }
  }, {
    key: "generateTransitions",
    value: function generateTransitions(duration) {
      var $$ = this.owner,
          axes = $$.axes,
          _map = ["x", "y", "y2", "subx"].map(function (v) {
        var axis = axes[v];
        return axis && duration && (axis = axis.transition().duration(duration)), axis;
      }),
          _map2 = _slicedToArray(_map, 4),
          axisX = _map2[0],
          axisY = _map2[1],
          axisY2 = _map2[2],
          axisSubX = _map2[3];

      return {
        axisX: axisX,
        axisY: axisY,
        axisY2: axisY2,
        axisSubX: axisSubX
      };
    }
  }, {
    key: "redraw",
    value: function redraw(transitions, isHidden, isInit) {
      var $$ = this.owner,
          opacity = isHidden ? "0" : "1";
      ["x", "y", "y2", "subX"].forEach(function (id) {
        var axis = $$["".concat(id, "Axis")];
        axis && (!isInit && (axis.config.withoutTransition = !$$.config.transition_duration), $$.axes[id.toLowerCase()].style("opacity", opacity), axis.create(transitions["axis".concat(capitalize(id))]));
      }), this.updateAxes();
    }
    /**
     * Redraw axis
     * @param {Object} targetsToShow targets data to be shown
     * @param {Object} wth
     * @param {Ojbect} transitions
     * @param {Object} flow
     * @private
     */

  }, {
    key: "redrawAxis",
    value: function redrawAxis(targetsToShow, wth, transitions, flow, isInit) {
      var xDomainForZoom,
          _this3 = this,
          $$ = this.owner,
          config = $$.config,
          hasZoom = !!$$.zoomScale;

      !hasZoom && $$.isCategorized() && targetsToShow.length === 0 && $$.x.domain([0, $$.axes.x.selectAll(".tick").size()]), $$.x && targetsToShow.length ? (!hasZoom && $$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain, wth.TrimXDomain), !config.axis_x_tick_values && this.updateXAxisTickValues(targetsToShow)) : $$.xAxis && ($$.xAxis.tickValues([]), $$.subXAxis.tickValues([])), config.zoom_rescale && !flow && (xDomainForZoom = $$.x.orgDomain()), ["y", "y2"].forEach(function (key) {
        var axis = $$[key];

        if (axis) {
          var tickValues = config["axis_".concat(key, "_tick_values")],
              tickCount = config["axis_".concat(key, "_tick_count")];

          if (axis.domain($$.getYDomain(targetsToShow, key, xDomainForZoom)), !tickValues && tickCount) {
            var domain = axis.domain();
            $$["".concat(key, "Axis")].tickValues(_this3.generateTickValues(domain, domain.every(function (v) {
              return v === 0;
            }) ? 1 : tickCount, $$.isTimeSeriesY()));
          }
        }
      }), this.redraw(transitions, $$.hasArcType(), isInit), this.updateLabels(wth.Transition), (wth.UpdateXDomain || wth.UpdateXAxis || wth.Y) && targetsToShow.length && this.setCulling(), wth.Y && ($$.subY && $$.subY.domain($$.getYDomain(targetsToShow, "y")), $$.subY2 && $$.subY2.domain($$.getYDomain(targetsToShow, "y2")));
    }
    /**
     * Set manual culling
     * @private
     */

  }, {
    key: "setCulling",
    value: function setCulling() {
      var $$ = this.owner,
          config = $$.config;
      ["subx", "x", "y", "y2"].forEach(function (type) {
        var axis = $$.axes[type],
            id = type === "subx" ? "x" : type,
            toCull = config["axis_".concat(id, "_tick_culling")]; // subchart x axis should be aligned with x axis culling

        if (axis && toCull) {
          var intervalForCulling,
              tickText = axis.selectAll(".tick text"),
              tickValues = sortValue(tickText.data()),
              tickSize = tickValues.length,
              cullingMax = config["axis_".concat(id, "_tick_culling_max")];

          if (tickSize) {
            for (var i = 1; i < tickSize; i++) if (tickSize / i < cullingMax) {
              intervalForCulling = i;
              break;
            }

            tickText.each(function (d) {
              this.style.display = tickValues.indexOf(d) % intervalForCulling ? "none" : "block";
            });
          } else tickText.style("display", "block"); // set/unset x_axis_tick_clippath


          if (type === "x") {
            var clipPath = $$.clipXAxisTickMaxWidth ? $$.clipPathForXAxisTickTexts : null;
            $$.svg.selectAll(".".concat(config_classes.axisX, " .tick text")).attr("clip-path", clipPath);
          }
        }
      });
    }
  }]), Axis;
}();


// CONCATENATED MODULE: ./src/internals/ChartInternal.js




/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */







/**
 * Internal chart class.
 * - Note: Instantiated internally, not exposed for public.
 * @class ChartInternal
 * @ignore
 * @private
 */

var ChartInternal_ChartInternal = /*#__PURE__*/function () {
  function ChartInternal(api) {
    _classCallCheck(this, ChartInternal);

    var $$ = this;
    $$.api = api, $$.config = $$.getOptions(), $$.data = {}, $$.cache = {}, $$.axes = {}, $$.rendered = !1;
  }

  return _createClass(ChartInternal, [{
    key: "beforeInit",
    value: function beforeInit() {
      var $$ = this;
      $$.callPluginHook("$beforeInit"), callFn($$.config.onbeforeinit, $$, $$.api);
    }
  }, {
    key: "afterInit",
    value: function afterInit() {
      var $$ = this;
      $$.callPluginHook("$afterInit"), callFn($$.config.onafterinit, $$, $$.api);
    }
  }, {
    key: "init",
    value: function init() {
      var $$ = this,
          config = $$.config;
      $$.initParams();
      var bindto = {
        element: config.bindto,
        classname: "bb"
      };
      isObject(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $$.selectChart = isFunction(bindto.element.node) ? config.bindto.element : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto.element || []), $$.selectChart.empty() && ($$.selectChart = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.body.appendChild(browser_doc.createElement("div")))), $$.selectChart.html("").classed(bindto.classname, !0), $$.initToRender();
    }
    /**
     * Initialize the rendering process
     * @param {Boolean} forced Force to render process
     * @private
     */

  }, {
    key: "initToRender",
    value: function initToRender(forced) {
      var $$ = this,
          config = $$.config,
          target = $$.selectChart,
          isHidden = function () {
        return target.style("display") === "none" || target.style("visibility") === "hidden";
      },
          isLazy = config.render.lazy || isHidden(),
          MutationObserver = win.MutationObserver;

      if (isLazy && MutationObserver && config.render.observe !== !1 && !forced && new MutationObserver(function (mutation, observer) {
        isHidden() || (observer.disconnect(), !$$.rendered && $$.initToRender(!0));
      }).observe(target.node(), {
        attributes: !0,
        attributeFilter: ["class", "style"]
      }), !isLazy || forced) {
        var convertedData = $$.convertData(config, $$.initWithData);
        convertedData && $$.initWithData(convertedData), $$.afterInit();
      }
    }
  }, {
    key: "initParams",
    value: function initParams() {
      var _this = this,
          $$ = this,
          config = $$.config,
          isRotated = config.axis_rotated;

      $$.datetimeId = "bb-".concat(+new Date()), $$.initClip(), $$.dragStart = null, $$.dragging = !1, $$.flowing = !1, $$.cancelClick = !1, $$.mouseover = !1, $$.transiting = !1, $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), $$.point = $$.generatePoint(), $$.extraLineClasses = $$.generateExtraLineClass(), $$.dataTimeFormat = config.data_xLocaltime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeParse"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcParse"], $$.axisTimeFormat = config.axis_x_localtime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeFormat"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcFormat"];
      var isDragZoom = $$.config.zoom_enabled && $$.config.zoom_enabled.type === "drag";
      $$.defaultAxisTimeFormat = function (d) {
        var isZoomed = isDragZoom ? _this.zoomScale : _this.zoomScale && $$.x.orgDomain().toString() !== _this.zoomScale.domain().toString(),
            specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDate() !== 1 && "%b %d" || isZoomed && d.getDate() === 1 && "%b\'%y" || d.getMonth() && "%-m/%-d" || "%Y";
        return $$.axisTimeFormat(specifier)(d);
      }, $$.hiddenTargetIds = [], $$.hiddenLegendIds = [], $$.focusedTargetIds = [], $$.defocusedTargetIds = [], $$.isLegendRight = config.legend_position === "right", $$.isLegendInset = config.legend_position === "inset", $$.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", $$.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", $$.legendStep = 0, $$.legendItemWidth = 0, $$.legendItemHeight = 0, $$.currentMaxTickWidths = {
        x: {
          size: 0,
          ticks: [],
          domain: ""
        },
        y: {
          size: 0,
          domain: ""
        },
        y2: {
          size: 0,
          domain: ""
        }
      }, $$.rotated_padding_left = 30, $$.rotated_padding_right = isRotated && !config.axis_x_show ? 0 : 30, $$.rotated_padding_top = 5, $$.withoutFadeIn = {}, $$.inputType = $$.convertInputType(), $$.axes.subx = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);
    }
  }, {
    key: "initWithData",
    value: function initWithData(data) {
      var $$ = this,
          config = $$.config;

      if ($$.axis = new Axis_Axis($$), config.zoom_enabled && $$.initZoom(), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter)), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.updateSizes(), $$.updateScales(!0), $$.x && ($$.x.domain(sortValue($$.getXDomain($$.data.targets))), $$.subX.domain($$.x.domain()), $$.orgXDomain = $$.x.domain()), $$.y && ($$.y.domain($$.getYDomain($$.data.targets, "y")), $$.subY.domain($$.y.domain())), $$.y2 && ($$.y2.domain($$.getYDomain($$.data.targets, "y2")), $$.subY2 && $$.subY2.domain($$.y2.domain())), $$.svg = $$.selectChart.append("svg").style("overflow", "hidden").style("display", "block"), config.interaction_enabled && $$.inputType) {
        var isTouch = $$.inputType === "touch";
        $$.svg.on(isTouch ? "touchstart" : "mouseenter", function () {
          return callFn(config.onover, $$, $$.api);
        }).on(isTouch ? "touchend" : "mouseleave", function () {
          return callFn(config.onout, $$, $$.api);
        });
      }

      config.svg_classname && $$.svg.attr("class", config.svg_classname), $$.defs = $$.svg.append("defs"), $$.clipChart = $$.appendClip($$.defs, $$.clipId), $$.clipXAxis = $$.appendClip($$.defs, $$.clipIdForXAxis), $$.clipYAxis = $$.appendClip($$.defs, $$.clipIdForYAxis), $$.clipGrid = $$.appendClip($$.defs, $$.clipIdForGrid), isFunction(config.color_tiles) && $$.patterns && $$.patterns.forEach(function (p) {
        return $$.defs.append(function () {
          return p.node;
        });
      }), $$.updateSvgSize(), $$.bindResize();
      // Define regions
      var main = $$.svg.append("g").attr("transform", $$.getTranslate("main"));

      // data.onmin/max callback
      if ($$.main = main, config.subchart_show && $$.initSubchart(), $$.initTooltip && $$.initTooltip(), $$.initLegend && $$.initLegend(), $$.initTitle && $$.initTitle(), config.data_empty_label_text && main.append("text").attr("class", "".concat(config_classes.text, " ").concat(config_classes.empty)).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
      .attr("dominant-baseline", "middle"), $$.initRegion(), config.clipPath || $$.axis.init(), main.append("g").attr("class", config_classes.chart).attr("clip-path", $$.clipPath), $$.callPluginHook("$init"), $$.initEventRect(), $$.initChartElements(), $$.initGrid(), main.insert("rect", config.zoom_privileged ? null : "g.".concat(config_classes.regions)).attr("class", config_classes.zoomRect).attr("width", $$.width).attr("height", $$.height).style("opacity", "0").on("dblclick.zoom", null), config.clipPath && $$.axis.init(), $$.updateTargets($$.data.targets), $$.updateDimension(), callFn(config.oninit, $$, $$.api), $$.setBackground(), $$.redraw({
        withTransition: !1,
        withTransform: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withTransitionForAxis: !1,
        initializing: !0
      }), config.data_onmin || config.data_onmax) {
        var minMax = $$.getMinMaxData();
        callFn(config.data_onmin, $$, minMax.min), callFn(config.data_onmax, $$, minMax.max);
      } // export element of the chart


      $$.api.element = $$.selectChart.node(), $$.rendered = !0;
    }
  }, {
    key: "initChartElements",
    value: function initChartElements() {
      var $$ = this;
      ["Bar", "Radar", "Line", "Bubble", "Arc", "Gauge", "Pie"].forEach(function (v) {
        $$["init".concat(v)]();
      }), notEmpty($$.config.data_labels) && $$.initText();
    }
  }, {
    key: "setChartElements",
    value: function setChartElements() {
      var $$ = this;
      $$.api.$ = {
        chart: $$.selectChart,
        svg: $$.svg,
        defs: $$.defs,
        main: $$.main,
        tooltip: $$.tooltip,
        legend: $$.legend,
        title: $$.title,
        grid: $$.grid,
        arc: $$.arcs,
        bar: {
          bars: $$.mainBar
        },
        line: {
          lines: $$.mainLine,
          areas: $$.mainArea,
          circles: $$.mainCircle
        },
        text: {
          texts: $$.mainText
        }
      };
    }
    /**
     * Set background element/image
     * @private
     */

  }, {
    key: "setBackground",
    value: function setBackground() {
      var $$ = this,
          bg = $$.config.background;

      if (notEmpty(bg)) {
        var element = $$.svg.select(".".concat(config_classes[$$.hasArcType() ? "chart" : "regions"])).insert(bg.imgUrl ? "image" : "rect", ":first-child");
        bg.imgUrl ? element.attr("href", bg.imgUrl) : bg.color && element.style("fill", bg.color), element.attr("class", bg["class"] || null).attr("width", "100%").attr("height", "100%");
      }
    }
  }, {
    key: "smoothLines",
    value: function smoothLines(el, type) {
      type === "grid" && el.each(function () {
        var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
        ["x1", "x2", "y1", "y2"].forEach(function (v) {
          return g.attr(v, Math.ceil(g.attr(v)));
        });
      });
    }
    /**
     * Update size values
     * @param {Boolean} isInit If is called at initialization
     * @private
     */

  }, {
    key: "updateSizes",
    value: function updateSizes(isInit) {
      var $$ = this;
      isInit || $$.setContainerSize();
      var config = $$.config,
          isRotated = config.axis_rotated,
          hasArc = $$.hasArcType(),
          legend = {
        width: $$.legend ? $$.getLegendWidth() : 0,
        height: $$.legend ? $$.getLegendHeight() : 0
      },
          legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legend.height,
          xAxisHeight = isRotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
          subchartXAxisHeight = config.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30,
          subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + subchartXAxisHeight : 0;
      $$.margin = isRotated ? {
        top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
      } : {
        top: 4 + $$.getCurrentPaddingTop(),
        // for top tick text
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: hasArc ? 0 : $$.getCurrentPaddingLeft()
      }, $$.margin2 = isRotated ? {
        top: $$.margin.top,
        right: NaN,
        bottom: 20 + legendHeightForBottom,
        left: $$.rotated_padding_left
      } : {
        top: $$.currentHeight - subchartHeight - legendHeightForBottom,
        right: NaN,
        bottom: subchartXAxisHeight + legendHeightForBottom,
        left: $$.margin.left
      }, $$.margin3 = {
        top: 0,
        right: NaN,
        bottom: 0,
        left: 0
      }, $$.updateSizeForLegend && $$.updateSizeForLegend(legend), $$.width = $$.currentWidth - $$.margin.left - $$.margin.right, $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom, $$.width < 0 && ($$.width = 0), $$.height < 0 && ($$.height = 0), $$.width2 = isRotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width, $$.height2 = isRotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom, $$.width2 < 0 && ($$.width2 = 0), $$.height2 < 0 && ($$.height2 = 0), $$.arcWidth = $$.width - ($$.isLegendRight ? legend.width + 10 : 0), $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && ($$.arcHeight += $$.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), $$.isLegendRight && hasArc && ($$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1), !hasArc && config.axis_x_show && config.axis_x_tick_autorotate && $$.updateXAxisTickClip();
    }
    /**
     * Update targeted element with given data
     * @param {Object} targets Data object formatted as 'target'
     * @private
     */

  }, {
    key: "updateTargets",
    value: function updateTargets(targets) {
      var $$ = this; // Text

      $$.updateTargetsForText(targets), $$.updateTargetsForBar(targets), $$.updateTargetsForLine(targets), $$.hasArcType(targets) && ($$.hasType("radar") ? $$.updateTargetsForRadar(targets) : $$.updateTargetsForArc(targets)), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets), $$.showTargets();
    }
    /**
     * Display targeted elements
     * @private
     */

  }, {
    key: "showTargets",
    value: function showTargets() {
      var $$ = this;
      $$.svg.selectAll(".".concat(config_classes.target)).filter(function (d) {
        return $$.isTargetToShow(d.id);
      }).transition().duration($$.config.transition_duration).style("opacity", "1");
    }
  }, {
    key: "getWithOption",
    value: function getWithOption(options) {
      var withOptions = {
        Y: !0,
        Subchart: !0,
        Transition: !0,
        EventRect: !0,
        Dimension: !0,
        TrimXDomain: !0,
        Transform: !1,
        UpdateXDomain: !1,
        UpdateOrgXDomain: !1,
        Legend: !1,
        UpdateXAxis: "UpdateXDomain",
        TransitionForExit: "Transition",
        TransitionForAxis: "Transition"
      };
      return Object.keys(withOptions).forEach(function (key) {
        var defVal = withOptions[key];
        isString(defVal) && (defVal = withOptions[defVal]), withOptions[key] = getOption(options, "with".concat(key), defVal);
      }), withOptions;
    }
  }, {
    key: "redraw",
    value: function redraw() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          transitionsValue = arguments.length > 1 ? arguments[1] : undefined,
          $$ = this,
          main = $$.main,
          config = $$.config,
          targetsToShow = $$.filterTargetsToShow($$.data.targets),
          initializing = options.initializing,
          flow = options.flow,
          wth = $$.getWithOption(options),
          duration = wth.Transition ? config.transition_duration : 0,
          durationForExit = wth.TransitionForExit ? duration : 0,
          durationForAxis = wth.TransitionForAxis ? duration : 0,
          transitions = transitionsValue || $$.axis.generateTransitions(durationForAxis);
      $$.updateSizes(initializing), wth.Legend && config.legend_show ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : wth.Dimension && $$.updateDimension(!0), $$.axis.redrawAxis(targetsToShow, wth, transitions, flow, initializing), $$.updateCircleY(), config.data_empty_label_text && main.select("text.".concat(config_classes.text, ".").concat(config_classes.empty)).attr("x", $$.width / 2).attr("y", $$.height / 2).text(config.data_empty_label_text).style("display", targetsToShow.length ? "none" : null), $$.updateGrid(duration), $$.updateRegion(duration), $$.updateBar(durationForExit), $$.updateLine(durationForExit), $$.updateArea(durationForExit), $$.updateCircle(), $$.hasDataLabel() && $$.updateText(durationForExit), $$.redrawTitle && $$.redrawTitle(), $$.arcs && $$.redrawArc(duration, durationForExit, wth.Transform), $$.radars && $$.redrawRadar(durationForExit), $$.mainText && main.selectAll(".".concat(config_classes.selectedCircles)).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !flow && wth.EventRect && $$.bindZoomEvent(), initializing && $$.setChartElements(), $$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart), $$.callPluginHook("$redraw", options, duration);
    }
    /**
     * Generate redraw list
     * @param {Object} targets targets data to be shown
     * @param {Object} flow
     * @param {Object} duration
     * @param {Boolean} withSubchart whether or not to show subchart
     * @private
     */

  }, {
    key: "generateRedrawList",
    value: function generateRedrawList(targets, flow, duration, withSubchart) {
      var $$ = this,
          config = $$.config,
          shape = $$.getDrawShape();
      config.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);
      // generate flow
      var flowFn = flow && $$.generateFlow({
        targets: targets,
        flow: flow,
        duration: flow.duration,
        shape: shape,
        xv: $$.xv.bind($$)
      }),
          isTransition = (duration || flowFn) && $$.isTabVisible(),
          redrawList = $$.getRedrawList(shape, flow, flowFn, isTransition),
          afterRedraw = flow || config.onrendered ? function () {
        flowFn && flowFn(), callFn(config.onrendered, $$, $$.api);
      } : null;
      if (afterRedraw) // Only use transition when current tab is visible.
        if (isTransition && redrawList.length) {
          // Wait for end of transitions for callback
          var waitForDraw = $$.generateWait(); // transition should be derived from one transition

          Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().duration(duration).each(function () {
            redrawList.reduce(function (acc, t1) {
              return acc.concat(t1);
            }, []).forEach(function (t) {
              return waitForDraw.add(t);
            });
          }).call(waitForDraw, afterRedraw);
        } else $$.transiting || afterRedraw(); // update fadein condition

      $$.mapToIds($$.data.targets).forEach(function (id) {
        $$.withoutFadeIn[id] = !0;
      });
    }
    /**
     * Get the shape draw function
     * @return {Object}
     * @private
     */

  }, {
    key: "getDrawShape",
    value: function getDrawShape() {
      var $$ = this,
          isRotated = $$.config.axis_rotated,
          hasRadar = $$.hasType("radar"),
          shape = {
        type: {},
        indices: {}
      };

      // setup drawer - MEMO: these must be called after axis updated
      if ($$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter")) {
        var indices = $$.getShapeIndices($$.isLineType);

        if (shape.indices.line = indices, shape.type.line = $$.generateDrawLine ? $$.generateDrawLine(indices, !1) : undefined, $$.hasTypeOf("Area")) {
          var _indices = $$.getShapeIndices($$.isAreaType);

          shape.indices.area = _indices, shape.type.area = $$.generateDrawArea ? $$.generateDrawArea(_indices, !1) : undefined;
        }
      }

      if ($$.hasType("bar")) {
        var _indices2 = $$.getShapeIndices($$.isBarType);

        shape.indices.bar = _indices2, shape.type.bar = $$.generateDrawBar ? $$.generateDrawBar(_indices2) : undefined;
      }

      return shape.pos = {
        xForText: $$.generateXYForText(shape.indices, !0),
        yForText: $$.generateXYForText(shape.indices, !1),
        // generate circle x/y functions depending on updated params
        cx: (hasRadar ? $$.radarCircleX : isRotated ? $$.circleY : $$.circleX).bind($$),
        cy: (hasRadar ? $$.radarCircleY : isRotated ? $$.circleX : $$.circleY).bind($$)
      }, shape;
    }
  }, {
    key: "getRedrawList",
    value: function getRedrawList(shape, flow, flowFn, isTransition) {
      var $$ = this,
          config = $$.config,
          hasArcType = $$.hasArcType(),
          _shape$pos = shape.pos,
          cx = _shape$pos.cx,
          cy = _shape$pos.cy,
          xForText = _shape$pos.xForText,
          yForText = _shape$pos.yForText,
          list = [];

      if (!hasArcType) {
        var _shape$type = shape.type,
            area = _shape$type.area,
            bar = _shape$type.bar,
            line = _shape$type.line;
        (config.grid_x_lines.length || config.grid_y_lines.length) && list.push($$.redrawGrid(isTransition)), config.regions.length && list.push($$.redrawRegion(isTransition)), $$.hasTypeOf("Line") && (list.push($$.redrawLine(line, isTransition)), $$.hasTypeOf("Area") && list.push($$.redrawArea(area, isTransition))), $$.hasType("bar") && list.push($$.redrawBar(bar, isTransition)), flow || list.push($$.updateGridFocus());
      }

      return (!hasArcType || $$.hasType("radar")) && (notEmpty(config.data_labels) && list.push($$.redrawText(xForText, yForText, flow, isTransition)), list.push($$.redrawCircle(cx, cy, isTransition, flowFn))), list;
    }
  }, {
    key: "updateAndRedraw",
    value: function updateAndRedraw() {
      var transitions,
          options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          $$ = this,
          config = $$.config;
      options.withTransition = getOption(options, "withTransition", !0), options.withTransform = getOption(options, "withTransform", !1), options.withLegend = getOption(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition), options.withLegend && config.legend_show || (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
    }
  }, {
    key: "redrawWithoutRescale",
    value: function redrawWithoutRescale() {
      this.redraw({
        withY: !1,
        withSubchart: !1,
        withEventRect: !1,
        withTransitionForAxis: !1
      });
    }
  }, {
    key: "isTimeSeries",
    value: function isTimeSeries() {
      return this.config.axis_x_type === "timeseries";
    }
  }, {
    key: "isCategorized",
    value: function isCategorized() {
      return this.config.axis_x_type.indexOf("category") >= 0 || this.hasType("radar");
    }
  }, {
    key: "isCustomX",
    value: function isCustomX() {
      var $$ = this,
          config = $$.config;
      return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
    }
  }, {
    key: "isTimeSeriesY",
    value: function isTimeSeriesY() {
      return this.config.axis_y_type === "timeseries";
    }
  }, {
    key: "getTranslate",
    value: function getTranslate(target) {
      var x,
          y,
          index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0,
          $$ = this,
          config = $$.config,
          isRotated = config.axis_rotated,
          hasGauge = $$.hasType("gauge"),
          padding = 0;
      if (index && /^(x|y2?)$/.test(target) && (padding = $$.getAxisSize(target) * index), target === "main") x = asHalfPixel($$.margin.left), y = asHalfPixel($$.margin.top);else if (target === "context") x = asHalfPixel($$.margin2.left), y = asHalfPixel($$.margin2.top);else if (target === "legend") x = $$.margin3.left, y = $$.margin3.top + (hasGauge ? 10 : 0);else if (target === "x") x = isRotated ? -padding : 0, y = isRotated ? 0 : $$.height + padding;else if (target === "y") x = isRotated ? 0 : -padding, y = isRotated ? $$.height + padding : 0;else if (target === "y2") x = isRotated ? 0 : $$.width + padding, y = isRotated ? 1 - padding : 0;else if (target === "subx") x = 0, y = isRotated ? 0 : $$.height2;else if (target === "arc") x = $$.arcWidth / 2, y = $$.arcHeight / 2;else if (target === "radar") {
        var _$$$getRadarSize = $$.getRadarSize(),
            _$$$getRadarSize2 = _slicedToArray(_$$$getRadarSize, 1),
            width = _$$$getRadarSize2[0];

        x = $$.width / 2 - width, y = asHalfPixel($$.margin.top);
      }
      return "translate(".concat(x, ", ").concat(y, ")");
    }
  }, {
    key: "initialOpacity",
    value: function initialOpacity(d) {
      return this.getBaseValue(d) !== null && this.withoutFadeIn[d.id] ? "1" : "0";
    }
  }, {
    key: "initialOpacityForCircle",
    value: function initialOpacityForCircle(d) {
      return this.getBaseValue(d) !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
    }
  }, {
    key: "opacityForCircle",
    value: function opacityForCircle(d) {
      var opacity = this.config.point_show ? "1" : "0";
      return isValue(this.getBaseValue(d)) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
    }
  }, {
    key: "opacityForText",
    value: function opacityForText() {
      return this.hasDataLabel() ? "1" : "0";
    }
    /**
     * Get the zoom or unzoomed scaled value
     * @param {Date|Number|Object} d Data value
     * @private
     */

  }, {
    key: "xx",
    value: function xx(d) {
      var $$ = this,
          fn = $$.config.zoom_enabled && $$.zoomScale ? $$.zoomScale : this.x;
      return d ? fn(isValue(d.x) ? d.x : d) : null;
    }
  }, {
    key: "xv",
    value: function xv(d) {
      var $$ = this,
          value = $$.getBaseValue(d);
      return $$.isTimeSeries() ? value = $$.parseDate(value) : $$.isCategorized() && isString(value) && (value = $$.config.axis_x_categories.indexOf(value)), Math.ceil($$.x(value));
    }
  }, {
    key: "yv",
    value: function yv(d) {
      var $$ = this,
          yScale = d.axis && d.axis === "y2" ? $$.y2 : $$.y;
      return Math.ceil(yScale($$.getBaseValue(d)));
    }
  }, {
    key: "subxx",
    value: function subxx(d) {
      return d ? this.subX(d.x) : null;
    }
  }, {
    key: "transformMain",
    value: function transformMain(withTransition, transitions) {
      var xAxis,
          yAxis,
          y2Axis,
          $$ = this;
      transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = $$.main.select(".".concat(config_classes.axisX)), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = $$.main.select(".".concat(config_classes.axisY)), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = $$.main.select(".".concat(config_classes.axisY2)), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? $$.main.transition() : $$.main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), $$.main.select(".".concat(config_classes.chartArcs)).attr("transform", $$.getTranslate("arc"));
    }
  }, {
    key: "transformAll",
    value: function transformAll(withTransition, transitions) {
      var $$ = this;
      $$.transformMain(withTransition, transitions), $$.config.subchart_show && $$.transformContext(withTransition, transitions), $$.legend && $$.transformLegend(withTransition);
    }
  }, {
    key: "updateSvgSize",
    value: function updateSvgSize() {
      var $$ = this,
          brush = $$.svg.select(".".concat(config_classes.brush, " .overlay")),
          brushSize = {
        width: 0,
        height: 0
      };
      brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), $$.svg.attr("width", $$.currentWidth).attr("height", $$.currentHeight), $$.svg.selectAll(["#".concat($$.clipId), "#".concat($$.clipIdForGrid)]).select("rect").attr("width", $$.width).attr("height", $$.height), $$.svg.select("#".concat($$.clipIdForXAxis)).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), $$.svg.select("#".concat($$.clipIdForYAxis)).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), $$.svg.select("#".concat($$.clipIdForSubchart)).select("rect").attr("width", $$.width).attr("height", brushSize.height), $$.svg.select(".".concat(config_classes.zoomRect)).attr("width", $$.width).attr("height", $$.height);
    }
  }, {
    key: "updateDimension",
    value: function updateDimension(withoutAxis) {
      var $$ = this;
      withoutAxis || ($$.xAxis && $$.config.axis_rotated ? ($$.xAxis.create($$.axes.x), $$.subXAxis.create($$.axes.subx)) : ($$.yAxis && $$.yAxis.create($$.axes.y), $$.y2Axis && $$.y2Axis.create($$.axes.y2))), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
    }
  }, {
    key: "bindResize",
    value: function bindResize() {
      var $$ = this,
          config = $$.config,
          resizeFunction = $$.generateResize(),
          list = [];
      list.push(function () {
        return callFn(config.onresize, $$, $$.api);
      }), config.resize_auto && list.push(function () {
        return $$.api.flush(!1, !0);
      }), list.push(function () {
        return callFn(config.onresized, $$, $$.api);
      }), list.forEach(function (v) {
        return resizeFunction.add(v);
      }), win.addEventListener("resize", $$.resizeFunction = resizeFunction);
    }
  }, {
    key: "generateResize",
    value: function generateResize() {
      function callResizeFn() {
        callResizeFn.timeout && (win.clearTimeout(callResizeFn.timeout), callResizeFn.timeout = null), callResizeFn.timeout = win.setTimeout(function () {
          fn.forEach(function (f) {
            return f();
          });
        }, 200);
      }

      var fn = [];
      return callResizeFn.add = function (f) {
        return fn.push(f);
      }, callResizeFn.remove = function (f) {
        return fn.splice(fn.indexOf(f), 1);
      }, callResizeFn;
    }
  }, {
    key: "endall",
    value: function endall(transition, callback) {
      var n = 0;
      transition.each(function () {
        return ++n;
      }).on("end", function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

        --n || callback.apply.apply(callback, [this].concat(args));
      });
    }
  }, {
    key: "generateWait",
    value: function generateWait() {
      var transitionsToWait = [],
          f = function (transition, callback) {
        function loop() {
          for (var t, done = 0, i = 0; t = transitionsToWait[i]; i++) {
            if (t === !0 || t.empty && t.empty()) {
              done++;
              continue;
            }

            try {
              t.transition();
            } catch (e) {
              done++;
            }
          }

          timer && clearTimeout(timer), done === transitionsToWait.length ? callback && callback() : timer = setTimeout(loop, 50);
        }

        var timer;
        loop();
      };

      return f.add = function (transition) {
        isArray(transition) ? transitionsToWait = transitionsToWait.concat(transition) : transitionsToWait.push(transition);
      }, f;
    }
  }, {
    key: "parseDate",
    value: function parseDate(date) {
      var parsedDate,
          $$ = this;
      return date instanceof Date ? parsedDate = date : isString(date) ? parsedDate = $$.dataTimeFormat($$.config.data_xFormat)(date) : isNumber(date) && !isNaN(date) && (parsedDate = new Date(+date)), (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '".concat(date, "' to Date object")), parsedDate;
    }
  }, {
    key: "isTabVisible",
    value: function isTabVisible() {
      return !browser_doc.hidden;
    }
  }, {
    key: "convertInputType",
    value: function convertInputType() {
      var $$ = this,
          config = $$.config,
          isMobile = !1;

      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Mobile_Tablet_or_Desktop
      if (/Mobi/.test(win.navigator.userAgent) && config.interaction_inputType_touch) {
        // Some Edge desktop return true: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/20417074/
        var hasTouchPoints = win.navigator && "maxTouchPoints" in win.navigator && win.navigator.maxTouchPoints > 0,
            hasTouch = "ontouchmove" in win || win.DocumentTouch && browser_doc instanceof win.DocumentTouch; // Ref: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
        // On IE11 with IE9 emulation mode, ('ontouchstart' in window) is returning true

        isMobile = hasTouchPoints || hasTouch;
      }

      var hasMouse = config.interaction_inputType_mouse && !isMobile && "onmouseover" in win;
      return hasMouse && "mouse" || isMobile && "touch" || null;
    }
    /**
     * Call plugin hook
     * @param {String} phase The lifecycle phase
     * @private
     */

  }, {
    key: "callPluginHook",
    value: function callPluginHook(phase) {
      for (var _this2 = this, _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];

      this.config.plugins.forEach(function (v) {
        phase === "$beforeInit" && (v.$$ = _this2, _this2.api.plugins.push(v)), v[phase].apply(v, args);
      });
    }
  }]), ChartInternal;
}();


// CONCATENATED MODULE: ./src/internals/Chart.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Main chart class.
 * - Note: Instantiated via `bb.generate()`.
 * @class Chart
 * @example
 * var chart = bb.generate({
 *  data: {
 *    columns: [
 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
 * 	    ["count1", 11, 8, 7, 6, 5 ],
 *	    ["count2", 9, 3, 6, 2, 8 ]
 *   ]}
 * }
 * @see {@link bb.generate} for the initialization.
*/

/**
 * Access instance's primary node elements
 * @member {Object} $
 * @property {Object} $
 * @property {d3.selection} $.chart Wrapper element
 * @property {d3.selection} $.svg Main svg element
 * @property {d3.selection} $.defs Definition element
 * @property {d3.selection} $.main Main grouping element
 * @property {d3.selection} $.tooltip Tooltip element
 * @property {d3.selection} $.legend Legend element
 * @property {d3.selection} $.title Title element
 * @property {d3.selection} $.grid Grid element
 * @property {d3.selection} $.arc Arc element
 * @property {Object} $.bar
 * @property {d3.selection} $.bar.bars Bar elements
 * @property {Object} $.line
 * @property {d3.selection} $.line.lines Line elements
 * @property {d3.selection} $.line.areas Areas elements
 * @property {d3.selection} $.line.circles Data point circle elements
 * @property {Object} $.text
 * @property {d3.selection} $.text.texts Data label text elements
 * @memberof Chart
 * @example
 * var chart = bb.generate({ ... });
 *
 * chart.$.chart; // wrapper element
 * chart.$.line.circles;  // all data point circle elements
 */

var Chart_Chart = function Chart(config) {
  _classCallCheck(this, Chart);

  var $$ = new ChartInternal_ChartInternal(this);
  /**
   * Plugin instance array
   * @member {Array} plugins
   * @memberof Chart
   * @instance
   	 * @example
   *  var chart = bb.generate({
   *     ...
   *     plugins: [
   *        new bb.plugin.stanford({ ... }),
   *        new PluginA()
   *     ]
   *  });
   *
   *  chart.plugins; // [Stanford, PluginA] - instance array
   */

  // bind "this" to nested API
  this.plugins = [], this.internal = $$, $$.loadConfig(config), $$.beforeInit(config), $$.init(), function bindThis(fn, target, argThis) {
    Object.keys(fn).forEach(function (key) {
      target[key] = fn[key].bind(argThis), Object.keys(fn[key]).length && bindThis(fn[key], target[key], argThis);
    });
  }(Chart.prototype, this, this);
};


// CONCATENATED MODULE: ./src/config/Options.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Class to set options on generating chart.
 * - It's instantiated internally, not exposed for public.
 * @class Options
 * @see {@link bb.generate} to use these options on generating the chart
 */
var Options_Options = function Options() {
  return _classCallCheck(this, Options), {
    /**
     * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>
     * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).
     * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.
     * @name bindto
     * @memberof Options
     * @property {String|HTMLElement|d3.selection} bindto=#chart Specify the element where chart will be drawn.
     * @property {String|HTMLElement|d3.selection} bindto.element=#chart Specify the element where chart will be drawn.
     * @property {String} [bindto.classname=bb] Specify the class name of bind element.<br>
     *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
     * @default #chart
     * @example
     * bindto: "#myContainer"
     *
     * // or HTMLElement
     * bindto: document.getElementById("myContainer")
     *
     * // or D3 selection object
     * bindto: d3.select("#myContainer")
     *
     * // or to change default classname
     * bindto: {
     *    element: "#chart",
     *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
     * }
     */
    bindto: "#chart",

    /**
     * Set chart background.
     * @name background
     * @memberof Options
     * @property {String} background.class Specify the class name for background element.
     * @property {String} background.color Specify the fill color for background element.<br>**NOTE:** Will be ignored if `imgUrl` option is set.
     * @property {String} background.imgUrl Specify the image url string for background.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.Background)
     * @example
     * background: {
     *    class: "myClass",
     *    color: "red",
     *
     *    // Set image url for background.
     *    // If specified, 'color' option will be ignored.
     *    imgUrl: "https://naver.github.io/billboard.js/img/logo/billboard.js.svg",
     * }
     */
    background: {},

    /**
     * Set 'clip-path' attribute for chart element
     * - **NOTE:**
     *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
     *  > Is to make chart element positioned over axis element.
     * @name clipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    clipPath: !0,

    /**
     * Set svg element's class name
     * @name svg
     * @memberof Options
     * @type {Object}
     * @property {String} [svg.classname] class name for svg element
     * @example
     * svg: {
              *   classname: "test_class"
     * }
     */
    svg_classname: undefined,

    /**
     * The desired size of the chart element.
     * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
     * @name size
     * @memberof Options
     * @type {Object}
     * @property {Number} [size.width] width of the chart element
     * @property {Number} [size.height] height of the chart element
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)
     * @example
     * size: {
              *   width: 640,
              *   height: 480
     * }
     */
    size_width: undefined,
    size_height: undefined,

    /**
     * The padding of the chart element.
     * @name padding
     * @memberof Options
     * @type {Object}
     * @property {Number} [padding.top] padding on the top of chart
     * @property {Number} [padding.right] padding on the right of chart
     * @property {Number} [padding.bottom] padding on the bottom of chart
     * @property {Number} [padding.left] padding on the left of chart
     * @example
     * padding: {
              *   top: 20,
              *   right: 20,
              *   bottom: 20,
              *   left: 20
     * }
     */
    padding_left: undefined,
    padding_right: undefined,
    padding_top: undefined,
    padding_bottom: undefined,

    /**
     * Set chart resize options
     * @name resize
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
     * @example
     *  resize: {
     *      auto: false
     *  }
     */
    resize_auto: !0,

    /**
     * Set zoom options
     * @name zoom
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [zoom.enabled=false] Enable zooming.
     * @property {String} [zoom.enabled.type='wheel'] Set zoom interaction type.
     *  - **Available types:**
     *    - wheel
     *    - drag
     * @property {Boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
     *  If true set, y domain will be updated according to the zoomed region.
     * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
     * @property {Number|Date} [zoom.x.min] Set x Axis minimum zoom range
     * @property {Number|Date} [zoom.x.max] Set x Axis maximum zoom range
     * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>
     *  Specified function receives the zoom event.
     * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>
     *  Specified function receives the zoomed domain.
     * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>
     *  Specified function receives the zoomed domain.
     * @property {Boolean|Object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom
     * @property {Function} [zoom.resetButton.onclick] Set callback when clicks the reset button. The callback will receive reset button element reference as argument.
     * @property {String} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.
     * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)
     * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)
     * @example
     *  zoom: {
     *      enabled: {
              *          type: "drag"
              *      },
     *      rescale: true,
     *      extent: [1, 100]  // enable more zooming
     *      x: {
     *          min: -1,  // set min range
     *          max: 10  // set max range
     *      },
     *      onzoomstart: function(event) { ... },
     *      onzoom: function(domain) { ... },
     *      onzoomend: function(domain) { ... },
     *
     *      // show reset button when is zoomed-in
     *      resetButton: true,
     *
     *      resetButton: {
     *          // onclick callback when reset button is clicked
     *          onclick: function(button) {
     *            button; // Reset button element reference
     *            ...
     *          },
     *
     *          // customized text value for reset zoom button
     *          text: "Unzoom"
     *      }
     *  }
     */
    zoom_enabled: undefined,
    zoom_extent: undefined,
    zoom_privileged: !1,
    zoom_rescale: !1,
    zoom_onzoom: undefined,
    zoom_onzoomstart: undefined,
    zoom_onzoomend: undefined,
    zoom_resetButton: !0,
    zoom_x_min: undefined,
    zoom_x_max: undefined,

    /**
     * Interaction options
     * @name interaction
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
     *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
     * @property {Boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)
     * @property {Boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
     * @property {Boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
     * @property {Boolean|Number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
     * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)
     * @example
     * interaction: {
              *    enabled: false,
              *    brighten: false,
              *    inputType: {
              *        mouse: true,
              *        touch: false
              *
              *        // or declare preventDefault explicitly.
              *        // In this case touch inputType is enabled by default
              *        touch: {
              *            preventDefault: true
              *
              *            // or threshold pixel value (pixel moved from touchstart to touchmove)
              *            preventDefault: 5
              *        }
              *    }
     * }
     */
    interaction_enabled: !0,
    interaction_brighten: !0,
    interaction_inputType_mouse: !0,
    interaction_inputType_touch: {},

    /**
     * Set a callback to execute when mouse/touch enters the chart.
     * @name onover
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onover: function(ctx) {
     *   ...
     * }
     */
    onover: undefined,

    /**
     * Set a callback to execute when mouse/touch leaves the chart.
     * @name onout
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onout: function(ctx) {
     *   ...
     * }
     */
    onout: undefined,

    /**
     * Set a callback to execute when user resizes the screen.
     * @name onresize
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresize: function(ctx) {
     *   ...
     * }
     */
    onresize: undefined,

    /**
     * Set a callback to execute when screen resize finished.
     * @name onresized
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresized: function(ctx) {
     *   ...
     * }
     */
    onresized: undefined,

    /**
     * Set a callback to execute before the chart is initialized
     * @name onbeforeinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onbeforeinit: function(ctx) {
     *   ...
     * }
     */
    onbeforeinit: undefined,

    /**
     * Set a callback to execute when the chart is initialized.
     * @name oninit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * oninit: function(ctx) {
     *   ...
     * }
     */
    oninit: undefined,

    /**
     * Set a callback to execute after the chart is initialized
     * @name onafterinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onafterinit: function(ctx) {
     *   ...
     * }
     */
    onafterinit: undefined,

    /**
     * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
     * @name onrendered
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onrendered: function(ctx) {
     *   ...
     * }
     */
    onrendered: undefined,

    /**
     * Set duration of transition (in milliseconds) for chart animation.<br><br>
     * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
     * @name transition
     * @memberof Options
     * @type {Object}
     * @property {Number} [transition.duration=350] duration in milliseconds
     * @example
     * transition: {
     *    duration: 500
     * }
     */
    transition_duration: 350,

    /**
     * Specify the key of x values in the data.<br><br>
     * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
     * @name datax
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * data: {
              *   x: "date"
     * }
     */
    data_x: undefined,

    /**
     * Specify the keys of the x values for each data.<br><br>
     * This option can be used if we want to show the data that has different x values.
     * @name dataxs
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
              *   xs: {
              *      data1: "x1",
              *      data2: "x2"
              *   }
     * }
     */
    data_xs: {},

    /**
     * Set a format specifier to parse string specifed as x.
     * @name dataxFormat
     * @memberof Options
     * @type {String}
     * @default %Y-%m-%d
     * @example
     * data: {
     *    x: "x",
     *    columns: [
     *        ["x", "01012019", "02012019", "03012019"],
     *        ["data1", 30, 200, 100]
     *    ],
     *    // Format specifier to parse as datetime for given 'x' string value
     *    xFormat: "%m%d%Y"
     * },
     * axis: {
     *    x: {
     *        type: "timeseries"
     *    }
     * }
     * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
     */
    data_xFormat: "%Y-%m-%d",

    /**
     * Set localtime format to parse x axis.
     * @name dataxLocaltime
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
              *   xLocaltime: false
     * }
     */
    data_xLocaltime: !0,

    /**
     * Sort on x axis.
     * @name dataxSort
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
              *   xSort: false
     * }
     */
    data_xSort: !0,

    /**
     * Converts data id value
     * @name dataidConverter
     * @memberof Options
     * @type {Function}
     * @default function(id) { return id; }
     * @example
     * data: {
              *    idConverter: function(id) {
              *       // when id is 'data1', converts to be 'data2'
              *       // 'data2' should be given as the initial data value
              *       if (id === "data1") {
              *          return "data2";
              *       } else {
              *          return id;
              *       }
              *    }
     * }
     */
    data_idConverter: function data_idConverter(id) {
      return id;
    },

    /**
     * Set custom data name.
     * @name datanames
     * @memberof Options
     * @type {Object}
     * @default {}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)
     * @example
     * data: {
              *   names: {
              *     data1: "Data Name 1",
              *     data2: "Data Name 2"
              *   }
     * }
     */
    data_names: {},

    /**
     * Set custom data class.<br><br>
     * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
     * @name dataclasses
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
              *   classes: {
              *     data1: "additional-data1-class",
              *     data2: "additional-data2-class"
              *   }
     * }
     */
    data_classes: {},

    /**
     * Set groups for the data for stacking.
     * @name datagroups
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     * data: {
              *   groups: [
              *     ["data1", "data2"],
              *     ["data3"]
              *   ]
     * }
     */
    data_groups: [],

    /**
     * Set y axis the data related to. y and y2 can be used.
     * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
     * @name dataaxes
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   axes: {
     *     data1: "y",
     *     data2: "y2"
     *   }
     * }
     */
    data_axes: {},

    /**
     * Set chart type at once.<br><br>
     * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
     * **Available Values:**
     * - area
     * - area-line-range
     * - area-spline
     * - area-spline-range
     * - area-step
     * - bar
     * - bubble
     * - donut
     * - gauge
     * - line
     * - pie
     * - radar
     * - scatter
     * - spline
     * - step
     * @name datatype
     * @memberof Options
     * @type {String}
     * @default line
     * @example
     * data: {
     *    type: "bar"
     * }
     */
    data_type: undefined,

    /**
     * Set chart type for each data.<br>
     * This setting overwrites data.type setting.
     * - **NOTE:** `radar` type can't be combined with other types.
     * @name datatypes
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   types: {
     *     data1: "bar",
     *     data2: "spline"
     *   }
     * }
     */
    data_types: {},

    /**
     * Set labels options
     * @name datalabels
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [data.labels=false] Show or hide labels on each data points
     * @property {Boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)
     * @property {Function} [data.labels.format] Set formatter function for data labels.<br>
     * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
     *  - `v` is the value of the data point where the label is shown.
     *  - `id` is the id of the data where the label is shown.
     *  - `i` is the index of the data point where the label is shown.
     *  - `j` is the sub index of the data point where the label is shown.<br><br>
     * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
    	 * @property {String|Object} [data.labels.colors] Set label text colors.
     * @property {Object} [data.labels.position] Set each dataset position, relative the original.
     * @property {Number} [data.labels.position.x=0] x coordinate position, relative the original.
     * @property {Number} [data.labels.position.y=0] y coordinate position, relative the original.
     * @memberof Options
     * @type {Object}
     * @default {}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)
     * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)
     * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)
     * @see [Demo: label overlap](https://naver.github.io/billboard.js/demo/#Data.DataLabelOverlap)
     * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)
     * @example
     * data: {
     *   labels: true,
     *
     *   // or set specific options
     *   labels: {
     *     format: function(v, id, i, j) { ... },
     *
     *     // it's possible to set for each data
     *     format: {
     *         data1: function(v, id, i, j) { ... },
     *         ...
     *     },
     *
     *     // align text to center of the 'bar' shape (works only for 'bar' type)
     *     centered: true,
     *
     *     // apply for all label texts
     *     colors: "red",
     *
     *     // or set different colors per dataset
     *     // for not specified dataset, will have the default color value
     *     colors: {
     *        data1: "yellow",
     *        data3: "green"
     *     },
     *
     *     // set x, y coordinate position
     *     position: {
     *        x: -10,
     *        y: 10
     *     },
     *
     *     // or set x, y coordinate position by each dataset
     *     position: {
     *        data1: {x: 5, y: 5},
     *        data2: {x: 10, y: -20}
     *     }
     *   }
     * }
     */
    data_labels: {},
    data_labels_colors: undefined,
    data_labels_position: {},

    /**
     *  This option changes the order of stacking data and pieces of pie/donut.
     *  - If `null` specified, it will be the order the data loaded.
     *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
     *
     *  **Available Values:**
     *  - `desc`: In descending order
     *  - `asc`: In ascending order
     *  - `null`: It keeps the data load order
     *  - `function(data1, data2) { ... }`: Array.sort compareFunction
     * @name dataorder
     * @memberof Options
     * @type {String|Function|null}
     * @default desc
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)
     * @example
     * data: {
     *   // in descending order (default)
     *   order: "desc"
     *
     *   // in ascending order
     *   order: "asc"
     *
     *   // keeps data input order
     *   order: null
     *
     *   // specifying sort function
     *   order: function(a, b) {
     *       // param data passed format
     *       {
     *          id: "data1", id_org: "data1", values: [
     *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
     *              ...
     *          ]
     *       }
     *   }
     * }
     */
    data_order: "desc",

    /**
     * Define regions for each data.<br>
     * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.
     * - The object type should be as:
     *   - start {Number}: Start data point number. If not set, the start will be the first data point.
     *   - [end] {Number}: End data point number. If not set, the end will be the last data point.
     *   - [style.dasharray="2 2"] {Object}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.
     * - **NOTE:** Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
     * @name dataregions
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   regions: {
     *     data1: [{
     *         start: 1,
     *         end: 2,
     *         style: {
     *             dasharray: "5 2"
     *         }
     *     }, {
     *         start: 3
     *     }],
     *     ...
     *   }
     * }
     */
    data_regions: {},

    /**
     * Set color converter function.<br><br>
     * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
     * @name datacolor
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)
     * @example
     * data: {
     *   color: function(color, d) { ... }
     * }
     */
    data_color: undefined,

    /**
     * Set color for each data.
     * @name datacolors
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   colors: {
     *     data1: "#ff0000",
     *     data2: function(d) {
     *        return "#000";
     *     }
     *     ...
     *   }
     * }
     */
    data_colors: {},

    /**
     * Hide each data when the chart appears.<br><br>
     * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
     * @name datahide
     * @memberof Options
     * @type {Boolean|Array}
     * @default false
     * @example
     * data: {
     *   // all of data will be hidden
     *   hide: true
     *
     *   // specified data will be hidden
     *   hide: ["data1", ...]
     * }
     */
    data_hide: !1,

    /**
     * Filter values to be shown
     * The data value is the same as the returned by `.data()`.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
     * @name datafilter
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * data: {
     *   // filter for id value
     *   filter: function(v) {
     *      // v: [{id: "data1", id_org: "data1", values: [
     *      //      {x: 0, value: 130, id: "data2", index: 0}, ...]
     *      //    }, ...]
     *      return v.id !== "data1";
     *   }
     */
    data_filter: undefined,

    /**
     * Set the stacking to be normalized
     * - **NOTE:**
     *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set
     *   - y Axis will be set in percentage value (0 ~ 100%)
     *   - Must have postive values
     * @name datastacknormalize
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)
     * @example
     * data: {
        *   stack: {
        *      normalize: true
        *   }
        * }
     */
    data_stack_normalize: !1,

    /**
     * Set data selection enabled<br><br>
     * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
     * @name dataselectionenabled
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)
     * @example
     * data: {
     *    selection: {
     *       enabled: true
     *    }
     * }
     */
    data_selection_enabled: !1,

    /**
     * Set grouped selection enabled.<br><br>
     * If this option set true, multiple data points that have same x value will be selected by one selection.
     * @name dataselectiongrouped
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * data: {
     *    selection: {
     *       grouped: true
     *    }
     * }
     */
    data_selection_grouped: !1,

    /**
     * Set a callback for each data point to determine if it's selectable or not.<br><br>
     * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
     * @name dataselectionisselectable
     * @memberof Options
     * @type {Function}
     * @default function() { return true; }
     * @example
     * data: {
     *    selection: {
     *       isselectable: function(d) { ... }
     *    }
     * }
     */
    data_selection_isselectable: function data_selection_isselectable() {
      return !0;
    },

    /**
     * Set multiple data points selection enabled.<br><br>
     * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
     * @name dataselectionmultiple
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
     *    selection: {
     *       multiple: false
     *    }
     * }
     */
    data_selection_multiple: !0,

    /**
     * Enable to select data points by dragging.
     * If this option set true, data points can be selected by dragging.
     * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
     * @name dataselectiondraggable
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * data: {
     *    selection: {
     *       draggable: true
     *   }
     * }
     */
    data_selection_draggable: !1,

    /**
     * Set a callback for click event on each data point.<br><br>
     * This callback will be called when each data point clicked and will receive `d` and element as the arguments.
     * - `d` is the data clicked and element is the element clicked.
     * - `element` is the current interacting svg element.
     * - In this callback, `this` will be the Chart object.
     * @name dataonclick
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onclick: function(d, element) {
     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
     *        // element - <circle>
     *        ...
     *     }
     * }
     */
    data_onclick: function data_onclick() {},

    /**
     * Set a callback for mouse/touch over event on each data point.<br><br>
     * This callback will be called when mouse cursor or via touch moves onto each data point and will receive `d` and `element` as the argument.
     * - `d` is the data where mouse cursor moves onto.
     * - `element` is the current interacting svg element.
     * - In this callback, `this` will be the Chart object.
     * @name dataonover
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onover: function(d, element) {
     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
     *        // element - <circle>
     *        ...
     *     }
     * }
     */
    data_onover: function data_onover() {},

    /**
     * Set a callback for mouse/touch out event on each data point.<br><br>
     * This callback will be called when mouse cursor or via touch moves out each data point and will receive `d` as the argument.
     * - `d` is the data where mouse cursor moves out.
     * - `element` is the current interacting svg element.
     * - In this callback, `this` will be the Chart object.
     * @name dataonout
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onout: function(d, element) {
     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
     *        // element - <circle>
     *        ...
     *     }
     * }
     */
    data_onout: function data_onout() {},

    /**
     * Set a callback for on data selection.
     * @name dataonselected
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onselected: function(d, element) {
     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
     *        // element - <circle>
     *        ...
     *    }
     * }
     */
    data_onselected: function data_onselected() {},

    /**
     * Set a callback for on data un-selection.
     * @name dataonunselected
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onunselected: function(d, element) {
     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
     *        // element - <circle>
     *        ...
     *    }
     * }
     */
    data_onunselected: function data_onunselected() {},

    /**
     * Set a callback for minimum data
     * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
     * @name dataonmin
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
     * @example
     *  onmin: function(data) {
     *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
        *    ...
     *  }
     */
    data_onmin: undefined,

    /**
     * Set a callback for maximum data
     * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
     * @name dataonmax
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
     * @example
     *  onmax: function(data) {
     *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
        *    ...
     *  }
     */
    data_onmax: undefined,

    /**
     * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
     * @name dataurl
     * @memberof Options
     * @type {String}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)
     * @example
     * data: {
     *     url: "/data/test.csv"
     * }
     */
    data_url: undefined,

    /**
     * XHR header value
     * - **NOTE:** Should be used with `data.url` option
     * @name dataheaders
     * @memberof Options
     * @type {String}
     * @default undefined
     * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader
     * @example
     * data: {
     *     url: "/data/test.csv",
     *     headers: {
     *        "Content-Type": "text/xml",
     *        ...
     *     }
     * }
     */
    data_headers: undefined,

    /**
     * Parse a JSON object for data. See also data.keys.
     * @name datajson
     * @memberof Options
     * @type {Object}
     * @default undefined
     * @see [datakeys](#.data%25E2%2580%25A4keys)
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)
     * @example
     * data: {
     *     json: [
     *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
     *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
     *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
     *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
     *     ],
     *     keys: {
     *       // x: "name", // it's possible to specify 'x' when category axis
     *       value: ["upload", "download"]
     *     }
     * }
     */
    data_json: undefined,

    /**
     * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
     * @name datarows
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)
     * @example
     * data: {
     *   rows: [
     *     ["A", "B", "C"],
     *     [90, 120, 300],
     *     [40, 160, 240],
     *     [50, 200, 290],
     *     [120, 160, 230],
     *     [80, 130, 300],
     *     [90, 220, 320]
     *   ]
     * }
     *
     * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
     * // - an array of [high, mid, low] data following the order
     * // - or an object with 'high', 'mid' and 'low' key value
     * data: {
     *   rows: [
     *      ["data1", "data2"],
     *      [
     *        // or {high:150, mid: 140, low: 110}, 120
     *        [150, 140, 110], 120
     *      ],
     *      [[155, 130, 115], 55],
     *      [[160, 135, 120], 60]
     *   ],
     *   types: {
     *       data1: "area-line-range",
     *       data2: "line"
     *   }
     * }
     *
     * // for 'bubble' type, data can contain dimension value:
     * // - an array of [y, z] data following the order
     * // - or an object with 'y' and 'z' key value
     * // 'y' is for y axis coordination and 'z' is the bubble radius value
     * data: {
     *   rows: [
     *      ["data1", "data2"],
     *      [
     *        // or {y:10, z: 140}, 120
     *        [10, 140], 120
     *      ],
     *      [[100, 30], 55],
     *      [[50, 100], 60]
     *   ],
     *   types: {
     *       data1: "bubble",
     *       data2: "line"
     *   }
     * }
     */
    data_rows: undefined,

    /**
     * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
     * @name datacolumns
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)
     * @example
     * data: {
     *   columns: [
     *      ["data1", 30, 20, 50, 40, 60, 50],
     *      ["data2", 200, 130, 90, 240, 130, 220],
     *      ["data3", 300, 200, 160, 400, 250, 250]
     *   ]
     * }
     *
     * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
     * // - an array of [high, mid, low] data following the order
     * // - or an object with 'high', 'mid' and 'low' key value
     * data: {
     *   columns: [
     *      ["data1",
     *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
     *          [150, 140, 110],
     *          [150, 140, 110]
     *      ]
     *   ],
     *   type: "area-line-range"
     * }
     *
     * // for 'bubble' type, data can contain dimension value:
     * // - an array of [y, z] data following the order
     * // - or an object with 'y' and 'z' key value
     * // 'y' is for y axis coordination and 'z' is the bubble radius value
     * data: {
     *   columns: [
     *      ["data1",
     *          [10, 140],  // or {y:10, z: 140}
     *          [100, 30],
     *          [50, 100]
     *      ]
     *   ],
     *   type: "bubble"
     * }
     */
    data_columns: undefined,

    /**
     * Used if loading JSON via data.url.
     * - **Available Values:**
     *   - json
     *   - csv
     *   - tsv
     * @name datamimeType
     * @memberof Options
     * @type {String}
     * @default csv
     * @example
     * data: {
     *     mimeType: "json"
     * }
     */
    data_mimeType: "csv",

    /**
     * Choose which JSON object keys correspond to desired data.
     * - **NOTE:** Only for JSON object given as array.
     * @name datakeys
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * data: {
     *     json: [
     *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
     *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
     *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
     *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
     *     ],
     *     keys: {
     *       // x: "name", // it's possible to specify 'x' when category axis
     *       value: ["upload", "download"]
     *     }
     * }
     */
    data_keys: undefined,

    /**
     * Set text label to be displayed when there's no data to show.
     * - ex. Toggling all visible data to not be shown, unloading all current data, etc.
     * @name dataemptylabeltext
     * @memberof Options
     * @type {String}
     * @default ""
     * @example
     * data: {
     *   empty: {
     *     label: {
     *       text: "No Data"
     *     }
     *   }
     * }
     */
    data_empty_label_text: "",

    /**
     * Set subchart options
     * @name subchart
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
     * @property {Boolean} [subchart.axis.x.show=true] Show or hide x axis.
     * @property {Boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.
     * @property {Boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.
     * @property {Number} [subchart.size.height] Change the height of the subchart.
     * @property {Function} [subchart.onbrush] Set callback for brush event.<br>
     *  Specified function receives the current zoomed x domain.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)
     * @example
     *  subchart: {
     *      axis: {
     *      	x: {
     *      	  show: true,
     *      	    tick: {
     *      	      show: true,
     *      	      text: {
     *      	        show: false
     *      	      }
     *      	    }
     *      	}
     *      },
     *      show: true,
     *      size: {
     *          height: 20
     *      },
     *      onbrush: function(domain) { ... }
     *  }
     */
    subchart_show: !1,
    subchart_size_height: 60,
    subchart_axis_x_show: !0,
    subchart_axis_x_tick_show: !0,
    subchart_axis_x_tick_text_show: !0,
    subchart_onbrush: function subchart_onbrush() {},

    /**
     * Set color of the data values
     * @name color
     * @memberof Options
     * @type {Object}
     * @property {String|Object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.
     * @property {Array|null} [color.pattern=[]] Set custom color pattern. Passing `null` will not set a color for these elements, which requires the usage of custom CSS-based theming to work.
     * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
     *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
     *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
     *    - `bb-colorize-pattern-red`
     *    - `bb-colorize-pattern-fff`
     * @property {Object} [color.threshold] color threshold for gauge and tooltip color
     * @property {String} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.
     * @property {Array} [color.threshold.values] Threshold values for each steps
     * @property {Number} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.
     * @example
     *  color: {
     *      pattern: ["#1f77b4", "#aec7e8", ...],
     *
     *      // Set colors' patterns
     *      // it should return an array of SVGPatternElement
     *      tiles: function() {
     *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
     *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
     *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
     *
     *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
     *         pattern.setAttribute("width", "32");
     *         pattern.setAttribute("height", "32");
     *
     *         g.style.fill = "#000";
     *         g.style.opacity = "0.2";
              *
     *         circle1.setAttribute("cx", "3");
     *         circle1.setAttribute("cy", "3");
     *         circle1.setAttribute("r", "3");
              *
     *         g.appendChild(circle1);
     *         pattern.appendChild(g);
     *
     *         return [pattern];
     *      },
     *
     *      // for threshold usage, pattern values should be set for each steps
     *      pattern: ["grey", "green", "yellow", "orange", "red"],
     *      threshold: {
     *          unit: "value",
     *
     *          // when value is 20 => 'green', value is 40 => 'orange' will be set.
     *          values: [10, 20, 30, 40, 50],
     *
     *          // the equation for max:
     *          // - unit == 'value': max => 30
     *          // - unit != 'value': max => value*100/30
     *          max: 30
     *      },
     *
     *      // set all data to 'red'
     *      onover: "red",
     *
     *      // set different color for data
     *      onover: {
     *          data1: "red",
     *          data2: "yellow"
     *      },
     *
     *      // will pass data object to the callback
     *      onover: function(d) {
     *          return d.id === "data1" ? "red" : "green";
     *      }
     *  }
     */
    color_pattern: [],
    color_tiles: undefined,
    color_threshold: {},
    color_onover: undefined,

    /**
     * Legend options
     * @name legend
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [legend.show=true] Show or hide legend.
     * @property {Boolean} [legend.hide=false] Hide legend
     *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
     * @property {String|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
     * @property {String|Function} [legend.contents.template=undefined] Set item's template.<br>
     *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
     *    - {=COLOR}: data color value
     *    - {=TITLE}: data title value
     *  - If set `function` value, will pass following arguments to the given function:
     *   - title {String}: data's id value
     *   - color {String}: color string
     *   - data {Array}: data array
     * @property {String} [legend.position=bottom] Change the position of legend.<br>
     *  Available values are: `bottom`, `right` and `inset` are supported.
     * @property {Object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
     *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
     *  - **anchor** decides the position of the legend:
     *   - top-left
     *   - top-right
     *   - bottom-left
     *   - bottom-right
     *  - **x** and **y**:
     *   - set the position of the legend based on the anchor.
     *  - **step**:
     *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
     * @property {Boolean} [legend.equally=false] Set to all items have same width size.
     * @property {Boolean} [legend.padding=0] Set padding value
     * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
     * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
     * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
     * @property {Number} [legend.item.tile.width=10] Set width of item tile element
     * @property {Number} [legend.item.tile.height=10] Set height of item tile element
     * @property {Boolean} [legend.usePoint=false] Whether to use custom points in legend.
     * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)
     * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)
     * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)
     * @example
     *  legend: {
     *      show: true,
     *      hide: true,
     *      //or hide: "data1"
              *      //or hide: ["data1", "data2"]
     *      contents: {
     *          bindto: "#legend",   // <ul id='legend'></ul>
     *
     *          // will be as: <li style='background-color:#1f77b4'>data1</li>
     *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
     *
     *          // or using function
     *          template: function(id, color, data) {
     *               // if you want omit some legend, return falsy value
     *               if (title !== "data1") {
     *                    return "<li style='background-color:"+ color +">"+ title +"</li>";
     *               }
     *          }
     *      },
              *      position: "bottom",  // bottom, right, inset
     *      inset: {
     *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
     *          x: 20,
     *          y: 10,
     *          step: 2
     *      },
              *      equally: false,
              *      padding: 10,
              *      item: {
     *          onclick: function(id) { ... },
     *          onover: function(id) { ... },
     *          onout: function(id) { ... },
     *
     *          // set tile's size
     *          tile: {
     *              width: 20,
     *              height: 15
     *          }
     *      },
     *      usePoint: true
     *  }
     */
    legend_show: !0,
    legend_hide: !1,
    legend_contents_bindto: undefined,
    legend_contents_template: undefined,
    legend_position: "bottom",
    legend_inset_anchor: "top-left",
    legend_inset_x: 10,
    legend_inset_y: 0,
    legend_inset_step: undefined,
    legend_item_onclick: undefined,
    legend_item_onover: undefined,
    legend_item_onout: undefined,
    legend_equally: !1,
    legend_padding: 0,
    legend_item_tile_width: 10,
    legend_item_tile_height: 10,
    legend_usePoint: !1,

    /**
     * Switch x and y axis position.
     * @name axisrotated
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   rotated: true
     * }
     */
    axis_rotated: !1,

    /**
     * Set clip-path attribute for x axis element
     * @name axisxclipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo]()
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    axis_x_clipPath: !0,

    /**
     * Show or hide x axis.
     * @name axisxshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     show: false
     *   }
     * }
     */
    axis_x_show: !0,

    /**
     * Set type of x axis.<br><br>
     * **Available Values:**
     * - timeseries
     * - category
     * - indexed
     * @name axisxtype
     * @memberof Options
     * @type {String}
     * @default indexed
     * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
     * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)
     * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)
     * @example
     * axis: {
     *   x: {
     *     type: "timeseries"
     *   }
     * }
     */
    axis_x_type: "indexed",

    /**
     * Set how to treat the timezone of x values.<br>
     * If true, treat x value as localtime. If false, convert to UTC internally.
     * @name axisxlocaltime
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     localtime: false
     *   }
     * }
     */
    axis_x_localtime: !0,

    /**
     * Set category names on category axis.
     * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
     * @name axisxcategories
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     * axis: {
     *   x: {
     *     categories: ["Category 1", "Category 2", ...]
     *   }
     * }
     */
    axis_x_categories: [],

    /**
     * centerize ticks on category axis.
     * @name axisxtickcentered
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       centered: true
     *     }
     *   }
     * }
     */
    axis_x_tick_centered: !1,

    /**
     * A function to format tick value. Format string is also available for timeseries data.
     * @name axisxtickformat
     * @memberof Options
     * @type {Function|String}
     * @default undefined
     * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *        // for timeseries, a 'datetime' object is given as parameter
     *       format: function(x) {
     *           return x.getFullYear();
     *       }
     *
     *       // for category, index(Number) and categoryName(String) are given as parameter
     *       format: function(index, categoryName) {
     *           return categoryName.substr(0, 10);
     *       },
     *
     *        // for timeseries format specifier
     *        format: "%Y-%m-%d %H:%M:%S"
     *     }
     *   }
     * }
     */
    axis_x_tick_format: undefined,

    /**
     * Setting for culling ticks.<br><br>
     * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
     * We can change the number of ticks to be shown by axis.x.tick.culling.max.
     * @name axisxtickculling
     * @memberof Options
     * @type {Boolean}
     * @default
     * - true for indexed axis and timeseries axis
     * - false for category axis
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       culling: false
     *     }
     *   }
     * }
     */
    axis_x_tick_culling: {},

    /**
     * The number of tick texts will be adjusted to less than this value.
     * @name axisxtickcullingmax
     * @memberof Options
     * @type {Number}
     * @default 10
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       culling: {
     *           max: 5
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_culling_max: 10,

    /**
     * The number of x axis ticks to show.<br><br>
     * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
     * @name axisxtickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_x_tick_count: undefined,

    /**
     * Show or hide x axis tick line.
     * @name axisxtickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_x_tick_show: !0,

    /**
     * Show or hide x axis tick text.
     * @name axisxticktextshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       text: {
     *           show: false
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_text_show: !0,

    /**
     * Set the x Axis tick text's position relatively its original position
     * @name axisxticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Fit x axis ticks.
     * - **true**: ticks will be positioned nicely to have same intervals.
     * - **false**: ticks will be positioned according to x value of the data points.
     * @name axisxtickfit
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)
     * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       fit: false
     *     }
     *   }
     * }
     */
    axis_x_tick_fit: !0,

    /**
     * Set the x values of ticks manually.<br><br>
     * If this option is provided, the position of the ticks will be determined based on those values.<br>
     * This option works with `timeseries` data and the x values will be parsed accoding to the type of the value and data.xFormat option.
     * @name axisxtickvalues
     * @memberof Options
     * @type {Array|Function}
     * @default null
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       values: [1, 2, 4, 8, 16, 32, ...],
     *
     *       // an Array value should be returned
     *       values: function() {
     *       	return [ ... ];
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_values: null,

    /**
     * Rotate x axis tick text if there is not enough space for 'category' and 'timeseries' type axis.
     * - **NOTE:** The conditions where `autorotate` is enabled are:
     *   - axis.x.type='category' or 'timeseries
     *   - axis.x.tick.multiline=false
     *   - axis.x.tick.culling=false
     *   - axis.x.tick.fit=true
     * @name axisxtickautorotate
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickAutorotate)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       rotate: 15,
     *       autorotate: true,
     *       multiline: false,
     *       culling: false,
     *       fit: true
     *     }
     *   }
     * }
     */
    axis_x_tick_autorotate: !1,

    /**
     * Rotate x axis tick text.
     * - If you set negative value, it will rotate to opposite direction.
     * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `false`.
     * - As long as `axis_x_tick_fit` is set to `true` it will calculate an overflow for the y2 axis and add this value to the right padding.
     * @name axisxtickrotate
     * @memberof Options
     * @type {Number}
     * @default 0
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       rotate: 60
     *     }
     *   }
     * }
     */
    axis_x_tick_rotate: 0,

    /**
     * Show x axis outer tick.
     * @name axisxtickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_x_tick_outer: !0,

    /**
     * Set tick text to be multiline
     * - **NOTE:**
     *  > When x tick text contains `\n`, it's used as line break and 'axis.x.tick.width' option is ignored.
     * @name axisxtickmultiline
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       multiline: false
     *     }
     *   }
     * }
     * @example
     * // example of line break with '\n'
     * // In this case, 'axis.x.tick.width' is ignored
     * data: {
     *    x: "x",
     *    columns: [
     *        ["x", "long\ntext", "Another\nLong\nText"],
     *        ...
     *    ],
     * }
     */
    axis_x_tick_multiline: !0,

    /**
     * Set tick width
     * - **NOTE:**
     *  > When x tick text contains `\n`, this option is ignored.
     * @name axisxtickwidth
     * @memberof Options
     * @type {Number}
     * @default null
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       width: 50
     *     }
     *   }
     * }
     */
    axis_x_tick_width: null,

    /**
     * Set to display system tooltip(via 'title' attribute) for tick text
     * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)
     * @name axisxticktooltip
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       tooltip: true
     *     }
     *   }
     * }
     */
    axis_x_tick_tooltip: !1,

    /**
     * Set max value of x axis range.
     * @name axisxmax
     * @memberof Options
     * @property {Number} max Set the max value
     * @property {Boolean} [max.fit=false] When specified `max.value` is greater than the bound data value, setting `true` will make x axis max to be fitted to the bound data max value.
     * - **NOTE:** If the bound data max value is greater than the `max.value`, the x axis max will be limited as the given `max.value`.
     * @property {Number} [max.value] Set the max value
     * @example
     * axis: {
     *   x: {
     *     max: 100,
     *
     *     max: {
     *       // 'fit=true' will make x axis max to be limited as the bound data value max when 'max.value' is greater.
     *       // - when bound data max is '10' and max.value: '100' ==>  x axis max will be '10'
     *       // - when bound data max is '1000' and max.value: '100' ==> x axis max will be '100'
     *       fit: true,
     *       value: 100
     *     }
     *   }
     * }
     */
    axis_x_max: undefined,

    /**
     * Set min value of x axis range.
     * @name axisxmin
     * @memberof Options
     * @property {Number} min Set the min value
     * @property {Boolean} [min.fit=false] When specified `min.value` is lower than the bound data value, setting `true` will make x axis min to be fitted to the bound data min value.
     * - **NOTE:** If the bound data min value is lower than the `min.value`, the x axis min will be limited as the given `min.value`.
     * @property {Number} [min.value] Set the min value
     * @example
     * axis: {
     *   x: {
     *     min: -100,
     *
     *     min: {
     *       // 'fit=true' will make x axis min to be limited as the bound data value min when 'min.value' is lower.
     *       // - when bound data min is '-10' and min.value: '-100' ==>  x axis min will be '-10'
     *       // - when bound data min is '-1000' and min.value: '-100' ==> x axis min will be '-100'
     *       fit: true,
     *       value: -100
     *     }
     *   }
     * }
     */
    axis_x_min: undefined,

    /**
     * Set padding for x axis.<br><br>
     * If this option is set, the range of x axis will increase/decrease according to the values.
     * If no padding is needed in the rage of x axis, 0 should be set.
     * - **NOTE:**
     *   The padding values aren't based on pixels. It differs according axis types<br>
     *   - **category:** The unit of tick value
     *     ex. the given value `1`, is same as the width of 1 tick width
     *   - **timeseries:** Numeric time value
     *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
     * @name axisxpadding
     * @memberof Options
     * @type {Object|Number}
     * @default {}
     * @example
     * axis: {
     *   x: {
     *     padding: {
     *       // when axis type is 'category'
     *       left: 1,  // set left padding width of equivalent value of a tick's width
     *       right: 0.5  // set right padding width as half of equivalent value of tick's width
     *
     *       // when axis type is 'timeseries'
     *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
     *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
     *     },
     *
     *     // or set both values at once.
     *     padding: 10
     *   }
     * }
     */
    axis_x_padding: {},

    /**
     * Set height of x axis.<br><br>
     * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
     * @name axisxheight
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     height: 20
     *   }
     * }
     */
    axis_x_height: undefined,

    /**
     * Set default extent for subchart and zoom. This can be an array or function that returns an array.
     * @name axisxextent
     * @memberof Options
     * @type {Array|Function}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     // extent range as a pixel value
     *     extent: [0, 200],
     *
     *     // when axis is 'timeseries', parsable datetime string
     *     extent: ["2019-03-01", "2019-03-05"],
     *
     *     // return extent value
     *     extent: function(domain, scale) {
     *    	 var extent = domain.map(function(v) {
     *     	    return scale(v);
     *     	 });
     *
     *   	 // it should return a format of array
     *   	 // ex) [0, 584]
     *     	 return extent;
     *     }
     *   }
     * }
     */
    axis_x_extent: undefined,

    /**
     * Set label on x axis.<br><br>
     * You can set x axis label and change its position by this option.
     * `string` and `object` can be passed and we can change the poisiton by passing object that has position key.<br>
     * Available position differs according to the axis direction (vertical or horizontal).
     * If string set, the position will be the default.
     *
     *  - **If it's horizontal axis:**
     *    - inner-right [default]
     *    - inner-center
     *    - inner-left
     *    - outer-right
     *    - outer-center
     *    - outer-left
     *  - **If it's vertical axis:**
     *    - inner-top [default]
     *    - inner-middle
     *    - inner-bottom
     *    - outer-top
     *    - outer-middle
     *    - outer-bottom
     * @name axisxlabel
     * @memberof Options
     * @type {String|Object}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     label: "Your X Axis"
     *   }
     * }
     *
     * axis: {
     *   x: {
     *     label: {
     *        text: "Your X Axis",
     *        position: "outer-center"
     *     }
     *   }
     * }
     */
    axis_x_label: {},

    /**
     * Set additional axes for x Axis.
     * - **NOTE:** Axis' scale is based on x Axis value if domain option isn't set.
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | domain | Array | - | Set the domain value |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisxaxes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
     * @example
     * x: {
     *    axes: [
     *      {
     *        // if set, will not be correlated with the main x Axis domain value
    	 *        domain: [0, 1000],
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_x_axes: [],

    /**
     * Set clip-path attribute for y axis element
     * - **NOTE**: `clip-path` attribute for y Axis is set only when `axis.y.inner` option is true.
     * @name axisyclipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    axis_y_clipPath: !0,

    /**
     * Show or hide y axis.
     * @name axisyshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y: {
     *     show: false
     *   }
     * }
     */
    axis_y_show: !0,

    /**
     * Set type of y axis.<br><br>
     * **Available Values:**
     *   - timeseries
     *   - indexed
     * @name axisytype
     * @memberof Options
     * @type {String}
     * @default "indexed"
     * @example
     * axis: {
     *   y: {
     *     type: "timeseries"
     *   }
     * }
     */
    axis_y_type: undefined,

    /**
     * Set max value of y axis.
     * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
     * @name axisymax
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     max: 1000
     *   }
     * }
     */
    axis_y_max: undefined,

    /**
     * Set min value of y axis.
     * - **NOTE:**
     *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
     * @name axisymin
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     min: 1000
     *   }
     * }
     */
    axis_y_min: undefined,

    /**
     * Change the direction of y axis.<br><br>
     * If true set, the direction will be from the top to the bottom.
     * @name axisyinverted
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y: {
     *     inverted: true
     *   }
     * }
     */
    axis_y_inverted: !1,

    /**
     * Set center value of y axis.
     * @name axisycenter
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     center: 0
     *   }
     * }
     */
    axis_y_center: undefined,

    /**
     * Show y axis inside of the chart.
     * @name axisyinner
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y: {
     *     inner: true
     *   }
     * }
     */
    axis_y_inner: !1,

    /**
     * Set label on y axis.<br><br>
     * You can set y axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
     * @name axisylabel
     * @memberof Options
     * @type {String|Object}
     * @default {}
     * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
     * @example
     * axis: {
     *   y: {
     *     label: "Your Y Axis"
     *   }
     * }
     *
     * axis: {
     *   y: {
     *     label: {
     *        text: "Your Y Axis",
     *        position: "outer-middle"
     *     }
     *   }
     * }
     */
    axis_y_label: {},

    /**
     * Set formatter for y axis tick text.<br><br>
     * This option accepts d3.format object as well as a function you define.
     * @name axisytickformat
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       format: function(x) {
     *           return x.getFullYear();
     *       }
     *     }
     *   }
     * }
     */
    axis_y_tick_format: undefined,

    /**
     * Setting for culling ticks.<br><br>
     * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
     * We can change the number of ticks to be shown by axis.y.tick.culling.max.
     * @name axisytickculling
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       culling: false
     *     }
     *   }
     * }
     */
    axis_y_tick_culling: !1,

    /**
     * The number of tick texts will be adjusted to less than this value.
     * @name axisytickcullingmax
     * @memberof Options
     * @type {Number}
     * @default 5
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       culling: {
     *           max: 5
     *       }
     *     }
     *   }
     * }
     */
    axis_y_tick_culling_max: 5,

    /**
     * Show y axis outer tick.
     * @name axisytickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_y_tick_outer: !0,

    /**
     * Set y axis tick values manually.
     * @name axisytickvalues
     * @memberof Options
     * @type {Array|Function}
     * @default null
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       values: [100, 1000, 10000],
     *
     *       // an Array value should be returned
     *       values: function() {
     *       	return [ ... ];
     *       }
     *     }
     *   }
     * }
     */
    axis_y_tick_values: null,

    /**
     * Rotate y axis tick text.
     * - If you set negative value, it will rotate to opposite direction.
     * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
     * @name axisytickrotate
     * @memberof Options
     * @type {Number}
     * @default 0
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       rotate: 60
     *     }
     *   }
     * }
     */
    axis_y_tick_rotate: 0,

    /**
     * Set the number of y axis ticks.<br><br>
     * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
     * @name axisytickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_y_tick_count: undefined,

    /**
     * Show or hide y axis tick line.
     * @name axisytickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_y_tick_show: !0,

    /**
     * Set axis tick step(interval) size.
     * - **NOTE:** Will be ignored if `axis.y.tick.count` or `axis.y.tick.values` options are set.
     * @name axisytickstepSize
     * @memberof Options
     * @type {Number}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       // tick value will step as indicated interval value.
     *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
     *       stepSize: 15
     *     }
     *   }
     * }
     */
    axis_y_tick_stepSize: null,

    /**
    * Show or hide y axis tick text.
    * @name axisyticktextshow
    * @memberof Options
    * @type {Boolean}
    * @default true
    * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
    * @example
    * axis: {
    *   y: {
    *     tick: {
    *       text: {
    *           show: false
    *       }
    *     }
    *   }
    * }
    */
    axis_y_tick_text_show: !0,

    /**
     * Set the y Axis tick text's position relatively its original position
     * @name axisyticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_y_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Set the number of y axis ticks.<br><br>
     * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
     * @name axisyticktime
     * @memberof Options
     * @private
     * @type {Object}
     * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       time: {
     *          // ticks at 15-minute intervals
     *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
     *          value: d3.timeMinute.every(15)
     *       }
     *     }
     *   }
     * }
     */
    // @TODO: not fully implemented yet
    axis_y_tick_time_value: undefined,

    /**
     * Set padding for y axis.<br><br>
     * You can set padding for y axis to create more space on the edge of the axis.
     * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
     *
     * - **NOTE:**
     *   - Given values are translated relative to the y Axis domain value for padding
     *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
     * @name axisypadding
     * @memberof Options
     * @type {Object|Number}
     * @default {}
     * @example
     * axis: {
     *   y: {
     *     padding: {
     *       top: 0,
     *       bottom: 0
     *     },
     *
     *     // or set both values at once.
     *     padding: 10
     *   }
     * }
     */
    axis_y_padding: {},

    /**
     * Set default range of y axis.<br><br>
     * This option set the default value for y axis when there is no data on init.
     * @name axisydefault
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     default: [0, 1000]
     *   }
     * }
     */
    axis_y_default: undefined,

    /**
     * Set additional axes for y Axis.
     * - **NOTE:** Axis' scale is based on y Axis value if domain option isn't set.
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | domain | Array | - | Set the domain value |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisyaxes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
     * @example
     * y: {
     *    axes: [
     *      {
     *        // if set, will not be correlated with the main y Axis domain value
     *        domain: [0, 1000],
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_y_axes: [],

    /**
     * Show or hide y2 axis.
     * - **NOTE**:
     *   - When set to `false` will not generate y2 axis node. In this case, all 'y2' axis related functionality won't work properly.
     *   - If need to use 'y2' related options while y2 isn't visible, set the value `true` and control visibility by css display property.
     * @name axisy2show
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     show: true
     *   }
     * }
     */
    axis_y2_show: !1,

    /**
     * Set max value of y2 axis.
     * @name axisy2max
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     max: 1000
     *   }
     * }
     */
    axis_y2_max: undefined,

    /**
     * Set min value of y2 axis.
     * @name axisy2min
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     min: -1000
     *   }
     * }
     */
    axis_y2_min: undefined,

    /**
     * Change the direction of y2 axis.<br><br>
     * If true set, the direction will be from the top to the bottom.
     * @name axisy2inverted
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     inverted: true
     *   }
     * }
     */
    axis_y2_inverted: !1,

    /**
     * Set center value of y2 axis.
     * @name axisy2center
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     center: 0
     *   }
     * }
     */
    axis_y2_center: undefined,

    /**
     * Show y2 axis inside of the chart.
     * @name axisy2inner
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     inner: true
     *   }
     * }
     */
    axis_y2_inner: !1,

    /**
     * Set label on y2 axis.<br><br>
     * You can set y2 axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
     * @name axisy2label
     * @memberof Options
     * @type {String|Object}
     * @default {}
     * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
     * @example
     * axis: {
     *   y2: {
     *     label: "Your Y2 Axis"
     *   }
     * }
     *
     * axis: {
     *   y2: {
     *     label: {
     *        text: "Your Y2 Axis",
     *        position: "outer-middle"
     *     }
     *   }
     * }
     */
    axis_y2_label: {},

    /**
     * Set formatter for y2 axis tick text.<br><br>
     * This option works in the same way as axis.y.format.
     * @name axisy2tickformat
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       format: d3.format("$,")
     *       //or format: function(d) { return "$" + d; }
     *     }
     *   }
     * }
     */
    axis_y2_tick_format: undefined,

    /**
     * Setting for culling ticks.<br><br>
     * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
     * We can change the number of ticks to be shown by axis.y.tick.culling.max.
     * @name axisy2tickculling
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       culling: false
     *     }
     *   }
     * }
     */
    axis_y2_tick_culling: !1,

    /**
     * The number of tick texts will be adjusted to less than this value.
     * @name axisy2tickcullingmax
     * @memberof Options
     * @type {Number}
     * @default 5
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       culling: {
     *           max: 5
     *       }
     *     }
     *   }
     * }
     */
    axis_y2_tick_culling_max: 5,

    /**
     * Show or hide y2 axis outer tick.
     * @name axisy2tickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_y2_tick_outer: !0,

    /**
     * Set y2 axis tick values manually.
     * @name axisy2tickvalues
     * @memberof Options
     * @type {Array|Function}
     * @default null
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       values: [100, 1000, 10000],
     *
     *       // an Array value should be returned
     *       values: function() {
     *       	return [ ... ];
     *       }
     *     }
     *   }
     * }
     */
    axis_y2_tick_values: null,

    /**
     * Rotate y2 axis tick text.
     * - If you set negative value, it will rotate to opposite direction.
     * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
     * @name axisy2tickrotate
     * @memberof Options
     * @type {Number}
     * @default 0
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       rotate: 60
     *     }
     *   }
     * }
     */
    axis_y2_tick_rotate: 0,

    /**
     * Set the number of y2 axis ticks.
     * - **NOTE:** This works in the same way as axis.y.tick.count.
     * @name axisy2tickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_y2_tick_count: undefined,

    /**
     * Show or hide y2 axis tick line.
     * @name axisy2tickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_y2_tick_show: !0,

    /**
     * Set axis tick step(interval) size.
     * - **NOTE:** Will be ignored if `axis.y2.tick.count` or `axis.y2.tick.values` options are set.
     * @name axisy2tickstepSize
     * @memberof Options
     * @type {Number}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       // tick value will step as indicated interval value.
     *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
     *       stepSize: 15
     *     }
     *   }
     * }
     */
    axis_y2_tick_stepSize: null,

    /**
     * Show or hide y2 axis tick text.
     * @name axisy2ticktextshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       text: {
     *           show: false
     *       }
     *     }
     *   }
     * }
     */
    axis_y2_tick_text_show: !0,

    /**
     * Set the y2 Axis tick text's position relatively its original position
     * @name axisy2ticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_y2_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Set padding for y2 axis.<br><br>
     * You can set padding for y2 axis to create more space on the edge of the axis.
     * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
     *
     * - **NOTE:**
     *   - Given values are translated relative to the y2 Axis domain value for padding
     *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
     * @name axisy2padding
     * @memberof Options
     * @type {Object|Number}
     * @default {}
     * @example
     * axis: {
     *   y2: {
     *     padding: {
     *       top: 100,
     *       bottom: 100
     *     }
     *
     *     // or set both values at once.
     *     padding: 10
     * }
     */
    axis_y2_padding: {},

    /**
     * Set default range of y2 axis.<br><br>
     * This option set the default value for y2 axis when there is no data on init.
     * @name axisy2default
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     default: [0, 1000]
     *   }
     * }
     */
    axis_y2_default: undefined,

    /**
     * Set additional axes for y2 Axis.
     * - **NOTE:** Axis' scale is based on y2 Axis value if domain option isn't set.
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | domain | Array | - | Set the domain value |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisy2axes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
     * @example
     * y2: {
     *    axes: [
     *      {
     *        // if set, will not be correlated with the main y2 Axis domain value
     *        domain: [0, 1000],
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_y2_axes: [],

    /**
     * Set related options
     * @name grid
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.
     * @property {Boolean} [x.show=false] Show grids along x axis.
     * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>
     *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
     *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
     * @property {Boolean} [y.show=false] Show grids along x axis.
     * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>
     *  This option accepts array including object that has value, text, position and class.
     * @property {Number} [y.ticks=10] Number of y grids to be shown.
     * @property {Boolean} [focus.edge=false] Show edged focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
     * @property {Boolean} [focus.show=true] Show grid line when focus.
     * @property {Boolean} [focus.y=false] Show y coordinate focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
     * @property {Boolean} [lines.front=true] Set grid lines to be positioned over chart elements.
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)
     * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)
     * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)
     * @example
     * grid: {
     *   x: {
     *     show: true,
     *     lines: [
     *       {value: 2, text: "Label on 2"},
     *       {value: 5, text: "Label on 5", class: "label-5"},
     *       {value: 6, text: "Label on 6", position: "start"}
     *     ]
     *   },
     *   y: {
     *     show: true,
     *     lines: [
     *       {value: 100, text: "Label on 100"},
     *       {value: 200, text: "Label on 200", class: "label-200"},
     *       {value: 300, text: "Label on 300", position: 'middle'}
     *     ],
     *     ticks: 5
     *   },
     *   front: true,
     *   focus: {
     *      show: false,
     *
     *      // Below options are available when 'tooltip.grouped=false' option is set
     *      edge: true,
     *      y: true
     *   },
     *   lines: {
     *      front: false
     *   }
     * }
     */
    grid_x_show: !1,
    grid_x_type: "tick",
    grid_x_lines: [],
    grid_y_show: !1,
    grid_y_lines: [],
    grid_y_ticks: 10,
    grid_focus_edge: !1,
    grid_focus_show: !0,
    grid_focus_y: !1,
    grid_front: !1,
    grid_lines_front: !0,

    /**
     * Set point options
     * @name point
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [point.show=true] Whether to show each point in line.
     * @property {Number|Function} [point.r=2.5] The radius size of each point.
     *  - **NOTE:** Disabled for 'bubble' type
     * @property {Boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
     * @property {Number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.
     *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`
     * @property {Number} [point.sensitivity=10] The senstivity value for interaction boundary.
     * @property {Number} [point.select.r=point.r*4] The radius size of each point on selected.
     * @property {String} [point.type="circle"] The type of point to be drawn
     * - **NOTE:**
     *   - If chart has 'bubble' type, only circle can be used.
     *   - For IE, non circle point expansions are not supported due to lack of transform support.
     * - **Available Values:**
     *   - circle
     *   - rectangle
     * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line
     * - **NOTE:**
     *   - This is an `experimental` feature and can have some unexpected behaviors.
     *   - If chart has 'bubble' type, only circle can be used.
     *   - For IE, non circle point expansions are not supported due to lack of transform support.
     * - **Available Values:**
     *   - circle
     *   - rectangle
     *   - svg shape tag interpreted as string<br>
     *     (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
     * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)
     * @example
     *  point: {
     *      show: false,
     *      r: 5,
     *
     *      // or customize the radius
     *      r: function(d) {
     *          ...
     *          return r;
     *      },
     *
     *      focus: {
     *          expand: {
     *              enabled: true,
     *              r: 1
     *          }
     *      },
     *      select: {
     *          r: 3
     *      },
     *
     *      // having lower value, means how closer to be for interaction
     *      sensitivity: 3,
     *
     *      // valid values are "circle" or "rectangle"
     *      type: "rectangle",
     *
     *      // or indicate as pattern
    	 *      pattern: [
    	 *        "circle",
    	 *        "rectangle",
    	 *        "<polygon points='0 6 4 0 -4 0'></polygon>"
    	 *     ],
     *  }
     */
    point_show: !0,
    point_r: 2.5,
    point_sensitivity: 10,
    point_focus_expand_enabled: !0,
    point_focus_expand_r: undefined,
    point_pattern: [],
    point_select_r: undefined,
    point_type: "circle",

    /**
     * Set line options
     * @name line
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
     *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
     * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
     * @property {Boolean} [line.step.type=step] Change step type for step chart.<br>
     * **Available values:**
     * - step
     * - step-before
     * - step-after
     * @property {Boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.
     * @property {Boolean} [line.zerobased=false] Set if min or max value will be 0 on line chart.
     * @example
     *  line: {
     *      connectNull: true,
     *      classes: [
     *          "line-class1",
     *          "line-class2"
     *      ],
     *      step: {
     *          type: "step-after"
     *      },
     *
     *      // hide all data points ('point.show=false' also has similar effect)
     *      point: false,
     *
     *      // show data points for only indicated datas
     *      point: [
     *          "data1", "data3"
     *      ],
     *
     *      zerobased: false
     *  }
     */
    line_connectNull: !1,
    line_step_type: "step",
    line_zerobased: !1,
    line_classes: undefined,
    line_point: !0,

    /**
    	* Set scatter options
    	* @name scatter
    	* @memberof Options
    	* @type {Object}
    	* @property {Boolean} [scatter.zerobased=false] Set if min or max value will be 0 on scatter chart.
    	* @example
    	*  scatter: {
    	*      connectNull: true,
    	*      step: {
    	*          type: "step-after"
    	*      },
    	*
    	*      // hide all data points ('point.show=false' also has similar effect)
    	*      point: false,
    	*
    	*      // show data points for only indicated datas
    	*      point: [
    	*          "data1", "data3"
    	*      ],
    	*
    	*      zerobased: false
    	*  }
    	*/
    scatter_zerobased: !1,

    /**
     * Set bar options
     * @name bar
     * @memberof Options
     * @type {Object}
     * @property {Number} [bar.padding=0] The padding pixel value between each bar.
     * @property {Number} [bar.radius] Set the radius of bar edge in pixel.
     * - **NOTE:** Works only for non-stacked bar
     * @property {Number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.
    	 * @property {Number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.
     * @property {Number} [bar.width] Change the width of bar chart.
     * @property {Number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
     * @property {Number} [bar.width.max] The maximum width value for ratio.
     * @property {Number} [bar.width.dataname] Change the width of bar for indicated dataset only.
     * - **NOTE:**
     *   - Works only for non-stacked bar
     *   - Bars are centered accoding its total width value
     * @property {Number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.
     * @property {Number} [bar.width.dataname.max] The maximum width value for ratio.
     * @property {Boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
     * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)
     * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)
     * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)
     * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)
     * @example
     *  bar: {
     *      padding: 1,
     *
     *      // the 'radius' option can be used only for non-stacking bars
     *      radius: 10,
     *      // or
     *      radius: {
     *          ratio: 0.5
     *      }
     *
     *      // will not have offset between each bar elements for interaction
     *      sensitivity: 0,
     *
     *      width: 10,
     *
     *      // or
     *      width: {
     *          ratio: 0.2,
     *          max: 20
     *      },
     *
     *      // or specify width per dataset
     *      width: {
     *          data1: 20,
     *          data2: {
     *              ratio: 0.2,
     *              max: 20
     *          }
     *      },
     *
     *      zerobased: false
     *  }
     */
    bar_padding: 0,
    bar_radius: undefined,
    bar_radius_ratio: undefined,
    bar_sensitivity: 2,
    bar_width: undefined,
    bar_width_ratio: .6,
    bar_width_max: undefined,
    bar_zerobased: !0,

    /**
     * Set bubble options
     * @name bubble
     * @memberof Options
     * @type {Object}
     * @property {Number|Function} [bubble.maxR=35] Set the max bubble radius value
     * @property {Boolean} [bubble.zerobased=false] Set if min or max value will be 0 on bubble chart.
     * @example
     *  bubble: {
     *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
     *      // And the lesser will have radius relatively from tha max value.
     *      maxR: 50,
     *
     *      // or set radius callback
     *      maxR: function(d) {
     *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
     *          ...
     *          return Math.sqrt(d.value * 2);
     *      },
     *      zerobased: false
     *  }
     */
    bubble_maxR: 35,
    bubble_zerobased: !1,

    /**
     * Set area options
     * @name area
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
     * @property {Boolean} [area.above=false] Set background area above the data chart line.
     * @property {Boolean|Object} [area.linearGradient=false] Set the linear gradient on area.<br><br>
     * Or customize by giving below object value:
     *  - x {Array}: `x1`, `x2` value
     *  - y {Array}: `y1`, `y2` value
     *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.
     * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
     * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)
     * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)
     * @example
     *  area: {
     *      zerobased: false,
     *      above: true,
     *
     *      // will generate follwing linearGradient:
     *      // <linearGradient x1="0" x2="0" y1="0" y2="1">
     *      //    <stop offset="0" stop-color="$DATA_COLOR" stop-opacity="1"></stop>
     *      //    <stop offset="1" stop-color="$DATA_COLOR" stop-opacity="0"></stop>
     *      // </linearGradient>
     *      linearGradient: true,
     *
     *      // Or customized gradient
     *      linearGradient: {
     *      	x: [0, 0],  // x1, x2 attributes
     *      	y: [0, 0],  // y1, y2 attributes
     *      	stops: [
     *      	  // offset, stop-color, stop-opacity
     *      	  [0, "#7cb5ec", 1],
     *
     *      	  // setting 'null' for stop-color, will set its original data color
     *      	  [0.5, null, 0],
     *
     *      	  // setting 'function' for stop-color, will pass data id as argument.
     *      	  // It should return color string or null value
     *      	  [1, function(id) { return id === "data1" ? "red" : "blue"; }, 0],
     *      	]
     *      }
     *  }
     */
    area_zerobased: !0,
    area_above: !1,
    area_linearGradient: !1,

    /**
     * Set pie options
     * @name pie
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [pie.label.show=true] Show or hide label on each pie piece.
     * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
     * @property {Number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
     * @property {Number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
     * @property {Boolean|Object} [pie.expand=true] Enable or disable expanding pie pieces.
     * @property {Number} [pie.expand.rate=0.98] Set expand rate.
     * @property {Number} [pie.expand.duration=50] Set expand transition time in ms.
     * @property {Number|Object} [pie.innerRadius=0] Sets the inner radius of pie arc.
     * @property {Number} [pie.padAngle=0] Set padding between data.
     * @property {Number} [pie.padding=0] Sets the gap between pie arcs.
    	 * @property {Number} [donut.startingAngle=0] Set starting angle where data draws.
     * @example
     *  pie: {
     *      label: {
     *          show: false,
     *          format: function(value, ratio, id) {
     *              return d3.format("$")(value);
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          threshold: 0.1,
     *
     *          // set ratio callback. Should return ratio value
     *          ratio: function(d, radius, h) {
     *              ...
     *              return ratio;
     *          },
     *          // or set ratio number
     *          ratio: 0.5
     *      },
     *
     *      // disable expand transition for interaction
     *      expand: false,
     *
     *      expand: {
     *      	// set duration of expand transition to 500ms.
     *          duration: 500,
     *
     *      	// set expand area rate
     *          rate: 1
     *      },
     *
     *      innerRadius: 0,
     *
     *      // set different innerRadius for each data
     *      innerRadius: {
     *      	data1: 10,
     *      	data2: 0
     *      }
     *
     *      padAngle: 0.1,
     *      padding: 0,
     *      startingAngle: 1
     *  }
     */
    pie_label_show: !0,
    pie_label_format: undefined,
    pie_label_threshold: .05,
    pie_label_ratio: undefined,
    pie_expand: {},
    pie_expand_rate: .98,
    pie_expand_duration: 50,
    pie_innerRadius: 0,
    pie_padAngle: 0,
    pie_padding: 0,
    pie_startingAngle: 0,

    /**
     * Set plugins
     * @name plugins
     * @memberof Options
     * @type {Array}
     * @example
     *  plugins: [
     *    new bb.plugin.stanford({ ... }),
     *    new PluginA(),
     *    ...
     * ]
     */
    plugins: [],

    /**
     * Set gauge options
     * @name gauge
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
     * @property {Boolean} [gauge.label.show=true] Show or hide label on gauge.
     * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\n` character.
     * @property {Function} [gauge.label.extents] Set customized min/max label text.
     * @property {Boolean} [gauge.expand=true] Enable or disable expanding gauge.
    	 * @property {Number} [gauge.expand.rate=0.98] Set expand rate.
     * @property {Number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
     * @property {Number} [gauge.min=0] Set min value of the gauge.
     * @property {Number} [gauge.max=100] Set max value of the gauge.
     * @property {Number} [gauge.startingAngle=-1 * Math.PI / 2] Set starting angle where data draws.
     * @property {String} [gauge.title=""] Set title of gauge chart. Use `\n` character to enter line break.
     * @property {String} [gauge.units] Set units of the gauge.
     * @property {Number} [gauge.width] Set width of gauge chart.
     * @property {String} [gauge.type="single"] Set type of gauge to be displayed.<br><br>
     * **Available Values:**
     * - single
     * - multi
     * @property {String} [gauge.arcs.minWidth=5] Set minimal width of gauge arcs until the innerRadius disappears.
     * @example
     *  gauge: {
     *      fullCircle: false,
     *      label: {
     *          show: false,
     *          format: function(value, ratio) {
     *              return value;
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          extents: function(value, isMax) {
    	 *              return (isMax ? "Max:" : "Min:") + value;
     *          }
     *      },
     *
     *      // disable expand transition for interaction
     *      expand: false,
     *
     *      expand: {
     *      	// set duration of expand transition to 500ms.
     *          duration: 500,
     *
     *      	// set expand area rate
     *          rate: 1
     *      },
     *
     *      min: -100,
     *      max: 200,
     *      type: "single"  // or 'multi'
     *      title: "Title Text",
     *      units: "%",
     *      width: 10,
     *      arcs: {
     *          minWidth: 5
     *      }
     *  }
     */
    gauge_fullCircle: !1,
    gauge_label_show: !0,
    gauge_label_format: undefined,
    gauge_min: 0,
    gauge_max: 100,
    gauge_type: "single",
    gauge_startingAngle: -1 * Math.PI / 2,
    gauge_label_extents: undefined,
    gauge_title: "",
    gauge_units: undefined,
    gauge_width: undefined,
    gauge_arcs_minWidth: 5,
    gauge_expand: {},
    gauge_expand_rate: .98,
    gauge_expand_duration: 50,

    /**
     * Set donut options
     * @name donut
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [donut.label.show=true] Show or hide label on each donut piece.
     * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
     * @property {Number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
     * @property {Number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
     * @property {Boolean} [donut.expand=true] Enable or disable expanding donut pieces.
     * @property {Number} [donut.expand.rate=0.98] Set expand rate.
     * @property {Number} [donut.expand.duration=50] Set expand transition time in ms.
     * @property {Number} [donut.width] Set width of donut chart.
     * @property {String} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
     * @property {Number} [donut.padAngle=0] Set padding between data.
     * @property {Number} [donut.startingAngle=0] Set starting angle where data draws.
     * @example
     *  donut: {
     *      label: {
     *          show: false,
     *          format: function(value, ratio, id) {
     *              return d3.format("$")(value);
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          threshold: 0.1,
     *
     *          // set ratio callback. Should return ratio value
     *          ratio: function(d, radius, h) {
     *          	...
     *          	return ratio;
     *          },
     *          // or set ratio number
     *          ratio: 0.5
     *      },
     *
     *      // disable expand transition for interaction
     *      expand: false,
     *
     *      expand: {
     *      	// set duration of expand transition to 500ms.
     *          duration: 500,
     *
     *      	// set expand area rate
     *          rate: 1
     *      },
     *
     *      width: 10,
     *      padAngle: 0.2,
     *      startingAngle: 1,
     *      title: "Donut Title"
     *
     *      // title with line break
     *      title: "Title1\nTitle2"
     *  }
     */
    donut_label_show: !0,
    donut_label_format: undefined,
    donut_label_threshold: .05,
    donut_label_ratio: undefined,
    donut_width: undefined,
    donut_title: "",
    donut_expand: {},
    donut_expand_rate: .98,
    donut_expand_duration: 50,
    donut_padAngle: 0,
    donut_startingAngle: 0,

    /**
     * Set spline options
     * - **Available interpolation type values:**
     *  - basis (d3.curveBasis)
     *  - basis-closed (d3.curveBasisClosed)
     *  - basis-open (d3.curveBasisOpen)
     *  - bundle (d3.curveBundle)
     *  - cardinal (d3.curveCardinal)
     *  - cardinal-closed (d3.curveCardinalClosed)
     *  - cardinal-open (d3.curveCardinalOpen)
     *  - catmull-rom (d3.curveCatmullRom)
     *  - catmull-rom-closed (d3.curveCatmullRomClosed)
     *  - catmull-rom-open (d3.curveCatmullRomOpen)
     *  - monotone-x (d3.curveMonotoneX)
     *  - monotone-y (d3.curveMonotoneY)
     *  - natural (d3.curveNatural)
     *  - linear-closed (d3.curveLinearClosed)
     *  - linear (d3.curveLinear)
     *  - step (d3.curveStep)
     *  - step-after (d3.curveStepAfter)
     *  - step-before (d3.curveStepBefore)
     * @name spline
     * @memberof Options
     * @type {Object}
     * @property {String} [spline.interpolation.type="cardinal"]
     * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)
     * @example
     *  spline: {
     *      interpolation: {
     *          type: "cardinal"
     *      }
     *  }
     */
    spline_interpolation_type: "cardinal",

    /**
     * Set radar options
     * - **NOTE:**
     *  > When x tick text contains `\n`, it's used as line break.
     * @name radar
     * @memberof Options
     * @type {Object}
     * @property {Number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.
     * @property {Boolean} [radar.axis.line.show=true] Show or hide axis line.
     * @property {Number} [radar.axis.text.position.x=0] x coordinate position, relative the original.
     * @property {NUmber} [radar.axis.text.position.y=0] y coordinate position, relative the original.
     * @property {Boolean} [radar.axis.text.show=true] Show or hide axis text.
     * @property {Boolean} [radar.direction.clockwise=false] Set the direction to be drawn.
     * @property {Number} [radar.level.depth=3] Set the level depth.
     * @property {Boolean} [radar.level.show=true] Show or hide level.
     * @property {Function} [radar.level.text.format=(x) => (x % 1 === 0 ? x : x.toFixed(2))] Set format function for the level value.
     * @property {Boolean} [radar.level.text.show=true] Show or hide level text.
     * @property {Number} [radar.size.ratio=0.87] Set size ratio.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)
     * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)
     * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)
     * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)
     * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)
     * @example
     *  radar: {
     *      axis: {
     *          max: 50,
     *          line: {
     *              show: false
     *          },
     *          text: {
     *              position: {
     *              	x: 0,
     *              	y: 0
     *              },
     *              show: false
     *          }
     *      },
     *      direction: {
     *          clockwise: true
     *      },
     *      level: {
     *          show: false,
     *          text: {
     *              format: function(x) {
     *                  return x + "%";
     *              },
     *              show: true
     *          }
     *      },
     *      size: {
     *          ratio: 0.7
     *      }
     *  }
     */
    radar_axis_max: undefined,
    radar_axis_line_show: !0,
    radar_axis_text_show: !0,
    radar_axis_text_position: {},
    radar_level_depth: 3,
    radar_level_show: !0,
    radar_level_text_format: function radar_level_text_format(x) {
      return x % 1 === 0 ? x : x.toFixed(2);
    },
    radar_level_text_show: !0,
    radar_size_ratio: .87,
    radar_direction_clockwise: !1,

    /**
     * Control the render timing
     * @name render
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [render.lazy=true] Make to not render at initialization (enabled by default when bind element's visibility is hidden).
     * @property {Boolean} [render.observe=true] Observe bind element's visibility(`display` or `visiblity` inline css property or class value) & render when is visible automatically (for IEs, only works IE11+). When set to **false**, call [`.flush()`](./Chart.html#flush) to render.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.LazyRender)
     * @example
     *  render: {
     *    lazy: true,
     *    observe: true
     * }
     *
     * @example
     *	// <!-- render.lazy will detect visibility defined -->
     *  // (a) <div id='chart' class='hide'></div>
     *  // (b) <div id='chart' style='display:none'></div>
     *
     *  // render.lazy enabled by default when element is hidden
     *  var chart = bb.generate({ ... });
     *
     *  // chart will be rendered automatically when element's visibility changes
     *  // Note: works only for inlined css property or class attribute changes
     *  document.getElementById('chart').classList.remove('hide')  // (a)
     *  document.getElementById('chart').style.display = 'block';  // (b)
     *
     * @example
     *	// chart won't be rendered and not observing bind element's visiblity changes
     *  var chart = bb.generate({
     *     render: {
     *          lazy: true,
     *          observe: false
     *     }
     *  });
     *
     *  // call at any point when you want to render
     *  chart.flush();
     */
    render: {},

    /**
     * Show rectangles inside the chart.<br><br>
     * This option accepts array including object that has axis, start, end and class.
     * The keys start, end and class are optional.
     * axis must be x, y or y2. start and end should be the value where regions start and end.
     * If not specified, the edge values will be used.
     * If timeseries x axis, date string, Date object and unixtime integer can be used.
     * If class is set, the region element will have it as class.
     * @name regions
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     *  regions: [
     *    {
     *      axis: "x",
     *      start: 1,
     *      end: 4,
     *      class: "region-1-4"
     *    }
     *  ]
     */
    regions: [],

    /**
     * Tooltip options
     * @name tooltip
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [tooltip.show=true] Show or hide tooltip.
     * @property {Boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.
     * @property {Boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
     *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.
     * @property {Boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.
     * @property {String} [tooltip.linked.name=""] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.
     * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
     *  Specified function receives x of the data point to show.
     * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
     *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
     * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
     *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
     *  If undefined returned, the row of that value will be skipped.
     * @property {Function} [tooltip.position] Set custom position function for the tooltip.<br>
     *  This option can be used to modify the tooltip position by returning object that has top and left.
     * @property {Function|Object} [tooltip.contents] Set custom HTML for the tooltip.<br>
     *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
     * @property {String|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.
     *  - **NOTE:** When is specified, will not be updating tooltip's position.
     * @property {String} [tooltip.contents.template=undefined] Set tooltip's template.<br><br>
     *  Within template, below syntax will be replaced using template-like syntax string:
     *    - **{{ ... }}**: the doubly curly brackets indicate loop block for data rows.
     *    - **{=CLASS_TOOLTIP}**: default tooltip class name `bb-tooltip`.
     *    - **{=CLASS_TOOLTIP_NAME}**: default tooltip data class name (ex. `bb-tooltip-name-data1`)
     *    - **{=TITLE}**: title value.
     *    - **{=COLOR}**: data color.
     *    - **{=VALUE}**: data value.
     * @property {Object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.
     *  - **NOTE:** It should contain `{ key: Array, ... }` value
     *    - 'key' name is used as substitution within template as '{=KEY}'
     *    - The value array length should match with the data length
     * @property {Boolean} [tooltip.init.show=false] Show tooltip at the initialization.
     * @property {Number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
     * @property {Object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
     * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
     * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
     * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
     * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
     * @property {String|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
     *  **Available Values:**
     *  - `desc`: In descending data value order
     *  - `asc`: In ascending data value order
     *  - `null`: It keeps the data display order<br>
     *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
     *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
     *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
     * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)
     * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)
     * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)
     * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)
     * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)
     * @example
     *  tooltip: {
     *      show: true,
     *      doNotHide: true,
     *      grouped: false,
     *      format: {
     *          title: function(x) { return "Data " + x; },
     *          name: function(name, ratio, id, index) { return name; },
     *          value: function(value, ratio, id, index) { return ratio; }
     *      },
     *      position: function(data, width, height, element) {
     *      	// return with unit or without. If the value is number, is treated as 'px'.
     *      	return {top: "10%", left: 20}  // top:10%; left: 20px;
    		 *      },
    		 *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
    		 *          return ... // formatted html as you want
     		 *      },
     *
     *       // specify tooltip contents using template
     *       // - example of HTML returned:
     *       // <ul class="bb-tooltip">
     *       //   <li class="bb-tooltip-name-data1"><span>250</span><br><span style="color:#00c73c">data1</span></li>
     *       //   <li class="bb-tooltip-name-data2"><span>50</span><br><span style="color:#fa7171">data2</span></li>
     *       // </ul>
     *       contents: {
     *      	bindto: "#tooltip",
     *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
     *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span><br>' +
     *      			'<span style=color:{=COLOR}>{=NAME}</span></li>' +
     *      		'}}</ul>'
     *      }
     *
     *       // with additional text value
     *       // - example of HTML returned:
     *       // <ul class="bb-tooltip">
     *       //   <li class="bb-tooltip-name-data1"><span>250</span><br>comment1<span style="color:#00c73c">data1</span>text1</li>
     *       //   <li class="bb-tooltip-name-data2"><span>50</span><br>comment2<span style="color:#fa7171">data2</span>text2</li>
     *       // </ul>
     *       contents: {
     *      	bindto: "#tooltip",
     *      	text: {
     *      		// a) 'key' name is used as substitution within template as '{=KEY}'
     *      		// b) the length should match with the data length
     *      		VAR1: ["text1", "text2"],
     *      		VAR2: ["comment1", "comment2"],
     *      	},
     *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
     *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span>{=VAR2}<br>' +
     *      			'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +
     *      		'}}</ul>'
     *      }
     		 *
     		 *      // sort tooltip data value display in ascending order
     		 *      order: "asc",
     		 *
     *      // specifying sort function
     *      order: function(a, b) {
     *         // param data passed format
     *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
     *           ...
     *      },
     *
     *      // show at the initialization
     *      init: {
     *          show: true,
     *          x: 2,
     *          position: {
     *              top: "150px",
     *              left: "250px"
     *          }
     *      },
     *
     *      // fires prior tooltip is shown
     *      onshow: function(ctx, selectedData) {
     *      	ctx; // current chart instance
     *
     *      	// current dataset selected
     *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
     *      	selectedData;
     *      },
     *
     *      // fires prior tooltip is hidden
     *      onhide: function(ctx, selectedData) {
     *      	ctx; // current chart instance
     *
     *      	// current dataset selected
     *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
     *      	selectedData;
     *      },
     *
     *      // fires after tooltip is shown
     *      onshown: function(ctx, selectedData) {
     *      	ctx; // current chart instance
     *
     *      	// current dataset selected
     *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
     *      	selectedData;
     *      },
     *
     *      // fires after tooltip is hidden
     *      onhidden: function(ctx, selectedData) {
     *      	ctx; // current chart instance
     *
     *      	// current dataset selected
     *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
     *      	selectedData;
     *      },
     *
     *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
     *      // Useful for timeseries correlation
     *      linked: true,
     *
     *      // Specify name to interact those with the same name only.
     *      linked: {
     *          name: "some-group"
     *      }
     *  }
     */
    tooltip_show: !0,
    tooltip_doNotHide: !1,
    tooltip_grouped: !0,
    tooltip_format_title: undefined,
    tooltip_format_name: undefined,
    tooltip_format_value: undefined,
    tooltip_position: undefined,
    tooltip_contents: {},
    tooltip_init_show: !1,
    tooltip_init_x: 0,
    tooltip_init_position: {
      top: "0px",
      left: "50px"
    },
    tooltip_linked: !1,
    tooltip_linked_name: "",
    tooltip_onshow: function tooltip_onshow() {},
    tooltip_onhide: function tooltip_onhide() {},
    tooltip_onshown: function tooltip_onshown() {},
    tooltip_onhidden: function tooltip_onhidden() {},
    tooltip_order: null,

    /**
     * Set title options
     * @name title
     * @memberof Options
     * @type {Object}
     * @property {String} [title.text] Title text. If contains `\n`, it's used as line break allowing multiline title.
     * @property {Number} [title.padding.top=0] Top padding value.
     * @property {Number} [title.padding.right=0] Right padding value.
     * @property {Number} [title.padding.bottom=0] Bottom padding value.
     * @property {Number} [title.padding.left=0] Left padding value.
     * @property {String} [title.position=center] Available values are: 'center', 'right' and 'left'.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)
     * @example
     *  title: {
     *      text: "Title Text",
     *
     *      // or Multiline title text
     *      text: "Main title text\nSub title text",
     *
     *      padding: {
     *          top: 10,
     *          right: 10,
     *          bottom: 10,
     *          left: 10
     *      },
     *      position: "center"
     *  }
     */
    title_text: undefined,
    title_padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    },
    title_position: "center"
  };
};


// CONCATENATED MODULE: ./src/config/config.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  getOptions: function getOptions() {
    return new Options_Options();
  },

  /**
   * Load configuration option
   * @param {Object} config User's generation config value
   * @private
   */
  loadConfig: function loadConfig(config) {
    var target,
        keys,
        read,
        thisConfig = this.config,
        find = function () {
      var key = keys.shift();
      return key && target && isObjectType(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
    };

    Object.keys(thisConfig).forEach(function (key) {
      target = config, keys = key.split("_"), read = find(), isDefined(read) && (thisConfig[key] = read);
    });
  }
});
// CONCATENATED MODULE: ./src/internals/scale.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  getScale: function getScale(min, max, forTimeseries) {
    return (forTimeseries ? Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleTime"])() : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])()).range([min, max]);
  },

  /**
   * Get x Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @param {Function} offset The offset getter to be sum
   * @return {Function} scale
   * @private
   */
  getX: function getX(min, max, domain, offset) {
    var $$ = this,
        scale = $$.zoomScale || $$.getScale(min, max, $$.isTimeSeries());
    return $$.getCustomizedScale(domain ? scale.domain(domain) : scale, offset);
  },

  /**
   * Get y Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @return {Function} scale
   * @private
   */
  getY: function getY(min, max, domain) {
    var scale = this.getScale(min, max, this.isTimeSeriesY());
    return domain && scale.domain(domain), scale;
  },

  /**
   * Get customized scale
   * @param {d3.scaleLinear|d3.scaleTime} scaleValue
   * @param {Function} offsetValue Offset getter to be sum
   * @return {} scale
   * @private
   */
  getCustomizedScale: function getCustomizedScale(scaleValue, offsetValue) {
    var $$ = this,
        offset = offsetValue || function () {
      return $$.xAxis.tickOffset();
    },
        scale = function (d, raw) {
      var v = scaleValue(d) + offset();
      return raw ? v : Math.ceil(v);
    };

    // copy original scale methods
    for (var key in scaleValue) scale[key] = scaleValue[key];

    return scale.orgDomain = function () {
      return scaleValue.domain();
    }, scale.orgScale = function () {
      return scaleValue;
    }, $$.isCategorized() && (scale.domain = function (domainValue) {
      var domain = domainValue;
      return arguments.length ? (scaleValue.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
    }), scale;
  },
  getYScale: function getYScale(id) {
    return this.axis.getId(id) === "y2" ? this.y2 : this.y;
  },
  getSubYScale: function getSubYScale(id) {
    return this.axis.getId(id) === "y2" ? this.subY2 : this.subY;
  },

  /**
   * Update scale
   * @private
   * @param {Boolean} isInit - param is given at the init rendering
   */
  updateScales: function updateScales(isInit) {
    var updateXDomain = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    $$.xMin = isRotated ? 1 : 0, $$.xMax = isRotated ? $$.height : $$.width, $$.yMin = isRotated ? 0 : $$.height, $$.yMax = isRotated ? $$.width : 1, $$.subXMin = $$.xMin, $$.subXMax = $$.xMax, $$.subYMin = isRotated ? 0 : $$.height2, $$.subYMax = isRotated ? $$.width2 : 1;
    // update scales
    // x Axis
    var xDomain = updateXDomain && $$.x && $$.x.orgDomain(),
        xSubDomain = updateXDomain && $$.orgXDomain;
    // y Axis
    // update for arc
    $$.x = $$.getX($$.xMin, $$.xMax, xDomain, function () {
      return $$.xAxis.tickOffset();
    }), $$.subX = $$.getX($$.xMin, $$.xMax, xSubDomain, function (d) {
      return d % 1 ? 0 : $$.subXAxis.tickOffset();
    }), $$.xAxisTickFormat = $$.axis.getXAxisTickFormat(), $$.xAxisTickValues = $$.axis.getTickValues("x"), $$.xAxis = $$.axis.getAxis("x", $$.x, config.axis_x_tick_outer, isInit), $$.subXAxis = $$.axis.getAxis("subX", $$.subX, config.axis_x_tick_outer, isInit), $$.y = $$.getY($$.yMin, $$.yMax, $$.y ? $$.y.domain() : config.axis_y_default), $$.subY = $$.getY($$.subYMin, $$.subYMax, $$.subY ? $$.subY.domain() : config.axis_y_default), $$.yAxisTickValues = $$.axis.getTickValues("y"), $$.yAxis = $$.axis.getAxis("y", $$.y, config.axis_y_tick_outer, isInit), config.axis_y2_show && ($$.y2 = $$.getY($$.yMin, $$.yMax, $$.y2 ? $$.y2.domain() : config.axis_y2_default), $$.subY2 = $$.getY($$.subYMin, $$.subYMax, $$.subY2 ? $$.subY2.domain() : config.axis_y2_default), $$.y2AxisTickValues = $$.axis.getTickValues("y2"), $$.y2Axis = $$.axis.getAxis("y2", $$.y2, config.axis_y2_tick_outer, isInit)), $$.updateArc && $$.updateArc();
  }
});
// CONCATENATED MODULE: ./src/internals/domain.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  getYDomainMinMax: function getYDomainMinMax(targets, type) {
    var $$ = this,
        config = $$.config,
        isMin = type === "min",
        dataGroups = config.data_groups,
        ids = $$.mapToIds(targets),
        ys = $$.getValuesAsIdKeyed(targets);
    return dataGroups.length > 0 && function () {
      for (var idsInGroup, _ret, hasValue = $$["has".concat(isMin ? "Negative" : "Positive", "ValueInTargets")](targets), _loop = function (j, _idsInGroup) {
        if (_idsInGroup = _idsInGroup.filter(function (v) {
          return ids.indexOf(v) >= 0;
        }), _idsInGroup.length === 0) return idsInGroup = _idsInGroup, "continue";
        var baseId = _idsInGroup[0],
            baseAxisId = $$.axis.getId(baseId);
        hasValue && ys[baseId] && (ys[baseId] = ys[baseId].map(function (v) {
          return (isMin ? v < 0 : v > 0) ? v : 0;
        }));

        for (var id, _ret2, _loop2 = function (k, id) {
          if (!ys[id]) return "continue";
          var axisId = $$.axis.getId(id);
          ys[id].forEach(function (v, i) {
            var val = +v,
                meetCondition = isMin ? val > 0 : val < 0;
            axisId !== baseAxisId || hasValue && meetCondition || (ys[baseId][i] += val);
          });
        }, k = 1; id = _idsInGroup[k]; k++) _ret2 = _loop2(k, id), _ret2 === "continue";

        idsInGroup = _idsInGroup;
      }, j = 0; idsInGroup = dataGroups[j]; j++) _ret = _loop(j, idsInGroup), _ret === "continue";
    }(), getMinMax(type, Object.keys(ys).map(function (key) {
      return getMinMax(type, ys[key]);
    }));
  },
  getYDomainMin: function getYDomainMin(targets) {
    return this.getYDomainMinMax(targets, "min");
  },
  getYDomainMax: function getYDomainMax(targets) {
    return this.getYDomainMinMax(targets, "max");
  },

  /**
   * Check if hidden targets bound to the given axis id
   * @return {Boolean}
   * @private
   */
  isHiddenTargetWithYDomain: function isHiddenTargetWithYDomain(id) {
    var $$ = this;
    return $$.hiddenTargetIds.some(function (v) {
      return $$.axis.getId(v) === id;
    });
  },
  getYDomain: function getYDomain(targets, axisId, xDomain) {
    var $$ = this,
        config = $$.config,
        pfx = "axis_".concat(axisId);
    if ($$.isStackNormalized()) return [0, 100];
    var targetsByAxisId = targets.filter(function (t) {
      return $$.axis.getId(t.id) === axisId;
    }),
        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId;
    if (yTargets.length === 0) return $$.isHiddenTargetWithYDomain(axisId) ? $$[axisId].domain() : axisId === "y2" ? $$.y.domain() : // When all data bounds to y2, y Axis domain is called prior y2.
    // So, it needs to call to get y2 domain here
    $$.getYDomain(targets, "y2", xDomain);
    var yMin = config["".concat(pfx, "_min")],
        yMax = config["".concat(pfx, "_max")],
        yDomainMin = $$.getYDomainMin(yTargets),
        yDomainMax = $$.getYDomainMax(yTargets),
        center = config["".concat(pfx, "_center")],
        isZeroBased = ["area", "bar", "bubble", "line", "scatter"].some(function (v) {
      return $$.hasType(v, yTargets) && config["".concat(v, "_zerobased")];
    }),
        isInverted = config["".concat(pfx, "_inverted")],
        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
    yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);
    var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
    (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));
    var domainLength = Math.abs(yDomainMax - yDomainMin),
        padding = {
      top: domainLength * .1,
      bottom: domainLength * .1
    };

    if (isDefined(center)) {
      var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
      yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
    } // add padding for data label


    if (showHorizontalDataLabel) {
      var diff = diffDomain($$.y.range()),
          ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, "width").map(function (v) {
        return v / diff;
      });
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));
      });
    } else if (showVerticalDataLabel) {
      var lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height");
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += $$.axis.convertPixelsToAxisPadding(lengths[i], domainLength);
      });
    } // if padding is set, the domain will be updated relative the current domain value
    // ex) $$.height=300, padding.top=150, domainLength=4  --> domain=6


    var p = config["".concat(pfx, "_padding")];
    notEmpty(p) && ["bottom", "top"].forEach(function (v) {
      padding[v] = $$.axis.getPadding(p, v, padding[v], domainLength);
    }), isZeroBased && (isAllPositive && (padding.bottom = yDomainMin), isAllNegative && (padding.top = -yDomainMax));
    var domain = [yDomainMin - padding.bottom, yDomainMax + padding.top];
    return isInverted ? domain.reverse() : domain;
  },
  getXDomainMinMax: function getXDomainMinMax(targets, type) {
    var $$ = this,
        configValue = $$.config["axis_x_".concat(type)],
        dataValue = getMinMax(type, targets.map(function (t) {
      return getMinMax(type, t.values.map(function (v) {
        return v.x;
      }));
    })),
        value = isObject(configValue) ? configValue.value : configValue;
    return value = isDefined(value) && $$.isTimeSeries() ? $$.parseDate(value) : value, isObject(configValue) && configValue.fit && (type === "min" && value < dataValue || type === "max" && value > dataValue) && (value = undefined), isDefined(value) ? value : dataValue;
  },
  getXDomainMin: function getXDomainMin(targets) {
    return this.getXDomainMinMax(targets, "min");
  },
  getXDomainMax: function getXDomainMax(targets) {
    return this.getXDomainMinMax(targets, "max");
  },
  getXDomainPadding: function getXDomainPadding(domain) {
    var maxDataCount,
        padding,
        $$ = this,
        config = $$.config,
        diff = domain[1] - domain[0],
        xPadding = config.axis_x_padding;
    $$.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01;
    var left = padding,
        right = padding;
    return isObject(xPadding) && notEmpty(xPadding) ? (left = isValue(xPadding.left) ? xPadding.left : padding, right = isValue(xPadding.right) ? xPadding.right : padding) : isNumber(config.axis_x_padding) && (left = xPadding, right = xPadding), {
      left: left,
      right: right
    };
  },
  getXDomain: function getXDomain(targets) {
    var $$ = this,
        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
        _xDomain2 = _slicedToArray(xDomain, 2),
        firstX = _xDomain2[0],
        lastX = _xDomain2[1],
        padding = $$.getXDomainPadding(xDomain),
        min = 0,
        max = 0;

    return firstX - lastX !== 0 || $$.isCategorized() || ($$.isTimeSeries() ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
  },
  updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
    var $$ = this,
        config = $$.config,
        zoomEnabled = config.zoom_enabled;

    if (withUpdateOrgXDomain && ($$.x.domain(domain || sortValue($$.getXDomain(targets))), $$.orgXDomain = $$.x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), $$.subX.domain($$.x.domain()), $$.brush && $$.brush.scale($$.subX)), withUpdateXDomain) {
      var domainValue = domain || !$$.brush || brushEmpty($$) ? $$.orgXDomain : getBrushSelection($$).map($$.subX.invert);
      $$.x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
    } // Trim domain when too big by zoom mousemove event


    return withTrim && $$.x.domain($$.trimXDomain($$.x.orgDomain())), $$.x.domain();
  },
  trimXDomain: function trimXDomain(domain) {
    var zoomDomain = this.getZoomDomain(),
        _zoomDomain = _slicedToArray(zoomDomain, 2),
        min = _zoomDomain[0],
        max = _zoomDomain[1];

    return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
  }
});
// CONCATENATED MODULE: ./src/data/data.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  isX: function isX(key) {
    var $$ = this,
        config = $$.config,
        dataKey = config.data_x && key === config.data_x,
        existValue = notEmpty(config.data_xs) && util_hasValue(config.data_xs, key);
    return dataKey || existValue;
  },
  isNotX: function isNotX(key) {
    return !this.isX(key);
  },
  isStackNormalized: function isStackNormalized() {
    var config = this.config;
    return config.data_stack_normalize && this.isGrouped();
  },
  isGrouped: function isGrouped(id) {
    var groups = this.config.data_groups;
    return id ? groups.some(function (v) {
      return v.indexOf(id) >= 0 && v.length > 1;
    }) : groups.length > 0;
  },
  getXKey: function getXKey(id) {
    var $$ = this,
        config = $$.config;
    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
  },
  getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
    var xValues,
        $$ = this,
        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
    return ids.forEach(function (id) {
      $$.getXKey(id) === key && (xValues = $$.data.xs[id]);
    }), xValues;
  },

  /**
   * Get index number based on given x Axis value
   * @param {Date|Number|String} x x Axis to be compared
   * @param {Array} basedX x Axis list to be based on
   * @return {Number} index number
   * @private
   */
  getIndexByX: function getIndexByX(x, basedX) {
    var $$ = this;
    return basedX ? basedX.indexOf(isString(x) ? x : +x) : ($$.filterByX($$.data.targets, x)[0] || {
      index: null
    }).index;
  },
  getXValue: function getXValue(id, i) {
    var $$ = this;
    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
  },
  getOtherTargetXs: function getOtherTargetXs() {
    var $$ = this,
        idsForX = Object.keys($$.data.xs);
    return idsForX.length ? $$.data.xs[idsForX[0]] : null;
  },
  getOtherTargetX: function getOtherTargetX(index) {
    var xs = this.getOtherTargetXs();
    return xs && index < xs.length ? xs[index] : null;
  },
  addXs: function addXs(xs) {
    var $$ = this;
    Object.keys(xs).forEach(function (id) {
      $$.config.data_xs[id] = xs[id];
    });
  },
  isMultipleX: function isMultipleX() {
    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
  },
  addName: function addName(data) {
    var name,
        $$ = this;
    return data && (name = $$.config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
  },
  getAllValuesOnIndex: function getAllValuesOnIndex(index) {
    var $$ = this;
    return $$.filterTargetsToShow($$.data.targets).map(function (t) {
      return $$.addName($$.getValueOnIndex(t.values, index));
    });
  },
  getValueOnIndex: function getValueOnIndex(values, index) {
    var valueOnIndex = values.filter(function (v) {
      return v.index === index;
    });
    return valueOnIndex.length ? valueOnIndex[0] : null;
  },
  updateTargetX: function updateTargetX(targets, x) {
    var $$ = this;
    targets.forEach(function (t) {
      t.values.forEach(function (v, i) {
        v.x = $$.generateTargetX(x[i], t.id, i);
      }), $$.data.xs[t.id] = x;
    });
  },
  updateTargetXs: function updateTargetXs(targets, xs) {
    var $$ = this;
    targets.forEach(function (t) {
      xs[t.id] && $$.updateTargetX([t], xs[t.id]);
    });
  },
  generateTargetX: function generateTargetX(rawX, id, index) {
    var $$ = this,
        x = $$.isCategorized() ? index : rawX || index;
    return $$.isTimeSeries() ? x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index)) : $$.isCustomX() && !$$.isCategorized() && (x = isValue(rawX) ? +rawX : $$.getXValue(id, index)), x;
  },
  cloneTarget: function cloneTarget(target) {
    return {
      id: target.id,
      id_org: target.id_org,
      values: target.values.map(function (d) {
        return {
          x: d.x,
          value: d.value,
          id: d.id
        };
      })
    };
  },
  updateXs: function updateXs(values) {
    values.length && (this.xs = values.map(function (v) {
      return v.x;
    }));
  },
  getPrevX: function getPrevX(i) {
    var x = this.xs[i - 1];
    return isDefined(x) ? x : null;
  },
  getNextX: function getNextX(i) {
    var x = this.xs[i + 1];
    return isDefined(x) ? x : null;
  },

  /**
   * Get base value isAreaRangeType
   * @param data Data object
   * @return {Number}
   * @private
   */
  getBaseValue: function getBaseValue(data) {
    var $$ = this,
        value = data.value;
    return value && ($$.isAreaRangeType(data) ? value = $$.getAreaRangeData(data, "mid") : $$.isBubbleZType(data) && (value = $$.getBubbleZData(value, "y"))), value;
  },

  /**
   * Get min/max value from the data
   * @private
   * @param {Array} data array data to be evaluated
   * @return {{min: {Number}, max: {Number}}}
   */
  getMinMaxValue: function getMinMaxValue(data) {
    var min,
        max,
        getBaseValue = this.getBaseValue.bind(this);
    return (data || this.data.targets.map(function (t) {
      return t.values;
    })).forEach(function (v, i) {
      var value = v.map(getBaseValue).filter(isNumber);
      min = Math.min.apply(Math, [i ? min : Infinity].concat(_toConsumableArray(value))), max = Math.max.apply(Math, [i ? max : -Infinity].concat(_toConsumableArray(value)));
    }), {
      min: min,
      max: max
    };
  },

  /**
   * Get the min/max data
   * @private
   * @return {{min: Array, max: Array}}
   */
  getMinMaxData: function getMinMaxData() {
    var $$ = this,
        cacheKey = "$minMaxData",
        minMaxData = $$.getCache(cacheKey);

    if (!minMaxData) {
      var data = $$.data.targets.map(function (t) {
        return t.values;
      }),
          minMax = $$.getMinMaxValue(data),
          min = [],
          max = [];
      // update the cached data
      data.forEach(function (v) {
        var minData = $$.getFilteredDataByValue(v, minMax.min),
            maxData = $$.getFilteredDataByValue(v, minMax.max);
        minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
      }), $$.addCache(cacheKey, minMaxData = {
        min: min,
        max: max
      });
    }

    return minMaxData;
  },

  /**
   * Get sum of data per index
   * @private
   * @return {Array}
   */
  getTotalPerIndex: function getTotalPerIndex() {
    var $$ = this,
        sum = $$.getCache("$totalPerIndex");
    return $$.isStackNormalized() && !sum && (sum = [], $$.data.targets.forEach(function (row) {
      row.values.forEach(function (v, i) {
        sum[i] || (sum[i] = 0), sum[i] += isNumber(v.value) ? v.value : 0;
      });
    })), sum;
  },

  /**
   * Get total data sum
   * @param {boolean} subtractHidden Subtract hidden data from total
   * @return {Number}
  	 * @private
   */
  getTotalDataSum: function getTotalDataSum(subtractHidden) {
    var $$ = this,
        cacheKey = "$totalDataSum",
        total = $$.getCache(cacheKey);

    if (!isNumber(total)) {
      var sum = mergeArray($$.data.targets.map(function (t) {
        return t.values;
      })).map(function (v) {
        return v.value;
      }).reduce(function (p, c) {
        return p + c;
      });
      $$.addCache(cacheKey, total = sum);
    }

    return subtractHidden && (total -= $$.getHiddenTotalDataSum()), total;
  },

  /**
   * Get total hidden data sum
   * @return {Number}
  	 * @private
   */
  getHiddenTotalDataSum: function getHiddenTotalDataSum() {
    var $$ = this,
        api = $$.api,
        hiddenTargetIds = $$.hiddenTargetIds,
        total = 0;
    return hiddenTargetIds.length && (total = api.data.values.bind(api)(hiddenTargetIds).reduce(function (p, c) {
      return p + c;
    })), total;
  },

  /**
   * Get filtered data by value
   * @param {Object} data
   * @param {Number} value
   * @return {Array} filtered array data
   * @private
   */
  getFilteredDataByValue: function getFilteredDataByValue(data, value) {
    var _this = this;

    return data.filter(function (t) {
      return _this.getBaseValue(t) === value;
    });
  },

  /**
   * Return the max length of the data
   * @return {Number} max data length
   * @private
   */
  getMaxDataCount: function getMaxDataCount() {
    return Math.max.apply(Math, _toConsumableArray(this.data.targets.map(function (t) {
      return t.values.length;
    })));
  },
  getMaxDataCountTarget: function getMaxDataCountTarget() {
    var target = this.filterTargetsToShow() || [],
        length = target.length;
    return length > 1 ? (target = target.map(function (t) {
      return t.values;
    }).reduce(function (a, b) {
      return a.concat(b);
    }).map(function (v) {
      return v.x;
    }), target = sortValue(getUnique(target)).map(function (x, index) {
      return {
        x: x,
        index: index
      };
    })) : length && (target = target[0].values), target;
  },
  mapToIds: function mapToIds(targets) {
    return targets.map(function (d) {
      return d.id;
    });
  },
  mapToTargetIds: function mapToTargetIds(ids) {
    var $$ = this;
    return ids ? isArray(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
  },
  hasTarget: function hasTarget(targets, id) {
    var ids = this.mapToIds(targets);

    for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

    return !1;
  },
  isTargetToShow: function isTargetToShow(targetId) {
    return this.hiddenTargetIds.indexOf(targetId) < 0;
  },
  isLegendToShow: function isLegendToShow(targetId) {
    return this.hiddenLegendIds.indexOf(targetId) < 0;
  },
  filterTargetsToShow: function filterTargetsToShow(targets) {
    var $$ = this;
    return (targets || $$.data.targets).filter(function (t) {
      return $$.isTargetToShow(t.id);
    });
  },
  mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
    var $$ = this,
        xs = [];
    return targets && targets.length && (xs = getUnique(mergeArray(targets.map(function (t) {
      return t.values.map(function (v) {
        return +v.x;
      });
    }))), xs = $$.isTimeSeries() ? xs.map(function (x) {
      return new Date(+x);
    }) : xs.map(function (x) {
      return +x;
    })), sortValue(xs);
  },
  addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
    this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds);
  },
  removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
    this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
    this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds);
  },
  removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
    this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
    var $$ = this,
        ys = {},
        isMultipleX = $$.isMultipleX(),
        xs = isMultipleX ? $$.mapTargetsToUniqueXs(targets).map(function (v) {
      return isString(v) ? v : +v;
    }) : null;
    return targets.forEach(function (t) {
      var data = [];
      t.values.forEach(function (v) {
        var value = v.value;
        isArray(value) ? data.push.apply(data, _toConsumableArray(value)) : isObject(value) && "high" in value ? data.push.apply(data, _toConsumableArray(Object.values(value))) : $$.isBubbleZType(v) ? data.push($$.getBubbleZData(value, "y")) : isMultipleX ? data[$$.getIndexByX(v.x, xs)] = value : data.push(value);
      }), ys[t.id] = data;
    }), ys;
  },
  checkValueInTargets: function checkValueInTargets(targets, checker) {
    var values,
        ids = Object.keys(targets);

    for (var i = 0; i < ids.length; i++) {
      values = targets[ids[i]].values;

      for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
    }

    return !1;
  },
  hasMultiTargets: function hasMultiTargets() {
    return this.filterTargetsToShow().length > 1;
  },
  hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v < 0;
    });
  },
  hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v > 0;
    });
  },
  _checkOrder: function _checkOrder(type) {
    var config = this.config,
        order = config.data_order;
    return isString(order) && order.toLowerCase() === type;
  },
  isOrderDesc: function isOrderDesc() {
    return this._checkOrder("desc");
  },
  isOrderAsc: function isOrderAsc() {
    return this._checkOrder("asc");
  },

  /**
   * Sort targets data
   * @param {Array} targetsValue
   * @return {Array}
   * @private
   */
  orderTargets: function orderTargets(targetsValue) {
    var $$ = this,
        config = $$.config,
        targets = _toConsumableArray(targetsValue),
        orderAsc = $$.isOrderAsc(),
        orderDesc = $$.isOrderDesc();

    // TODO: accept name array for order
    return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
      var reducer = function (p, c) {
        return p + Math.abs(c.value);
      },
          t1Sum = t1.values.reduce(reducer, 0),
          t2Sum = t2.values.reduce(reducer, 0);

      return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
    }) : isFunction(config.data_order) && targets.sort(config.data_order), targets;
  },
  filterByX: function filterByX(targets, x) {
    return mergeArray(targets.map(function (t) {
      return t.values;
    })).filter(function (v) {
      return v.x - x === 0;
    });
  },
  filterRemoveNull: function filterRemoveNull(data) {
    var _this2 = this;

    return data.filter(function (d) {
      return isValue(_this2.getBaseValue(d));
    });
  },
  filterByXDomain: function filterByXDomain(targets, xDomain) {
    return targets.map(function (t) {
      return {
        id: t.id,
        id_org: t.id_org,
        values: t.values.filter(function (v) {
          return xDomain[0] <= v.x && v.x <= xDomain[1];
        })
      };
    });
  },
  hasDataLabel: function hasDataLabel() {
    var dataLabels = this.config.data_labels;
    return isBoolean(dataLabels) && dataLabels || isObjectType(dataLabels) && notEmpty(dataLabels);
  },
  getDataLabelLength: function getDataLabelLength(min, max, key) {
    var $$ = this,
        lengths = [0, 0];
    return $$.selectChart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
      return $$.dataLabelFormat(d.id)(d);
    }).each(function (d, i) {
      lengths[i] = this.getBoundingClientRect()[key] * 1.3;
    }).remove(), lengths;
  },
  isNoneArc: function isNoneArc(d) {
    return this.hasTarget(this.data.targets, d.id);
  },
  isArc: function isArc(d) {
    return "data" in d && this.hasTarget(this.data.targets, d.data.id);
  },
  findSameXOfValues: function findSameXOfValues(values, index) {
    var i,
        targetX = values[index].x,
        sames = [];

    for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);

    for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);

    return sames;
  },
  findClosestFromTargets: function findClosestFromTargets(targets, pos) {
    var $$ = this,
        candidates = targets.map(function (target) {
      return $$.findClosest(target.values, pos);
    });
    // map to array of closest points of each target
    // decide closest point and return
    return $$.findClosest(candidates, pos);
  },
  findClosest: function findClosest(values, pos) {
    var closest,
        $$ = this,
        data = values.filter(function (v) {
      return v && isValue(v.value);
    }),
        minDist = $$.config.point_sensitivity;
    return data.filter(function (v) {
      return $$.isBarType(v.id);
    }).forEach(function (v) {
      var shape = $$.main.select(".".concat(config_classes.bars).concat($$.getTargetSelectorSuffix(v.id), " .").concat(config_classes.bar, "-").concat(v.index)).node();
      !closest && $$.isWithinBar(shape) && (closest = v);
    }), data.filter(function (v) {
      return !$$.isBarType(v.id);
    }).forEach(function (v) {
      var d = $$.dist(v, pos);
      d < minDist && (minDist = d, closest = v);
    }), closest;
  },
  dist: function dist(data, pos) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        xIndex = isRotated ? 1 : 0,
        yIndex = isRotated ? 0 : 1,
        y = $$.circleY(data, data.index),
        x = ($$.zoomScale || $$.x)(data.x);
    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
  },

  /**
   * Convert data for step type
   * @param {Array} values Object data values
   * @return {Array}
   * @private
   */
  convertValuesToStep: function convertValuesToStep(values) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        stepType = config.line_step_type,
        isCategorized = $$.isCategorized(),
        converted = isArray(values) ? values.concat() : [values];
    if (!isRotated && !isCategorized) return values; // insert & append cloning first/last value to be fully rendered covering on each gap sides

    var id = converted[0].id,
        x = converted[0].x - 1,
        value = converted[0].value; // insert

    return isCategorized && converted.unshift({
      x: x,
      value: value,
      id: id
    }), stepType === "step-after" && converted.unshift({
      x: x - 1,
      value: value,
      id: id
    }), x = converted.length - 1, value = converted[x].value, isCategorized && converted.push({
      x: x,
      value: value,
      id: id
    }), stepType === "step-before" && converted.push({
      x: x + 1,
      value: value,
      id: id
    }), converted;
  },
  convertValuesToRange: function convertValuesToRange(values) {
    var converted = isArray(values) ? values.concat() : [values],
        ranges = [];
    return converted.forEach(function (range) {
      var x = range.x,
          id = range.id;
      ranges.push({
        x: x,
        id: id,
        value: range.value[0]
      }), ranges.push({
        x: x,
        id: id,
        value: range.value[2]
      });
    }), ranges;
  },
  updateDataAttributes: function updateDataAttributes(name, attrs) {
    var $$ = this,
        config = $$.config,
        current = config["data_".concat(name)];
    return isUndefined(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
      current[id] = attrs[id];
    }), $$.redraw({
      withLegend: !0
    }), current);
  },
  getAreaRangeData: function getAreaRangeData(d, type) {
    var value = d.value;

    if (isArray(value)) {
      var index = ["high", "mid", "low"].indexOf(type);
      return index === -1 ? null : value[index];
    }

    return value[type];
  },

  /**
   * Get ratio value
   * @param {String} type Ratio for given type
   * @param {Object} d Data value object
   * @param {Boolean} asPercent Convert the return as percent or not
   * @return {Number} Ratio value
   * @private
   */
  getRatio: function getRatio(type, d, asPercent) {
    var $$ = this,
        config = $$.config,
        api = $$.api,
        ratio = 0;
    if (d && api.data.shown.call(api).length) if (ratio = d.ratio || d.value, type === "arc") ratio = $$.pie.padAngle()() ? d.value / $$.getTotalDataSum(!0) : (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));else if (type === "index") {
      var dataValues = api.data.values.bind(api),
          total = this.getTotalPerIndex();

      if ($$.hiddenTargetIds.length) {
        var hiddenSum = dataValues($$.hiddenTargetIds, !1);
        hiddenSum.length && (hiddenSum = hiddenSum.reduce(function (acc, curr) {
          return acc.map(function (v, i) {
            return (isNumber(v) ? v : 0) + curr[i];
          });
        }), total = total.map(function (v, i) {
          return v - hiddenSum[i];
        }));
      }

      d.ratio = isNumber(d.value) && total && total[d.index] > 0 ? d.value / total[d.index] : 0, ratio = d.ratio;
    } else type === "radar" && (ratio = parseFloat(Math.max(d.value, 0)) / $$.maxValue * config.radar_size_ratio);
    return asPercent && ratio ? ratio * 100 : ratio;
  },

  /**
   * Sort data index to be aligned with x axis.
   * @param {Array} tickValues Tick array values
   * @private
   */
  updateDataIndexByX: function updateDataIndexByX(tickValues) {
    var $$ = this,
        tickValueMap = tickValues.reduce(function (out, tick, index) {
      return out[+tick.x] = index, out;
    }, {});
    $$.data.targets.forEach(function (t) {
      t.values.forEach(function (value, valueIndex) {
        var index = tickValueMap[+value.x];
        index === undefined && (index = valueIndex), value.index = index;
      });
    });
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-dsv","commonjs2":"d3-dsv","amd":"d3-dsv","root":"d3"}
var external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_ = __webpack_require__(8);

// CONCATENATED MODULE: ./src/data/data.convert.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Convert CSV/TSV data
 * @param {Object} parser Parser object
 * @param {Object} xsv Data
 * @private
 * @return {Object}
 */

var convertCsvTsvToData = function (parser, xsv) {
  var d,
      rows = parser.rows(xsv);
  return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
    d[0][id] = null;
  })) : d = parser.parse(xsv), d;
};

extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Convert data according its type
   * @param {Object} args data object
   * @param {Function} [callback] callback for url(XHR) type loading
   * @return {Object}
   * @private
   */
  convertData: function convertData(args, callback) {
    var data,
        $$ = this;
    if (args.bindto ? (data = {}, ["url", "mimeType", "headers", "keys", "json", "keys", "rows", "columns"].forEach(function (v) {
      var key = "data_".concat(v);
      key in args && (data[v] = args[key]);
    })) : data = args, data.url && callback) $$.convertUrlToData(data.url, data.mimeType, data.headers, data.keys, callback);else if (data.json) data = $$.convertJsonToData(data.json, data.keys);else if (data.rows) data = $$.convertRowsToData(data.rows);else if (data.columns) data = $$.convertColumnsToData(data.columns);else if (args.bindto) throw Error("url or json or rows or columns is required.");
    return isArray(data) && data;
  },

  /**
   * Convert URL data
   * @param {String} url Remote URL
   * @param {String} mimeType MIME type string: json | csv | tsv
   * @param {Object} headers Header object
   * @param {Object} keys Key object
   * @param {Function} done Callback function
   * @private
   */
  convertUrlToData: function convertUrlToData(url) {
    var _this = this,
        mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "csv",
        headers = arguments.length > 2 ? arguments[2] : undefined,
        keys = arguments.length > 3 ? arguments[3] : undefined,
        done = arguments.length > 4 ? arguments[4] : undefined,
        req = new XMLHttpRequest();

    req.open("GET", url), headers && Object.keys(headers).forEach(function (key) {
      req.setRequestHeader(key, headers[key]);
    }), req.onreadystatechange = function () {
      if (req.readyState === 4) if (req.status === 200) {
        var response = req.responseText;
        response && done.call(_this, _this["convert".concat(capitalize(mimeType), "ToData")](mimeType === "json" ? JSON.parse(response) : response, keys));
      } else throw new Error("".concat(url, ": Something went wrong loading!"));
    }, req.send();
  },
  convertCsvToData: function convertCsvToData(xsv) {
    return convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParse"]
    }, xsv);
  },
  convertTsvToData: function convertTsvToData(tsv) {
    return convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParse"]
    }, tsv);
  },
  convertJsonToData: function convertJsonToData(json, keysParam) {
    var targetKeys,
        data,
        _this2 = this,
        config = this.config,
        newRows = [];

    if (isArray(json)) {
      var keys = keysParam || config.data_keys;
      keys.x ? (targetKeys = keys.value.concat(keys.x), config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {
        var newRow = targetKeys.map(function (key) {
          // convert undefined to null because undefined data will be removed in convertDataToTargets()
          var v = _this2.findValueInJson(o, key);

          return isUndefined(v) && (v = null), v;
        });
        newRows.push(newRow);
      }), data = this.convertRowsToData(newRows);
    } else Object.keys(json).forEach(function (key) {
      var tmp = json[key].concat();
      tmp.unshift(key), newRows.push(tmp);
    }), data = this.convertColumnsToData(newRows);

    return data;
  },
  findValueInJson: function findValueInJson(object, path) {
    if (object[path] !== undefined) return object[path];
    var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
        pathArray = convertedPath.replace(/^\./, "").split("."),
        target = object; // convert indexes to properties (replace [] with .)

    return pathArray.some(function (k) {
      return !(target = target && k in target ? target[k] : undefined);
    }), target;
  },
  convertRowsToData: function convertRowsToData(rows) {
    var keys = rows[0],
        newRows = [];
    return rows.forEach(function (row, i) {
      if (i > 0) {
        var newRow = {};
        row.forEach(function (v, j) {
          if (isUndefined(v)) throw new Error("Source data is missing a component at (".concat(i, ", ").concat(j, ")!"));
          newRow[keys[j]] = v;
        }), newRows.push(newRow);
      }
    }), newRows;
  },
  convertColumnsToData: function convertColumnsToData(columns) {
    var newRows = [];
    return columns.forEach(function (col, i) {
      var key = col[0];
      col.forEach(function (v, j) {
        if (j > 0) {
          if (isUndefined(newRows[j - 1]) && (newRows[j - 1] = {}), isUndefined(v)) throw new Error("Source data is missing a component at (".concat(i, ", ").concat(j, ")!"));
          newRows[j - 1][key] = v;
        }
      });
    }), newRows;
  },
  convertDataToTargets: function convertDataToTargets(data, appendXs) {
    var xsData,
        _this3 = this,
        $$ = this,
        config = $$.config,
        isTimeSeries = $$.isTimeSeries(),
        dataKeys = Object.keys(data[0] || {}),
        ids = dataKeys.length ? dataKeys.filter($$.isNotX, $$) : [],
        xs = dataKeys.length ? dataKeys.filter($$.isX, $$) : [];

    ids.forEach(function (id) {
      var xKey = _this3.getXKey(id);

      _this3.isCustomX() || isTimeSeries ? xs.indexOf(xKey) >= 0 ? xsData = (appendXs && $$.data.xs[id] || []).concat(data.map(function (d) {
        return d[xKey];
      }).filter(isValue).map(function (rawX, i) {
        return $$.generateTargetX(rawX, id, i);
      })) : config.data_x ? xsData = _this3.getOtherTargetXs() : notEmpty(config.data_xs) && (xsData = $$.getXValuesOfXKey(xKey, $$.data.targets)) : xsData = data.map(function (d, i) {
        return i;
      }), xsData && (_this3.data.xs[id] = xsData);
    }), ids.forEach(function (id) {
      if (!_this3.data.xs[id]) throw new Error("x is not defined for id = \"".concat(id, "\"."));
    });
    // convert to target
    var targets = ids.map(function (id, index) {
      var convertedId = config.data_idConverter(id),
          xKey = $$.getXKey(id),
          isCategorized = $$.isCustomX() && $$.isCategorized(),
          hasCategory = isCategorized && data.map(function (v) {
        return v.x;
      }).every(function (v) {
        return config.axis_x_categories.indexOf(v) > -1;
      });
      return {
        id: convertedId,
        id_org: id,
        values: data.map(function (d, i) {
          var x,
              rawX = d[xKey],
              value = d[id];
          return value = value === null || isNaN(value) || isObject(value) ? isArray(value) || isObject(value) ? value : null : +value, isCategorized && index === 0 && !isUndefined(rawX) ? (!hasCategory && index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), (isUndefined(value) || $$.data.xs[id].length <= i) && (x = undefined), {
            x: x,
            value: value,
            id: convertedId
          };
        }).filter(function (v) {
          return isDefined(v.x);
        })
      };
    }); // finish targets

    return targets.forEach(function (t) {
      config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
        var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
            x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
        return x1 - x2;
      })), t.values.forEach(function (v, i) {
        return v.index = i;
      }), $$.data.xs[t.id].sort(function (v1, v2) {
        return v1 - v2;
      });
    }), $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets), $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
      return !(id in config.data_types);
    }), config.data_type), targets.forEach(function (d) {
      return $$.addCache(d.id_org, d, !0);
    }), targets;
  }
});
// CONCATENATED MODULE: ./src/data/data.load.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  load: function load(rawTargets, args) {
    var $$ = this,
        targets = rawTargets;
    // Set targets
    // Redraw with new targets
    targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
      var type = args.types && args.types[t.id] || args.type;
      $$.setTargetType(t.id, type);
    }), $$.data.targets.forEach(function (d) {
      for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
        d.values = targets[i].values, targets.splice(i, 1);
        break;
      }
    }), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    }), args.done && args.done();
  },
  loadFromArgs: function loadFromArgs(args) {
    var $$ = this; // prevent load when chart is already destroyed

    if ($$.config) {
      $$.resetCache();
      var data = args.data || $$.convertData(args, function (d) {
        return $$.load($$.convertDataToTargets(d), args);
      });
      data && $$.load($$.convertDataToTargets(data), args);
    } // reset internally cached data

  },
  unload: function unload(rawTargetIds, customDoneCb) {
    var $$ = this,
        done = customDoneCb,
        targetIds = rawTargetIds;
    // If no target, call done and return
    return $$.resetCache(), done || (done = function () {}), targetIds = targetIds.filter(function (id) {
      return $$.hasTarget($$.data.targets, id);
    }), targetIds && targetIds.length !== 0 ? void ($$.svg.selectAll(targetIds.map(function (id) {
      return $$.selectorTarget(id);
    })).transition().style("opacity", "0").remove().call($$.endall, done), targetIds.forEach(function (id) {
      $$.withoutFadeIn[id] = !1, $$.legend && $$.legend.selectAll(".".concat(config_classes.legendItem).concat($$.getTargetSelectorSuffix(id))).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
        return t.id !== id;
      });
    })) : void done();
  }
});
// CONCATENATED MODULE: ./src/internals/category.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Category Name
   * @private
   * @param {Number} index
   * @returns {String} gategory Name
   */
  categoryName: function categoryName(i) {
    var config = this.config;
    return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-drag","commonjs2":"d3-drag","amd":"d3-drag","root":"d3"}
var external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_ = __webpack_require__(9);

// CONCATENATED MODULE: ./src/interactions/interaction.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the area that detects the event.
   * Add a container for the zone that detects the event.
   * @private
   */
  initEventRect: function initEventRect() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.eventRects).style("fill-opacity", "0");
  },

  /**
   * Redraws the area that detects the event.
   * @private
   */
  redrawEventRect: function redrawEventRect() {
    var eventRectUpdate,
        $$ = this,
        config = $$.config,
        isMultipleX = $$.isMultipleX(),
        zoomEnabled = config.zoom_enabled,
        eventRects = $$.main.select(".".concat(config_classes.eventRects)).style("cursor", zoomEnabled && zoomEnabled.type !== "drag" ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(config_classes.eventRectsMultiple, isMultipleX).classed(config_classes.eventRectsSingle, !isMultipleX);
    if (eventRects.selectAll(".".concat(config_classes.eventRect)).remove(), $$.eventRect = eventRects.selectAll(".".concat(config_classes.eventRect)), isMultipleX) eventRectUpdate = $$.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate);else {
      // Set data and update $$.eventRect
      var xAxisTickValues = $$.getMaxDataCountTarget(); // update data's index value to be alinged with the x Axis

      $$.updateDataIndexByX(xAxisTickValues), $$.updateXs(xAxisTickValues), $$.updatePointClass(!0), eventRects.datum(xAxisTickValues), $$.eventRect = eventRects.selectAll(".".concat(config_classes.eventRect)), eventRectUpdate = $$.eventRect.data(function (d) {
        return d;
      }), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate);
    }
    $$.eventRect = eventRectUpdate, $$.updateEventRect(eventRectUpdate), $$.inputType !== "touch" || $$.svg.on("touchstart.eventRect") || $$.hasArcType() || $$.bindTouchOnEventRect(isMultipleX);
  },
  bindTouchOnEventRect: function bindTouchOnEventRect(isMultipleX) {
    var startPx,
        $$ = this,
        config = $$.config,
        getEventRect = function () {
      var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0];
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
    },
        getIndex = function (eventRect) {
      var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(".concat(config_classes.eventRect, "-?|s)"), "g"), "") * 1;
      return (isNaN(index) || index === null) && (index = -1), index;
    },
        selectRect = function (context) {
      if (isMultipleX) $$.selectRectForMultipleXs(context);else {
        var eventRect = getEventRect(),
            index = getIndex(eventRect);
        $$.callOverOutForTouch(index), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
      }
    },
        preventDefault = config.interaction_inputType_touch.preventDefault,
        isPrevented = isBoolean(preventDefault) && preventDefault || !1,
        preventThreshold = !isNaN(preventDefault) && preventDefault || null,
        preventEvent = function (event) {
      var eventType = event.type,
          touch = event.changedTouches[0],
          currentXY = touch["client".concat(config.axis_rotated ? "Y" : "X")];
      eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
    };

    // bind touch events
    $$.svg.on("touchstart.eventRect touchmove.eventRect", function () {
      var eventRect = getEventRect(),
          event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"];

      if (!eventRect.empty() && eventRect.classed(config_classes.eventRect)) {
        // if touch points are > 1, means doing zooming interaction. In this case do not execute tooltip codes.
        if ($$.dragging || $$.flowing || $$.hasArcType() || event.touches.length > 1) return;
        preventEvent(event), selectRect(this);
      } else $$.unselectRect(), $$.callOverOutForTouch();
    }, !0).on("touchend.eventRect", function () {
      var eventRect = getEventRect();
      !eventRect.empty() && eventRect.classed(config_classes.eventRect) && ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) && $$.cancelClick && ($$.cancelClick = !1);
    }, !0);
  },

  /**
   * Updates the location and size of the eventRect.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   */
  updateEventRect: function updateEventRect(eventRectUpdate) {
    var x,
        y,
        w,
        h,
        $$ = this,
        config = $$.config,
        xScale = $$.zoomScale || $$.x,
        eventRectData = eventRectUpdate || $$.eventRect.data(),
        isRotated = config.axis_rotated;
    if ($$.isMultipleX()) // TODO: rotated not supported yet
    x = 0, y = 0, w = $$.width, h = $$.height;else {
      var rectW, rectX;
      if ($$.isCategorized()) rectW = $$.getEventRectWidth(), rectX = function (d) {
        return xScale(d.x) - rectW / 2;
      };else {
        var getPrevNextX = function (d) {
          var index = d.index;
          return {
            prev: $$.getPrevX(index),
            next: $$.getNextX(index)
          };
        };

        rectW = function (d) {
          var x = getPrevNextX(d); // if there this is a single data point make the eventRect full width (or height)

          return x.prev === null && x.next === null ? isRotated ? $$.height : $$.width : (x.prev === null && (x.prev = xScale.domain()[0]), x.next === null && (x.next = xScale.domain()[1]), Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2));
        }, rectX = function (d) {
          var x = getPrevNextX(d),
              thisX = d.x;
          // if there this is a single data point position the eventRect at 0
          return x.prev === null && x.next === null ? 0 : (x.prev === null && (x.prev = xScale.domain()[0]), (xScale(thisX) + xScale(x.prev)) / 2);
        };
      }
      x = isRotated ? 0 : rectX, y = isRotated ? rectX : 0, w = isRotated ? $$.width : rectW, h = isRotated ? rectW : $$.height;
    }
    eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
  },
  selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
    var $$ = this,
        config = $$.config,
        isSelectionEnabled = config.data_selection_enabled,
        isSelectionGrouped = config.data_selection_grouped,
        isTooltipGrouped = config.tooltip_grouped,
        selectedData = $$.getAllValuesOnIndex(index);
    isTooltipGrouped && ($$.showTooltip(selectedData, context), $$.showGridFocus(selectedData), !isSelectionEnabled || isSelectionGrouped) || $$.main.selectAll(".".concat(config_classes.shape, "-").concat(index)).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED, !0), isSelectionEnabled && eventRect.style("cursor", isSelectionGrouped ? "pointer" : null), isTooltipGrouped || ($$.hideGridFocus(), $$.hideTooltip(), !isSelectionGrouped && $$.expandCirclesBars(index));
    }).filter(function (d) {
      return $$.isWithinShape(this, d);
    }).call(function (selected) {
      var d = selected.data();
      isSelectionEnabled && (isSelectionGrouped || config.data_selection_isselectable(d)) && eventRect.style("cursor", "pointer"), isTooltipGrouped || ($$.showTooltip(d, context), $$.showGridFocus(d), $$.unexpandCircles(), selected.each(function (d) {
        return $$.expandCirclesBars(index, d.id);
      }));
    });
  },
  expandCirclesBars: function expandCirclesBars(index, id, reset) {
    var $$ = this,
        config = $$.config;
    config.point_focus_expand_enabled && $$.expandCircles(index, id, reset), $$.expandBars(index, id, reset);
  },
  selectRectForMultipleXs: function selectRectForMultipleXs(context) {
    var $$ = this,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    // do nothing when dragging
    if (!($$.dragging || $$.hasArcType(targetsToShow))) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(context),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id) && (config.data_onout.call($$.api, $$.mouseover), $$.mouseover = undefined), !closest) return void $$.unselectRect();
      var sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x),
          selectedData = sameXData.map(function (d) {
        return $$.addName(d);
      }); // show tooltip when cursor is close to some point

      $$.showTooltip(selectedData, context), $$.expandCirclesBars(closest.index, closest.id, !0), $$.showGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.svg.select(".".concat(config_classes.eventRect)).style("cursor", "pointer"), !$$.mouseover && (config.data_onover.call($$.api, closest), $$.mouseover = closest));
    }
  },

  /**
   * Unselect EventRect.
   * @private
   */
  unselectRect: function unselectRect() {
    var $$ = this;
    $$.svg.select(".".concat(config_classes.eventRect)).style("cursor", null), $$.hideGridFocus(), $$.hideTooltip(), $$._handleLinkedCharts(!1), $$.unexpandCircles(), $$.unexpandBars();
  },

  /**
   * Handle data.onover/out callback options
   * @param {Boolean} isOver
   * @param {Number|Object} d
   * @private
   */
  setOverOut: function setOverOut(isOver, d) {
    var $$ = this,
        config = $$.config,
        isArc = isObject(d);

    // Call event handler
    if (isArc || d !== -1) {
      var callback = config[isOver ? "data_onover" : "data_onout"].bind($$.api);
      if (config.color_onover && $$.setOverColor(isOver, d, isArc), isArc) callback(d, $$.main.select(".".concat(config_classes.arc).concat($$.getTargetSelectorSuffix(d.id))).node());else if (!config.tooltip_grouped) {
        var callee = $$.setOverOut,
            last = callee.last || [],
            shape = $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).filter(function (d) {
          return $$.isWithinShape(this, d);
        });
        shape.each(function (d) {
          var _this = this;

          (last.length === 0 || last.every(function (v) {
            return v !== _this;
          })) && (callback(d, this), last.push(this));
        }), last.length > 0 && shape.empty() && (callback = config.data_onout.bind($$.api), last.forEach(function (v) {
          return callback(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(v).datum(), v);
        }), last = []), callee.last = last;
      } else isOver && $$.expandCirclesBars(d, null, !0), $$.isMultipleX() || $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).each(function (d) {
        callback(d, this);
      });
    }
  },

  /**
   * Call data.onover/out callback for touch event
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  callOverOutForTouch: function callOverOutForTouch(d) {
    var $$ = this,
        callee = $$.callOverOutForTouch,
        last = callee.last;
    (isObject(d) && last ? d.id !== last.id : d !== last) && ((last || isNumber(last)) && $$.setOverOut(!1, last), (d || isNumber(d)) && $$.setOverOut(!0, d), callee.last = d);
  },

  /**
   * Return draggable selection function
   * @return {Function}
   * @private
   */
  getDraggableSelection: function getDraggableSelection() {
    var $$ = this,
        config = $$.config;
    return config.interaction_enabled && config.data_selection_draggable && $$.drag ? Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().on("drag", function () {
      $$.drag(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("start", function () {
      $$.dragstart(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("end", function () {
      $$.dragend();
    }) : function () {};
  },

  /**
   * Create eventRect for each data on the x-axis.
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
    var $$ = this,
        config = $$.config,
        rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function (d) {
      $$.clickHandlerForSingleX.bind(this)(d, $$);
    }).call($$.getDraggableSelection());
    return $$.inputType === "mouse" && rect.on("mouseover", function (d) {
      $$.dragging || $$.flowing || $$.hasArcType() || $$.config.tooltip_grouped && $$.setOverOut(!0, d.index);
    }).on("mousemove", function (d) {
      // do nothing while dragging/flowing
      if (!($$.dragging || $$.flowing || $$.hasArcType())) {
        var index = d.index,
            eventRect = $$.svg.select(".".concat(config_classes.eventRect, "-").concat(index));
        $$.isStepType(d) && $$.config.line_step_type === "step-after" && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[0] < $$.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index), $$.config.tooltip_grouped || $$.setOverOut(index !== -1, d.index);
      }
    }).on("mouseout", function (d) {
      !$$.config || $$.hasArcType() || ($$.unselectRect(), $$.setOverOut(!1, d.index));
    }), rect;
  },
  clickHandlerForSingleX: function clickHandlerForSingleX(d, ctx) {
    var $$ = ctx,
        config = $$.config;
    if ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) return void ($$.cancelClick && ($$.cancelClick = !1));
    var index = d.index;
    $$.main.selectAll(".".concat(config_classes.shape, "-").concat(index)).each(function (d2) {
      (config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), config.data_onclick.call($$.api, d2, this));
    });
  },

  /**
   * Create an eventRect,
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
    var $$ = this,
        rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", $$.width).attr("height", $$.height).attr("class", config_classes.eventRect).on("click", function () {
      $$.clickHandlerForMultipleXS.bind(this)($$);
    }).call($$.getDraggableSelection());
    return $$.inputType === "mouse" && rect.on("mouseover mousemove", function () {
      $$.selectRectForMultipleXs(this);
    }).on("mouseout", function () {
      !$$.config || $$.hasArcType() || $$.unselectRect();
    }), rect;
  },
  clickHandlerForMultipleXS: function clickHandlerForMultipleXS(ctx) {
    var $$ = ctx,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    if (!$$.hasArcType(targetsToShow)) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      !closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.main.selectAll(".".concat(config_classes.shapes).concat($$.getTargetSelectorSuffix(closest.id))).selectAll(".".concat(config_classes.shape, "-").concat(closest.index)).each(function () {
        (config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), config.data_onclick.call($$.api, closest, this));
      });
    } // select if selection enabled

  },

  /**
   * Dispatch a mouse event.
   * @private
   * @param {String} type event type
   * @param {Number} index Index of eventRect
   * @param {Array} mouse x and y coordinate value
   */
  dispatchEvent: function dispatchEvent(type, index, mouse) {
    var $$ = this,
        isMultipleX = $$.isMultipleX(),
        selector = ".".concat(isMultipleX ? config_classes.eventRect : "".concat(config_classes.eventRect, "-").concat(index)),
        eventRect = $$.main.select(selector).node(),
        _eventRect$getBoundin = eventRect.getBoundingClientRect(),
        width = _eventRect$getBoundin.width,
        left = _eventRect$getBoundin.left,
        top = _eventRect$getBoundin.top,
        x = left + (mouse ? mouse[0] : 0) + (isMultipleX || $$.config.axis_rotated ? 0 : width / 2),
        y = top + (mouse ? mouse[1] : 0);

    emulateEvent[/^(mouse|click)/.test(type) ? "mouse" : "touch"](eventRect, type, {
      screenX: x,
      screenY: y,
      clientX: x,
      clientY: y
    });
  }
});
// CONCATENATED MODULE: ./src/internals/size.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Update container size
   * @private
   */
  setContainerSize: function setContainerSize() {
    var $$ = this;
    $$.currentWidth = $$.getCurrentWidth(), $$.currentHeight = $$.getCurrentHeight();
  },
  getCurrentWidth: function getCurrentWidth() {
    var $$ = this;
    return $$.config.size_width || $$.getParentWidth();
  },
  getCurrentHeight: function getCurrentHeight() {
    var $$ = this,
        config = $$.config,
        h = config.size_height || $$.getParentHeight();
    return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
  },

  /**
   * Get Axis size according its position
   * @param {String} id Axis id value - x, y or y2
   * @return {number} size Axis size value
   * @private
   */
  getAxisSize: function getAxisSize(id) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    return isRotated && id === "x" || !isRotated && /y2?/.test(id) ? $$.getAxisWidthByAxisId(id, !0) : $$.getHorizontalAxisHeight(id);
  },
  getCurrentPaddingTop: function getCurrentPaddingTop() {
    var $$ = this,
        config = $$.config,
        axesLen = config.axis_y2_axes.length,
        padding = isValue(config.padding_top) ? config.padding_top : 0;
    return $$.title && $$.title.node() && (padding += $$.getTitlePadding()), axesLen && config.axis_rotated && (padding += $$.getHorizontalAxisHeight("y2") * axesLen), padding;
  },
  getCurrentPaddingBottom: function getCurrentPaddingBottom() {
    var $$ = this,
        config = $$.config,
        axisId = config.axis_rotated ? "y" : "x",
        axesLen = config["axis_".concat(axisId, "_axes")].length,
        padding = isValue(config.padding_bottom) ? config.padding_bottom : 0;
    return padding + (axesLen ? $$.getHorizontalAxisHeight(axisId) * axesLen : 0);
  },
  getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
    var padding,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        axisId = isRotated ? "x" : "y",
        axesLen = config["axis_".concat(axisId, "_axes")].length,
        axisWidth = $$.getAxisWidthByAxisId(axisId, withoutRecompute);
    return padding = isValue(config.padding_left) ? config.padding_left : isRotated ? config.axis_x_show ? Math.max(ceil10(axisWidth), 40) : 1 : !config.axis_y_show || config.axis_y_inner ? $$.axis.getAxisLabelPosition("y").isOuter ? 30 : 1 : ceil10(axisWidth), padding + axisWidth * axesLen;
  },
  getCurrentPaddingRight: function getCurrentPaddingRight() {
    var padding,
        withoutTickTextOverflow = !!(arguments.length > 0 && arguments[0] !== undefined) && arguments[0],
        $$ = this,
        config = $$.config,
        defaultPadding = 10,
        legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0,
        axesLen = config.axis_y2_axes.length,
        axisWidth = $$.getAxisWidthByAxisId("y2"),
        xAxisTickTextOverflow = withoutTickTextOverflow ? 0 : $$.axis.getXAxisTickTextY2Overflow(defaultPadding);
    return padding = isValue(config.padding_right) ? config.padding_right + 1 : config.axis_rotated ? defaultPadding + legendWidthOnRight : !config.axis_y2_show || config.axis_y2_inner ? Math.max(2 + legendWidthOnRight + ($$.axis.getAxisLabelPosition("y2").isOuter ? 20 : 0), xAxisTickTextOverflow) : Math.max(ceil10(axisWidth) + legendWidthOnRight, xAxisTickTextOverflow), padding + axisWidth * axesLen;
  },

  /**
   * Get the parent rect element's size
   * @param {String} key property/attribute name
   * @private
   */
  getParentRectValue: function getParentRectValue(key) {
    for (var v, offsetName = "offset".concat(capitalize(key)), parent = this.selectChart.node(); !v && parent && parent.tagName !== "BODY";) {
      try {
        v = parent.getBoundingClientRect()[key];
      } catch (e) {
        offsetName in parent && (v = parent[offsetName]);
      }

      parent = parent.parentNode;
    }

    if (key === "width") {
      // Sometimes element's width value is incorrect(ex. flex container)
      // In this case, use body's offsetWidth instead.
      var bodyWidth = browser_doc.body.offsetWidth;
      v > bodyWidth && (v = bodyWidth);
    }

    return v;
  },
  getParentWidth: function getParentWidth() {
    return this.getParentRectValue("width");
  },
  getParentHeight: function getParentHeight() {
    var h = this.selectChart.style("height");
    return h.indexOf("px") > 0 ? parseInt(h, 10) : 0;
  },
  getSvgLeft: function getSvgLeft(withoutRecompute) {
    var $$ = this,
        config = $$.config,
        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
        leftAxisClass = config.axis_rotated ? config_classes.axisX : config_classes.axisY,
        leftAxis = $$.main.select(".".concat(leftAxisClass)).node(),
        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {
      right: 0
    },
        chartRect = $$.selectChart.node().getBoundingClientRect(),
        hasArc = $$.hasArcType(),
        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
    return svgLeft > 0 ? svgLeft : 0;
  },
  getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
    var $$ = this,
        position = $$.axis.getLabelPositionById(id);
    return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
  },
  getHorizontalAxisHeight: function getHorizontalAxisHeight(id) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        h = 30;
    if (id === "x" && !config.axis_x_show) return 8;
    if (id === "x" && config.axis_x_height) return config.axis_x_height;
    if (id === "y" && !config.axis_y_show) return !config.legend_show || $$.isLegendRight || $$.isLegendInset ? 1 : 10;
    if (id === "y2" && !config.axis_y2_show) return $$.rotated_padding_top; // const rotate = config[`axis_${id}_tick_rotate`];

    var rotate = $$.getAxisTickRotate(id); // Calculate x/y axis height when tick rotated

    return (id === "x" && !isRotated || /y2?/.test(id) && isRotated) && rotate && (h = 30 + $$.axis.getMaxTickWidth(id) * Math.cos(Math.PI * (90 - rotate) / 180), !config.axis_x_tick_multiline && $$.currentHeight && h > $$.currentHeight / 2 && (h = $$.currentHeight / 2)), h + ($$.axis.getLabelPositionById(id).isInner ? 0 : 10) + (id !== "y2" || isRotated ? 0 : -10);
  },
  getEventRectWidth: function getEventRectWidth() {
    return Math.max(0, this.xAxis.tickInterval());
  },

  /**
   * Get axis tick test rotate value
   * @param {String} id
   * @return {Number} rotate value
   * @private
   */
  getAxisTickRotate: function getAxisTickRotate(id) {
    var $$ = this,
        config = $$.config,
        rotate = config["axis_".concat(id, "_tick_rotate")];

    if (id === "x") {
      var isCategorized = $$.isCategorized(),
          isTimeSeries = $$.isTimeSeries(),
          allowedXAxisTypes = isCategorized || isTimeSeries,
          tickCount = 0;
      config.axis_x_tick_fit && allowedXAxisTypes && ($$.axis.x = {
        padding: {
          left: 0,
          right: 0
        },
        tickCount: 0
      }, tickCount = $$.currentMaxTickWidths.x.ticks.length + (isTimeSeries ? -1 : 1), tickCount !== $$.axis.x.tickCount && ($$.axis.x.padding = $$.axis.getXAxisPadding(tickCount)), $$.axis.x.tickCount = tickCount), $$.svg && config.axis_x_tick_fit && !config.axis_x_tick_multiline && !config.axis_x_tick_culling && config.axis_x_tick_autorotate && allowedXAxisTypes && (rotate = $$.needToRotateXAxisTickTexts() ? config.axis_x_tick_rotate : 0);
    }

    return rotate;
  },

  /**
   * Check weather axis tick text needs to be rotated
   * @private
   */
  needToRotateXAxisTickTexts: function needToRotateXAxisTickTexts() {
    var $$ = this,
        xAxisLength = $$.currentWidth - $$.getCurrentPaddingLeft(!1) - $$.getCurrentPaddingRight(!0),
        tickCountWithPadding = $$.axis.x.tickCount + $$.axis.x.padding.left + $$.axis.x.padding.right,
        maxTickWidth = $$.axis.getMaxTickWidth("x");
    return maxTickWidth > (xAxisLength / tickCountWithPadding || 0);
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-shape","commonjs2":"d3-shape","amd":"d3-shape","root":"d3"}
var external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_ = __webpack_require__(10);

// CONCATENATED MODULE: ./src/shape/shape.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  getShapeIndices: function getShapeIndices(typeFilter) {
    var $$ = this,
        config = $$.config,
        xs = config.data_xs,
        hasXs = notEmpty(xs),
        indices = {},
        i = hasXs ? {} : 0;
    return hasXs && getUnique(Object.keys(xs).map(function (v) {
      return xs[v];
    })).forEach(function (v) {
      i[v] = 0, indices[v] = {};
    }), $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
      for (var groups, xKey = (d.id in xs) ? xs[d.id] : "", ind = xKey ? indices[xKey] : indices, j = 0; groups = config.data_groups[j]; j++) if (!(groups.indexOf(d.id) < 0)) for (var _row4, _k4 = 0; _row4 = groups[_k4]; _k4++) if (_row4 in ind) {
        ind[d.id] = ind[_row4];
        break;
      }

      isUndefined(ind[d.id]) && (ind[d.id] = xKey ? i[xKey]++ : i++, ind.__max__ = (xKey ? i[xKey] : i) - 1);
    }), indices;
  },

  /**
   * Get indices value based on data ID value
   * @param {Object} indices Indices object
   * @param {String} id Data id value
   * @return {Object} Indices object
   * @private
   */
  getIndices: function getIndices(indices, id) {
    var xs = this.config.data_xs;
    return notEmpty(xs) ? indices[xs[id]] : indices;
  },

  /**
   * Get indices max number
   * @param {Object} indices Indices object
   * @return {Number} Max number
   * @private
   */
  getIndicesMax: function getIndicesMax(indices) {
    return notEmpty(this.config.data_xs) ? // if is multiple xs, return total sum of xs' __max__ value
    Object.keys(indices).map(function (v) {
      return indices[v].__max__ || 0;
    }).reduce(function (acc, curr) {
      return acc + curr;
    }) : indices.__max__;
  },
  getShapeX: function getShapeX(offset, indices, isSub) {
    var $$ = this,
        scale = isSub ? $$.subX : $$.zoomScale || $$.x,
        barPadding = $$.config.bar_padding,
        sum = function (p, c) {
      return p + c;
    },
        halfWidth = isObjectType(offset) && offset.total.length ? offset.total.reduce(sum) / 2 : 0;

    return function (d) {
      var ind = $$.getIndices(indices, d.id),
          index = d.id in ind ? ind[d.id] : 0,
          targetsNum = (ind.__max__ || 0) + 1,
          x = 0;

      if (notEmpty(d.x)) {
        var xPos = scale(d.x);
        x = halfWidth ? xPos - (offset[d.id] || offset.width) + offset.total.slice(0, index + 1).reduce(sum) - halfWidth : xPos - (isNumber(offset) ? offset : offset.width) * (targetsNum / 2 - index);
      } // adjust x position for bar.padding optionq


      return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
    };
  },
  getShapeY: function getShapeY(isSub) {
    var $$ = this,
        isStackNormalized = $$.isStackNormalized();
    return function (d) {
      var value = isStackNormalized ? $$.getRatio("index", d, !0) : $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : d.value;
      return (isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id))(value);
    };
  },

  /**
   * Get shape based y Axis min value
   * @param {String} id Data id
   * @return {Number}
   * @private
   */
  getShapeYMin: function getShapeYMin(id) {
    var $$ = this,
        _$$$$$$axis$getId$dom = $$[$$.axis.getId(id)].domain(),
        _$$$$$$axis$getId$dom2 = _slicedToArray(_$$$$$$axis$getId$dom, 1),
        yMin = _$$$$$$axis$getId$dom2[0];

    return !$$.isGrouped(id) && yMin > 0 ? yMin : 0;
  },

  /**
   * Get Shape's offset data
   * @param {function(Object): boolean} typeFilter
   * @return {{shapeOffsetTargets: ShapeOffsetTarget[], indexMapByTargetId: object}}
   * @private
   */
  getShapeOffsetData: function getShapeOffsetData(typeFilter) {
    var $$ = this,
        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
        isStackNormalized = $$.isStackNormalized(),
        shapeOffsetTargets = targets.map(function (target) {
      var rowValues = target.values,
          values = {};
      $$.isStepType(target) && (rowValues = $$.convertValuesToStep(rowValues));
      var rowValueMapByXValue = rowValues.reduce(function (out, d) {
        var key = +d.x;
        return out[key] = d, values[key] = isStackNormalized ? $$.getRatio("index", d, !0) : d.value, out;
      }, {});
      return {
        id: target.id,
        rowValues: rowValues,
        rowValueMapByXValue: rowValueMapByXValue,
        values: values
      };
    }),
        indexMapByTargetId = targets.reduce(function (out, _ref, index) {
      var id = _ref.id;
      return out[id] = index, out;
    }, {});
    return {
      indexMapByTargetId: indexMapByTargetId,
      shapeOffsetTargets: shapeOffsetTargets
    };
  },
  getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
    var $$ = this,
        _$$$getShapeOffsetDat = $$.getShapeOffsetData(typeFilter),
        shapeOffsetTargets = _$$$getShapeOffsetDat.shapeOffsetTargets,
        indexMapByTargetId = _$$$getShapeOffsetDat.indexMapByTargetId;

    return function (d, idx) {
      var ind = $$.getIndices(indices, d.id),
          scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
          y0 = scale($$.getShapeYMin(d.id)),
          dataXAsNumber = +d.x,
          offset = y0;
      return shapeOffsetTargets.filter(function (t) {
        return t.id !== d.id;
      }).forEach(function (t) {
        if (ind[t.id] === ind[d.id] && indexMapByTargetId[t.id] < indexMapByTargetId[d.id]) {
          var row = t.rowValues[idx]; // check if the x values line up

          row && +row.x === dataXAsNumber || (row = t.rowValueMapByXValue[dataXAsNumber]), row && row.value * d.value >= 0 && (offset += scale(t.values[dataXAsNumber]) - y0);
        }
      }), offset;
    };
  },
  isWithinShape: function isWithinShape(that, d) {
    var isWithin,
        $$ = this,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that);
    return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0) : that.nodeName === "path" && (isWithin = !shape.classed(config_classes.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
  },
  getInterpolate: function getInterpolate(d) {
    var $$ = this,
        interpolation = $$.getInterpolateType(d);
    return {
      "basis": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasis"],
      "basis-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisClosed"],
      "basis-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisOpen"],
      "bundle": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBundle"],
      "cardinal": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinal"],
      "cardinal-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalClosed"],
      "cardinal-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalOpen"],
      "catmull-rom": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRom"],
      "catmull-rom-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomClosed"],
      "catmull-rom-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomOpen"],
      "monotone-x": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneX"],
      "monotone-y": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneY"],
      "natural": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveNatural"],
      "linear-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinearClosed"],
      "linear": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinear"],
      "step": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStep"],
      "step-after": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepAfter"],
      "step-before": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepBefore"]
    }[interpolation];
  },
  getInterpolateType: function getInterpolateType(d) {
    var $$ = this,
        type = $$.config.spline_interpolation_type,
        interpolation = $$.isInterpolationType(type) ? type : "cardinal";
    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? $$.config.line_step_type : "linear";
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-interpolate","commonjs2":"d3-interpolate","amd":"d3-interpolate","root":"d3"}
var external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_ = __webpack_require__(11);

// CONCATENATED MODULE: ./src/shape/arc.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */







extend(ChartInternal_ChartInternal.prototype, {
  initPie: function initPie() {
    var $$ = this,
        config = $$.config,
        dataType = config.data_type,
        padding = config.pie_padding,
        startingAngle = config["".concat(dataType, "_startingAngle")] || 0,
        padAngle = ($$.hasType("pie") && padding ? padding * .01 : config["".concat(dataType, "_padAngle")]) || 0;
    $$.pie = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["pie"])().startAngle(startingAngle).endAngle(startingAngle + 2 * Math.PI).padAngle(padAngle).sortValues($$.isOrderAsc() || $$.isOrderDesc() ? function (a, b) {
      return $$.isOrderAsc() ? a - b : b - a;
    } : null).value(function (d) {
      return d.values.reduce(function (a, b) {
        return a + b.value;
      }, 0);
    });
  },
  updateRadius: function updateRadius() {
    var $$ = this,
        config = $$.config,
        radius = config.pie_innerRadius,
        padding = config.pie_padding,
        w = config.gauge_width || config.donut_width,
        gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * config.gauge_arcs_minWidth;
    $$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2 * ($$.hasMultiArcGauge() ? .85 : 1), $$.radius = $$.radiusExpanded * .95, $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : .6, $$.gaugeArcWidth = w || (gaugeArcWidth <= $$.radius - $$.innerRadius ? $$.radius - $$.innerRadius : gaugeArcWidth <= $$.radius ? gaugeArcWidth : $$.radius);
    var innerRadius = radius || (padding ? padding * ($$.innerRadiusRatio + .1) : 0); // NOTE: innerRadius can be an object by user setting, only for 'pie' type

    $$.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? $$.radius * $$.innerRadiusRatio : innerRadius;
  },
  getInnerRadius: function getInnerRadius(d) {
    var $$ = this,
        radius = $$.innerRadius;
    return !isNumber(radius) && d && (radius = radius[d.data.id] || 0), radius;
  },
  updateArc: function updateArc() {
    var $$ = this;
    $$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded();
  },
  updateAngle: function updateAngle(dValue) {
    var $$ = this,
        config = $$.config,
        pie = $$.pie,
        d = dValue,
        found = !1;
    if (!config) return null;
    var radius = Math.PI * (config.gauge_fullCircle ? 2 : 1),
        gStart = config.gauge_startingAngle;

    if (d.data && $$.isGaugeType(d.data) && !$$.hasMultiArcGauge()) {
      // to prevent excluding total data sum during the init(when data.hide option is used), use $$.rendered state value
      var totalSum = $$.getTotalDataSum($$.rendered); // if gauge_max less than totalSum, make totalSum to max value

      totalSum > config.gauge_max && (config.gauge_max = totalSum);
      var gEnd = radius * (totalSum / (config.gauge_max - config.gauge_min));
      pie = pie.startAngle(gStart).endAngle(gEnd + gStart);
    }

    if (pie($$.filterTargetsToShow()).forEach(function (t, i) {
      found || t.data.id !== d.data.id || (found = !0, d = t, d.index = i);
    }), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), d.data && $$.hasMultiArcGauge()) {
      var maxValue = $$.getMinMaxData().max[0].value; // if gauge_max less than maxValue, make maxValue to max value

      maxValue > config.gauge_max && (config.gauge_max = maxValue);
      var gMin = config.gauge_min,
          gMax = config.gauge_max,
          gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
      d.startAngle = gStart, d.endAngle = gStart + radius / (gMax - gMin) * gValue;
    }

    return found ? d : null;
  },
  getSvgArc: function getSvgArc() {
    var $$ = this,
        ir = $$.getInnerRadius(),
        singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? $$.radius - singleArcWidth * d.index : $$.radius;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? $$.radius - singleArcWidth * (d.index + 1) : isNumber(ir) ? ir : 0;
    }),
        newArc = function (d, withoutUpdate) {
      var path = "M 0 0";

      if (d.value || d.data) {
        isNumber(ir) || (arc = arc.innerRadius($$.getInnerRadius(d)));
        var updated = !withoutUpdate && $$.updateAngle(d);
        withoutUpdate ? path = arc(d) : updated && (path = arc(updated));
      }

      return path;
    };

    return newArc.centroid = arc.centroid, newArc;
  },
  getSvgArcExpanded: function getSvgArcExpanded(rate) {
    var $$ = this,
        newRate = rate || 1,
        singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        expandWidth = Math.min($$.radiusExpanded * newRate - $$.radius, singleArcWidth * .8 - (1 - newRate) * 100),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? $$.radius - singleArcWidth * d.index + expandWidth : $$.radiusExpanded * newRate;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? $$.radius - singleArcWidth * (d.index + 1) : $$.innerRadius;
    });
    return function (d) {
      var updated = $$.updateAngle(d);
      return updated ? (hasMultiArcGauge ? arc : arc.innerRadius($$.getInnerRadius(d)))(updated) : "M 0 0";
    };
  },
  getArc: function getArc(d, withoutUpdate, force) {
    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
  },
  transformForArcLabel: function transformForArcLabel(d) {
    var $$ = this,
        config = $$.config,
        updated = $$.updateAngle(d),
        translate = "";
    if (updated) if ($$.hasMultiArcGauge()) {
      var y1 = Math.sin(updated.endAngle - Math.PI / 2),
          x = Math.cos(updated.endAngle - Math.PI / 2) * ($$.radiusExpanded + 25),
          y = y1 * ($$.radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;
      translate = "translate(".concat(x, ",").concat(y, ")");
    } else if (!$$.hasType("gauge") || $$.data.targets.length > 1) {
      var c = this.svgArc.centroid(updated),
          x = isNaN(c[0]) ? 0 : c[0],
          y = isNaN(c[1]) ? 0 : c[1],
          h = Math.sqrt(x * x + y * y),
          ratio = $$.hasType("donut") && config.donut_label_ratio || $$.hasType("pie") && config.pie_label_ratio;
      ratio = ratio ? isFunction(ratio) ? ratio(d, $$.radius, h) : ratio : $$.radius && (h ? (36 / $$.radius > .375 ? 1.175 - 36 / $$.radius : .8) * $$.radius / h : 0), translate = "translate(".concat(x * ratio, ",").concat(y * ratio, ")");
    }
    return translate;
  },
  convertToArcData: function convertToArcData(d) {
    return this.addName({
      id: d.data.id,
      value: d.value,
      ratio: this.getRatio("arc", d),
      index: d.index
    });
  },
  textForArcLabel: function textForArcLabel(selection) {
    var $$ = this,
        hasGauge = $$.hasType("gauge");
    $$.shouldShowArcLabel() && selection.each(function (d) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          updated = $$.updateAngle(d),
          ratio = $$.getRatio("arc", updated),
          isUnderThreshold = hasGauge || $$.meetsArcLabelThreshold(ratio);

      if (isUnderThreshold) {
        var value = (updated || d).value,
            text = ($$.getArcLabelFormat() || $$.defaultArcValueFormat)(value, ratio, d.data.id).toString();
        setTextValue(node, text, [-1, 1], hasGauge);
      } else node.text("");
    });
  },
  textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
    var format = this.getGaugeLabelExtents();
    return format ? format(value, isMax) : value;
  },
  expandArc: function expandArc(targetIds) {
    var $$ = this; // MEMO: avoid to cancel transition

    if ($$.transiting) {
      var interval = setInterval(function () {
        $$.transiting || (clearInterval(interval), $$.legend.selectAll(".".concat(config_classes.legendItemFocused)).size() > 0 && $$.expandArc(targetIds));
      }, 10);
      return;
    }

    var newTargetIds = $$.mapToTargetIds(targetIds);
    $$.svg.selectAll($$.selectorTargets(newTargetIds, ".".concat(config_classes.chartArc))).each(function (d) {
      if ($$.shouldExpand(d.data.id)) {
        var expandDuration = $$.getExpandConfig(d.data.id, "duration"),
            svgArcExpandedSub = $$.getSvgArcExpanded($$.getExpandConfig(d.data.id, "rate"));
        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).selectAll("path").transition().duration(expandDuration).attr("d", $$.svgArcExpanded).transition().duration(expandDuration * 2).attr("d", svgArcExpandedSub);
      }
    });
  },
  unexpandArc: function unexpandArc(targetIds) {
    var $$ = this;

    if (!$$.transiting) {
      var newTargetIds = $$.mapToTargetIds(targetIds);
      $$.svg.selectAll($$.selectorTargets(newTargetIds, ".".concat(config_classes.chartArc))).selectAll("path").transition().duration(function (d) {
        return $$.getExpandConfig(d.data.id, "duration");
      }).attr("d", $$.svgArc), $$.svg.selectAll("".concat(config_classes.arc)).style("opacity", "1");
    }
  },

  /**
   * Get expand config value
   * @param {String} id data ID
   * @param {String} key config key: 'duration | rate'
   * @return {Number}
   * @private
   */
  getExpandConfig: function getExpandConfig(id, key) {
    var type,
        $$ = this,
        config = $$.config;
    return $$.isDonutType(id) ? type = "donut" : $$.isGaugeType(id) ? type = "gauge" : $$.isPieType(id) && (type = "pie"), type ? config["".concat(type, "_expand_").concat(key)] : {
      duration: 50,
      rate: .98
    }[key];
  },
  shouldExpand: function shouldExpand(id) {
    var $$ = this,
        config = $$.config;
    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
  },
  shouldShowArcLabel: function shouldShowArcLabel() {
    var $$ = this,
        config = $$.config;
    return ["pie", "donut", "gauge"].some(function (v) {
      return $$.hasType(v) && config["".concat(v, "_label_show")];
    });
  },
  meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
    var $$ = this,
        config = $$.config,
        threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;
    return ratio >= threshold;
  },
  getArcLabelFormat: function getArcLabelFormat() {
    var $$ = this,
        config = $$.config,
        format = config.pie_label_format;
    return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), format;
  },
  getGaugeLabelExtents: function getGaugeLabelExtents() {
    var config = this.config;
    return config.gauge_label_extents;
  },
  getArcTitle: function getArcTitle() {
    var $$ = this,
        type = $$.hasType("donut") && "donut" || $$.hasType("gauge") && "gauge";
    return type ? $$.config["".concat(type, "_title")] : "";
  },
  updateTargetsForArc: function updateTargetsForArc(targets) {
    var $$ = this,
        main = $$.main,
        hasGauge = $$.hasType("gauge"),
        classChartArc = $$.classChartArc.bind($$),
        classArcs = $$.classArcs.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainPieUpdate = main.select(".".concat(config_classes.chartArcs)).selectAll(".".concat(config_classes.chartArc)).data($$.pie(targets)).attr("class", function (d) {
      return classChartArc(d) + classFocus(d.data);
    }),
        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
    mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", hasGauge && !$$.hasMultiTargets() ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
  },
  initArc: function initArc() {
    var $$ = this;
    $$.arcs = $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
  },

  /**
   * Set arc title text
   * @private
   */
  setArcTitle: function setArcTitle() {
    var $$ = this,
        title = $$.getArcTitle(),
        hasGauge = $$.hasType("gauge");

    if (title) {
      var text = $$.arcs.append("text").attr("class", config_classes[hasGauge ? "chartArcsGaugeTitle" : "chartArcsTitle"]).style("text-anchor", "middle");
      hasGauge && text.attr("dy", "-0.3em").style("font-size", "27px"), setTextValue(text, title, hasGauge ? undefined : [-.6, 1.35], !0);
    }
  },
  redrawArc: function redrawArc(duration, durationForExit, withTransform) {
    var $$ = this,
        config = $$.config,
        main = $$.main,
        hasInteraction = config.interaction_enabled,
        mainArc = main.selectAll(".".concat(config_classes.arcs)).selectAll(".".concat(config_classes.arc)).data($$.arcData.bind($$));
    // bind arc events
    mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function (d) {
      return $$.color(d.data);
    }).style("cursor", function (d) {
      return hasInteraction && config.data_selection_isselectable(d) ? "pointer" : null;
    }).style("opacity", "0").each(function (d) {
      $$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
    }).merge(mainArc), $$.hasMultiArcGauge() && $$.redrawMultiArcGauge(), mainArc.attr("transform", function (d) {
      return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
    }).style("opacity", function (d) {
      return d === this._current ? "0" : "1";
    }).each(function () {
      $$.transiting = !0;
    }).transition().duration(duration).attrTween("d", function (d) {
      var updated = $$.updateAngle(d);
      if (!updated) return function () {
        return "M 0 0";
      };
      isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);
      var interpolate = Object(external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_["interpolate"])(this._current, updated);
      return this._current = interpolate(0), function (t) {
        var interpolated = interpolate(t);
        // data.id will be updated by interporator
        return interpolated.data = d.data, $$.getArc(interpolated, !0);
      };
    }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
      var color;
      return $$.levelColor ? (color = $$.levelColor(d.data.values[0].value), config.data_colors[d.data.id] = color) : color = $$.color(d.data.id), color;
    }) // Where gauge reading color would receive customization.
    .style("opacity", "1").call($$.endall, function () {
      if ($$.levelColor) {
        var path = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            d = path.datum();
        $$.updateLegendItemColor(d.data.id, path.style("fill"));
      }

      $$.transiting = !1, callFn(config.onrendered, $$, $$.api);
    }), hasInteraction && $$.bindArcEvent(mainArc), $$.redrawArcText(duration);
  },
  redrawMultiArcGauge: function redrawMultiArcGauge() {
    var $$ = this,
        config = $$.config,
        arcLabelLines = $$.main.selectAll(".".concat(config_classes.arcs)).selectAll(".".concat(config_classes.arcLabelLine)).data($$.arcData.bind($$)),
        mainArcLabelLine = arcLabelLines.enter().append("rect").attr("class", function (d) {
      return "".concat(config_classes.arcLabelLine, " ").concat(config_classes.target, " ").concat(config_classes.target, "-").concat(d.data.id);
    }).merge(arcLabelLines);
    mainArcLabelLine.style("fill", function (d) {
      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data);
    }).style("display", config.gauge_label_show ? "" : "none").each(function (d) {
      var lineLength = 0,
          lineThickness = 2,
          x = 0,
          y = 0,
          transform = "";

      if ($$.hiddenTargetIds.indexOf(d.data.id) < 0) {
        var updated = $$.updateAngle(d),
            innerLineLength = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length * (updated.index + 1),
            lineAngle = updated.endAngle - Math.PI / 2,
            arcInnerRadius = $$.radius - innerLineLength,
            linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);
        lineLength = $$.radiusExpanded - $$.radius + innerLineLength, x = Math.cos(linePositioningAngle) * arcInnerRadius, y = Math.sin(linePositioningAngle) * arcInnerRadius, transform = "rotate(".concat(lineAngle * 180 / Math.PI, ", ").concat(x, ", ").concat(y, ")");
      }

      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr("x", x).attr("y", y).attr("width", lineLength).attr("height", lineThickness).attr("transform", transform).style("stroke-dasharray", "0, ".concat(lineLength + lineThickness, ", 0"));
    });
  },
  bindArcEvent: function bindArcEvent(arc) {
    function selectArc(_this, arcData, id) {
      $$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
    }

    function unselectArc(arcData) {
      var id = arcData && arcData.id || undefined;
      $$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
    }

    var $$ = this,
        isTouch = $$.inputType === "touch",
        isMouse = $$.inputType === "mouse";

    // touch events
    if (arc.on("click", function (d, i) {
      var arcData,
          updated = $$.updateAngle(d);
      updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), $$.config.data_onclick.call($$.api, arcData, this));
    }), isMouse && arc.on("mouseover", function (d) {
      if (!$$.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null,
              id = arcData && arcData.id || undefined;
          selectArc(this, arcData, id), $$.setOverOut(!0, arcData);
        }
    }).on("mouseout", function (d) {
      if (!$$.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null;
          unselectArc(), $$.setOverOut(!1, arcData);
        }
    }).on("mousemove", function (d) {
      var updated = $$.updateAngle(d),
          arcData = updated ? $$.convertToArcData(updated) : null;
      $$.showTooltip([arcData], this);
    }), isTouch && $$.hasArcType() && !$$.radars) {
      var getEventArc = function () {
        var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0],
            eventArc = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
        return eventArc;
      },
          handler = function () {
        if (!$$.transiting) // skip while transiting
          {
            var eventArc = getEventArc(),
                datum = eventArc.datum(),
                updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
                arcData = updated ? $$.convertToArcData(updated) : null,
                id = arcData && arcData.id || undefined;
            $$.callOverOutForTouch(arcData), isUndefined(id) ? unselectArc() : selectArc(this, arcData, id);
          }
      };

      $$.svg.on("touchstart", handler).on("touchmove", handler);
    }
  },
  redrawArcText: function redrawArcText(duration) {
    var text,
        $$ = this,
        config = $$.config,
        main = $$.main,
        hasGauge = $$.hasType("gauge"),
        hasMultiArcGauge = $$.hasMultiArcGauge();

    if (hasGauge && $$.data.targets.length === 1 && config.gauge_title || (text = main.selectAll(".".concat(config_classes.chartArc)).select("text").style("opacity", "0").attr("class", function (d) {
      return $$.isGaugeType(d.data) ? config_classes.gaugeValue : null;
    }).call($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function (d) {
      return $$.isGaugeType(d.data) && $$.data.targets.length === 1 && !hasMultiArcGauge ? "".concat(Math.round($$.radius / 5), "px") : null;
    }).transition().duration(duration).style("opacity", function (d) {
      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
    }), hasMultiArcGauge && text.attr("dy", "-.1em")), main.select(".".concat(config_classes.chartArcsTitle)).style("opacity", $$.hasType("donut") || hasGauge ? "1" : "0"), hasGauge) {
      var isFullCircle = config.gauge_fullCircle,
          startAngle = -1 * Math.PI / 2,
          endAngle = (isFullCircle ? -4 : -1) * startAngle;
      isFullCircle && text && text.attr("dy", "".concat(Math.round($$.radius / 14)));
      var backgroundArc = $$.arcs.select("".concat(hasMultiArcGauge ? "g" : "", ".").concat(config_classes.chartArcsBackground));

      if (hasMultiArcGauge) {
        var index = 0;
        backgroundArc = backgroundArc.selectAll("path.".concat(config_classes.chartArcsBackground)).data($$.data.targets), backgroundArc.enter().append("path").attr("class", function (d, i) {
          return "".concat(config_classes.chartArcsBackground, " ").concat(config_classes.chartArcsBackground, "-").concat(i);
        }).merge(backgroundArc).attr("d", function (d1) {
          if ($$.hiddenTargetIds.indexOf(d1.id) >= 0) return "M 0 0";
          var d = {
            data: [{
              value: config.gauge_max
            }],
            startAngle: startAngle,
            endAngle: endAngle,
            index: index++
          };
          return $$.getArc(d, !0, !0);
        }), backgroundArc.exit().remove();
      } else backgroundArc.attr("d", function () {
        var d = {
          data: [{
            value: config.gauge_max
          }],
          startAngle: startAngle,
          endAngle: endAngle
        };
        return $$.getArc(d, !0, !0);
      });

      $$.arcs.select(".".concat(config_classes.chartArcsGaugeUnit)).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && ($$.arcs.select(".".concat(config_classes.chartArcsGaugeMin)).attr("dx", "".concat(-1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (isFullCircle ? 1 : 2)), "px")).attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !isFullCircle && $$.arcs.select(".".concat(config_classes.chartArcsGaugeMax)).attr("dx", "".concat($$.innerRadius + ($$.radius - $$.innerRadius) / 2, "px")).attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
    }
  },
  initGauge: function initGauge() {
    var $$ = this,
        config = $$.config,
        arcs = $$.arcs,
        appendText = function (className) {
      arcs.append("text").attr("class", className).style("text-anchor", "middle").style("pointer-events", "none");
    };

    $$.hasType("gauge") && (arcs.append($$.hasMultiArcGauge() ? "g" : "path").attr("class", config_classes.chartArcsBackground), config.gauge_units && appendText(config_classes.chartArcsGaugeUnit), config.gauge_label_show && (appendText(config_classes.chartArcsGaugeMin), !config.gauge_fullCircle && appendText(config_classes.chartArcsGaugeMax)));
  },
  getGaugeLabelHeight: function getGaugeLabelHeight() {
    return this.config.gauge_label_show ? 20 : 0;
  }
});
// CONCATENATED MODULE: ./src/shape/bar.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  initBar: function initBar() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartBars);
  },
  updateTargetsForBar: function updateTargetsForBar(targets) {
    var $$ = this,
        config = $$.config,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainBarUpdate = $$.main.select(".".concat(config_classes.chartBars)).selectAll(".".concat(config_classes.chartBar)).data(targets).attr("class", function (d) {
      return classChartBar(d) + classFocus(d);
    }),
        mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");
    // Bars for each data
    mainBarEnter.append("g").attr("class", classBars).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    });
  },
  updateBar: function updateBar(durationForExit) {
    var $$ = this,
        barData = $$.barData.bind($$),
        classBar = $$.classBar.bind($$),
        initialOpacity = $$.initialOpacity.bind($$);
    $$.mainBar = $$.main.selectAll(".".concat(config_classes.bars)).selectAll(".".concat(config_classes.bar)).data(barData), $$.mainBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainBar = $$.mainBar.enter().append("path").attr("class", classBar).style("fill", $$.color).merge($$.mainBar).style("opacity", initialOpacity);
  },
  redrawBar: function redrawBar(drawBar, withTransition) {
    return [(withTransition ? this.mainBar.transition(getRandom()) : this.mainBar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
  },
  getBarW: function getBarW(axis, barTargetsNum) {
    var result,
        $$ = this,
        config = $$.config,
        maxDataCount = $$.getMaxDataCount(),
        isGrouped = $$.isGrouped(),
        tickInterval = ($$.zoomScale || $$) && !$$.isCategorized() ? $$.xx($$.subX.domain()[1]) / maxDataCount : axis.tickInterval(maxDataCount),
        getWidth = function (id) {
      var width = id ? config.bar_width[id] : config.bar_width,
          ratio = id ? width.ratio : config.bar_width_ratio,
          max = id ? width.max : config.bar_width_max,
          w = isNumber(width) ? width : barTargetsNum ? tickInterval * ratio / barTargetsNum : 0;
      return max && w > max ? max : w;
    };

    return result = getWidth(), !isGrouped && isObjectType(config.bar_width) && (result = {
      width: result,
      total: []
    }, $$.filterTargetsToShow($$.data.targets).forEach(function (v) {
      config.bar_width[v.id] && (result[v.id] = getWidth(v.id), result.total.push(result[v.id] || result.width));
    })), result;
  },
  getBars: function getBars(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-".concat(i) : "";
    return (id ? $$.main.selectAll(".".concat(config_classes.bars).concat($$.getTargetSelectorSuffix(id))) : $$.main).selectAll(".".concat(config_classes.bar).concat(suffix));
  },
  expandBars: function expandBars(i, id, reset) {
    var $$ = this;
    reset && $$.unexpandBars(), $$.getBars(i, id).classed(config_classes.EXPANDED, !0);
  },
  unexpandBars: function unexpandBars(i) {
    this.getBars(i).classed(config_classes.EXPANDED, !1);
  },
  generateDrawBar: function generateDrawBar(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        getPoints = $$.generateGetBarPoints(barIndices, isSub),
        isRotated = config.axis_rotated,
        isGrouped = $$.isGrouped(),
        barRadius = config.bar_radius,
        barRadiusRatio = config.bar_radius_ratio,
        getRadius = isNumber(barRadius) && barRadius > 0 ? function () {
      return barRadius;
    } : isNumber(barRadiusRatio) ? function (w) {
      return w * barRadiusRatio;
    } : null;
    return function (d, i) {
      // 4 points that make a bar
      var points = getPoints(d, i),
          indexX = +isRotated,
          indexY = +!indexX,
          isNegative = d.value < 0,
          pathRadius = ["", ""],
          radius = 0; // switch points if axis is rotated, not applicable for sub chart

      if (getRadius && !isGrouped) {
        var index = isRotated ? indexY : indexX,
            barW = points[2][index] - points[0][index];
        radius = getRadius(barW);
        var arc = "a".concat(radius, ",").concat(radius, " ").concat(isNegative ? "1 0 0" : "0 0 1", " ");
        pathRadius[+!isRotated] = "".concat(arc).concat(radius, ",").concat(radius), pathRadius[+isRotated] = "".concat(arc).concat([-radius, radius][isRotated ? "sort" : "reverse"]()), isNegative && pathRadius.reverse();
      } // path string data shouldn't be containing new line chars
      // https://github.com/naver/billboard.js/issues/530


      var path = isRotated ? "H".concat(points[1][indexX] - radius, " ").concat(pathRadius[0], "V").concat(points[2][indexY] - radius, " ").concat(pathRadius[1], "H").concat(points[3][indexX]) : "V".concat(points[1][indexY] + (isNegative ? -radius : radius), " ").concat(pathRadius[0], "H").concat(points[2][indexX] - radius, " ").concat(pathRadius[1], "V").concat(points[3][indexY]);
      return "M".concat(points[0][indexX], ",").concat(points[0][indexY]).concat(path, "z");
    };
  },
  generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
    var $$ = this,
        axis = isSub ? $$.subXAxis : $$.xAxis,
        barTargetsNum = $$.getIndicesMax(barIndices) + 1,
        barW = $$.getBarW(axis, barTargetsNum),
        barX = $$.getShapeX(barW, barIndices, !!isSub),
        barY = $$.getShapeY(!!isSub),
        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = barOffset(d, i) || y0,
          width = isNumber(barW) ? barW : barW[d.id] || barW.width,
          posX = barX(d),
          posY = barY(d);
      // 4 points that make a bar
      return $$.config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), posY -= y0 - offset, [[posX, offset], [posX, posY], [posX + width, posY], [posX + width, offset]];
    };
  },
  isWithinBar: function isWithinBar(that) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that),
        list = getRectSegList(that),
        _list2 = _slicedToArray(list, 2),
        seg0 = _list2[0],
        seg1 = _list2[1],
        x = Math.min(seg0.x, seg1.x),
        y = Math.min(seg0.y, seg1.y),
        offset = this.config.bar_sensitivity,
        _that$getBBox = that.getBBox(),
        width = _that$getBBox.width,
        height = _that$getBBox.height;

    return x - offset < mouse[0] && mouse[0] < x + width + offset && y - offset < mouse[1] && mouse[1] < y + height + offset;
  }
});
// CONCATENATED MODULE: ./src/shape/bubble.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializer
   * @private
   */
  initBubble: function initBubble() {
    var $$ = this,
        config = $$.config;
    $$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
  },

  /**
   * Get user agent's computed value for the total length of the path in user units
   * https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
   * @return {Number}
   * @private
   */
  getBaseLength: function getBaseLength() {
    var $$ = this,
        cacheKey = "$baseLength",
        baseLength = $$.getCache(cacheKey);
    return baseLength || $$.addCache(cacheKey, baseLength = getMinMax("min", [$$.axes.x.select("path").node().getTotalLength(), $$.axes.y.select("path").node().getTotalLength()])), baseLength;
  },

  /**
   * Get the radius value for bubble circle
   * @param {Object} d
   * @return {Number}
   * @private
  	 */
  getBubbleR: function getBubbleR(d) {
    var $$ = this,
        maxR = $$.config.bubble_maxR;
    isFunction(maxR) ? maxR = maxR(d) : !isNumber(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);
    var max = getMinMax("max", $$.getMinMaxData().max.map(function (d) {
      return $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : isObject(d.value) ? d.value.mid : d.value;
    })),
        maxArea = maxR * maxR * Math.PI,
        area = ($$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value) * (maxArea / max);
    return Math.sqrt(area / Math.PI);
  },

  /**
   * Get bubble dimension data
   * @param {Object|Array} d data value
   * @param {String} type - y or z
   * @return {Number}
   * @private
   */
  getBubbleZData: function getBubbleZData(d, type) {
    return isObject(d) ? d[type] : d[type === "y" ? 0 : 1];
  },

  /**
   * Determine if bubble has dimension data
   * @param {Object|array} d data value
   * @return {Boolean}
   * @private
   */
  isBubbleZType: function isBubbleZType(d) {
    var $$ = this;
    return $$.isBubbleType(d) && (isObject(d.value) && ("z" in d.value || "y" in d.value) || isArray(d.value) && d.value.length === 2);
  }
});
// CONCATENATED MODULE: ./src/shape/line.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  initLine: function initLine() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartLines);
  },
  updateTargetsForLine: function updateTargetsForLine(targets) {
    var $$ = this,
        config = $$.config,
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$),
        classCircles = $$.classCircles.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainLineUpdate = $$.main.select(".".concat(config_classes.chartLines)).selectAll(".".concat(config_classes.chartLine)).data(targets).attr("class", function (d) {
      return classChartLine(d) + classFocus(d);
    }),
        mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");
    // Lines for each data
    // Areas
    // Update date for selected circles
    mainLineEnter.append("g").attr("class", classLines), mainLineEnter.append("g").attr("class", classAreas), config.point_show && (config.data_selection_enabled && mainLineEnter.append("g").attr("class", function (d) {
      return $$.generateClass(config_classes.selectedCircles, d.id);
    }), mainLineEnter.append("g").attr("class", classCircles).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    })), targets.forEach(function (t) {
      $$.main.selectAll(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(t.id))).selectAll("".concat(config_classes.selectedCircle)).each(function (d) {
        d.value = t.values[d.index].value;
      });
    });
  },
  updateLine: function updateLine(durationForExit) {
    var $$ = this;
    $$.mainLine = $$.main.selectAll(".".concat(config_classes.lines)).selectAll(".".concat(config_classes.line)).data($$.lineData.bind($$)), $$.mainLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainLine = $$.mainLine.enter().append("path").attr("class", function (d) {
      return "".concat($$.classLine.bind($$)(d), " ").concat($$.extraLineClasses(d) || "");
    }).style("stroke", $$.color).merge($$.mainLine).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function (d) {
      return $$.isStepType(d) ? "crispEdges" : "";
    }).attr("transform", null);
  },
  redrawLine: function redrawLine(drawLine, withTransition) {
    return [(withTransition ? this.mainLine.transition(getRandom()) : this.mainLine).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
  },

  /**
   * Get the curve interpolate
   * @param {Array} d Data object
   * @return {Function}
   * @private
   */
  getCurve: function getCurve(d) {
    var $$ = this,
        isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);
    // when is step & rotated, should be computed in different way
    // https://github.com/naver/billboard.js/issues/471
    return isRotatedStepType ? function (context) {
      var step = $$.getInterpolate(d)(context); // keep the original method

      return step.orgPoint = step.point, step.pointRotated = function (x, y) {
        this._point === 1 && (this._point = 2);
        var y1 = this._y * (1 - this._t) + y * this._t;
        this._context.lineTo(this._x, y1), this._context.lineTo(x, y1), this._x = x, this._y = y;
      }, step.point = function (x, y) {
        this._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);
      }, step;
    } : $$.getInterpolate(d);
  },
  generateDrawLine: function generateDrawLine(lineIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetLinePoints(lineIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        yValue = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getBaseValue(d));
    },
        line = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["line"])();

    line = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
      return $$.getBaseValue(d) !== null;
    }));
    var x = isSub ? $$.subX : $$.x;
    return function (d) {
      var path,
          y = yScaleGetter.call($$, d.id),
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isLineType(d)) {
        var regions = config.data_regions[d.id];
        regions ? path = $$.lineWithRegions(values, x, y, regions) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getCurve(d))(values));
      } else values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = isRotated ? "M ".concat(y0, " ").concat(x0) : "M ".concat(x0, " ").concat(y0);

      return path || "M 0 0";
    };
  },
  generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        isSub = !!isSubValue,
        x = $$.getShapeX(0, lineIndices, isSub),
        y = $$.getShapeY(isSub),
        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = lineOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);
      // 1 point that marks the line position
      var point = [posX, posY - (y0 - offset)];
      return [point, point, // from here and below, needed for compatibility
      point, point];
    };
  },
  lineWithRegions: function lineWithRegions(d, x, y, _regions) {
    var xp,
        yp,
        diff,
        diffx2,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isTimeSeries = $$.isTimeSeries(),
        xOffset = $$.isCategorized() ? .5 : 0,
        regions = [],
        dasharray = "2 2",
        isWithinRegions = function (withinX, withinRegions) {
      for (var reg, i = 0; reg = withinRegions[i]; i++) if (reg.start < withinX && withinX <= reg.end) return reg.style;

      return !1;
    };

    // Check start/end of regions
    if (isDefined(_regions)) {
      var getValue = function (v, def) {
        return isUndefined(v) ? def : isTimeSeries ? $$.parseDate(v) : v;
      };

      for (var reg, i = 0; reg = _regions[i]; i++) {
        var start = getValue(reg.start, d[0].x),
            end = getValue(reg.end, d[d.length - 1].x),
            style = reg.style || {
          dasharray: dasharray
        };
        regions[i] = {
          start: start,
          end: end,
          style: style
        };
      }
    } // Set scales


    var xValue = isRotated ? function (dt) {
      return y(dt.value);
    } : function (dt) {
      return x(dt.x);
    },
        yValue = isRotated ? function (dt) {
      return x(dt.x);
    } : function (dt) {
      return y(dt.value);
    },
        generateM = function (points) {
      return "M".concat(points[0][0], ",").concat(points[0][1], "L").concat(points[1][0], ",").concat(points[1][1]);
    },
        sWithRegion = isTimeSeries ? function (d0, d1, k, timeseriesDiff) {
      var x0 = d0.x.getTime(),
          xDiff = d1.x - d0.x,
          xv0 = new Date(x0 + xDiff * k),
          xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
          points = isRotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];
      return generateM(points);
    } : function (d0, d1, k, otherDiff) {
      var points = isRotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]];
      return generateM(points);
    },
        path = "";

    for (var data, _i = 0; data = d[_i]; _i++) {
      var prevData = d[_i - 1],
          hasPrevData = prevData && isValue(prevData.value),
          style = isWithinRegions(data.x, regions);
      // https://github.com/naver/billboard.js/issues/1172
      if (isValue(data.value)) // Draw as normal
        if (isUndefined(regions) || !style || !hasPrevData) path += "".concat(_i && hasPrevData ? "L" : "M").concat(xValue(data), ",").concat(yValue(data));else if (hasPrevData) {
          try {
            style = style.dasharray.split(" ");
          } catch (e) {
            style = dasharray.split(" ");
          } // Draw with region // TODO: Fix for horizotal charts


          xp = $$.getScale(prevData.x + xOffset, data.x + xOffset, isTimeSeries), yp = $$.getScale(prevData.value, data.value);
          var dx = x(data.x) - x(prevData.x),
              dy = y(data.value) - y(prevData.value),
              dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          diff = style[0] / dd, diffx2 = diff * style[1];

          for (var _j = diff; _j <= 1; _j += diffx2) path += sWithRegion(prevData, data, _j, diff), _j + diffx2 >= 1 && (path += sWithRegion(prevData, data, 1, 0));
        }
    }

    return path;
  },
  updateAreaGradient: function updateAreaGradient() {
    var $$ = this;
    $$.data.targets.forEach(function (d) {
      var id = "".concat($$.datetimeId, "-areaGradient").concat($$.getTargetSelectorSuffix(d.id));

      if ($$.isAreaType(d) && $$.defs.select("#".concat(id)).empty()) {
        var color = $$.color(d),
            _$$$config$area_linea = $$.config.area_linearGradient,
            _$$$config$area_linea2 = _$$$config$area_linea.x,
            x = _$$$config$area_linea2 === void 0 ? [0, 0] : _$$$config$area_linea2,
            _$$$config$area_linea3 = _$$$config$area_linea.y,
            y = _$$$config$area_linea3 === void 0 ? [0, 1] : _$$$config$area_linea3,
            _$$$config$area_linea4 = _$$$config$area_linea.stops,
            stops = _$$$config$area_linea4 === void 0 ? [[0, color, 1], [1, color, 0]] : _$$$config$area_linea4,
            linearGradient = $$.defs.append("linearGradient").attr("id", "".concat(id)).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
        stops.forEach(function (v) {
          var stopColor = isFunction(v[1]) ? v[1](d.id) : v[1];
          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
        });
      }
    });
  },
  updateAreaColor: function updateAreaColor(d) {
    var $$ = this;
    return $$.config.area_linearGradient ? "url(#".concat($$.datetimeId, "-areaGradient").concat($$.getTargetSelectorSuffix(d.id), ")") : $$.color(d);
  },
  updateArea: function updateArea(durationForExit) {
    var $$ = this;
    $$.config.area_linearGradient && $$.updateAreaGradient(), $$.mainArea = $$.main.selectAll(".".concat(config_classes.areas)).selectAll(".".concat(config_classes.area)).data($$.lineData.bind($$)), $$.mainArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainArea = $$.mainArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
      return $$.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($$.mainArea), $$.mainArea.style("opacity", $$.orgAreaOpacity);
  },
  redrawArea: function redrawArea(drawArea, withTransition) {
    var $$ = this;
    return [(withTransition ? $$.mainArea.transition(getRandom()) : $$.mainArea).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
      return ($$.isAreaRangeType(d) ? $$.orgAreaOpacity / 1.75 : $$.orgAreaOpacity) + "";
    })];
  },

  /**
   * Generate area path data
   * @param areaIndices
   * @param isSub
   * @return {function(*=): (*|string)}
   * @private
   */
  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        value0 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : $$.getShapeYMin(d.id));
    },
        value1 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
    };

    return function (d) {
      var path,
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isAreaType(d)) {
        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue).y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
          return $$.getBaseValue(d) !== null;
        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
      } else values[0] && (x0 = $$.x(values[0].x), y0 = $$.getYScale(d.id)(values[0].value)), path = isRotated ? "M ".concat(y0, " ").concat(x0) : "M ".concat(x0, " ").concat(y0);

      return path || "M 0 0";
    };
  },
  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        x = $$.getShapeX(0, areaIndices, !!isSub),
        y = $$.getShapeY(!!isSub),
        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = areaOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      // 1 point that marks the area position
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
      [posX, offset] // needed for compatibility
      ];
    };
  },
  updateCircle: function updateCircle() {
    var $$ = this;

    if ($$.config.point_show) {
      $$.mainCircle = $$.main.selectAll(".".concat(config_classes.circles)).selectAll(".".concat(config_classes.circle)).data(function (d) {
        return !$$.isBarType(d) && (!$$.isLineType(d) || $$.shouldDrawPointsForLine(d)) && $$.labelishData(d);
      }), $$.mainCircle.exit().remove();
      var fn = $$.point("create", this, $$.pointR.bind($$), $$.color);
      $$.mainCircle = $$.mainCircle.enter().append(fn).merge($$.mainCircle).style("stroke", $$.color).style("opacity", $$.initialOpacityForCircle.bind($$));
    }
  },
  redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
    var $$ = this,
        selectedCircles = $$.main.selectAll(".".concat(config_classes.selectedCircle));
    if (!$$.config.point_show) return [];
    var mainCircles = [];
    $$.mainCircle.each(function (d) {
      var fn = $$.point("update", $$, cx, cy, $$.opacityForCircle.bind($$), $$.color, withTransition, flow, selectedCircles).bind(this),
          result = fn(d);
      mainCircles.push(result);
    });
    var posAttr = $$.isCirclePoint() ? "c" : "";
    return [mainCircles, selectedCircles.attr("".concat(posAttr, "x"), cx).attr("".concat(posAttr, "y"), cy)];
  },
  circleX: function circleX(d) {
    var $$ = this,
        hasValue = isValue(d.x);
    return $$.config.zoom_enabled && $$.zoomScale ? hasValue ? $$.zoomScale(d.x) : null : hasValue ? $$.x(d.x) : null;
  },
  updateCircleY: function updateCircleY() {
    var $$ = this,
        getPoints = $$.generateGetLinePoints($$.getShapeIndices($$.isLineType), !1);

    $$.circleY = function (d, i) {
      var id = d.id;
      return $$.isGrouped(id) ? getPoints(d, i)[0][1] : $$.getYScale(id)($$.getBaseValue(d));
    };
  },
  getCircles: function getCircles(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-".concat(i) : "";
    return (id ? $$.main.selectAll(".".concat(config_classes.circles).concat($$.getTargetSelectorSuffix(id))) : $$.main).selectAll(".".concat(config_classes.circle).concat(suffix));
  },
  expandCircles: function expandCircles(i, id, reset) {
    var $$ = this,
        r = $$.pointExpandedR.bind($$);
    reset && $$.unexpandCircles();
    var circles = $$.getCircles(i, id).classed(config_classes.EXPANDED, !0),
        scale = r(circles) / $$.config.point_r,
        ratio = 1 - scale;
    $$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
      var point = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      if (this.tagName === "circle") point.attr("r", r);else {
        var _this$getBBox = this.getBBox(),
            width = _this$getBBox.width,
            height = _this$getBBox.height,
            x = ratio * (+point.attr("x") + width / 2),
            y = ratio * (+point.attr("y") + height / 2);

        point.attr("transform", "translate(".concat(x, " ").concat(y, ") scale(").concat(scale, ")"));
      }
    });
  },
  unexpandCircles: function unexpandCircles(i) {
    var $$ = this,
        r = $$.pointR.bind($$),
        circles = $$.getCircles(i).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED);
    }).classed(config_classes.EXPANDED, !1);
    circles.attr("r", r), $$.isCirclePoint() || circles.attr("transform", "scale(".concat(r(circles) / $$.config.point_r, ")"));
  },
  pointR: function (d) {
    var $$ = this,
        config = $$.config,
        pointR = config.point_r,
        r = pointR;
    return $$.isStepType(d) ? r = 0 : $$.isBubbleType(d) ? r = $$.getBubbleR(d) : isFunction(pointR) && (r = pointR(d)), r;
  },
  pointExpandedR: function pointExpandedR(d) {
    var $$ = this,
        config = $$.config,
        scale = $$.isBubbleType(d) ? 1.15 : 1.75;
    return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
  },
  pointSelectR: function pointSelectR(d) {
    var $$ = this,
        selectR = $$.config.point_select_r;
    return isFunction(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
  },
  isWithinCircle: function isWithinCircle(node, r) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(node),
        element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(node),
        prefix = this.isCirclePoint() ? "c" : "",
        cx = +element.attr("".concat(prefix, "x")),
        cy = +element.attr("".concat(prefix, "y"));

    // if node don't have cx/y or x/y attribute value
    if (!(cx || cy) && node.nodeType === 1) {
      var _ref = node.getBBox ? node.getBBox() : node.getBoundingClientRect(),
          x = _ref.x,
          y = _ref.y;

      cx = x, cy = y;
    }

    return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < (r || this.config.point_sensitivity);
  },
  isWithinStep: function isWithinStep(that, y) {
    return Math.abs(y - Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that)[1]) < 30;
  },
  shouldDrawPointsForLine: function shouldDrawPointsForLine(d) {
    var linePoint = this.config.line_point;
    return linePoint === !0 || isArray(linePoint) && linePoint.indexOf(d.id) !== -1;
  }
});
// CONCATENATED MODULE: ./src/shape/point.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  hasValidPointType: function hasValidPointType(type) {
    return /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);
  },
  hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
    var pointType = type || this.config.point_type;
    return isObjectType(pointType) && isFunction(pointType.create) && isFunction(pointType.update);
  },
  insertPointInfoDefs: function insertPointInfoDefs(point, id) {
    var $$ = this,
        copyAttr = function (from, target) {
      for (var name, attribs = from.attributes, i = 0; name = attribs[i]; i++) name = name.name, target.setAttribute(name, from.getAttribute(name));
    },
        doc = new DOMParser().parseFromString(point, "image/svg+xml"),
        node = doc.documentElement,
        clone = browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, node.nodeName.toLowerCase());

    if (clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "inherit", copyAttr(node, clone), node.childNodes && node.childNodes.length) {
      var parent = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(clone);
      "innerHTML" in clone ? parent.html(node.innerHTML) : toArray(node.childNodes).forEach(function (v) {
        copyAttr(v, parent.append(v.tagName).node());
      });
    }

    $$.defs.node().appendChild(clone);
  },
  pointFromDefs: function pointFromDefs(id) {
    return this.defs.select("#".concat(id));
  },
  updatePointClass: function updatePointClass(d) {
    var $$ = this,
        pointClass = !1;
    return (isObject(d) || $$.mainCircle) && (pointClass = d === !0 ? $$.mainCircle.each(function (d) {
      var className = $$.classCircle.bind($$)(d);
      this.getAttribute("class").indexOf(config_classes.EXPANDED) > -1 && (className += " ".concat(config_classes.EXPANDED)), this.setAttribute("class", className);
    }) : $$.classCircle(d)), pointClass;
  },
  generatePoint: function generatePoint() {
    var $$ = this,
        config = $$.config,
        ids = [],
        pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
    return function (method, context) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

      return function (d) {
        var id = d.id || d.data && d.data.id || d,
            element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
        ids.indexOf(id) < 0 && ids.push(id);
        var point = pattern[ids.indexOf(id) % pattern.length];
        if ($$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
          var pointId = "".concat($$.datetimeId, "-point-").concat(id),
              pointFromDefs = $$.pointFromDefs(pointId);
          if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(void 0, [element, pointId].concat(args));
          if (method === "update") return $$.custom.update.bind(context).apply(void 0, [element].concat(args));
        }
        return point[method].bind(context).apply(void 0, [element].concat(args));
      };
    };
  },
  getTransitionName: function getTransitionName() {
    return getRandom();
  },
  custom: {
    create: function create(element, id, sizeFn, fillStyleFn) {
      return element.append("use").attr("xlink:href", "#".concat(id)).attr("class", this.updatePointClass.bind(this)).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          _element$node$getBBox = element.node().getBBox(),
          width = _element$node$getBBox.width,
          height = _element$node$getBBox.height,
          xPosFn2 = function (d) {
        return xPosFn(d) - width / 2;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("x", xPosFn2), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("x", xPosFn2).attr("y", function yPosFn2(d) {
        return yPosFn(d) - height / 2;
      }).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'circle' data point
  circle: {
    create: function create(element, sizeFn, fillStyleFn) {
      return element.append("circle").attr("class", this.updatePointClass.bind(this)).attr("r", sizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          mainCircles = element;

      if ($$.hasType("bubble") && mainCircles.attr("r", $$.pointR.bind($$)), withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("cx", xPosFn), mainCircles.attr("cx") && (mainCircles = mainCircles.transition(transitionName)), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("cx", xPosFn).attr("cy", yPosFn).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'rectangle' data point
  rectangle: {
    create: function create(element, sizeFn, fillStyleFn) {
      var rectSizeFn = function (d) {
        return sizeFn(d) * 2;
      };

      return element.append("rect").attr("class", this.updatePointClass.bind(this)).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          r = $$.config.point_r,
          rectXPosFn = function (d) {
        return xPosFn(d) - r;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("x", rectXPosFn), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("x", rectXPosFn).attr("y", function rectYPosFn(d) {
        return yPosFn(d) - r;
      }).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  }
});
// CONCATENATED MODULE: ./src/shape/radar.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Get the position value
 * @param {Boolean} isClockwise If the direction is clockwise
 * @param {String} type Coordinate type 'x' or 'y'
 * @param {Number} edge Number of edge
 * @param {Number} pos The indexed position
 * @param {Number} range
 * @param {Number} ratio
 * @return {number}
 * @private
 */

function getPosition(isClockwise, type, edge, pos, range, ratio) {
  var index = isClockwise && pos > 0 ? edge - pos : pos,
      r = 2 * Math.PI,
      func = type === "x" ? Math.sin : Math.cos;
  return range * (1 - ratio * func(index * r / edge));
} // cache key


var radar_cacheKey = "$radarPoints";
extend(ChartInternal_ChartInternal.prototype, {
  initRadar: function initRadar() {
    var $$ = this,
        config = $$.config;
    $$.hasType("radar") && ($$.radars = $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartRadars), $$.radars.levels = $$.radars.append("g").attr("class", config_classes.levels), $$.radars.axes = $$.radars.append("g").attr("class", config_classes.axis), $$.radars.shapes = $$.radars.append("g").attr("class", config_classes.shapes), $$.maxValue = config.radar_axis_max || $$.getMinMaxData().max[0].value);
  },
  getRadarSize: function getRadarSize() {
    var $$ = this,
        config = $$.config,
        padding = config.axis_x_categories.length < 4 ? -20 : 10,
        size = (Math.min($$.arcWidth, $$.arcHeight) - padding) / 2;
    return [size, size];
  },
  updateTargetsForRadar: function updateTargetsForRadar(targets) {
    var $$ = this,
        config = $$.config;
    isEmpty(config.axis_x_categories) && (config.axis_x_categories = getRange(0, getMinMax("max", targets.map(function (v) {
      return v.values.length;
    })))), $$.generateRadarPoints();
  },
  getRadarPosition: function getRadarPosition(type, index, range, ratio) {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize = $$.getRadarSize(),
        _$$$getRadarSize2 = _slicedToArray(_$$$getRadarSize, 2),
        width = _$$$getRadarSize2[0],
        height = _$$$getRadarSize2[1],
        edge = config.axis_x_categories.length,
        isClockwise = config.radar_direction_clockwise,
        pos = toArray(type).map(function (v) {
      return getPosition(isClockwise, v, edge, index, isDefined(range) ? range : type === "x" ? width : height, isNumber(ratio) ? ratio : config.radar_size_ratio);
    });

    return pos.length === 1 ? pos[0] : pos;
  },

  /**
   * Generate data points
   * @private
   */
  generateRadarPoints: function generateRadarPoints() {
    var $$ = this,
        targets = $$.data.targets,
        _$$$getRadarSize3 = $$.getRadarSize(),
        _$$$getRadarSize4 = _slicedToArray(_$$$getRadarSize3, 2),
        width = _$$$getRadarSize4[0],
        height = _$$$getRadarSize4[1],
        points = $$.getCache(radar_cacheKey) || {},
        size = points._size;

    size && (size.width === width || size.height === height) || (targets.forEach(function (d) {
      points[d.id] = d.values.map(function (v, i) {
        return $$.getRadarPosition(["x", "y"], i, undefined, $$.getRatio("radar", v));
      });
    }), points._size = {
      width: width,
      height: height
    }, $$.addCache(radar_cacheKey, points));
  },
  redrawRadar: function redrawRadar(durationForExit) {
    var $$ = this,
        translate = $$.getTranslate("radar");
    translate && ($$.radars.attr("transform", translate), $$.main.selectAll(".".concat(config_classes.circles)).attr("transform", translate), $$.main.select(".".concat(config_classes.chartTexts)).attr("transform", translate), $$.generateRadarPoints(), $$.updateRadarLevel(), $$.updateRadarAxes(), $$.updateRadarShape(durationForExit));
  },
  generateGetRadarPoints: function generateGetRadarPoints() {
    var $$ = this,
        points = $$.getCache(radar_cacheKey);
    return function (d, i) {
      var point = points[d.id][i];
      return [point, point, point, point];
    };
  },
  updateRadarLevel: function updateRadarLevel() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize5 = $$.getRadarSize(),
        _$$$getRadarSize6 = _slicedToArray(_$$$getRadarSize5, 2),
        width = _$$$getRadarSize6[0],
        height = _$$$getRadarSize6[1],
        depth = config.radar_level_depth,
        edge = config.axis_x_categories.length,
        showText = config.radar_level_text_show,
        radarLevels = $$.radars.levels,
        levelData = getRange(0, depth),
        radius = config.radar_size_ratio * Math.min(width, height),
        levelRatio = levelData.map(function (l) {
      return radius * ((l + 1) / depth);
    }),
        levelTextFormat = config.radar_level_text_format,
        points = levelData.map(function (v) {
      var range = levelRatio[v],
          pos = getRange(0, edge).map(function (i) {
        return $$.getRadarPosition(["x", "y"], i, range, 1).join(",");
      });
      return pos.join(" ");
    }),
        level = radarLevels.selectAll(".".concat(config_classes.level)).data(levelData);

    level.exit().remove();
    var levelEnter = level.enter().append("g").attr("class", function (d, i) {
      return "".concat(config_classes.level, " ").concat(config_classes.level, "-").concat(i);
    });
    levelEnter.append("polygon").style("visibility", config.radar_level_show ? null : "hidden"), showText && (radarLevels.select("text").empty() && radarLevels.append("text").attr("dx", "-.5em").attr("dy", "-.7em").style("text-anchor", "end").text(function () {
      return levelTextFormat(0);
    }), levelEnter.append("text").attr("dx", "-.5em").style("text-anchor", "end").text(function (d) {
      return levelTextFormat($$.maxValue / levelData.length * (d + 1));
    })), levelEnter.merge(level).attr("transform", function (d) {
      return "translate(".concat(width - levelRatio[d], ", ").concat(height - levelRatio[d], ")");
    }).selectAll("polygon").attr("points", function (d) {
      return points[d];
    }), showText && radarLevels.selectAll("text").attr("x", function (d) {
      return isUndefined(d) ? width : points[d].split(",")[0];
    }).attr("y", function (d) {
      return isUndefined(d) ? height : 0;
    });
  },
  updateRadarAxes: function updateRadarAxes() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize7 = $$.getRadarSize(),
        _$$$getRadarSize8 = _slicedToArray(_$$$getRadarSize7, 2),
        width = _$$$getRadarSize8[0],
        height = _$$$getRadarSize8[1],
        categories = config.axis_x_categories,
        axis = $$.radars.axes.selectAll("g").data(categories);

    axis.exit().remove();
    var axisEnter = axis.enter().append("g").attr("class", function (d, i) {
      return "".concat(config_classes.axis, "-").concat(i);
    });

    // axis text
    if (config.radar_axis_line_show && axisEnter.append("line"), config.radar_axis_text_show && axisEnter.append("text"), axis = axisEnter.merge(axis), config.radar_axis_line_show && axis.select("line").attr("x1", width).attr("y1", height).attr("x2", function (d, i) {
      return $$.getRadarPosition("x", i);
    }).attr("y2", function (d, i) {
      return $$.getRadarPosition("y", i);
    }), config.radar_axis_text_show) {
      var _config$radar_axis_te = config.radar_axis_text_position,
          _config$radar_axis_te2 = _config$radar_axis_te.x,
          x = _config$radar_axis_te2 === void 0 ? 0 : _config$radar_axis_te2,
          _config$radar_axis_te3 = _config$radar_axis_te.y,
          y = _config$radar_axis_te3 === void 0 ? 0 : _config$radar_axis_te3;
      axis.select("text").style("text-anchor", "middle").attr("dy", ".5em").call(function (selection) {
        selection.each(function (d) {
          setTextValue(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this), d + "", [-.6, 1.2]);
        });
      }).datum(function (d, i) {
        return {
          index: i
        };
      }).attr("transform", function (d) {
        isUndefined(this.width) && (this.width = this.getBoundingClientRect().width / 2);
        var posX = $$.getRadarPosition("x", d.index, undefined, 1),
            posY = Math.round($$.getRadarPosition("y", d.index, undefined, 1));
        return posX > width ? posX += this.width + x : Math.round(posX) < width && (posX -= this.width + x), posY > height ? (posY / 2 === height && this.firstChild.tagName === "tspan" && this.firstChild.setAttribute("dy", "0em"), posY += y) : posY < height && (posY -= y), "translate(".concat(posX, " ").concat(posY, ")");
      });
    }

    $$.bindEvent();
  },
  bindEvent: function bindEvent() {
    var _this = this,
        $$ = this,
        config = $$.config;

    if (config.interaction_enabled) {
      var isMouse = $$.inputType === "mouse",
          getIndex = function () {
        var target = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].target; // in case of multilined axis text

        /tspan/i.test(target.tagName) && (target = target.parentNode);
        var d = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum();
        return d && Object.keys(d).length === 1 ? d.index : undefined;
      },
          hide = function () {
        var index = getIndex(),
            noIndex = isUndefined(index);
        (isMouse || noIndex) && (_this.hideTooltip(), _this.unexpandCircles(), isMouse ? $$.setOverOut(!1, index) : noIndex && $$.callOverOutForTouch());
      };

      $$.radars.select(".".concat(config_classes.axis)).on(isMouse ? "mouseover " : "touchstart", function () {
        if (!$$.transiting) // skip while transiting
          {
            var index = getIndex();
            $$.selectRectForSingle($$.svg.node(), null, index), isMouse ? $$.setOverOut(!0, index) : $$.callOverOutForTouch(index);
          }
      }).on("mouseout", isMouse ? hide : null), isMouse || $$.svg.on("touchstart", hide);
    }
  },
  updateRadarShape: function updateRadarShape(durationForExit) {
    var $$ = this,
        targets = $$.data.targets,
        points = $$.getCache(radar_cacheKey),
        areas = $$.radars.shapes.selectAll("polygon").data(targets),
        areasEnter = areas.enter().append("g").attr("class", $$.classChartRadar.bind($$));
    areas.exit().transition().duration(durationForExit).remove(), areasEnter.append("polygon").merge(areas).style("fill", $$.color).style("stroke", $$.color).attr("points", function (d) {
      return points[d.id].join(" ");
    });
  },

  /**
   * Get data point x coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleX: function radarCircleX(d) {
    return this.getCache(radar_cacheKey)[d.id][d.index][0];
  },

  /**
   * Get data point y coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleY: function radarCircleY(d) {
    return this.getCache(radar_cacheKey)[d.id][d.index][1];
  }
});
// CONCATENATED MODULE: ./src/internals/text.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the text
   * @private
   */
  initText: function initText() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartTexts), $$.mainText = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);
  },

  /**
   * Update chartText
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForText: function updateTargetsForText(targets) {
    var $$ = this,
        classChartText = $$.classChartText.bind($$),
        classTexts = $$.classTexts.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainTextUpdate = $$.main.select(".".concat(config_classes.chartTexts)).selectAll(".".concat(config_classes.chartText)).data(targets).attr("class", function (d) {
      return classChartText(d) + classFocus(d);
    }),
        mainTextEnter = mainTextUpdate.enter().append("g").attr("class", classChartText).style("opacity", "0").style("pointer-events", "none");
    mainTextEnter.append("g").attr("class", classTexts);
  },

  /**
   * Update text
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateText: function updateText(durationForExit) {
    var _this = this,
        $$ = this,
        config = $$.config,
        dataFn = $$.labelishData.bind($$),
        classText = $$.classText.bind($$);

    $$.mainText = $$.main.selectAll(".".concat(config_classes.texts)).selectAll(".".concat(config_classes.text)).data(function (d) {
      return _this.isRadarType(d) ? d.values : dataFn(d);
    }), $$.mainText.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $$.mainText = $$.mainText.enter().append("text").merge($$.mainText).attr("class", classText).attr("text-anchor", function (d) {
      return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
    }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", "0").text(function (d, i, j) {
      var value = $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value;
      return $$.dataLabelFormat(d.id)(value, d.id, i, j);
    });
  },
  updateTextColor: function updateTextColor(d) {
    var color,
        $$ = this,
        labelColors = $$.config.data_labels_colors;
    return isString(labelColors) ? color = labelColors : isObject(labelColors) && (color = labelColors[d.id]), color || $$.color(d);
  },

  /**
   * Redraw chartText
   * @param {Function} x Positioning function for x
   * @param {Function} y Positioning function for y
   * @param {Boolean} forFlow
   * @param {Boolean} withTransition transition is enabled
   * @private
   */
  redrawText: function redrawText(x, y, forFlow, withTransition) {
    var $$ = this,
        t = getRandom(),
        opacityForText = forFlow ? 0 : $$.opacityForText.bind($$);
    // need to return 'true' as of being pushed to the redraw list
    // ref: getRedrawList()
    return $$.mainText.each(function (d, i) {
      var text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this); // do not apply transition for newly added text elements

      (withTransition && text.attr("x") ? text.transition(t) : text).attr("x", x.bind(this)(d, i)).attr("y", y.bind(this)(d, i)).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", opacityForText);
    }), !0;
  },

  /**
   * Gets the getBoundingClientRect value of the element
   * @private
   * @param {HTMLElement|d3.selection} element
   * @param {String} className
   * @returns {Object} value of element.getBoundingClientRect()
   */
  getTextRect: function getTextRect(element, className) {
    var $$ = this,
        base = element.node ? element.node() : element;
    /text/i.test(base.tagName) || (base = base.querySelector("text"));
    var text = base.textContent,
        cacheKey = "$".concat(text.replace(/\W/g, "_")),
        rect = $$.getCache(cacheKey);
    return rect || ($$.svg.append("text").style("visibility", "hidden").style("font", Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(base).style("font")).classed(className, !0).text(text).call(function (v) {
      rect = getBoundingRect(v.node());
    }).remove(), $$.addCache(cacheKey, rect)), rect;
  },

  /**
   * Gets the x or y coordinate of the text
   * @param {Object} indices Indices values
   * @param {Boolean} forX whether or not to x
   * @returns {Number} coordinates
   * @private
   */
  generateXYForText: function generateXYForText(indices, forX) {
    var $$ = this,
        types = Object.keys(indices),
        points = {},
        getter = forX ? $$.getXForText : $$.getYForText;
    return $$.hasType("radar") && types.push("radar"), types.forEach(function (v) {
      points[v] = $$["generateGet".concat(capitalize(v), "Points")](indices[v], !1);
    }), function (d, i) {
      var type = $$.isAreaType(d) && "area" || $$.isBarType(d) && "bar" || $$.isRadarType(d) && "radar" || "line";
      return getter.call($$, points[type](d, i), d, this);
    };
  },

  /**
   * Get centerized text position for bar type data.label.text
   * @private
   * @param {Object} d Data object
   * @param {Array} points Data points position
   * @param {HTMLElement} textElement Data label text element
   * @returns {Number} Position value
   */
  getCenteredTextPos: function getCenteredTextPos(d, points, textElement) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;

    if (config.data_labels.centered && $$.isBarType(d)) {
      var rect = getBoundingRect(textElement),
          isPositive = d.value >= 0;

      if (isRotated) {
        var w = (isPositive ? points[1][1] - points[0][1] : points[0][1] - points[1][1]) / 2 + rect.width / 2;
        return isPositive ? -w - 3 : w + 2;
      }

      var h = (isPositive ? points[0][1] - points[1][1] : points[1][1] - points[0][1]) / 2 + rect.height / 2;
      return isPositive ? h : -h - 2;
    }

    return 0;
  },

  /**
   * Get data.labels.position value
   * @param {String} id Data id value
   * @param {String} type x | y
   * @return {Number} Position value
   * @private
   */
  getTextPos: function getTextPos(id, type) {
    var pos = this.config.data_labels_position;
    return (id in pos ? pos[id] : pos)[type] || 0;
  },

  /**
   * Gets the x coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} x coordinate
   */
  getXForText: function getXForText(points, d, textElement) {
    var xPos,
        padding,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    // show labels regardless of the domain if value is null
    if (isRotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null) if (xPos > $$.width) {
      var _getBoundingRect = getBoundingRect(textElement),
          width = _getBoundingRect.width;

      xPos = $$.width - width;
    } else xPos < 0 && (xPos = 4);
    return isRotated && (xPos += $$.getCenteredTextPos(d, points, textElement)), xPos + $$.getTextPos(d.id, "x");
  },

  /**
   * Gets the y coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} y coordinate
   */
  getYForText: function getYForText(points, d, textElement) {
    var yPos,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        r = config.point_r,
        rect = getBoundingRect(textElement),
        baseY = 3;
    if (isRotated) yPos = (points[0][0] + points[2][0] + rect.height * .6) / 2;else if (yPos = points[2][1], isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d)) && (baseY += config.point_r / 2.3), d.value < 0 || d.value === 0 && !$$.hasPositiveValue && $$.hasNegativeValue) yPos += rect.height + ($$.isBarType(d) ? -baseY : baseY);else {
      var diff = -baseY * 2;
      $$.isBarType(d) ? diff = -baseY : $$.isBubbleType(d) && (diff = baseY), yPos += diff;
    } // show labels regardless of the domain if value is null

    if (d.value === null && !isRotated) {
      var boxHeight = rect.height;
      yPos < boxHeight ? yPos = boxHeight : yPos > this.height && (yPos = this.height - 4);
    }

    return isRotated || (yPos += $$.getCenteredTextPos(d, points, textElement)), yPos + $$.getTextPos(d.id, "y");
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Mark overlapping text nodes with "text-overlapping" class
   * @private
   * @param {number} id
   * @param {ChartInternal} $$
   * @param {string} selector
   */
  markOverlapped: function markOverlapped(id, $$, selector) {
    var textNodes = $$.arcs.selectAll(selector),
        filteredTextNodes = textNodes.filter(function (node) {
      return node.data.id !== id;
    }),
        textNode = textNodes.filter(function (node) {
      return node.data.id === id;
    }),
        translate = getTranslation(textNode.node()),
        calcHypo = function (x, y) {
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };

    textNode.node() && filteredTextNodes.each(function () {
      var coordinate = getTranslation(this),
          filteredTextNode = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          nodeForWidth = calcHypo(translate.e, translate.f) > calcHypo(coordinate.e, coordinate.f) ? textNode : filteredTextNode,
          overlapsX = Math.ceil(Math.abs(translate.e - coordinate.e)) < Math.ceil(nodeForWidth.node().getComputedTextLength()),
          overlapsY = Math.ceil(Math.abs(translate.f - coordinate.f)) < parseInt(textNode.style("font-size"), 10);
      filteredTextNode.classed(config_classes.TextOverlapping, overlapsX && overlapsY);
    });
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Remove "text-overlapping" class on selected text nodes
   * @private
   * @param {ChartInternal} $$
   * @param {string} selector
   */
  undoMarkOverlapped: function undoMarkOverlapped($$, selector) {
    $$.arcs.selectAll(selector).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([this, this.previousSibling]).classed(config_classes.TextOverlapping, !1);
    });
  }
});
// CONCATENATED MODULE: ./src/internals/type.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

 // defined chart types as category

var TYPES = {
  Area: ["area", "area-spline", "area-spline-range", "area-line-range", "area-step"],
  AreaRange: ["area-spline-range", "area-line-range"],
  Arc: ["pie", "donut", "gauge", "radar"],
  Line: ["line", "spline", "area", "area-spline", "area-spline-range", "area-line-range", "step", "area-step"],
  Step: ["step", "area-step"],
  Spline: ["spline", "area-spline", "area-spline-range"]
};
extend(ChartInternal_ChartInternal.prototype, {
  setTargetType: function setTargetType(targetIds, type) {
    var $$ = this,
        config = $$.config;
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      $$.withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
    }), targetIds || (config.data_type = type);
  },
  hasType: function hasType(type, targetsValue) {
    var $$ = this,
        types = $$.config.data_types,
        targets = targetsValue || $$.data.targets,
        has = !1;
    return targets && targets.length ? targets.forEach(function (target) {
      var t = types[target.id];
      (t && t.indexOf(type) >= 0 || !t && type === "line") && (has = !0);
    }) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
      types[id] === type && (has = !0);
    }) : has = $$.config.data_type === type, has;
  },

  /**
   * Check if contains given chart types
   * @param {String} type Type key
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasTypeOf: function hasTypeOf(type, targets) {
    var _this = this,
        exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    return !TYPES[type].filter(function (v) {
      return exclude.indexOf(v) === -1;
    }).every(function (v) {
      return !_this.hasType(v, targets);
    });
  },

  /**
   * Check if given data is certain chart type
   * @param {Object} d Data object
   * @param {String} type chart type
   * @return {Boolean}
   * @private
   */
  isTypeOf: function isTypeOf(d, type) {
    var id = isString(d) ? d : d.id,
        dataType = this.config.data_types[id];
    return isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;
  },

  /**
   * Check if contains arc types chart
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasArcType: function hasArcType(targets, exclude) {
    return this.hasTypeOf("Arc", targets, exclude);
  },
  hasMultiArcGauge: function hasMultiArcGauge() {
    return this.hasType("gauge") && this.config.gauge_type === "multi";
  },
  isLineType: function isLineType(d) {
    var id = isString(d) ? d : d.id;
    return !this.config.data_types[id] || this.isTypeOf(id, TYPES.Line);
  },
  isStepType: function isStepType(d) {
    return this.isTypeOf(d, TYPES.Step);
  },
  isSplineType: function isSplineType(d) {
    return this.isTypeOf(d, TYPES.Spline);
  },
  isAreaType: function isAreaType(d) {
    return this.isTypeOf(d, TYPES.Area);
  },
  isAreaRangeType: function isAreaRangeType(d) {
    return this.isTypeOf(d, TYPES.AreaRange);
  },
  isBarType: function isBarType(d) {
    return this.isTypeOf(d, "bar");
  },
  isBubbleType: function isBubbleType(d) {
    return this.isTypeOf(d, "bubble");
  },
  isScatterType: function isScatterType(d) {
    return this.isTypeOf(d, "scatter");
  },
  isPieType: function isPieType(d) {
    return this.isTypeOf(d, "pie");
  },
  isGaugeType: function isGaugeType(d) {
    return this.isTypeOf(d, "gauge");
  },
  isDonutType: function isDonutType(d) {
    return this.isTypeOf(d, "donut");
  },
  isRadarType: function isRadarType(d) {
    return this.isTypeOf(d, "radar");
  },
  isArcType: function isArcType(d) {
    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d) || this.isRadarType(d);
  },
  // determine if is 'circle' data point
  isCirclePoint: function isCirclePoint() {
    var config = this.config,
        pattern = config.point_pattern;
    return config.point_type === "circle" && (!pattern || isArray(pattern) && pattern.length === 0);
  },
  lineData: function lineData(d) {
    return this.isLineType(d) ? [d] : [];
  },
  arcData: function arcData(d) {
    return this.isArcType(d.data) ? [d] : [];
  },
  barData: function barData(d) {
    return this.isBarType(d) ? d.values : [];
  },

  /**
   * Get data adapt for data label showing
   * @param {Object} d Data object
   * @return {Array}
   * @private
   */
  labelishData: function labelishData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) || this.isRadarType(d) ? d.values : [];
  },
  barLineBubbleData: function barLineBubbleData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
  },
  // https://github.com/d3/d3-shape#curves
  isInterpolationType: function isInterpolationType(type) {
    return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
  }
});
// CONCATENATED MODULE: ./src/internals/grid.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



 // Grid position and text anchor helpers

var getGridTextAnchor = function (d) {
  return isValue(d.position) || "end";
},
    getGridTextDx = function (d) {
  return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
},
    getGridTextX = function (isX, width, height) {
  return function (d) {
    var x = isX ? 0 : width;
    return d.position === "start" ? x = isX ? -height : 0 : d.position === "middle" && (x = (isX ? -height : width) / 2), x;
  };
};

extend(ChartInternal_ChartInternal.prototype, {
  initGrid: function initGrid() {
    var $$ = this;
    $$.xgrid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]), $$.initGridLines(), $$.initFocusGrid();
  },
  initGridLines: function initGridLines() {
    var $$ = this,
        config = $$.config;
    (config.grid_x_lines.length || config.grid_y_lines.length) && ($$.gridLines = $$.main.insert("g", ".".concat(config_classes.chart).concat(config.grid_lines_front ? " + *" : "")).attr("clip-path", $$.clipPathForGrid).attr("class", "".concat(config_classes.grid, " ").concat(config_classes.gridLines)), $$.gridLines.append("g").attr("class", config_classes.xgridLines), $$.gridLines.append("g").attr("class", config_classes.ygridLines), $$.xgridLines = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]));
  },
  updateXGrid: function updateXGrid(withoutUpdate) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        xgridData = $$.generateGridData(config.grid_x_type, $$.x),
        tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0,
        pos = function (d) {
      return ($$.zoomScale || $$.x)(d) + tickOffset * (isRotated ? -1 : 1);
    };

    $$.xgridAttr = isRotated ? {
      "x1": 0,
      "x2": $$.width,
      "y1": pos,
      "y2": pos
    } : {
      "x1": pos,
      "x2": pos,
      "y1": 0,
      "y2": $$.height
    }, $$.xgrid = $$.main.select(".".concat(config_classes.xgrids)).selectAll(".".concat(config_classes.xgrid)).data(xgridData), $$.xgrid.exit().remove(), $$.xgrid = $$.xgrid.enter().append("line").attr("class", config_classes.xgrid).merge($$.xgrid), withoutUpdate || $$.xgrid.each(function () {
      var grid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      Object.keys($$.xgridAttr).forEach(function (id) {
        grid.attr(id, $$.xgridAttr[id]).style("opacity", function () {
          return grid.attr(isRotated ? "y1" : "x1") === (isRotated ? $$.height : 0) ? "0" : "1";
        });
      });
    });
  },
  updateYGrid: function updateYGrid() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks),
        pos = function (d) {
      return Math.ceil($$.y(d));
    };

    $$.ygrid = $$.main.select(".".concat(config_classes.ygrids)).selectAll(".".concat(config_classes.ygrid)).data(gridValues), $$.ygrid.exit().remove(), $$.ygrid = $$.ygrid.enter().append("line").attr("class", config_classes.ygrid).merge($$.ygrid), $$.ygrid.attr("x1", isRotated ? pos : 0).attr("x2", isRotated ? pos : $$.width).attr("y1", isRotated ? 0 : pos).attr("y2", isRotated ? $$.height : pos), $$.smoothLines($$.ygrid, "grid");
  },
  updateGrid: function updateGrid(duration) {
    var $$ = this;
    // hide if arc type
    $$.gridLines || $$.initGridLines(), $$.grid.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.hideGridFocus(), $$.updateXGridLines(duration), $$.updateYGridLines(duration);
  },

  /**
   * Update X Grid lines
   * @param {Number} duration
   * @private
   */
  updateXGridLines: function updateXGridLines(duration) {
    var $$ = this,
        main = $$.main,
        config = $$.config,
        isRotated = config.axis_rotated;
    config.grid_x_show && $$.updateXGrid(), $$.xgridLines = main.select(".".concat(config_classes.xgridLines)).selectAll(".".concat(config_classes.xgridLine)).data(config.grid_x_lines), $$.xgridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var xgridLine = $$.xgridLines.enter().append("g");
    xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("transform", isRotated ? "" : "rotate(-90)").attr("dy", -5).style("opacity", "0"), $$.xgridLines = xgridLine.merge($$.xgridLines), $$.xgridLines.attr("class", function (d) {
      return "".concat(config_classes.xgridLine, " ").concat(d["class"] || "").trim();
    }).select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1");
  },

  /**
   * Update Y Grid lines
   * @param {Number} duration
   * @private
   */
  updateYGridLines: function updateYGridLines(duration) {
    var $$ = this,
        main = $$.main,
        config = $$.config,
        isRotated = config.axis_rotated;
    config.grid_y_show && $$.updateYGrid(), $$.ygridLines = main.select(".".concat(config_classes.ygridLines)).selectAll(".".concat(config_classes.ygridLine)).data(config.grid_y_lines), $$.ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var ygridLine = $$.ygridLines.enter().append("g");
    ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("transform", isRotated ? "rotate(-90)" : "").style("opacity", "0"), $$.ygridLines = ygridLine.merge($$.ygridLines);
    // update
    var yv = $$.yv.bind($$);
    $$.ygridLines.attr("class", function (d) {
      return "".concat(config_classes.ygridLine, " ").concat(d["class"] || "").trim();
    }).select("line").transition().duration(duration).attr("x1", isRotated ? yv : 0).attr("x2", isRotated ? yv : $$.width).attr("y1", isRotated ? 0 : yv).attr("y2", isRotated ? $$.height : yv).transition().style("opacity", "1"), $$.ygridLines.select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).attr("dy", -5).attr("x", getGridTextX(isRotated, $$.width, $$.height)).attr("y", yv).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1");
  },
  redrawGrid: function redrawGrid(withTransition) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        xv = $$.xv.bind($$),
        lines = $$.xgridLines.select("line"),
        texts = $$.xgridLines.select("text");
    return lines = (withTransition ? lines.transition() : lines).attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? $$.width : xv).attr("y1", isRotated ? xv : 0).attr("y2", isRotated ? xv : $$.height), texts = (withTransition ? texts.transition() : texts).attr("x", getGridTextX(!isRotated, $$.width, $$.height)).attr("y", xv).text(function (d) {
      return d.text;
    }), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
  },
  initFocusGrid: function initFocusGrid() {
    var $$ = this,
        config = $$.config,
        isFront = config.grid_front,
        className = ".".concat(config_classes[isFront && $$.gridLines ? "gridLines" : "chart"]).concat(isFront ? " + *" : "");
    $$.grid = $$.main.insert("g", className).attr("clip-path", $$.clipPathForGrid).attr("class", config_classes.grid), config.grid_x_show && $$.grid.append("g").attr("class", config_classes.xgrids), config.grid_y_show && $$.grid.append("g").attr("class", config_classes.ygrids), config.grid_focus_show && ($$.grid.append("g").attr("class", config_classes.xgridFocus).append("line").attr("class", config_classes.xgridFocus), config.grid_focus_y && !config.tooltip_grouped && $$.grid.append("g").attr("class", config_classes.ygridFocus).append("line").attr("class", config_classes.ygridFocus));
  },

  /**
   * Show grid focus line
   * @param {Array} selectedData
   * @private
   */
  showGridFocus: function showGridFocus(selectedData) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    // Hide when bubble/scatter/stanford plot exists
    if (!(!config.tooltip_show || dataToShow.length === 0 || $$.hasType("bubble") || $$.hasArcType())) {
      var focusEl = $$.main.selectAll("line.".concat(config_classes.xgridFocus, ", line.").concat(config_classes.ygridFocus)),
          isEdge = config.grid_focus_edge && !config.tooltip_grouped,
          xx = $$.xx.bind($$);
      focusEl.style("visibility", "visible").data(dataToShow.concat(dataToShow)).each(function (d) {
        var xy,
            el = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            pos = {
          x: xx(d),
          y: $$.getYScale(d.id)(d.value)
        };
        if (el.classed(config_classes.xgridFocus)) xy = isRotated ? [null, // x1
        pos.x, // y1
        isEdge ? pos.y : $$.width, // x2
        pos.x // y2
        ] : [pos.x, isEdge ? pos.y : null, pos.x, $$.height];else {
          var isY2 = $$.axis.getId(d.id) === "y2";
          xy = isRotated ? [pos.y, // x1
          isEdge && !isY2 ? pos.x : null, // y1
          pos.y, // x2
          isEdge && isY2 ? pos.x : $$.height // y2
          ] : [isEdge && isY2 ? pos.x : null, pos.y, isEdge && !isY2 ? pos.x : $$.width, pos.y];
        }
        ["x1", "y1", "x2", "y2"].forEach(function (v, i) {
          return el.attr(v, xy[i]);
        });
      }), $$.smoothLines(focusEl, "grid");
    }
  },
  hideGridFocus: function hideGridFocus() {
    var $$ = this;
    $$.inputType === "mouse" && $$.main.selectAll("line.".concat(config_classes.xgridFocus, ", line.").concat(config_classes.ygridFocus)).style("visibility", "hidden");
  },
  updateGridFocus: function updateGridFocus() {
    var $$ = this,
        xgridFocus = $$.grid.select("line.".concat(config_classes.xgridFocus));

    if (!($$.inputType === "touch")) {
      var _isRotated = $$.config.axis_rotated;
      xgridFocus.attr("x1", _isRotated ? 0 : -10).attr("x2", _isRotated ? $$.width : -10).attr("y1", _isRotated ? -10 : 0).attr("y2", _isRotated ? -10 : $$.height);
    } else if (!xgridFocus.empty()) {
      var d = xgridFocus.datum();
      d && $$.showGridFocus([d]);
    } // need to return 'true' as of being pushed to the redraw list
    // ref: getRedrawList()


    return !0;
  },
  generateGridData: function generateGridData(type, scale) {
    var $$ = this,
        tickNum = $$.main.select(".".concat(config_classes.axisX)).selectAll(".tick").size(),
        gridData = [];

    if (type === "year") {
      var xDomain = $$.getXDomain(),
          firstYear = xDomain[0].getFullYear(),
          lastYear = xDomain[1].getFullYear();

      for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date("".concat(i, "-01-01 00:00:00")));
    } else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
      return (d + "").indexOf(".") < 0;
    }));

    return gridData;
  },
  getGridFilterToRemove: function getGridFilterToRemove(params) {
    return params ? function (line) {
      var found = !1;
      return (isArray(params) ? params.concat() : [params]).forEach(function (param) {
        ("value" in param && line.value === param.value || "class" in param && line["class"] === param["class"]) && (found = !0);
      }), found;
    } : function () {
      return !0;
    };
  },
  removeGridLines: function removeGridLines(params, forX) {
    var $$ = this,
        config = $$.config,
        toRemove = $$.getGridFilterToRemove(params),
        classLines = forX ? config_classes.xgridLines : config_classes.ygridLines,
        classLine = forX ? config_classes.xgridLine : config_classes.ygridLine;
    $$.main.select(".".concat(classLines)).selectAll(".".concat(classLine)).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();
    var gridLines = "grid_".concat(forX ? "x" : "y", "_lines");
    config[gridLines] = config[gridLines].filter(function toShow(line) {
      return !toRemove(line);
    });
  }
});
// CONCATENATED MODULE: ./src/internals/tooltip.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the tooltip
   * @private
   */
  initTooltip: function initTooltip() {
    var $$ = this,
        config = $$.config,
        bindto = config.tooltip_contents.bindto;

    // Show tooltip if needed
    if ($$.tooltip = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto), $$.tooltip.empty() && ($$.tooltip = $$.selectChart.style("position", "relative").append("div").attr("class", config_classes.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none")), config.tooltip_init_show) {
      if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
        var i,
            val,
            targets = $$.data.targets[0];

        for (config.tooltip_init_x = $$.parseDate(config.tooltip_init_x), i = 0; (val = targets.values[i]) && val.x - config.tooltip_init_x !== 0; i++);

        config.tooltip_init_x = i;
      }

      $$.tooltip.html($$.getTooltipHTML($$.data.targets.map(function (d) {
        return $$.addName(d.values[config.tooltip_init_x]);
      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType(null, ["radar"])), $$.color)), bindto || $$.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
    }

    $$.bindTooltipResizePos();
  },

  /**
   * Get the tooltip HTML string
   * @param  {...any} args
   * @private
   * @return {String} Formatted HTML string
   */
  getTooltipHTML: function getTooltipHTML() {
    for (var _config$tooltip_conte, _$$, $$ = this, config = $$.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return isFunction(config.tooltip_contents) ? (_config$tooltip_conte = config.tooltip_contents).call.apply(_config$tooltip_conte, [$$].concat(args)) : (_$$ = $$).getTooltipContent.apply(_$$, args);
  },

  /**
   * Returns the tooltip content(HTML string)
   * @param {Object} d data
   * @param {Function} defaultTitleFormat Default title format
   * @param {Function} defaultValueFormat Default format for each data value in the tooltip.
   * @param {Function} color Color function
   * @returns {String} html
   * @private
   */
  getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
    var $$ = this,
        config = $$.config,
        titleFormat = config.tooltip_format_title || defaultTitleFormat,
        nameFormat = config.tooltip_format_name || function (name) {
      return name;
    },
        valueFormat = config.tooltip_format_value || ($$.isStackNormalized() ? function (v, ratio) {
      return "".concat((ratio * 100).toFixed(2), "%");
    } : defaultValueFormat),
        order = config.tooltip_order,
        getRowValue = function (row) {
      return $$.isBubbleZType(row) ? $$.getBubbleZData(row.value, "z") : $$.getBaseValue(row);
    },
        getBgColor = $$.levelColor ? function (row) {
      return $$.levelColor(row.value);
    } : function (row) {
      return color(row);
    },
        contents = config.tooltip_contents,
        tplStr = contents.template,
        targetIds = $$.mapToTargetIds();

    if (order === null && $$.isGrouped()) {
      // for stacked data, order should aligned with the visually displayed data
      var ids = $$.orderTargets($$.data.targets).map(function (i2) {
        return i2.id;
      }).reverse();
      d.sort(function (a, b) {
        var v1 = a ? a.value : null,
            v2 = b ? b.value : null;
        return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
      });
    } else if (/^(asc|desc)$/.test(order)) {
      d.sort(function (a, b) {
        var v1 = a ? getRowValue(a) : null,
            v2 = b ? getRowValue(b) : null;
        return order === "asc" ? v1 - v2 : v2 - v1;
      });
    } else isFunction(order) && d.sort(order);

    var text,
        row,
        param,
        value,
        i,
        tpl = $$.getTooltipContentTemplate(tplStr),
        len = d.length;

    for (i = 0; i < len; i++) if (row = d[i], row && (getRowValue(row) || getRowValue(row) === 0)) {
      if (isUndefined(text)) {
        var title = sanitise(titleFormat ? titleFormat(row.x) : row.x);
        text = tplProcess(tpl[0], {
          CLASS_TOOLTIP: config_classes.tooltip,
          TITLE: isValue(title) ? tplStr ? title : "<tr><th colspan=\"2\">".concat(title, "</th></tr>") : ""
        });
      }

      if (param = [row.ratio, row.id, row.index, d], value = sanitise(valueFormat.apply(void 0, [getRowValue(row)].concat(_toConsumableArray(param)))), $$.isAreaRangeType(row)) {
        var _map = ["high", "low"].map(function (v) {
          return sanitise(valueFormat.apply(void 0, [$$.getAreaRangeData(row, v)].concat(_toConsumableArray(param))));
        }),
            _map2 = _slicedToArray(_map, 2),
            high = _map2[0],
            low = _map2[1];

        value = "<b>Mid:</b> ".concat(value, " <b>High:</b> ").concat(high, " <b>Low:</b> ").concat(low);
      }

      if (value !== undefined) {
        var _ret = function () {
          // Skip elements when their name is set to null
          if (row.name === null) return "continue";
          var name = sanitise(nameFormat.apply(void 0, [row.name].concat(_toConsumableArray(param)))),
              color = getBgColor(row),
              contentValue = {
            CLASS_TOOLTIP_NAME: config_classes.tooltipName + $$.getTargetSelectorSuffix(row.id),
            COLOR: tplStr || !$$.patterns ? color : "<svg><rect style=\"fill:".concat(color, "\" width=\"10\" height=\"10\"></rect></svg>"),
            NAME: name,
            VALUE: value
          };

          if (tplStr && isObject(contents.text)) {
            var index = targetIds.indexOf(row.id);
            Object.keys(contents.text).forEach(function (key) {
              contentValue[key] = contents.text[key][index];
            });
          }

          text += tplProcess(tpl[1], contentValue);
        }();

        if (_ret === "continue") continue;
      }
    }

    return "".concat(text, "</table>");
  },

  /**
   * Get the content template string
   * @param {String} tplStr
   * @return {String} Template string
   * @private
   */
  getTooltipContentTemplate: function getTooltipContentTemplate(tplStr) {
    return (tplStr || "<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">".concat(this.patterns ? "{=COLOR}" : "<span style=\"background-color:{=COLOR}\"></span>", "{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>")).replace(/(\r?\n|\t)/g, "").split(/{{(.*)}}/);
  },

  /**
   * Returns the position of the tooltip
   * @param {Object} dataToShow data
   * @param {String} tWidth Width value of tooltip element
   * @param {String} tHeight Height value of tooltip element
   * @param {HTMLElement} element
   * @returns {Object} top, left value
   * @private
   */
  tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
    var $$ = this,
        config = $$.config,
        hasGauge = $$.hasType("gauge") && !config.gauge_fullCircle,
        svgLeft = $$.getSvgLeft(!0),
        _d3Mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(element),
        _d3Mouse2 = _slicedToArray(_d3Mouse, 2),
        left = _d3Mouse2[0],
        top = _d3Mouse2[1],
        chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight(!0),
        chartLeft = $$.getCurrentPaddingLeft(!0),
        size = 20;

    // Determine tooltip position
    if (top += size, $$.hasArcType()) {
      var raw = $$.inputType === "touch" || $$.hasType("radar");
      raw || (top += hasGauge ? $$.height : $$.height / 2, left += ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2);
    } else {
      var dataScale = $$.x(dataToShow[0].x);
      config.axis_rotated ? (top = dataScale + size, left += svgLeft + 100, chartRight -= svgLeft) : (top -= 5, left = svgLeft + chartLeft + size + ($$.zoomScale ? left : dataScale));
    } // when tooltip left + tWidth > chart's width


    left + tWidth + 15 > chartRight && (left -= tWidth + chartLeft), top + tHeight > $$.currentHeight && (top -= hasGauge ? tHeight * 3 : tHeight + 30);
    var pos = {
      top: top,
      left: left
    }; // make sure to not be positioned out of viewport

    return Object.keys(pos).forEach(function (v) {
      pos[v] < 0 && (pos[v] = 0);
    }), pos;
  },

  /**
   * Show the tooltip
   * @private
   * @param {Object} selectedData
   * @param {HTMLElement} element
   */
  showTooltip: function showTooltip(selectedData, element) {
    var $$ = this,
        config = $$.config,
        bindto = config.tooltip_contents.bindto,
        forArc = $$.hasArcType(null, ["radar"]),
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    if (dataToShow.length !== 0 && config.tooltip_show) {
      var datum = $$.tooltip.datum(),
          _ref = datum || {},
          _ref$width = _ref.width,
          width = _ref$width === void 0 ? 0 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 0 : _ref$height,
          dataStr = JSON.stringify(selectedData);

      if (!datum || datum.current !== dataStr) {
        var index = selectedData.concat().sort()[0].index;
        callFn(config.tooltip_onshow, $$, $$.api, selectedData), $$.tooltip.html($$.getTooltipHTML(selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", null).style("visibility", null) // for IE9
        .datum(datum = {
          index: index,
          current: dataStr,
          width: width = $$.tooltip.property("offsetWidth"),
          height: height = $$.tooltip.property("offsetHeight")
        }), callFn(config.tooltip_onshown, $$, $$.api, selectedData), $$._handleLinkedCharts(!0, index);
      }

      if (!bindto) {
        var fnPos = config.tooltip_position || $$.tooltipPosition,
            pos = fnPos.call(this, dataToShow, width, height, element); // Get tooltip dimensions

        ["top", "left"].forEach(function (v) {
          var value = pos[v];
          $$.tooltip.style(v, "".concat(value, "px")), v !== "left" || datum.xPosInPercent || (datum.xPosInPercent = value / $$.currentWidth * 100);
        });
      }
    }
  },

  /**
   * Adjust tooltip position on resize event
   * @private
   */
  bindTooltipResizePos: function bindTooltipResizePos() {
    var $$ = this,
        resizeFunction = $$.resizeFunction,
        tooltip = $$.tooltip;
    resizeFunction.add(function () {
      if (tooltip.style("display") === "block") {
        var currentWidth = $$.currentWidth,
            _tooltip$datum = tooltip.datum(),
            width = _tooltip$datum.width,
            xPosInPercent = _tooltip$datum.xPosInPercent,
            _value = currentWidth / 100 * xPosInPercent,
            diff = currentWidth - (_value + width);

        diff < 0 && (_value += diff), tooltip.style("left", "".concat(_value, "px"));
      }
    });
  },

  /**
   * Hide the tooltip
   * @param {Boolean} force Force to hide
   * @private
   */
  hideTooltip: function hideTooltip(force) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        tooltip = $$.tooltip;

    if (tooltip.style("display") !== "none" && (!config.tooltip_doNotHide || force)) {
      var selectedData = JSON.parse(this.tooltip.datum().current);
      // hide tooltip
      callFn(config.tooltip_onhide, $$, api, selectedData), tooltip.style("display", "none").style("visibility", "hidden") // for IE9
      .datum(null), callFn(config.tooltip_onhidden, $$, api, selectedData);
    }
  },

  /**
   * Toggle display for linked chart instances
   * @param {Boolean} show true: show, false: hide
   * @param {Number} index x Axis index
   * @private
   */
  _handleLinkedCharts: function _handleLinkedCharts(show, index) {
    var $$ = this;

    if ($$.config.tooltip_linked) {
      var linkedName = $$.config.tooltip_linked_name;
      ($$.api.internal.charts || []).forEach(function (c) {
        if (c !== $$.api) {
          var _config = c.internal.config,
              isLinked = _config.tooltip_linked,
              name = _config.tooltip_linked_name,
              isInDom = browser_doc.body.contains(c.element);

          if (isLinked && linkedName === name && isInDom) {
            var data = c.internal.tooltip.data()[0],
                isNotSameIndex = index !== (data && data.index);

            // prevent throwing error for non-paired linked indexes
            try {
              show && isNotSameIndex ? c.tooltip.show({
                index: index
              }) : !show && c.tooltip.hide();
            } catch (e) {}
          }
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/internals/legend.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the legend.
   * @private
   */
  initLegend: function initLegend() {
    var $$ = this,
        config = $$.config;
    $$.legendItemTextBox = {}, $$.legendHasRendered = !1, $$.legend = $$.svg.append("g"), config.legend_show ? ($$.legend.attr("transform", $$.getTranslate("legend")), $$.updateLegend()) : ($$.legend.style("visibility", "hidden"), $$.hiddenLegendIds = $$.mapToIds($$.data.targets));
  },

  /**
   * Update legend element
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @param {Object} transitions Return value of the generateTransitions
   * @private
   */
  updateLegend: function updateLegend(targetIds, options, transitions) {
    var $$ = this,
        config = $$.config,
        optionz = options || {
      withTransform: !1,
      withTransitionForTransform: !1,
      withTransition: !1
    };
    // toggle legend state
    // Update size and scale
    // Update g positions
    optionz.withTransition = getOption(optionz, "withTransition", !0), optionz.withTransitionForTransform = getOption(optionz, "withTransitionForTransform", !0), config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : $$.updateLegendElement(targetIds || $$.mapToIds($$.data.targets), optionz, transitions), $$.legend.selectAll(".".concat(config_classes.legendItem)).classed(config_classes.legendItemHidden, function (id) {
      return !$$.isTargetToShow(id);
    }), $$.updateScales(!1, !$$.zoomScale), $$.updateSvgSize(), $$.transformAll(optionz.withTransitionForTransform, transitions), $$.legendHasRendered = !0;
  },

  /**
   * Update legend using template option
   * @private
   */
  updateLegendTemplate: function updateLegendTemplate() {
    var $$ = this,
        config = $$.config,
        wrapper = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(config.legend_contents_bindto),
        template = config.legend_contents_template;

    if (!wrapper.empty()) {
      var targets = $$.mapToIds($$.data.targets),
          ids = [],
          html = "";
      targets.forEach(function (v) {
        var content = isFunction(template) ? template.call($$, v, $$.color(v), $$.api.data(v)[0].values) : tplProcess(template, {
          COLOR: $$.color(v),
          TITLE: v
        });
        content && (ids.push(v), html += content);
      });
      var legendItem = wrapper.html(html).selectAll(function () {
        return this.childNodes;
      }).data(ids);
      $$.setLegendItem(legendItem), $$.legend = wrapper;
    }
  },

  /**
   * Update the size of the legend.
   * @private
   * @param {Obejct} size S
   */
  updateSizeForLegend: function updateSizeForLegend(size) {
    var $$ = this,
        config = $$.config,
        width = size.width,
        height = size.height,
        insetLegendPosition = {
      top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - height - $$.getCurrentPaddingBottom() - config.legend_inset_y,
      left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : $$.currentWidth - width - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
    };
    $$.margin3 = {
      top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - height,
      right: NaN,
      bottom: 0,
      left: $$.isLegendRight ? $$.currentWidth - width : $$.isLegendInset ? insetLegendPosition.left : 0
    };
  },

  /**
   * Transform Legend
   * @private
   * @param {Boolean} whether or not to transition.
   */
  transformLegend: function transformLegend(withTransition) {
    var $$ = this;
    (withTransition ? $$.legend.transition() : $$.legend).attr("transform", $$.getTranslate("legend"));
  },

  /**
   * Update the legend step
   * @private
   * @param {Number} step
   */
  updateLegendStep: function updateLegendStep(step) {
    this.legendStep = step;
  },

  /**
   * Update legend item width
   * @private
   * @param {Number} width
   */
  updateLegendItemWidth: function updateLegendItemWidth(w) {
    this.legendItemWidth = w;
  },

  /**
   * Update legend item height
   * @private
   * @param {Number} height
   */
  updateLegendItemHeight: function updateLegendItemHeight(h) {
    this.legendItemHeight = h;
  },

  /**
   * Update legend item color
   * @private
   * @param {String} id Corresponding data ID value
   * @param {String} color Color value
   */
  updateLegendItemColor: function updateLegendItemColor(id, color) {
    this.legend.select(".".concat(config_classes.legendItem, "-").concat(id, " line")).style("stroke", color);
  },

  /**
   * Get the width of the legend
   * @private
   * @return {Number} width
   */
  getLegendWidth: function getLegendWidth() {
    var $$ = this;
    return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;
  },

  /**
   * Get the height of the legend
   * @return {Number} height
   * @private
   */
  getLegendHeight: function getLegendHeight() {
    var $$ = this;
    return $$.config.legend_show ? $$.isLegendRight ? $$.currentHeight : Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1) : 0;
  },

  /**
   * Get the opacity of the legend
   * @private
   * @param {Object} d3.Select
   * @returns {Number} opacity
   */
  opacityForLegend: function opacityForLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "1";
  },

  /**
   * Get the opacity of the legend that is unfocused
   * @private
   * @param {Object} legendItem, d3.Select
   * @returns {Number} opacity
   */
  opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "0.3";
  },

  /**
   * Toggles the focus of the legend
   * @private
   * @param {Array} ID's of target
   * @param {Boolean} whether or not to focus.
   */
  toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
    var $$ = this,
        targetIdz = $$.mapToTargetIds(targetIds);
    $$.legend.selectAll(".".concat(config_classes.legendItem)).filter(function (id) {
      return targetIdz.indexOf(id) >= 0;
    }).classed(config_classes.legendItemFocused, focus).transition().duration(100).style("opacity", function () {
      return (focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend).call($$, Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Revert the legend to its default state
   * @private
   */
  revertLegend: function revertLegend() {
    var $$ = this;
    $$.legend.selectAll(".".concat(config_classes.legendItem)).classed(config_classes.legendItemFocused, !1).transition().duration(100).style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Shows the legend
   * @private
   * @param {Array} ID's of target
   */
  showLegend: function showLegend(targetIds) {
    var $$ = this,
        config = $$.config;
    config.legend_show || (config.legend_show = !0, $$.legend.style("visibility", "visible"), !$$.legendHasRendered && $$.updateLegend()), $$.removeHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Hide the legend
   * @private
   * @param {Array} ID's of target
   */
  hideLegend: function hideLegend(targetIds) {
    var $$ = this,
        config = $$.config;
    config.legend_show && isEmpty(targetIds) && (config.legend_show = !1, $$.legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
  },

  /**
   * Clear the LegendItemTextBox cache.
   * @private
   */
  clearLegendItemTextBoxCache: function clearLegendItemTextBoxCache() {
    this.legendItemTextBox = {};
  },

  /**
   * Set legend item style & bind events
   * @private
   * @param {d3.selection} item
   */
  setLegendItem: function setLegendItem(item) {
    var $$ = this,
        config = $$.config,
        isTouch = $$.inputType === "touch",
        hasGauge = $$.hasType("gauge");
    item.attr("class", function (id) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          itemClass = !node.empty() && node.attr("class") || "";
      return itemClass + $$.generateClass(config_classes.legendItem, id);
    }).style("visibility", function (id) {
      return $$.isLegendToShow(id) ? "visible" : "hidden";
    }).style("cursor", "pointer").on("click", function (id) {
      callFn(config.legend_item_onclick, $$, id) || (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].altKey ? ($$.api.hide(), $$.api.show(id)) : ($$.api.toggle(id), !isTouch && $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert())), isTouch && $$.hideTooltip();
    }), isTouch || item.on("mouseout", function (id) {
      callFn(config.legend_item_onout, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !1), hasGauge && $$.undoMarkOverlapped($$, ".".concat(config_classes.gaugeValue)), $$.api.revert());
    }).on("mouseover", function (id) {
      callFn(config.legend_item_onover, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !0), hasGauge && $$.markOverlapped(id, $$, ".".concat(config_classes.gaugeValue)), !$$.transiting && $$.isTargetToShow(id) && $$.api.focus(id));
    });
  },

  /**
   * Update the legend
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
  	 * @private
   */
  updateLegendElement: function updateLegendElement(targetIds, options) {
    var xForLegend,
        yForLegend,
        background,
        $$ = this,
        config = $$.config,
        posMin = 10,
        tileWidth = config.legend_item_tile_width + 5,
        maxWidth = 0,
        maxHeight = 0,
        totalLength = 0,
        offsets = {},
        widths = {},
        heights = {},
        margins = [0],
        steps = {},
        step = 0,
        isLegendRightOrInset = $$.isLegendRight || $$.isLegendInset,
        targetIdz = targetIds.filter(function (id) {
      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
    }),
        withTransition = options.withTransition,
        getTextBox = function (textElement, id) {
      return $$.legendItemTextBox[id] || ($$.legendItemTextBox[id] = $$.getTextRect(textElement, config_classes.legendItem)), $$.legendItemTextBox[id];
    },
        updatePositions = function (textElement, id, index) {
      var margin,
          isLast = index === targetIdz.length - 1,
          box = getTextBox(textElement, id),
          itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
          itemHeight = box.height + 4,
          itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
          areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
          updateValues = function (id2, withoutStep) {
        withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < posMin && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = $$.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
      };

      if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);
      widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);
      var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;
      config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
        return widths[id2] = maxWidth;
      }), Object.keys(heights).forEach(function (id2) {
        return heights[id2] = maxHeight;
      }), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < posMin ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
        return updateValues(id2);
      })) : updateValues(id, !0)) : updateValues(id);
    };

    $$.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), $$.isLegendRight ? (xForLegend = function (id) {
      return maxWidth * steps[id];
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : $$.isLegendInset ? (xForLegend = function (id) {
      return maxWidth * steps[id] + 10;
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : (xForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }, yForLegend = function (id) {
      return maxHeight * steps[id];
    });

    var xForLegendText = function (id, i) {
      return xForLegend(id, i) + 4 + config.legend_item_tile_width;
    },
        xForLegendRect = function (id, i) {
      return xForLegend(id, i);
    },
        x1ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2;
    },
        x2ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2 + config.legend_item_tile_width;
    },
        yForLegendText = function (id, i) {
      return yForLegend(id, i) + 9;
    },
        yForLegendRect = function (id, i) {
      return yForLegend(id, i) - 5;
    },
        yForLegendTile = function (id, i) {
      return yForLegend(id, i) + 4;
    },
        pos = -200,
        l = $$.legend.selectAll(".".concat(config_classes.legendItem)).data(targetIdz).enter().append("g");

    $$.setLegendItem(l), l.append("text").text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }).each(function (id, i) {
      updatePositions(this, id, i);
    }).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : pos).attr("y", isLegendRightOrInset ? pos : yForLegendText), l.append("rect").attr("class", config_classes.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : pos).attr("y", isLegendRightOrInset ? pos : yForLegendRect);
    var usePoint = $$.config.legend_usePoint;

    if (usePoint) {
      var ids = [];
      l.append(function (d) {
        var pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
        ids.indexOf(d) === -1 && ids.push(d);
        var point = pattern[ids.indexOf(d) % pattern.length];
        return point === "rectangle" && (point = "rect"), browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, $$.hasValidPointType(point) ? point : "use");
      }).attr("class", config_classes.legendItemPoint).style("fill", function (d) {
        return $$.color(d);
      }).style("pointer-events", "none").attr("href", function (data, idx, selection) {
        var node = selection[idx],
            nodeName = node.nodeName.toLowerCase();
        return nodeName === "use" ? "#".concat($$.datetimeId, "-point-").concat(data) : undefined;
      });
    } else l.append("line").attr("class", config_classes.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : pos).attr("y1", isLegendRightOrInset ? pos : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : pos).attr("y2", isLegendRightOrInset ? pos : yForLegendTile).attr("stroke-width", config.legend_item_tile_height); // Set background for inset legend


    background = $$.legend.select(".".concat(config_classes.legendBackground, " rect")), $$.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = $$.legend.insert("g", ".".concat(config_classes.legendItem)).attr("class", config_classes.legendBackground).append("rect"));
    var texts = $$.legend.selectAll("text").data(targetIdz).text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }) // MEMO: needed for update
    .each(function (id, i) {
      updatePositions(this, id, i);
    });
    (withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);
    var rects = $$.legend.selectAll("rect.".concat(config_classes.legendItemEvent)).data(targetIdz);

    if ((withTransition ? rects.transition() : rects).attr("width", function (id) {
      return widths[id];
    }).attr("height", function (id) {
      return heights[id];
    }).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
      var tiles = $$.legend.selectAll(".".concat(config_classes.legendItemPoint)).data(targetIdz);
      (withTransition ? tiles.transition() : tiles).each(function () {
        var radius,
            width,
            height,
            nodeName = this.nodeName.toLowerCase(),
            pointR = $$.config.point_r,
            x = "x",
            y = "y",
            xOffset = 2,
            yOffset = 2.5;

        if (nodeName === "circle") {
          var size = pointR * .2;
          x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
        } else if (nodeName === "rect") {
          var _size = pointR * 2.5;

          width = _size, height = _size, yOffset = 3;
        }

        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr(x, function (d) {
          return x1ForLegendTile(d) + xOffset;
        }).attr(y, function (d) {
          return yForLegendTile(d) - yOffset;
        }).attr("r", radius).attr("width", width).attr("height", height);
      });
    } else {
      var _tiles = $$.legend.selectAll("line.".concat(config_classes.legendItemTile)).data(targetIdz);

      (withTransition ? _tiles.transition() : _tiles).style("stroke", $$.levelColor ? function (id) {
        return $$.levelColor($$.cache[id].values[0].value);
      } : $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
    }

    background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step);
  }
});
// CONCATENATED MODULE: ./src/internals/title.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Get the text position
 * @param {String} pos right, left or center
 * @param {Number} width chart width
 * @return {String|Number} text-anchor value or position in pixel
 * @private
 */

var getTextPos = function () {
  var position,
      pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "left",
      width = arguments.length > 1 ? arguments[1] : undefined,
      isNum = isNumber(width);
  return position = pos.indexOf("center") > -1 ? isNum ? width / 2 : "middle" : pos.indexOf("right") > -1 ? isNum ? width : "end" : isNum ? 0 : "start", position;
};

extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the title
   * @private
   */
  initTitle: function initTitle() {
    var $$ = this;

    if ($$.config.title_text) {
      $$.title = $$.svg.append("g");
      var text = $$.title.append("text").style("text-anchor", getTextPos($$.config.title_position)).attr("class", config_classes.title);
      setTextValue(text, $$.config.title_text, [.3, 1.5]);
    }
  },

  /**
   * Redraw title
   * @private
   */
  redrawTitle: function redrawTitle() {
    var $$ = this;

    if ($$.title) {
      var y = $$.yForTitle.call($$);
      /g/i.test($$.title.node().tagName) ? $$.title.attr("transform", "translate(".concat(getTextPos($$.config.title_position, $$.currentWidth), ", ").concat(y, ")")) : $$.title.attr("x", $$.xForTitle.call($$)).attr("y", y);
    }
  },

  /**
   * Returns the x attribute value of the title
   * @private
   * @returns {Number} x attribute value
   */
  xForTitle: function xForTitle() {
    var x,
        $$ = this,
        config = $$.config,
        position = config.title_position || "left",
        textRectWidth = $$.getTextRect($$.title, config_classes.title).width;
    return /(right|center)/.test(position) ? (x = $$.currentWidth - textRectWidth, position.indexOf("right") >= 0 ? x = $$.currentWidth - textRectWidth - config.title_padding.right : position.indexOf("center") >= 0 && (x = ($$.currentWidth - textRectWidth) / 2)) : x = config.title_padding.left || 0, x;
  },

  /**
   * Returns the y attribute value of the title
   * @private
   * @returns {Number} y attribute value
   */
  yForTitle: function yForTitle() {
    var $$ = this;
    return ($$.config.title_padding.top || 0) + $$.getTextRect($$.title, config_classes.title).height;
  },

  /**
   * Get title padding
   * @private
   * @returns {Number} padding value
   */
  getTitlePadding: function getTitlePadding() {
    var $$ = this;
    return $$.yForTitle() + ($$.config.title_padding.bottom || 0);
  }
});
// CONCATENATED MODULE: ./src/internals/clip.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  initClip: function initClip() {
    var $$ = this; // MEMO: clipId needs to be unique because it conflicts when multiple charts exist

    // Define 'clip-path' attribute values
    $$.clipId = "".concat($$.datetimeId, "-clip"), $$.clipIdForXAxis = "".concat($$.clipId, "-xaxis"), $$.clipIdForYAxis = "".concat($$.clipId, "-yaxis"), $$.clipIdForGrid = "".concat($$.clipId, "-grid"), $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis), $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid);
  },
  getClipPath: function getClipPath(id) {
    var $$ = this,
        config = $$.config;
    if (!config.clipPath && /-clip$/.test(id) || !config.axis_x_clipPath && /-clip-xaxis$/.test(id) || !config.axis_y_clipPath && /-clip-yaxis$/.test(id)) return null;
    var isIE9 = !!win.navigator && win.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
    return "url(".concat(isIE9 ? "" : browser_doc.URL.split("#")[0], "#").concat(id, ")");
  },
  appendClip: function appendClip(parent, id) {
    return parent.append("clipPath").attr("id", id).append("rect");
  },
  getAxisClipX: function getAxisClipX(forHorizontal) {
    // axis line width + padding for left
    var left = Math.max(30, this.margin.left);
    return forHorizontal ? -(1 + left) : -(left - 1);
  },
  getAxisClipY: function getAxisClipY(forHorizontal) {
    return forHorizontal ? -20 : -this.margin.top;
  },
  getXAxisClipX: function getXAxisClipX() {
    var $$ = this;
    return $$.getAxisClipX(!$$.config.axis_rotated);
  },
  getXAxisClipY: function getXAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY(!$$.config.axis_rotated);
  },
  getYAxisClipX: function getYAxisClipX() {
    var $$ = this;
    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
  },
  getYAxisClipY: function getYAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY($$.config.axis_rotated);
  },
  getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
    var $$ = this,
        left = Math.max(30, $$.margin.left),
        right = Math.max(30, $$.margin.right);
    // width + axis line width + padding for left/right
    return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
  },
  getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
    // less than 20 is not enough to show the axis label 'outer' without legend
    return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20;
  },
  getXAxisClipWidth: function getXAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth(!$$.config.axis_rotated);
  },
  getXAxisClipHeight: function getXAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight(!$$.config.axis_rotated);
  },
  getYAxisClipWidth: function getYAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
  },
  getYAxisClipHeight: function getYAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight($$.config.axis_rotated);
  },
  updateXAxisTickClip: function updateXAxisTickClip() {
    var $$ = this,
        newXAxisHeight = $$.getHorizontalAxisHeight("x");

    if ($$.defs && !$$.clipXAxisTickTexts) {
      var clipId = "".concat($$.clipId, "-xaxisticktexts");
      $$.clipXAxisTickTexts = $$.appendClip($$.defs, clipId), $$.clipPathForXAxisTickTexts = $$.getClipPath(clipId), $$.clipIdForXAxisTickTexts = clipId;
    }

    !$$.config.axis_x_tick_multiline && $$.getAxisTickRotate("x") && newXAxisHeight !== $$.xAxisHeight && ($$.setXAxisTickClipWidth(), $$.setXAxisTickTextClipPathWidth()), $$.xAxisHeight = newXAxisHeight;
  },
  setXAxisTickClipWidth: function setXAxisTickClipWidth() {
    var $$ = this,
        config = $$.config,
        xAxisTickRotate = $$.getAxisTickRotate("x");

    if (!config.axis_x_tick_multiline && xAxisTickRotate) {
      var sinRotation = Math.sin(Math.PI / 180 * Math.abs(xAxisTickRotate));
      $$.xAxisTickClipPathMaxWidth = ($$.getHorizontalAxisHeight("x") - 20) / sinRotation;
    } else $$.xAxisTickClipPathMaxWidth = null;
  },
  setXAxisTickTextClipPathWidth: function setXAxisTickTextClipPathWidth() {
    var $$ = this;
    $$.svg && $$.svg.select("#".concat($$.clipIdForXAxisTickTexts, " rect")).attr("width", $$.xAxisTickClipPathMaxWidth).attr("height", 30);
  }
});
// CONCATENATED MODULE: ./src/internals/region.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
 // selection




extend(ChartInternal_ChartInternal.prototype, {
  initRegion: function initRegion() {
    var $$ = this;
    $$.region = $$.main.append("g").attr("clip-path", $$.clipPath).attr("class", config_classes.regions);
  },
  updateRegion: function updateRegion(duration) {
    var $$ = this,
        config = $$.config;
    // hide if arc type
    // select <g> element
    $$.region.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.mainRegion = $$.main.select(".".concat(config_classes.regions)).selectAll(".".concat(config_classes.region)).data(config.regions), $$.mainRegion.exit().transition().duration(duration).style("opacity", "0").remove(), $$.mainRegion = $$.mainRegion.enter().append("g").merge($$.mainRegion).attr("class", $$.classRegion.bind($$)), $$.mainRegion.append("rect").style("fill-opacity", "0");
  },
  redrawRegion: function redrawRegion(withTransition) {
    var $$ = this,
        regions = $$.mainRegion.select("rect");
    return regions = (withTransition ? regions.transition() : regions).attr("x", $$.regionX.bind($$)).attr("y", $$.regionY.bind($$)).attr("width", $$.regionWidth.bind($$)).attr("height", $$.regionHeight.bind($$)), [(withTransition ? regions.transition() : regions).style("fill-opacity", function (d) {
      return isValue(d.opacity) ? d.opacity : "0.1";
    }).on("end", function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this.parentNode).selectAll("rect:not([x])").remove();
    })];
  },
  getRegionXY: function getRegionXY(type, d) {
    var scale,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isX = type === "x",
        key = "start",
        pos = 0;
    return d.axis === "y" || d.axis === "y2" ? (!isX && (key = "end"), (isX ? isRotated : !isRotated) && key in d && (scale = $$[d.axis], pos = scale(d[key]))) : (isX ? !isRotated : isRotated) && key in d && (scale = $$.zoomScale || $$.x, pos = scale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), pos;
  },
  regionX: function regionX(d) {
    return this.getRegionXY("x", d);
  },
  regionY: function regionY(d) {
    return this.getRegionXY("y", d);
  },
  getRegionSize: function getRegionSize(type, d) {
    var scale,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isWidth = type === "width",
        start = $$[isWidth ? "regionX" : "regionY"](d),
        key = "end",
        end = $$[type];
    return d.axis === "y" || d.axis === "y2" ? (!isWidth && (key = "start"), (isWidth ? isRotated : !isRotated) && key in d && (scale = $$[d.axis], end = scale(d[key]))) : (isWidth ? !isRotated : isRotated) && key in d && (scale = $$.zoomScale || $$.x, end = scale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), end < start ? 0 : end - start;
  },
  regionWidth: function regionWidth(d) {
    return this.getRegionSize("width", d);
  },
  regionHeight: function regionHeight(d) {
    return this.getRegionSize("height", d);
  },
  isRegionOnX: function isRegionOnX(d) {
    return !d.axis || d.axis === "x";
  }
});
// CONCATENATED MODULE: ./src/interactions/drag.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Called when dragging.
   * Data points can be selected.
   * @private
   * @param {Object} mouse Object
   */
  drag: function drag(mouse) {
    var $$ = this,
        config = $$.config,
        main = $$.main;

    if (!$$.hasArcType() && config.data_selection_enabled && ( // do nothing if not selectable
    !config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple // skip when single selection because drag is used for multiple selection
    ) {
        var _$$$dragStart = _slicedToArray($$.dragStart, 2),
            sx = _$$$dragStart[0],
            sy = _$$$dragStart[1],
            _mouse = _slicedToArray(mouse, 2),
            mx = _mouse[0],
            my = _mouse[1],
            minX = Math.min(sx, mx),
            maxX = Math.max(sx, mx),
            minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my),
            maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);

        main.select(".".concat(config_classes.dragarea)).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).filter(function (d) {
          return config.data_selection_isselectable(d);
        }).each(function (d, i) {
          var toggle,
              shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
              isSelected = shape.classed(config_classes.SELECTED),
              isIncluded = shape.classed(config_classes.INCLUDED),
              isWithin = !1;

          if (shape.classed(config_classes.circle)) {
            var x = shape.attr("cx") * 1,
                y = shape.attr("cy") * 1;
            toggle = $$.togglePoint, isWithin = minX < x && x < maxX && minY < y && y < maxY;
          } else if (shape.classed(config_classes.bar)) {
            var _getPathBox = getPathBox(this),
                _x = _getPathBox.x,
                y = _getPathBox.y,
                width = _getPathBox.width,
                height = _getPathBox.height;

            toggle = $$.togglePath, isWithin = !(maxX < _x || _x + width < minX) && !(maxY < y || y + height < minY);
          } else // line/area selection not supported yet
            return;

          isWithin ^ isIncluded && (shape.classed(config_classes.INCLUDED, !isIncluded), shape.classed(config_classes.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
        });
      }
  },

  /**
   * Called when the drag starts.
   * Adds and Shows the drag area.
   * @private
   * @param {Object} mouse Object
   */
  dragstart: function dragstart(mouse) {
    var $$ = this,
        config = $$.config;
    $$.hasArcType() || !config.data_selection_enabled || ($$.dragStart = mouse, $$.main.select(".".concat(config_classes.chart)).append("rect").attr("class", config_classes.dragarea).style("opacity", "0.1"), $$.setDragStatus(!0));
  },

  /**
   * Called when the drag finishes.
   * Removes the drag area.
   * @private
   */
  dragend: function dragend() {
    var $$ = this,
        config = $$.config;
    $$.hasArcType() || !config.data_selection_enabled || ($$.main.select(".".concat(config_classes.dragarea)).transition().duration(100).style("opacity", "0").remove(), $$.main.selectAll(".".concat(config_classes.shape)).classed(config_classes.INCLUDED, !1), $$.setDragStatus(!1));
  },
  setDragStatus: function setDragStatus(isDragging) {
    this.dragging = isDragging;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-color","commonjs2":"d3-color","amd":"d3-color","root":"d3"}
var external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_ = __webpack_require__(12);

// CONCATENATED MODULE: ./src/internals/selection.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Select a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  selectPoint: function selectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        cx = (isRotated ? $$.circleY : $$.circleX).bind($$),
        cy = (isRotated ? $$.circleX : $$.circleY).bind($$),
        r = $$.pointSelectR.bind($$);
    // add selected-circle on low layer g
    callFn(config.data_onselected, $$.api, d, target.node()), $$.main.select(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(d.id))).selectAll(".".concat(config_classes.selectedCircle, "-").concat(i)).data([d]).enter().append("circle").attr("class", function () {
      return $$.generateClass(config_classes.selectedCircle, i);
    }).attr("cx", cx).attr("cy", cy).attr("stroke", $$.color).attr("r", function (d2) {
      return $$.pointSelectR(d2) * 1.4;
    }).transition().duration(100).attr("r", r);
  },

  /**
   * Unelect a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  unselectPoint: function unselectPoint(target, d, i) {
    var $$ = this;
    // remove selected-circle from low layer g
    callFn($$.config.data_onunselected, $$.api, d, target.node()), $$.main.select(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(d.id))).selectAll(".".concat(config_classes.selectedCircle, "-").concat(i)).transition().duration(100).attr("r", 0).remove();
  },

  /**
   * Toggles the selection of points
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  togglePoint: function togglePoint(selected, target, d, i) {
    var method = "".concat(selected ? "" : "un", "selectPoint");
    this[method](target, d, i);
  },

  /**
   * Select a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  selectPath: function selectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return Object(external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_["rgb"])($$.color(d)).brighter(.75);
    });
  },

  /**
   * Unelect a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  unselectPath: function unselectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onunselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return $$.color(d);
    });
  },

  /**
   * Toggles the selection of lines
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  togglePath: function togglePath(selected, target, d, i) {
    this["".concat(selected ? "" : "un", "selectPath")](target, d, i);
  },

  /**
   * Returns the toggle method of the target
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @returns {Function} toggle method
   */
  getToggle: function getToggle(that, d) {
    var $$ = this;
    return that.nodeName === "path" ? $$.togglePath : $$.isStepType(d) ? function () {} : // circle is hidden in step chart, so treat as within the click area
    $$.togglePoint;
  },

  /**
   * Toggles the selection of shapes
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  toggleShape: function toggleShape(that, d, i) {
    var toggledShape,
        $$ = this,
        config = $$.config,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that),
        isSelected = shape.classed(config_classes.SELECTED),
        toggle = $$.getToggle(that, d).bind($$);

    if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
      if (!config.data_selection_multiple) {
        var selector = ".".concat(config_classes.shapes);
        config.data_selection_grouped && (selector += $$.getTargetSelectorSuffix(d.id)), $$.main.selectAll(selector).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
          var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
          shape.classed(config_classes.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
        });
      }

      toggledShape && toggledShape.node() === shape.node() || (shape.classed(config_classes.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
    }
  }
});
// CONCATENATED MODULE: ./src/interactions/subchart.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the brush.
   * @private
   */
  initBrush: function initBrush() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    $$.brush = isRotated ? Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushY"])() : Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushX"])();

    // set "brush" event
    var lastDomain,
        timeout,
        brushHandler = function () {
      $$.redrawForBrush();
    },
        getBrushSize = function () {
      var brush = $$.svg.select(".".concat(config_classes.brush, " .overlay")),
          brushSize = {
        width: 0,
        height: 0
      };
      return brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), brushSize[isRotated ? "width" : "height"];
    };

    // set the brush extent
    $$.brush.on("start", function () {
      $$.inputType === "touch" && $$.hideTooltip(), brushHandler();
    }).on("brush", brushHandler).on("end", function () {
      lastDomain = $$.x.orgDomain();
    }), $$.brush.updateResize = function () {
      var _this = this;

      timeout && clearTimeout(timeout), timeout = setTimeout(function () {
        var selection = _this.getSelection();

        lastDomain && Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection.node()) && _this.move(selection, lastDomain.map($$.subX.orgScale()));
      }, 0);
    }, $$.brush.update = function () {
      var extent = this.extent()();
      return extent[1].filter(function (v) {
        return isNaN(v);
      }).length === 0 && $$.context && $$.context.select(".".concat(config_classes.brush)).call(this), this;
    }, $$.brush.scale = function (scale) {
      var h = config.subchart_size_height || getBrushSize(),
          extent = $$.getExtent();
      // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
      // when extent updates, brush selection also be re-applied
      // https://github.com/d3/d3/issues/2918
      !extent && scale.range ? extent = [[0, 0], [scale.range()[1], h]] : isArray(extent) && (extent = extent.map(function (v, i) {
        return [v, i > 0 ? h : i];
      })), isRotated && extent[1].reverse(), this.extent(extent), this.update();
    }, $$.brush.getSelection = function () {
      return $$.context ? $$.context.select(".".concat(config_classes.brush)) : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])([]);
    };
  },

  /**
   * Initialize the subchart.
   * @private
   */
  initSubchart: function initSubchart() {
    var $$ = this,
        config = $$.config,
        visibility = config.subchart_show ? "visible" : "hidden",
        clipId = "".concat($$.clipId, "-subchart"),
        clipPath = $$.getClipPath(clipId);
    $$.clipIdForSubchart = clipId, $$.appendClip($$.defs, clipId), $$.initBrush(), $$.context = $$.svg.append("g").attr("transform", $$.getTranslate("context"));
    var context = $$.context;
    // Define g for chart area
    // Define g for bar chart area
    // Define g for line chart area
    // Add extent rect for Brush
    // ATTENTION: This must be called AFTER chart added
    // Add Axis
    context.style("visibility", visibility), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.chart), $$.hasType("bar") && context.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartBars), context.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartLines), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.brush).call($$.brush), $$.axes.subx = context.append("g").attr("class", config_classes.axisX).attr("transform", $$.getTranslate("subx")).attr("clip-path", config.axis_rotated ? "" : $$.clipPathForXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
  },

  /**
   * Update sub chart
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
    var $$ = this,
        context = $$.context,
        config = $$.config,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$);

    if (config.subchart_show) {
      // -- Bar --//
      var contextBarUpdate = context.select(".".concat(config_classes.chartBars)).selectAll(".".concat(config_classes.chartBar)).data(targets).attr("class", classChartBar),
          contextBarEnter = contextBarUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(contextBarUpdate);
      contextBarEnter.append("g").attr("class", classBars);
      // -- Line --//
      var contextLineUpdate = context.select(".".concat(config_classes.chartLines)).selectAll(".".concat(config_classes.chartLine)).data(targets).attr("class", classChartLine),
          contextLineEnter = contextLineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(contextLineUpdate);
      // Lines for each data
      // Area
      // -- Brush --//
      contextLineEnter.append("g").attr("class", classLines), $$.hasType("area") && contextLineEnter.append("g").attr("class", classAreas), context.selectAll(".".concat(config_classes.brush, " rect")).attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? $$.width2 : $$.height2);
    }
  },

  /**
   * Update the bar of the sub chart
   * @private
   * @param {Object} durationForExit
   */
  updateBarForSubchart: function updateBarForSubchart(durationForExit) {
    var $$ = this;
    $$.contextBar = $$.context.selectAll(".".concat(config_classes.bars)).selectAll(".".concat(config_classes.bar)).data($$.barData.bind($$)), $$.contextBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextBar = $$.contextBar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge($$.contextBar).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the bar of the subchart
   * @private
   * @param {String} path in subchart bar
   * @param {Boolean} whether or not to transition.
   * @param {Number} transition duration
   */
  redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
    var contextBar = withTransition ? this.contextBar.transition(getRandom()).duration(duration) : this.contextBar;
    contextBar.attr("d", drawBarOnSub).style("opacity", "1");
  },

  /**
   * Update the line of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateLineForSubchart: function updateLineForSubchart(durationForExit) {
    var $$ = this;
    $$.contextLine = $$.context.selectAll(".".concat(config_classes.lines)).selectAll(".".concat(config_classes.line)).data($$.lineData.bind($$)), $$.contextLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextLine = $$.contextLine.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge($$.contextLine).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the line of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
    var contextLine = withTransition ? this.contextLine.transition(getRandom()).duration(duration) : this.contextLine;
    contextLine.attr("d", drawLineOnSub).style("opacity", "1");
  },

  /**
   * Update the area of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
    var $$ = this;
    $$.contextArea = $$.context.selectAll(".".concat(config_classes.areas)).selectAll(".".concat(config_classes.area)).data($$.lineData.bind($$)), $$.contextArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextArea = $$.contextArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
      return $$.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($$.contextArea).style("opacity", "0");
  },

  /**
   * Redraw the area of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
    var contextArea = withTransition ? this.contextArea.transition(getRandom()).duration(duration) : this.contextArea;
    contextArea.attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.orgAreaOpacity);
  },

  /**
   * Redraw subchart.
   * @private
   * @param {Boolean} withSubchart whether or not to show subchart
   * @param {Number} duration duration
   * @param {Object} shape Shape's info
   */
  redrawSubchart: function redrawSubchart(withSubchart, duration, shape) {
    var $$ = this,
        config = $$.config;
    $$.context.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].type === "zoom" && $$.brush.update(), withSubchart && (!brushEmpty($$) && $$.brush.update(), Object.keys(shape.type).forEach(function (v) {
      var name = capitalize(v),
          draw = $$["generateDraw".concat(name)](shape.indices[v], !0);
      $$["update".concat(name, "ForSubchart")](duration), $$["redraw".concat(name, "ForSubchart")](draw, duration, duration);
    })));
  },

  /**
   * Redraw the brush.
   * @private
   */
  redrawForBrush: function redrawForBrush() {
    var $$ = this;
    $$.redraw({
      withTransition: !1,
      withY: $$.config.zoom_rescale,
      withSubchart: !1,
      withUpdateXDomain: !0,
      withDimension: !1
    }), $$.config.subchart_onbrush.call($$.api, $$.x.orgDomain());
  },

  /**
   * Transform context
   * @private
   * @param {Boolean} indicates transition is enabled
   * @param {Object} The return value of the generateTransitions method of Axis.
   */
  transformContext: function transformContext(withTransition, transitions) {
    var subXAxis,
        $$ = this;
    transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = $$.context.select(".".concat(config_classes.axisX)), withTransition && (subXAxis = subXAxis.transition())), $$.context.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subx"));
  },

  /**
   * Get extent value
   * @private
   * @returns {Array} default extent
   */
  getExtent: function getExtent() {
    var $$ = this,
        extent = $$.config.axis_x_extent;
    return extent && (isFunction(extent) ? extent = extent($$.getXDomain($$.data.targets), $$.subX) : $$.isTimeSeries() && extent.every(isNaN) && (extent = extent.map(function (v) {
      return $$.subX($$.parseDate(v));
    }))), extent;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-zoom","commonjs2":"d3-zoom","amd":"d3-zoom","root":"d3"}
var external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_ = __webpack_require__(13);

// CONCATENATED MODULE: ./src/interactions/zoom.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */







extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize zoom.
   * @private
   */
  initZoom: function initZoom() {
    var $$ = this;
    $$.zoomScale = null, $$.generateZoom(), $$.initZoomBehaviour();
  },

  /**
   * Bind zoom event
   * @param {Boolean} bind Weather bind or unbound
   * @private
   */
  bindZoomEvent: function bindZoomEvent() {
    var bind = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0],
        $$ = this,
        zoomEnabled = $$.config.zoom_enabled;
    $$.redrawEventRect();
    var eventRects = $$.main.select(".".concat(config_classes.eventRects));
    zoomEnabled && bind ? !$$.config.subchart_show && $$.bindZoomOnEventRect(eventRects, zoomEnabled.type) : bind === !1 && ($$.api.unzoom(), eventRects.on(".zoom", null).on(".drag", null));
  },

  /**
   * Generate zoom
   * @private
   */
  generateZoom: function generateZoom() {
    var $$ = this,
        config = $$.config,
        zoom = Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoom"])().duration(0).on("start", $$.onZoomStart.bind($$)).on("zoom", $$.onZoom.bind($$)).on("end", $$.onZoomEnd.bind($$));
    // get zoom extent

    /**
     * Update scale according zoom transform value
     * @param {Object} transform
     * @private
     */
    zoom.orgScaleExtent = function () {
      var extent = config.zoom_extent || [1, 10];
      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
    }, zoom.updateScaleExtent = function () {
      var ratio = diffDomain($$.x.orgDomain()) / diffDomain($$.getZoomDomain()),
          extent = this.orgScaleExtent();
      return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
    }, zoom.updateTransformScale = function (transform) {
      $$.orgXScale && $$.orgXScale.range($$.x.range());
      // rescale from the original scale
      var newScale = transform[config.axis_rotated ? "rescaleY" : "rescaleX"]($$.orgXScale || $$.x),
          domain = $$.trimXDomain(newScale.domain()),
          rescale = config.zoom_rescale;
      newScale.domain(domain, $$.orgXDomain), $$.zoomScale = $$.getCustomizedScale(newScale), $$.xAxis.scale($$.zoomScale), rescale && (!$$.orgXScale && ($$.orgXScale = $$.x.copy()), $$.x.domain(domain));
    }, $$.zoom = zoom;
  },

  /**
   * 'start' event listener
   * @private
   */
  onZoomStart: function onZoomStart() {
    var $$ = this,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    event && ($$.zoom.startEvent = event, callFn($$.config.zoom_onzoomstart, $$.api, event));
  },

  /**
   * 'zoom' event listener
   * @private
   */
  onZoom: function onZoom() {
    var $$ = this,
        config = $$.config,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
        sourceEvent = event.sourceEvent;

    if (config.zoom_enabled && event.sourceEvent && $$.filterTargetsToShow($$.data.targets).length !== 0 && ($$.zoomScale || !(sourceEvent.type.indexOf("touch") > -1) || sourceEvent.touches.length !== 1)) {
      var isMousemove = sourceEvent.type === "mousemove",
          isZoomOut = sourceEvent.wheelDelta < 0,
          transform = event.transform;
      !isMousemove && isZoomOut && $$.x.domain().every(function (v, i) {
        return v !== $$.orgXDomain[i];
      }) && $$.x.domain($$.orgXDomain), $$.zoom.updateTransformScale(transform), $$.isCategorized() && $$.x.orgDomain()[0] === $$.orgXDomain[0] && $$.x.domain([$$.orgXDomain[0] - 1e-10, $$.x.orgDomain()[1]]), $$.redraw({
        withTransition: !1,
        withY: config.zoom_rescale,
        withSubchart: !1,
        withEventRect: !1,
        withDimension: !1
      }), $$.cancelClick = isMousemove, callFn(config.zoom_onzoom, $$.api, $$.zoomScale.domain());
    }
  },

  /**
   * 'end' event listener
   * @private
   */
  onZoomEnd: function onZoomEnd() {
    var $$ = this,
        startEvent = $$.zoom.startEvent,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    startEvent && startEvent.type.indexOf("touch") > -1 && (startEvent = startEvent.changedTouches[0], event = event.changedTouches[0]);
    // if click, do nothing. otherwise, click interaction will be canceled.
    !startEvent || event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), callFn($$.config.zoom_onzoomend, $$.api, $$[$$.zoomScale ? "zoomScale" : "subX"].domain()));
  },

  /**
   * Get zoom domain
   * @returns {Array} zoom domain
  	 * @private
   */
  getZoomDomain: function getZoomDomain() {
    var $$ = this,
        config = $$.config,
        _$$$orgXDomain = _slicedToArray($$.orgXDomain, 2),
        min = _$$$orgXDomain[0],
        max = _$$$orgXDomain[1];

    return isDefined(config.zoom_x_min) && (min = getMinMax("min", [min, config.zoom_x_min])), isDefined(config.zoom_x_max) && (max = getMinMax("max", [max, config.zoom_x_max])), [min, max];
  },

  /**
   * Update zoom
   * @param {Boolean} force Force unzoom
   * @private
   */
  updateZoom: function updateZoom(force) {
    var $$ = this;

    if ($$.zoomScale) {
      var zoomDomain = $$.zoomScale.domain(),
          xDomain = $$.subX.domain(),
          delta = .015,
          isfullyShown = (zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta);
      (force || isfullyShown) && ($$.xAxis.scale($$.subX), $$.x.domain($$.subX.orgDomain()), $$.zoomScale = null);
    }
  },

  /**
   * Attach zoom event on <rect>
   * @private
   */
  bindZoomOnEventRect: function bindZoomOnEventRect(eventRects, type) {
    var $$ = this,
        behaviour = type === "drag" ? $$.zoomBehaviour : $$.zoom;
    eventRects.call(behaviour).on("dblclick.zoom", null);
  },

  /**
   * Initialize the drag behaviour used for zooming.
   * @private
   */
  initZoomBehaviour: function initZoomBehaviour() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        start = 0,
        end = 0,
        zoomRect = null,
        prop = {
      axis: isRotated ? "y" : "x",
      attr: isRotated ? "height" : "width",
      index: isRotated ? 1 : 0
    };
    $$.zoomBehaviour = Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().clickDistance(4).on("start", function () {
      $$.setDragStatus(!0), zoomRect || (zoomRect = $$.main.append("rect").attr("clip-path", $$.clipPath).attr("class", config_classes.zoomBrush).attr("width", isRotated ? $$.width : 0).attr("height", isRotated ? 0 : $$.height)), start = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], end = start, zoomRect.attr(prop.axis, start).attr(prop.attr, 0), $$.onZoomStart();
    }).on("drag", function () {
      end = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], zoomRect.attr(prop.axis, Math.min(start, end)).attr(prop.attr, Math.abs(end - start));
    }).on("end", function () {
      var _ref,
          scale = $$.zoomScale || $$.x;

      if ($$.setDragStatus(!1), zoomRect.attr(prop.axis, 0).attr(prop.attr, 0), start > end && (_ref = [end, start], start = _ref[0], end = _ref[1], _ref), start < 0 && (end += Math.abs(start), start = 0), start !== end) $$.api.zoom([start, end].map(function (v) {
        return scale.invert(v);
      })), $$.onZoomEnd();else if ($$.isMultipleX()) $$.clickHandlerForMultipleXS.bind(this)($$);else {
        var _event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent || external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
            _ref2 = "clientX" in _event ? [_event.clientX, _event.clientY] : [_event.x, _event.y],
            _ref3 = _slicedToArray(_ref2, 2),
            x = _ref3[0],
            y = _ref3[1],
            target = browser_doc.elementFromPoint(x, y);

        $$.clickHandlerForSingleX.bind(target)(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum(), $$);
      }
    });
  },
  setZoomResetButton: function setZoomResetButton() {
    var $$ = this,
        config = $$.config,
        resetButton = config.zoom_resetButton;
    resetButton && config.zoom_enabled.type === "drag" && ($$.zoom.resetBtn ? $$.zoom.resetBtn.style("display", null) : $$.zoom.resetBtn = $$.selectChart.append("div").classed(config_classes.button, !0).append("span").on("click", function () {
      isFunction(resetButton.onclick) && resetButton.onclick(this), $$.api.unzoom.call($$);
    }).classed(config_classes.buttonZoomReset, !0).text(resetButton.text || "Reset Zoom"));
  }
});
// CONCATENATED MODULE: ./src/internals/color.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/**
 * Set pattern's background color
 * (it adds a <rect> element to simulate bg-color)
 * @param {SVGPatternElement} pattern SVG pattern element
 * @param {String} color Color string
 * @param {String} id ID to be set
 * @return {{id: string, node: SVGPatternElement}}
 * @private
 */

var colorizePattern = function (pattern, color, id) {
  var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(pattern.cloneNode(!0));
  return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
    id: id,
    node: node.node()
  };
},
    schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Replacement of d3.schemeCategory10.
// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Get color pattern from CSS file
   * CSS should be defined as: background-image: url("#00c73c;#fa7171; ...");
   * @return {Array}
   * @private
   */
  getColorFromCss: function getColorFromCss() {
    var body = browser_doc.body,
        pattern = body["__colorPattern__"];

    if (!pattern) {
      var span = browser_doc.createElement("span");
      span.className = config_classes.colorPattern, span.style.display = "none", body.appendChild(span);
      var content = win.getComputedStyle(span).backgroundImage;
      span.parentNode.removeChild(span), content.indexOf(";") > -1 && (pattern = content.replace(/url[^#]*|["'()]|(\s|%20)/g, "").split(";").map(function (v) {
        return v.trim().replace(/[\"'\s]/g, "");
      }).filter(Boolean), body["__colorPattern__"] = pattern);
    }

    return pattern;
  },
  generateColor: function generateColor() {
    var $$ = this,
        config = $$.config,
        colors = config.data_colors,
        callback = config.data_color,
        ids = [],
        pattern = notEmpty(config.color_pattern) ? config.color_pattern : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleOrdinal"])($$.getColorFromCss() || schemeCategory10).range(),
        originalColorPattern = pattern;

    if (isFunction(config.color_tiles)) {
      var tiles = config.color_tiles(),
          colorizedPatterns = pattern.map(function (p, index) {
        var color = p.replace(/[#\(\)\s,]/g, ""),
            id = "".concat($$.datetimeId, "-pattern-").concat(color, "-").concat(index);
        return colorizePattern(tiles[index % tiles.length], p, id);
      }); // Add background color to patterns

      pattern = colorizedPatterns.map(function (p) {
        return "url(#".concat(p.id, ")");
      }), $$.patterns = colorizedPatterns;
    }

    return function (d) {
      var color,
          id = d.id || d.data && d.data.id || d,
          isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !$$.config.data_types[id];
      return isFunction(colors[id]) ? color = colors[id](d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), isFunction(callback) ? callback(color, d) : color;
    };
  },
  generateLevelColor: function generateLevelColor() {
    var $$ = this,
        config = $$.config,
        colors = config.color_pattern,
        threshold = config.color_threshold,
        asValue = threshold.unit === "value",
        max = threshold.max || 100,
        values = threshold.values && threshold.values.length ? threshold.values : [];
    return notEmpty(threshold) ? function (value) {
      var v = asValue ? value : value * 100 / max,
          color = colors[colors.length - 1];

      for (var i = 0, l = values.length; i < l; i++) if (v <= values[i]) {
        color = colors[i];
        break;
      }

      return color;
    } : null;
  },

  /**
   * Set the data over color.
   * When is out, will restore in its previous color value
   * @param {Boolean} isOver true: set overed color, false: restore
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  setOverColor: function setOverColor(isOver, d) {
    var $$ = this,
        config = $$.config,
        onover = config.color_onover,
        color = isOver ? onover : $$.color;
    isObject(color) ? color = function (_ref) {
      var id = _ref.id;
      return id in onover ? onover[id] : $$.color(id);
    } : isString(color) && (color = function () {
      return onover;
    }), isObject(d) ? $$.main.selectAll(".".concat(config_classes.arc).concat($$.getTargetSelectorSuffix(d.id))).style("fill", color(d)) : $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).style("fill", color);
  }
});
// CONCATENATED MODULE: ./src/internals/format.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



var getFormat = function ($$, typeValue, v) {
  var config = $$.config,
      type = "axis_".concat(typeValue, "_tick_format"),
      format = config[type] ? config[type] : $$.defaultValueFormat;
  return format(v);
};

extend(ChartInternal_ChartInternal.prototype, {
  getYFormat: function getYFormat(forArc) {
    var $$ = this,
        formatForY = $$.yFormat,
        formatForY2 = $$.y2Format;
    return forArc && !$$.hasType("gauge") && (formatForY = $$.defaultArcValueFormat, formatForY2 = $$.defaultArcValueFormat), function (v, ratio, id) {
      var format = $$.axis.getId(id) === "y2" ? formatForY2 : formatForY;
      return format.call($$, v, ratio);
    };
  },
  yFormat: function yFormat(v) {
    return getFormat(this, "y", v);
  },
  y2Format: function y2Format(v) {
    return getFormat(this, "y2", v);
  },
  defaultValueFormat: function defaultValueFormat(v) {
    return isValue(v) ? +v : "";
  },
  defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
    return "".concat((ratio * 100).toFixed(1), "%");
  },
  dataLabelFormat: function dataLabelFormat(targetId) {
    var $$ = this,
        dataLabels = $$.config.data_labels,
        defaultFormat = function (v) {
      return isValue(v) ? +v : "";
    },
        format = defaultFormat;

    return isFunction(dataLabels.format) ? format = dataLabels.format : isObjectType(dataLabels.format) && (dataLabels.format[targetId] ? format = dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : format = function () {
      return "";
    }), format;
  }
});
// CONCATENATED MODULE: ./src/internals/cache.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Add cache
   * @param {String} key
   * @param {*} value
   * @param {Boolean} isDataType
   * @private
   */
  addCache: function addCache(key, value) {
    var isDataType = !!(arguments.length > 2 && arguments[2] !== undefined) && arguments[2];
    this.cache[key] = isDataType ? this.cloneTarget(value) : value;
  },

  /**
   * Remove cache
   * @param {String|Array} key
   * @private
   */
  removeCache: function removeCache(key) {
    var _this = this;

    toArray(key).forEach(function (v) {
      return delete _this.cache[v];
    });
  },

  /**
   * Get cahce
   * @param {String|Array} key
   * @param {Boolean} isDataType
   * @return {*}
   * @private
   */
  getCache: function getCache(key) {
    var isDataType = !!(arguments.length > 1 && arguments[1] !== undefined) && arguments[1];

    if (isDataType) {
      var targets = [];

      for (var id, i = 0; id = key[i]; i++) id in this.cache && targets.push(this.cloneTarget(this.cache[id]));

      return targets;
    }

    return this.cache[key] || null;
  },

  /**
   * reset cached data
   * @param {Boolean} all true: reset all data, false: reset only '$' prefixed key data
   * @private
  	 */
  resetCache: function resetCache(all) {
    var $$ = this;

    for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
  }
});
// CONCATENATED MODULE: ./src/internals/class.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  generateClass: function generateClass(prefix, targetId) {
    return " ".concat(prefix, " ").concat(prefix + this.getTargetSelectorSuffix(targetId));
  },
  classText: function classText(d) {
    return this.generateClass(config_classes.text, d.index);
  },
  classTexts: function classTexts(d) {
    return this.generateClass(config_classes.texts, d.id);
  },
  classShape: function classShape(d) {
    return this.generateClass(config_classes.shape, d.index);
  },
  classShapes: function classShapes(d) {
    return this.generateClass(config_classes.shapes, d.id);
  },
  generateExtraLineClass: function generateExtraLineClass() {
    var $$ = this,
        classes = $$.config.line_classes || [],
        ids = [];
    return function (d) {
      var id = d.id || d.data && d.data.id || d;
      return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
    };
  },
  classLine: function classLine(d) {
    return this.classShape(d) + this.generateClass(config_classes.line, d.id);
  },
  classLines: function classLines(d) {
    return this.classShapes(d) + this.generateClass(config_classes.lines, d.id);
  },
  classCircle: function classCircle(d) {
    return this.classShape(d) + this.generateClass(config_classes.circle, d.index);
  },
  classCircles: function classCircles(d) {
    return this.classShapes(d) + this.generateClass(config_classes.circles, d.id);
  },
  classBar: function classBar(d) {
    return this.classShape(d) + this.generateClass(config_classes.bar, d.index);
  },
  classBars: function classBars(d) {
    return this.classShapes(d) + this.generateClass(config_classes.bars, d.id);
  },
  classArc: function classArc(d) {
    return this.classShape(d.data) + this.generateClass(config_classes.arc, d.data.id);
  },
  classArcs: function classArcs(d) {
    return this.classShapes(d.data) + this.generateClass(config_classes.arcs, d.data.id);
  },
  classArea: function classArea(d) {
    return this.classShape(d) + this.generateClass(config_classes.area, d.id);
  },
  classAreas: function classAreas(d) {
    return this.classShapes(d) + this.generateClass(config_classes.areas, d.id);
  },
  classRegion: function classRegion(d, i) {
    return "".concat(this.generateClass(config_classes.region, i), " ").concat("class" in d ? d["class"] : "");
  },
  classEvent: function classEvent(d) {
    return this.generateClass(config_classes.eventRect, d.index);
  },
  classTarget: function classTarget(id) {
    var additionalClassSuffix = this.config.data_classes[id],
        additionalClass = "";
    return additionalClassSuffix && (additionalClass = " ".concat(config_classes.target, "-").concat(additionalClassSuffix)), this.generateClass(config_classes.target, id) + additionalClass;
  },
  classFocus: function classFocus(d) {
    return this.classFocused(d) + this.classDefocused(d);
  },
  classFocused: function classFocused(d) {
    return " ".concat(this.focusedTargetIds.indexOf(d.id) >= 0 ? config_classes.focused : "");
  },
  classDefocused: function classDefocused(d) {
    return " ".concat(this.defocusedTargetIds.indexOf(d.id) >= 0 ? config_classes.defocused : "");
  },
  classChartText: function classChartText(d) {
    return config_classes.chartText + this.classTarget(d.id);
  },
  classChartLine: function classChartLine(d) {
    return config_classes.chartLine + this.classTarget(d.id);
  },
  classChartBar: function classChartBar(d) {
    return config_classes.chartBar + this.classTarget(d.id);
  },
  classChartArc: function classChartArc(d) {
    return config_classes.chartArc + this.classTarget(d.data.id);
  },
  classChartRadar: function classChartRadar(d) {
    return config_classes.chartRadar + this.classTarget(d.id);
  },
  getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
    return targetId || targetId === 0 ? "-".concat(targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
  },
  selectorTarget: function selectorTarget(id, prefix) {
    return "".concat(prefix || "", ".").concat(config_classes.target + this.getTargetSelectorSuffix(id));
  },
  selectorTargets: function selectorTargets(idsValue, prefix) {
    var $$ = this,
        ids = idsValue || [];
    return ids.length ? ids.map(function (id) {
      return $$.selectorTarget(id, prefix);
    }) : null;
  },
  selectorLegend: function selectorLegend(id) {
    return ".".concat(config_classes.legendItem + this.getTargetSelectorSuffix(id));
  },
  selectorLegends: function selectorLegends(ids) {
    var $$ = this;
    return ids && ids.length ? ids.map(function (id) {
      return $$.selectorLegend(id);
    }) : null;
  }
});
// CONCATENATED MODULE: ./src/api/api.focus.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(Chart_Chart.prototype, {
  /**
   * This API highlights specified targets and fade out the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
   * @method focus
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIdsValue Target ids to be highlighted.
   * @example
   *  // data1 will be highlighted and the others will be faded out
   *  chart.focus("data1");
   *
   * // data1 and data2 will be highlighted and the others will be faded out
   * chart.focus(["data1", "data2"]);
   *
   * // all targets will be highlighted
   * chart.focus();
   */
  focus: function focus(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    this.revert(), this.defocus(), candidates.classed(config_classes.focused, !0).classed(config_classes.defocused, !1), $$.hasArcType() && ($$.expandArc(targetIds), $$.hasType("gauge") && $$.markOverlapped(targetIdsValue, $$, ".".concat(config_classes.gaugeValue))), $$.toggleFocusLegend(targetIds, !0), $$.focusedTargetIds = targetIds, $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },

  /**
   * This API fades out specified targets and reverts the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
   * @method defocus
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be faded out.
   * @example
   * // data1 will be faded out and the others will be reverted.
   * chart.defocus("data1");
   *
   * // data1 and data2 will be faded out and the others will be reverted.
   * chart.defocus(["data1", "data2"]);
   *
   * // all targets will be faded out.
   * chart.defocus();
   */
  defocus: function defocus(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !0), $$.hasArcType() && ($$.unexpandArc(targetIds), $$.hasType("gauge") && $$.undoMarkOverlapped($$, ".".concat(config_classes.gaugeValue))), $$.toggleFocusLegend(targetIds, !1), $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    }), $$.defocusedTargetIds = targetIds;
  },

  /**
   * This API reverts specified targets.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
   * @method revert
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be reverted
   * @example
   * // data1 will be reverted.
   * chart.revert("data1");
   *
   * // data1 and data2 will be reverted.
   * chart.revert(["data1", "data2"]);
   *
   * // all targets will be reverted.
   * chart.revert();
   */
  revert: function revert(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds));
    // should be for all targets
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), $$.config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused);
    }).classed(config_classes.legendItemFocused, !1)), $$.focusedTargetIds = [], $$.defocusedTargetIds = [];
  }
});
// CONCATENATED MODULE: ./src/api/api.show.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Show/Hide data series
   * @private
   */
  _showHide: function _showHide(show, targetIdsValue, options) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue);
    $$["".concat(show ? "remove" : "add", "HiddenTargetIds")](targetIds);
    var targets = $$.svg.selectAll($$.selectorTargets(targetIds)),
        opacity = show ? "1" : "0";
    targets.transition().style("opacity", opacity, "important").call($$.endall, function () {
      targets.style("opacity", null).style("opacity", opacity);
    }), options.withLegend && $$["".concat(show ? "show" : "hide", "Legend")](targetIds), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    });
  },

  /**
   * Show data series on chart
   * @method show
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // show 'data1'
   * chart.show("data1");
   *
   * // show 'data1' and 'data3'
   * chart.show(["data1", "data3"]);
   */
  show: function show(targetIdsValue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this._showHide(!0, targetIdsValue, options);
  },

  /**
   * Hide data series from chart
   * @method hide
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // hide 'data1'
   * chart.hide("data1");
   *
   * // hide 'data1' and 'data3'
   * chart.hide(["data1", "data3"]);
   */
  hide: function hide(targetIdsValue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this._showHide(!1, targetIdsValue, options);
  },

  /**
   * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
   * @method toggle
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // toggle 'data1'
   * chart.toggle("data1");
   *
   * // toggle 'data1' and 'data3'
   * chart.toggle(["data1", "data3"]);
   */
  toggle: function toggle(targetIds) {
    var _this = this,
        options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        $$ = this.internal,
        targets = {
      show: [],
      hide: []
    };

    // sort show & hide target ids
    // perform show & hide task separately
    // https://github.com/naver/billboard.js/issues/454
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      return targets[$$.isTargetToShow(id) ? "hide" : "show"].push(id);
    }), targets.show.length && this.show(targets.show, options), targets.hide.length && setTimeout(function () {
      return _this.hide(targets.hide, options);
    }, 0);
  }
});
// CONCATENATED MODULE: ./src/api/api.zoom.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Check if the given domain is within zoom range
 * @param {Array} domain
 * @return {Boolean}
 * @private
 */

var withinRange = function (domain, range) {
  var _range = _slicedToArray(range, 2),
      min = _range[0],
      max = _range[1];

  return domain.every(function (v, i) {
    return i === 0 ? v >= min : v <= max;
  });
},
    api_zoom_zoom = function (domainValue) {
  var resultDomain,
      $$ = this.internal,
      domain = domainValue;

  if ($$.config.zoom_enabled && domain && withinRange(domain, $$.getZoomDomain())) {
    var isTimeSeries = $$.isTimeSeries();

    if (isTimeSeries && (domain = domain.map(function (x) {
      return $$.parseDate(x);
    })), $$.config.subchart_show) {
      var xScale = $$.zoomScale || $$.x;
      $$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
    } else $$.x.domain(domain), $$.zoomScale = $$.x, $$.xAxis.scale($$.zoomScale), resultDomain = $$.zoomScale.orgDomain();

    $$.redraw({
      withTransition: !0,
      withY: $$.config.zoom_rescale,
      withDimension: !1
    }), $$.setZoomResetButton(), callFn($$.config.zoom_onzoom, $$.api, resultDomain);
  } else resultDomain = $$.zoomScale ? $$.zoomScale.domain() : $$.x.orgDomain();

  return resultDomain;
};
/**
 * Zoom by giving x domain.
 * - **NOTE:**
 *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain. To get the initial state, [.unzoom()](#unzoom) should be called.
 *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.
 * @method zoom
 * @instance
 * @memberof Chart
 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
 * @return {Array} domain value in array
 * @example
 *  // Zoom to specified domain
 *  chart.zoom([10, 20]);
 *
 *  // Get the current zoomed domain
 *  chart.zoom();
 */


extend(api_zoom_zoom, {
  /**
   * Enable and disable zooming.
   * @method zoomenable
   * @instance
   * @memberof Chart
   * @param {String|Boolean} enabled Possible string values are "wheel" or "drag". If enabled is true, "wheel" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.
   * @example
   *  // Enable zooming using the mouse wheel
   *  chart.zoom.enable(true);
   *  // Or
   *  chart.zoom.enable("wheel");
   *
   *  // Enable zooming by dragging
   *  chart.zoom.enable("drag");
   *
   *  // Disable zooming
   *  chart.zoom.enable(false);
   */
  enable: function enable() {
    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "wheel",
        $$ = this.internal,
        config = $$.config,
        enableType = enabled;
    enabled && (enableType = isString(enabled) && /^(drag|wheel)$/.test(enabled) ? {
      type: enabled
    } : enabled), config.zoom_enabled = enableType, $$.zoom ? enabled === !1 && $$.bindZoomEvent(!1) : ($$.initZoom(), $$.bindZoomEvent()), $$.updateAndRedraw();
  },

  /**
   * Set or get x Axis maximum zoom range value
   * @method zoommax
   * @instance
   * @memberof Chart
   * @param {Number} [max] maximum value to set for zoom
   * @return {Number} zoom max value
   * @example
   *  // Set maximum range value
   *  chart.zoom.max(20);
   */
  max: function max(_max) {
    var $$ = this.internal,
        config = $$.config;
    return (_max === 0 || _max) && (config.zoom_x_max = getMinMax("max", [$$.orgXDomain[1], _max])), config.zoom_x_max;
  },

  /**
   * Set or get x Axis minimum zoom range value
   * @method zoommin
   * @instance
   * @memberof Chart
   * @param {Number} [min] minimum value to set for zoom
   * @return {Number} zoom min value
   * @example
   *  // Set minimum range value
   *  chart.zoom.min(-1);
   */
  min: function min(_min) {
    var $$ = this.internal,
        config = $$.config;
    return (_min === 0 || _min) && (config.zoom_x_min = getMinMax("min", [$$.orgXDomain[0], _min])), config.zoom_x_min;
  },

  /**
   * Set zoom range
   * @method zoomrange
   * @instance
   * @memberof Chart
   * @param {Object} [range]
   * @return {Object} zoom range value
   * {
   *   min: 0,
   *   max: 100
   * }
   * @example
   *  chart.zoom.range({
   *      min: 10,
   *      max: 100
   *  });
   */
  range: function range(_range2) {
    var zoom = this.zoom;

    if (isObject(_range2)) {
      var min = _range2.min,
          max = _range2.max;
      isDefined(min) && zoom.min(min), isDefined(max) && zoom.max(max);
    }

    return {
      min: zoom.min(),
      max: zoom.max()
    };
  }
}), extend(Chart_Chart.prototype, {
  zoom: api_zoom_zoom,

  /**
   * Unzoom zoomed area
   * @method unzoom
   * @instance
   * @memberof Chart
   * @example
   *  chart.unzoom();
   */
  unzoom: function unzoom() {
    var $$ = this.internal,
        config = $$.config;

    if ($$.zoomScale) {
      config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.updateZoom(!0), $$.zoom.resetBtn && $$.zoom.resetBtn.style("display", "none");
      // reset transform
      var eventRects = $$.main.select(".".concat(config_classes.eventRects));
      Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomTransform"])(eventRects.node()) !== external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"] && $$.zoom.transform(eventRects, external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.redraw({
        withTransition: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withY: config.zoom_rescale
      });
    }
  }
});
// CONCATENATED MODULE: ./src/api/api.load.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Load data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   *   - unload should be used if some data needs to be unloaded simultaneously.
   *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
   *   - done will be called after data loaded, but it's not after rendering.
   *     It's because rendering will finish after some transition and there is some time lag between loading and rendering
   * @method load
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Description |
   *    | --- | --- |
   *    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
   *    | data | Data objects to be loaded. Checkout the example. |
   *    | names | Same as data.names() |
   *    | xs | Same as data.xs option  |
   *    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
   *    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
   *    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
   *    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
   *    | headers |  Set request header if loading via `data.url`.<br>@see [dataheaders](Options.html#.data%25E2%2580%25A4headers) |
   *    | keys |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [datakeys](Options.html#.data%25E2%2580%25A4keys) |
   *    | mimeType |  Set 'json' if loading JSON via url.<br>@see [datamimeType](Options.html#.data%25E2%2580%25A4mimeType) |
   *    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
   *    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
   *    | done | The specified function will be called after data loaded.|
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)
   * @example
   * // Load data1 and unload data2 and data3
   * chart.load({
   *     columns: [
   *        ["data1", 100, 200, 150, ...],
   *        ...
   *    ],
   *    unload: ["data2", "data3"],
   *    url: "...",
   *    done: function() { ... }
   * });
   * @example
   * // myAPI.json
   * // {
   * //   "data1": [220, 240, 270, 250, 280],
   * //   "data2": [180, 150, 300, 70, 120]
   * // }
   *
   * chart.load({
   *     url: './data/myAPI.json',
   *     mimeType: "json",
   *
   *     // set request header if is needed
   *     headers: {
   *       "Content-Type": "text/json"
   *     }
   * });
   * @example
   * chart.load({
   *     data: [
   *       // equivalent as: columns: [["data1", 30, 200, 100]]
   *       {"data1": 30}, {"data1": 200}, {"data1": 100}
   *
   *       // or
   *       // equivalent as: columns: [["data1", 10, 20], ["data2", 13, 30]]
   *       // {"data1": 10, "data2": 13}, {"data1": 20, "data2": 30}}
   *     ]
   * });
   * @example
   * chart.load({
   *     json: [
   *          {name: "www.site1.com", upload: 800, download: 500, total: 400},
   *     ],
   *     keys: {
   *         x: "name",
   *         value: ["upload", "download"]
   *     }
   * });
   */
  load: function load(args) {
    var $$ = this.internal,
        config = $$.config;
    // update xs if specified
    // update names if exists
    // update classes if exists
    // update axes if exists
    // update colors if exists
    args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
      config.data_classes[id] = args.classes[id];
    }), "categories" in args && $$.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
      config.data_axes[id] = args.axes[id];
    }), "colors" in args && Object.keys(args.colors).forEach(function (id) {
      config.data_colors[id] = args.colors[id];
    }), "unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds(args.unload === !0 ? null : args.unload), function () {
      return $$.loadFromArgs(args);
    }) : $$.loadFromArgs(args);
  },

  /**
   * Unload data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
   * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
   * @method unload
   * @instance
   * @memberof Chart
   * @param {Object} args
   *  | key | Type | Description |
   *  | --- | --- | --- |
   *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |
   *  | done | Fuction | Callback after data is unloaded. |
   * @example
   *  // Unload data2 and data3
   *  chart.unload({
   *    ids: ["data2", "data3"],
   *    done: function() {
   *       // called after the unloaded
   *    }
   *  });
   */
  unload: function unload(argsValue) {
    var $$ = this.internal,
        args = argsValue || {};
    isArray(args) ? args = {
      ids: args
    } : isString(args) && (args = {
      ids: [args]
    });
    var ids = $$.mapToTargetIds(args.ids);
    $$.unload(ids, function () {
      $$.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
      }), $$.removeCache(ids), args.done && args.done();
    });
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-ease","commonjs2":"d3-ease","amd":"d3-ease","root":"d3"}
var external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_ = __webpack_require__(14);

// CONCATENATED MODULE: ./src/api/api.flow.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */







extend(Chart_Chart.prototype, {
  /**
   * Flow data to the chart.<br><br>
   * By this API, you can append new data points to the chart.
   * @method flow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | json | Object | Data as JSON format (@see [datajson](Options.html#.data%25E2%2580%25A4json)) |
   *    | rows | Array | Data in array as row format (@see [datarows](Options.html#.data%25E2%2580%25A4json)) |
   *    | columns | Array | Data in array as column format (@see [datacolumns](Options.html#.data%25E2%2580%25A4columns)) |
   *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
   *    | length | Number | The lower x edge will move by the number of this argument |
   *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
   *    | done | Function | The specified function will be called when flow ends |
   *
   * - **NOTE:**
   *   - If json, rows and columns given, the data will be loaded.
   *   - If data that has the same target id is given, the chart will be appended.
   *   - Otherwise, new target will be added. One of these is required when calling.
   *   - If json specified, keys is required as well as data.json.
   * 	 - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.
   * @example
   * // 2 data points will be apprended to the tail and popped from the head.
   * // After that, 4 data points will be appended and no data points will be poppoed.
   * chart.flow({
   *  columns: [
   *    ["x", "2018-01-11", "2018-01-21"],
   *    ["data1", 500, 200],
   *    ["data2", 100, 300],
   *    ["data3", 200, 120]
   *  ],
   *  to: "2013-01-11",
   *  done: function () {
   *    chart.flow({
   *      columns: [
   *        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
   *        ["data1", 200, 300, 100, 250],
   *        ["data2", 100, 90, 40, 120],
   *        ["data3", 100, 100, 300, 500]
   *      ],
   *      length: 2,
      *      duration: 1500
   *    });
   *  }
   * });
   */
  flow: function flow(args) {
    var data,
        domain,
        diff,
        to,
        $$ = this.internal,
        length = 0,
        tail = 0;

    if ((args.json || args.rows || args.columns) && (data = $$.convertData(args)), data && $$.isTabVisible()) {
      var notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          targets = $$.convertDataToTargets(data, !0);
      $$.data.targets.forEach(function (t) {
        for (var found = !1, i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
          found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

          for (var _j3 = 0; _j3 < length; _j3++) targets[i].values[_j3].index = tail + _j3, $$.isTimeSeries() || (targets[i].values[_j3].x = tail + _j3);

          t.values = t.values.concat(targets[i].values), targets.splice(i, 1);
          break;
        }

        found || notfoundIds.push(t.id);
      }), $$.data.targets.forEach(function (t) {
        for (var _i = 0; _i < notfoundIds.length; _i++) if (t.id === notfoundIds[_i]) {
          tail = t.values[t.values.length - 1].index + 1;

          for (var _j4 = 0; _j4 < length; _j4++) t.values.push({
            id: t.id,
            index: tail + _j4,
            x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + _j4) : tail + _j4,
            value: null
          });
        }
      }), $$.data.targets.length && targets.forEach(function (t) {
        for (var missing = [], i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
          id: t.id,
          index: i,
          x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
          value: null
        });

        t.values.forEach(function (v) {
          v.index += tail, $$.isTimeSeries() || (v.x += tail);
        }), t.values = missing.concat(t.values);
      }), $$.data.targets = $$.data.targets.concat(targets);
      // add remained
      // check data count because behavior needs to change when it"s only one
      // const dataCount = $$.getMaxDataCount();
      var baseTarget = $$.data.targets[0],
          baseValue = baseTarget.values[0];
      isDefined(args.to) ? (length = 0, to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to, baseTarget.values.forEach(function (v) {
        v.x < to && length++;
      })) : isDefined(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && $$.isTimeSeries() && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]) : (diff = $$.isTimeSeries() ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x]), domain && $$.updateXDomain(null, !0, !0, !1, domain), $$.updateTargets($$.data.targets), $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: !0,
        withTransition: orgDataCount > 1,
        withTrimXDomain: !1,
        withUpdateXAxis: !0
      });
    }
  }
}), extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Generate flow
   * @memberof ChartInternal
   * @private
   * @param {Object} args
   * @return {Function}
   */
  generateFlow: function generateFlow(args) {
    var $$ = this,
        config = $$.config;
    return function () {
      var translateX,
          targets = args.targets,
          flow = args.flow,
          _args$shape$type = args.shape.type,
          drawBar = _args$shape$type.bar,
          drawLine = _args$shape$type.line,
          drawArea = _args$shape$type.area,
          _args$shape$pos = args.shape.pos,
          cx = _args$shape$pos.cx,
          cy = _args$shape$pos.cy,
          xForText = _args$shape$pos.xForText,
          yForText = _args$shape$pos.yForText,
          xv = args.xv,
          duration = args.duration,
          scaleX = 1,
          flowIndex = flow.index,
          flowLength = flow.length,
          flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
          flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
          orgDomain = $$.x.domain(),
          durationForFlow = flow.duration || duration,
          done = flow.done || function () {},
          wait = $$.generateWait(),
          xgrid = $$.xgrid || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          xgridLines = $$.xgridLines || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainRegion = $$.mainRegion || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainText = $$.mainText || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainBar = $$.mainBar || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainLine = $$.mainLine || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainArea = $$.mainArea || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainCircle = $$.mainCircle || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);

      $$.flowing = !0, $$.data.targets.forEach(function (d) {
        d.values.splice(0, flowLength);
      });
      // update x domain to generate axis elements for flow
      var domain = $$.updateXDomain(targets, !0, !0); // update elements related to x scale

      $$.updateXGrid && $$.updateXGrid(!0), flow.orgDataCount ? flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : $$.isTimeSeries() ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : translateX = $$.x(flowStart.x) - $$.x(flowEnd.x) : $$.data.targets[0].values.length === 1 ? $$.isTimeSeries() ? (flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0), flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1), translateX = $$.x(flowStart.x) - $$.x(flowEnd.x)) : translateX = diffDomain(domain) / 2 : translateX = $$.x(orgDomain[0]) - $$.x(domain[0]), scaleX = diffDomain(orgDomain) / diffDomain(domain);
      var transform = "translate(".concat(translateX, ",0) scale(").concat(scaleX, ",1)");
      $$.hideGridFocus();
      var gt = Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().ease(external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_["easeLinear"]).duration(durationForFlow);
      wait.add([$$.axes.x.transition(gt).call(function (g) {
        return $$.xAxis.setTransition(gt).create(g);
      }), mainBar.transition(gt).attr("transform", transform), mainLine.transition(gt).attr("transform", transform), mainArea.transition(gt).attr("transform", transform), mainCircle.transition(gt).attr("transform", transform), mainText.transition(gt).attr("transform", transform), mainRegion.filter($$.isRegionOnX).transition(gt).attr("transform", transform), xgrid.transition(gt).attr("transform", transform), xgridLines.transition(gt).attr("transform", transform)]), gt.call(wait, function () {
        var isRotated = config.axis_rotated; // remove flowed elements

        if (flowLength) {
          for (var target = {
            shapes: [],
            texts: [],
            eventRects: []
          }, i = 0; i < flowLength; i++) target.shapes.push(".".concat(config_classes.shape, "-").concat(i)), target.texts.push(".".concat(config_classes.text, "-").concat(i)), target.eventRects.push(".".concat(config_classes.eventRect, "-").concat(i));

          ["shapes", "texts", "eventRects"].forEach(function (v) {
            $$.svg.selectAll(".".concat(config_classes[v])).selectAll(target[v]).remove();
          }), $$.svg.select(".".concat(config_classes.xgrid)).remove();
        } // draw again for removing flowed elements and reverting attr


        if (xgrid.size() && xgrid.attr("transform", null).attr($$.xgridAttr), xgridLines.attr("transform", null), xgridLines.select("line").attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? $$.width : xv), xgridLines.select("text").attr("x", isRotated ? $$.width : 0).attr("y", xv), mainBar.attr("transform", null).attr("d", drawBar), mainLine.attr("transform", null).attr("d", drawLine), mainArea.attr("transform", null).attr("d", drawArea), mainCircle.attr("transform", null), $$.isCirclePoint()) mainCircle.attr("cx", cx).attr("cy", cy);else {
          var xFunc = function (d) {
            return cx(d) - config.point_r;
          },
              yFunc = function (d) {
            return cy(d) - config.point_r;
          };

          mainCircle.attr("x", xFunc).attr("y", yFunc).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
          .attr("cy", cy);
        }
        mainText.attr("transform", null).attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$)), mainRegion.attr("transform", null), mainRegion.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$)), config.interaction_enabled && $$.redrawEventRect(), done(), $$.flowing = !1;
      });
    };
  }
});
// CONCATENATED MODULE: ./src/api/api.selection.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(Chart_Chart.prototype, {
  /**
   * Get selected data points.<br><br>
   * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
   * @method selected
   * @instance
   * @memberof Chart
   * @param {String} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
   * @return {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
   * @example
   *  // all selected data points will be returned.
   *  chart.selected();
   *  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
   *
   *  // all selected data points of data1 will be returned.
   *  chart.selected("data1");
   */
  selected: function selected(targetId) {
    var $$ = this.internal,
        dataPoint = [];
    return $$.main.selectAll(".".concat(config_classes.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll(".".concat(config_classes.shape)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.SELECTED);
    }).each(function (d) {
      return dataPoint.push(d);
    }), dataPoint;
  },

  /**
   * Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
   * @method select
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to get selected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @param {Boolean} [resetOther] Unselect already selected.
   * @example
   *  // select all data points
   *  chart.select();
   *
   *  // select all from 'data2'
   *  chart.select("data2");
   *
   *  // select all from 'data1' and 'data2'
   *  chart.select(["data1", "data2"]);
   *
   *  // select from 'data1', indices 2 and unselect others selected
   *  chart.select("data1", [2], true);
   *
   *  // select from 'data1', indices 0, 3 and 5
   *  chart.select("data1", [0, 3, 5]);
   */
  select: function select(ids, indices, resetOther) {
    var $$ = this.internal,
        config = $$.config;
    config.data_selection_enabled && $$.main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable(d) && !isSelected && toggle(!0, shape.classed(config_classes.SELECTED, !0), d, i) : isDefined(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
    });
  },

  /**
   * Set data points to be un-selected.
   * @method unselect
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to be unselected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @example
   *  // unselect all data points
   *  chart.unselect();
   *
   *  // unselect all from 'data1'
   *  chart.unselect("data1");
   *
   *  // unselect from 'data1', indices 2
   *  chart.unselect("data1", [2]);
   */
  unselect: function unselect(ids, indices) {
    var $$ = this.internal,
        config = $$.config;
    config.data_selection_enabled && $$.main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || isTargetId && isTargetIndex && config.data_selection_isselectable(d) && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i);
    });
  }
});
// CONCATENATED MODULE: ./src/api/api.transform.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Change the type of the chart.
 * @private
 * @param {String|Array} targetIds
 * @param {String} type
 * @param {Object} optionsForRedraw
 */

function transformTo(targetIds, type, optionsForRedraw) {
  var $$ = this,
      options = optionsForRedraw || {
    withTransitionForAxis: !$$.hasArcType()
  };
  // this is needed when transforming to arc
  options.withTransitionForTransform = !1, $$.transiting = !1, $$.setTargetType(targetIds, type), $$.updateTargets($$.data.targets), $$.updateAndRedraw(options);
}

extend(Chart_Chart.prototype, {
  /**
   * Change the type of the chart.
   * @method transform
   * @instance
   * @memberof Chart
   * @param {String} type Specify the type to be transformed. The types listed in data.type can be used.
   * @param {String|Array} targetIds Specify targets to be transformed. If not given, all targets will be the candidate.
   * @example
   *  // all targets will be bar chart.
   *  chart.transform("bar");
   *
   *  // only data1 will be bar chart.
   *  chart.transform("bar", "data1");
   *
   *  // only data1 and data2 will be bar chart.
   *  chart.transform("bar", ["data1", "data2"]);
   */
  transform: function transform(type, targetIds) {
    var $$ = this.internal,
        options = ["pie", "donut"].indexOf(type) >= 0 ? {
      withTransform: !0
    } : null;
    transformTo.bind($$)(targetIds, type, options);
  }
});
// CONCATENATED MODULE: ./src/api/api.group.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Update groups for the targets.
   * @method groups
   * @instance
   * @memberof Chart
   * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
   * @return {Array} Grouped data names array
   * @example
   *  // data1 and data2 will be a new group.
   *  chart.groups([
   *     ["data1", "data2"]
   *  ]);
   */
  groups: function groups(_groups) {
    var $$ = this.internal,
        config = $$.config;
    return isUndefined(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
  }
});
// CONCATENATED MODULE: ./src/api/api.grid.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Update x grid lines.
 * @method xgrids
 * @instance
 * @memberof Chart
 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
 * @example
 *  // Show 2 x grid lines
 * chart.xgrids([
 *    {value: 1, text: "Label 1"},
 *    {value: 4, text: "Label 4"}
 * ]);
 */

var xgrids = function (grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
};

extend(xgrids, {
  /**
   * Add x grid lines.<br>
   * This API adds new x grid lines instead of replacing like xgrids.
   * @method xgridsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.xgrids.add(
   *   {value: 4, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.xgrids.add([
   *   {value: 2, text: "Label 2"},
   *   {value: 4, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
  },

  /**
   * Remove x grid lines.<br>
   * This API removes x grid lines.
   * @method xgridsremove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
   * @example
   * // x grid line on x = 2 will be removed
   * chart.xgrids.remove({value: 2});
   *
   * // x grid lines that have 'grid-A' will be removed
   * chart.xgrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of x grid lines will be removed
   * chart.xgrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !0);
  }
});

/**
 * Update y grid lines.
 * @method ygrids
 * @instance
 * @memberof Chart
 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
 * @example
 *  // Show 2 y grid lines
 * chart.ygrids([
 *    {value: 100, text: "Label 1"},
 *    {value: 400, text: "Label 4"}
 * ]);
 */
var ygrids = function (grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_y_lines = grids, $$.redrawWithoutRescale(), config.grid_y_lines) : config.grid_y_lines;
};

extend(ygrids, {
  /**
   * Add y grid lines.<br>
   * This API adds new y grid lines instead of replacing like ygrids.
   * @method ygridsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.ygrids.add(
   *   {value: 400, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.ygrids.add([
   *   {value: 200, text: "Label 2"},
   *   {value: 400, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
  },

  /**
   * Remove y grid lines.<br>
   * This API removes x grid lines.
   * @method ygridsremove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
   * @example
   * // y grid line on y = 200 will be removed
   * chart.ygrids.remove({value: 200});
   *
   * // y grid lines that have 'grid-A' will be removed
   * chart.ygrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of y grid lines will be removed
   * chart.ygrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !1);
  }
}), extend(Chart_Chart.prototype, {
  xgrids: xgrids,
  ygrids: ygrids
});
// CONCATENATED MODULE: ./src/api/api.region.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Update regions.
 * @method regions
 * @instance
 * @memberof Chart
 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
 * @return {Array} regions
 * @example
 * // Show 2 regions
 * chart.regions([
 *    {axis: "x", start: 5, class: "regionX"},
 *    {axis: "y", end: 50, class: "regionY"}
 * ]);
 */

var api_region_regions = function (_regions) {
  var $$ = this.internal,
      config = $$.config;
  return _regions ? (config.regions = _regions, $$.redrawWithoutRescale(), _regions) : config.regions;
};

extend(api_region_regions, {
  /**
   * Add new region.<br><br>
   * This API adds new region instead of replacing like regions.
   * @method regionsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
   * @return {Array} regions
   * @example
   * // Add a new region
   * chart.regions.add(
   *    {axis: "x", start: 5, class: "regionX"}
   * );
   *
   * // Add new regions
   * chart.regions.add([
   *    {axis: "x", start: 5, class: "regionX"},
   *    {axis: "y", end: 50, class: "regionY"}
   *]);
   */
  add: function add(regions) {
    var $$ = this.internal,
        config = $$.config;
    return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
  },

  /**
   * Remove regions.<br><br>
   * This API removes regions.
   * @method regionsremove
   * @instance
   * @memberof Chart
   * @param {Object} regions This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
   * @return {Array} regions Removed regions
   * @example
   * // regions that have 'region-A' or 'region-B' will be removed.
   * chart.regions.remove({
   *   classes: [
   *     "region-A", "region-B"
   *   ]
   * });
   *
   * // all of regions will be removed.
   * chart.regions.remove();
   */
  remove: function remove(optionsValue) {
    var $$ = this.internal,
        config = $$.config,
        options = optionsValue || {},
        duration = getOption(options, "duration", config.transition_duration),
        classes = getOption(options, "classes", [config_classes.region]),
        regions = $$.main.select(".".concat(config_classes.regions)).selectAll(classes.map(function (c) {
      return ".".concat(c);
    }));
    return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), regions = config.regions, Object.keys(options).length ? (regions = regions.filter(function (region) {
      var found = !1;
      return !region["class"] || (region["class"].split(" ").forEach(function (c) {
        classes.indexOf(c) >= 0 && (found = !0);
      }), !found);
    }), config.regions = regions) : config.regions = [], regions;
  }
}), extend(Chart_Chart.prototype, {
  regions: api_region_regions
});
// CONCATENATED MODULE: ./src/api/api.data.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get data loaded in the chart.
 * @method data
 * @instance
 * @memberof Chart
 * @param {String|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
 * @return {Array} Data objects
 * @example
 * // Get only data1 data
 * chart.data("data1");
 * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
 *
 * // Get data1 and data2 data
 * chart.data(["data1", "data2"]);
 *
 * // Get all data
 * chart.data();
 */

var api_data_data = function (targetIds) {
  var targets = this.internal.data.targets;

  if (!isUndefined(targetIds)) {
    var ids = isArray(targetIds) ? targetIds : [targetIds];
    return targets.filter(function (t) {
      return ids.some(function (v) {
        return v === t.id;
      });
    });
  }

  return targets;
};

extend(api_data_data, {
  /**
   * Get data shown in the chart.
   * @method datashown
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
   * @return {Array} Data objects
   * @example
   * // Get shown data by filtering to include only data1 data
   * chart.data.shown("data1");
   * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
   *
   * // Get shown data by filtering to include data1 and data2 data
   * chart.data.shown(["data1", "data2"]);
   *
   * // Get all shown data
   * chart.data.shown();
   */
  shown: function shown(targetIds) {
    return this.internal.filterTargetsToShow(this.data(targetIds));
  },

  /**
   * Get values of the data loaded in the chart.
   * @method datavalues
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
   * @return {Array} Data values
   * @example
   * // Get data1 values
   * chart.data.values("data1");
   * // --> [10, 20, 30, 40]
   */
  values: function (targetId) {
    var flat = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
        values = null;

    if (targetId) {
      var targets = this.data(targetId);
      targets && isArray(targets) && (values = [], targets.forEach(function (v) {
        var dataValue = v.values.map(function (d) {
          return d.value;
        });
        flat ? values = values.concat(dataValue) : values.push(dataValue);
      }));
    }

    return values;
  },

  /**
   * Get and set names of the data loaded in the chart.
   * @method datanames
   * @instance
   * @memberof Chart
   * @param {Object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
   * @return {Object} Corresponding names according its key value, if specified names values.
   * @example
   * // Get current names
   * chart.data.names();
   * // --> {data1: "test1", data2: "test2"}
   *
   * // Update names
   * chart.data.names({
   *  data1: "New Name 1",
   *  data2: "New Name 2"
   *});
   */
  names: function names(_names) {
    return this.internal.clearLegendItemTextBoxCache(), this.internal.updateDataAttributes("names", _names);
  },

  /**
   * Get and set colors of the data loaded in the chart.
   * @method datacolors
   * @instance
   * @memberof Chart
   * @param {Object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).
   * @return {Object} Corresponding data color value according its key value.
   * @example
   * // Get current colors
   * chart.data.colors();
   * // --> {data1: "#00c73c", data2: "#fa7171"}
   *
   * // Update colors
   * chart.data.colors({
   *  data1: "#FFFFFF",
   *  data2: "#000000"
   * });
   */
  colors: function colors(_colors) {
    return this.internal.updateDataAttributes("colors", _colors);
  },

  /**
   * Get and set axes of the data loaded in the chart.
   * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @method dataaxes
   * @instance
   * @memberof Chart
   * @param {Object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
   * @return {Object} Corresponding axes value for data, if specified axes value.
   * @example
   * // Get current axes
   * chart.data.axes();
   * // --> {data1: "y"}
   *
   * // Update axes
   * chart.data.axes({
   *  data1: "y",
   *  data2: "y2"
   * });
   */
  axes: function axes(_axes) {
    return this.internal.updateDataAttributes("axes", _axes);
  },

  /**
   * Get the minimum data value bound to the chart
   * @method datamin
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.min();
   * // --> [{x: 0, value: 30, id: "data1", index: 0}, ...]
   */
  min: function min() {
    return this.internal.getMinMaxData().min;
  },

  /**
   * Get the maximum data value bound to the chart
   * @method datamax
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.max();
   * // --> [{x: 3, value: 400, id: "data1", index: 3}, ...]
   */
  max: function max() {
    return this.internal.getMinMaxData().max;
  }
}), extend(Chart_Chart.prototype, {
  data: api_data_data
});
// CONCATENATED MODULE: ./src/api/api.category.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Set specified category name on category axis.
   * @method category
   * @instance
   * @memberof Chart
   * @param {Number} i index of category to be changed
   * @param {String} category category value to be changed
   * @example
   * chart.category(2, "Category 3");
   */
  category: function category(i, _category) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
  },

  /**
   * Set category names on category axis.
   * @method categories
   * @instance
   * @memberof Chart
   * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @example
   * chart.categories([
   *      "Category 1", "Category 2", ...
   * ]);
   */
  categories: function categories(_categories) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
  }
});
// CONCATENATED MODULE: ./src/api/api.color.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Get the color
   * @method color
   * @instance
   * @memberof Chart
   * @param {String} id id to get the color
   * @example
   * chart.color("data1");
   */
  color: function color(id) {
    return this.internal.color(id); // more patterns
  }
});
// CONCATENATED MODULE: ./src/api/api.x.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Get and set x values for the chart.
   * @method x
   * @instance
   * @memberof Chart
   * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.x();
   *
   *  // Update x values for all targets
   *  chart.x([100, 200, 300, 400, ...]);
   */
  x: function x(_x) {
    var $$ = this.internal,
        isCategorized = $$.isCustomX() && $$.isCategorized();
    return isArray(_x) && (isCategorized ? $$.api.categories(_x) : ($$.updateTargetX($$.data.targets, _x), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    }))), isCategorized ? $$.api.categories() : $$.data.xs;
  },

  /**
   * Get and set x values for the chart.
   * @method xs
   * @instance
   * @memberof Chart
   * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.xs();
   *
   *  // Update x values for all targets
   *  chart.xs({
   *    data1: [10, 20, 30, 40, ...],
   *    data2: [100, 200, 300, 400, ...]
   *  });
   */
  xs: function xs(_xs) {
    var $$ = this.internal;
    return isObject(_xs) && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    })), $$.data.xs;
  }
});
// CONCATENATED MODULE: ./src/api/api.axis.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Set the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @param {Object} value
 * @return {undefined}
 * @private
 */

var setMinMax = function ($$, type, value) {
  var config = $$.config,
      axisX = "axis_x_".concat(type),
      axisY = "axis_y_".concat(type),
      axisY2 = "axis_y2_".concat(type);
  return isDefined(value) && (isObjectType(value) ? (isValue(value.x) && (config[axisX] = value.x), isValue(value.y) && (config[axisY] = value.y), isValue(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0
  })), undefined;
},
    api_axis_getMinMax = function ($$, type) {
  var config = $$.config;
  return {
    x: config["axis_x_".concat(type)],
    y: config["axis_y_".concat(type)],
    y2: config["axis_y2_".concat(type)]
  };
},
    api_axis_axis = extend(function () {}, {
  /**
   * Get and set axis labels.
   * @method axislabels
   * @instance
   * @memberof Chart
   * @param {Object} labels specified axis' label to be updated.
   * @example
   * // Update axis' label
   * chart.axis.labels({
   *   x: "New X Axis Label",
   *   y: "New Y Axis Label"
   * });
   */
  labels: function labels(_labels) {
    var $$ = this.internal;
    arguments.length && (Object.keys(_labels).forEach(function (axisId) {
      $$.axis.setLabelText(axisId, _labels[axisId]);
    }), $$.axis.updateLabels());
  },

  /**
   * Get and set axis min value.
   * @method axismin
   * @instance
   * @memberof Chart
   * @param {Object} min If min is given, specified axis' min value will be updated.<br>
   *     If no argument is given, the min values set on generating option for each axis will be returned.
   *     If not set any min values on generation, it will return `undefined`.
   * @example
   * // Update axis' min
   * chart.axis.min({
   *   x: -10,
   *   y: 1000,
   *   y2: 100
   * });
   */
  min: function min(_min) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "min", _min) : api_axis_getMinMax($$, "min");
  },

  /**
   * Get and set axis max value.
   * @method axismax
   * @instance
   * @memberof Chart
   * @param {Object} max If max is given, specified axis' max value will be updated.<br>
   *     If no argument is given, the max values set on generating option for each axis will be returned.
   *     If not set any max values on generation, it will return `undefined`.
   * @example
   * // Update axis' label
   * chart.axis.max({
   *    x: 100,
   *    y: 1000,
   *    y2: 10000
   * });
   */
  max: function max(_max) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "max", _max) : api_axis_getMinMax($$, "max");
  },

  /**
   * Get and set axis min and max value.
   * @method axisrange
   * @instance
   * @memberof Chart
   * @param {Object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
   * @example
   * // Update axis' label
   * chart.axis.range({
   *   min: {
   *     x: -10,
   *     y: -1000,
   *     y2: -10000
   *   },
   *   max: {
   *     x: 100,
   *     y: 1000,
   *     y2: 10000
   *   },
   * });
   */
  range: function range(_range) {
    var axis = this.axis;
    if (arguments.length) isDefined(_range.max) && axis.max(_range.max), isDefined(_range.min) && axis.min(_range.min);else return {
      max: axis.max(),
      min: axis.min()
    };
    return undefined;
  }
});
/**
 * Get the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @return {{x, y, y2}}
 * @private
 */


extend(Chart_Chart.prototype, {
  axis: api_axis_axis
});
// CONCATENATED MODULE: ./src/api/api.legend.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Define legend
 * @ignore
 */

var legend = extend(function () {}, {
  /**
   * Show legend for each target.
   * @method legendshow
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be shown.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be shown.
   * @example
   * // Show legend for data1.
   * chart.legend.show("data1");
   *
   * // Show legend for data1 and data2.
   * chart.legend.show(["data1", "data2"]);
   *
   * // Show all legend.
   * chart.legend.show();
   */
  show: function show(targetIds) {
    var $$ = this.internal;
    $$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  },

  /**
   * Hide legend for each target.
   * @method legendhide
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be hidden.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be hidden.
   * @example
   * // Hide legend for data1.
   * chart.legend.hide("data1");
   *
   * // Hide legend for data1 and data2.
   * chart.legend.hide(["data1", "data2"]);
   *
   * // Hide all legend.
   * chart.legend.hide();
   */
  hide: function hide(targetIds) {
    var $$ = this.internal;
    $$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  }
});
extend(Chart_Chart.prototype, {
  legend: legend
});
// CONCATENATED MODULE: ./src/api/api.chart.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(Chart_Chart.prototype, {
  /**
   * Resize the chart.
   * @method resize
   * @instance
   * @memberof Chart
   * @param {Object} size This argument should include width and height in pixels.
   * @example
   * // Resize to 640x480
   * chart.resize({
   *    width: 640,
   *    height: 480
   * });
   */
  resize: function resize(size) {
    var $$ = this.internal,
        config = $$.config;
    $$.rendered && (config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush(!1, !0), $$.resizeFunction());
  },

  /**
   * Force to redraw.
   * @method flush
   * @instance
   * @memberof Chart
   * @param {Boolean} [soft] For soft redraw.
   * @example
   * chart.flush();
   *
   * // for soft redraw
   * chart.flush(true);
   */
  flush: function flush(soft, _isFromResize) {
    var $$ = this.internal;
    $$.rendered ? (_isFromResize ? $$.brush && $$.brush.updateResize() : $$.axis && $$.axis.setOrient(), $$.zoomScale = null, soft ? $$.redraw({
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withLegend: !0
    }) : $$.updateAndRedraw({
      withLegend: !0,
      withTransition: !1,
      withTransitionForTransform: !1
    })) : $$.initToRender(!0);
  },

  /**
   * Reset the chart object and remove element and events completely.
   * @method destroy
   * @instance
   * @memberof Chart
   * @example
   * chart.destroy();
   */
  destroy: function destroy() {
    var _this = this,
        $$ = this.internal;

    return notEmpty($$) && ($$.callPluginHook("$willDestroy"), $$.charts.splice($$.charts.indexOf(this), 1), $$.svg.select("*").interrupt(), $$.generateResize.timeout && win.clearTimeout($$.generateResize.timeout), win.removeEventListener("resize", $$.resizeFunction), $$.selectChart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
      key === "internal" && Object.keys($$).forEach(function (k) {
        $$[k] = null;
      }), _this[key] = null, delete _this[key];
    })), null;
  },

  /**
   * Get or set single config option value.
   * @method config
   * @instance
   * @memberof Chart
   * @param {String} name The option key name.
   * @param {*} [value] The value accepted for indicated option.
   * @param {Boolean} [redraw] Set to redraw with the new option changes.
   * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.
   * @example
   * // Getter
   * chart.config("gauge.max");
   *
   * // Setter
   * chart.config("gauge.max", 100);
   *
   * // Setter & redraw with the new option
   * chart.config("gauge.max", 100, true);
   */
  config: function config(name, value, redraw) {
    var res,
        $$ = this.internal,
        key = name && name.replace(/\./g, "_");
    return key in $$.config && (isDefined(value) ? ($$.config[key] = value, res = value, redraw && this.flush()) : res = $$.config[key]), res;
  }
});
// CONCATENATED MODULE: ./src/api/api.tooltip.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Define tooltip
 * @ignore
 */

var api_tooltip_tooltip = extend(function () {}, {
  /**
   * Show tooltip
   * @method tooltipshow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | index | Number | Determine focus by index |
   *    | x | Number &vert; Date | Determine focus by x Axis index |
   *    | mouse | Array | Determine x and y coordinate value relative the targeted '.bb-event-rect' x Axis.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
   *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {Number &verbar; Date}: x Axis value<br>- index {Number}: x Axis index (useless for data.xs)<br>- id {String}: data id<br>- value {Number}: The corresponding value for tooltip. |
   *
   * @example
   *  // show the 2nd x Axis coordinate tooltip
   *  chart.tooltip.show({
   *    index: 1
   *  });
   *
   *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate of '.bb-event-rect' of the x Axis.
   *  chart.tooltip.show({
   *    x: 2,
   *    mouse: [50, 100]
   *  });
   *
   *  // show tooltip for timeseries x axis
   *  chart.tooltip.show({
   *    x: new Date("2018-01-02 00:00")
   *  });
   *
   *  // when data.xs is used
   *  chart.tooltip.show({
   *    data: {
   *        x: 3,  // x Axis value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   *
   *  // when data.xs isn't used, but tooltip.grouped=false is set
   *  chart.tooltip.show({
   *    data: {
   *        index: 3,  // or 'x' key value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   */
  show: function show() {
    var index,
        mouse,
        args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        $$ = this.internal;

    // determine focus data
    if (args.mouse && (mouse = args.mouse), args.data) {
      var y = $$.getYScale(args.data.id)(args.data.value);
      $$.isMultipleX() ? mouse = [$$.x(args.data.x), y] : (!$$.config.tooltip_grouped && (mouse = [0, y]), index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x));
    } else isDefined(args.x) ? index = $$.getIndexByX(args.x) : isDefined(args.index) && (index = args.index); // emulate events to show


    ($$.inputType === "mouse" ? ["mouseover", "mousemove"] : ["touchstart"]).forEach(function (eventName) {
      $$.dispatchEvent(eventName, index, mouse);
    });
  },

  /**
   * Hide tooltip
   * @method tooltiphide
   * @instance
   * @memberof Chart
   */
  hide: function hide() {
    var $$ = this.internal; // reset last touch point index

    $$.inputType === "touch" && $$.callOverOutForTouch(), $$.hideTooltip(!0), $$.hideGridFocus(), $$.unexpandCircles(), $$.unexpandBars();
  }
});
extend(Chart_Chart.prototype, {
  tooltip: api_tooltip_tooltip
});
// CONCATENATED MODULE: ./src/api/api.export.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Encode to base64
 * @param {String} str
 * @return {String}
 * @private
 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 */

var b64EncodeUnicode = function (str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p) {
    return String.fromCharCode("0x".concat(p));
  }));
},
    nodeToSvgDataUrl = function (node, size) {
  var serializer = new XMLSerializer(),
      clone = node.cloneNode(!0),
      cssText = getCssRules(toArray(browser_doc.styleSheets)).filter(function (r) {
    return r.cssText;
  }).map(function (r) {
    return r.cssText;
  });
  clone.setAttribute("xmlns", external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].xhtml);
  var nodeXml = serializer.serializeToString(clone),
      style = browser_doc.createElement("style"); // escape css for XML

  style.appendChild(browser_doc.createTextNode(cssText.join("\n")));
  var styleXml = serializer.serializeToString(style),
      dataStr = "<svg xmlns=\"".concat(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, "\" width=\"").concat(size.width, "\" height=\"").concat(size.height, "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t").concat(styleXml, "\n\t\t\t\t").concat(nodeXml.replace(/(url\()[^#]+/g, "$1"), "\n\t\t\t</foreignObject></svg>").replace("/\n/g", "%0A"); // foreignObject not supported in IE11 and below
  // https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

  return "data:image/svg+xml;base64,".concat(b64EncodeUnicode(dataStr));
};
/**
 * Convert svg node to data url
 * @param {HTMLElement} node
 * @return {String}
 * @private
 */


extend(Chart_Chart.prototype, {
  /**
   * Export chart as an image.
   * - **NOTE:**
   *   - IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
   *   - The basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.
   * @method export
   * @instance
   * @memberof Chart
   * @param {String} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
   * @param {Function} [callback] The callback to be invoked when export is ready.
   * @return {String} dataURI
   * @example
   *  chart.export();
   *  // --> "data:image/svg+xml;base64,PHN..."
   *
   *  // Initialize the download automatically
   *  chart.export("image/png", dataUrl => {
   *     const link = document.createElement("a");
   *
   *     link.download = `${Date.now()}.png`;
   *     link.href = dataUrl;
   *     link.innerHTML = "Download chart as image";
   *
   *     document.body.appendChild(link);
   *  });
   */
  "export": function _export(mimeType, callback) {
    var $$ = this.internal,
        size = {
      width: $$.currentWidth,
      height: $$.currentHeight
    },
        svgDataUrl = nodeToSvgDataUrl(this.element, size);

    if (isFunction(callback)) {
      var img = new Image();
      img.crosssOrigin = "Anonymous", img.onload = function () {
        var canvas = browser_doc.createElement("canvas"),
            ctx = canvas.getContext("2d");
        canvas.width = size.width, canvas.height = size.height, ctx.drawImage(img, 0, 0), callback(canvas.toDataURL(mimeType));
      }, img.src = svgDataUrl;
    }

    return svgDataUrl;
  }
});
// CONCATENATED MODULE: ./src/core.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard project is licensed under the MIT license
 */























































var _defaults = {},
    bb = {
  /**
   * Version information
   * @property {String} version version
   * @example
   *    bb.version;  // "1.0.0"
   * @memberof bb
   */
  version: "1.12.11",

  /**
   * Generate chart
   * @param {Options} options chart options
   * @memberof bb
   * @return {Chart}
   * @see {@link Options} for different generation options
   * @see {@link Chart} for different methods API
   * @example
   *  <!-- chart holder -->
   * <div id="LineChart"></div>
   * @example
   *   // generate chart with options
   *  var chart = bb.generate({
   *      "bindto": "#LineChart"
   *      "data": {
   *          "columns": [
   *              ["data1", 30, 200, 100, 400, 150, 250],
   *              ["data2", 50, 20, 10, 40, 15, 25]
   *           ]
   *      }
   *  });
   *
   *  // call some API
   *  // ex) get the data of 'data1'
   *  chart.data("data1");
   */
  generate: function generate(config) {
    var options = mergeObj({}, _defaults, config),
        inst = new Chart_Chart(options);
    return inst.internal.charts = this.instance, this.instance.push(inst), inst;
  },

  /**
   * Set or get global default options.
   * - **NOTE:**
   *   - The options values settings are valid within page context only.
   *   - If is called multiple times, will override the last value.
   * @param {Options} options chart options
   * @memberof bb
   * @return {Options}
   * @see {@link Options}
   * @example
   * // Set same option value as for `.generate()`
   * bb.defaults({
   *   data: {
   *     type: "bar"
   *   }
   * });
   *
   * bb.defaults();  // {data:{type: "bar"}}
   *
   * // data.type defaults to 'bar'
   * var chart = bb.generate({ ... });
   */
  defaults: function defaults(options) {
    return isObject(options) && (_defaults = options), _defaults;
  },

  /**
   * An array containing instance created
   * @property {Array} instance instance array
   * @example
   *  // generate charts
   *  var chart1 = bb.generate(...);
   *  var chart2 = bb.generate(...);
   *
   *  bb.instance;  // [ chart1, chart2, ... ]
   * @memberof bb
   */
  instance: [],

  /**
   * Namespace for plugins
   * @property {Object} plugin plugin namespace
   * @example
   *  // Stanford diagram plugin
   *  bb.plugin.stanford;
   * @memberof bb
   */
  plugin: {},

  /**
   * Internal chart object
   * @private
   */
  chart: {
    fn: Chart_Chart.prototype,
    internal: {
      fn: ChartInternal_ChartInternal.prototype,
      axis: {
        fn: Axis_Axis.prototype
      }
    }
  }
};
/**
 * @namespace bb
 * @version 1.12.11
 */


/* harmony default export */ var core = __webpack_exports__["default"] = (bb);

/***/ })
/******/ ]);
});
//# sourceMappingURL=billboard.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/billboard.js/dist/billboard.css":
/*!********************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/billboard.js/dist/billboard.css ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/*!\n * Copyright (c) 2017 ~ present NAVER Corp.\r\n * billboard.js project is licensed under the MIT license\r\n * \r\n * billboard.js, JavaScript chart library\r\n * https://naver.github.io/billboard.js/\r\n * \r\n * @version 1.12.11\n */\n/*-- Chart --*/\n.bb svg {\n  font: 10px sans-serif;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.bb path, .bb line {\n  fill: none;\n  stroke: #000; }\n\n.bb text, .bb .bb-button {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none; }\n\n.bb-legend-item-tile,\n.bb-xgrid-focus,\n.bb-ygrid-focus,\n.bb-ygrid,\n.bb-event-rect,\n.bb-bars path {\n  shape-rendering: crispEdges; }\n\n.bb-chart-arc .bb-gauge-value {\n  fill: #000; }\n\n.bb-chart-arc path {\n  stroke: #fff; }\n\n.bb-chart-arc rect {\n  stroke: #fff;\n  stroke-width: 1; }\n\n.bb-chart-arc text {\n  fill: #fff;\n  font-size: 13px; }\n\n/*-- Axis --*/\n.bb-axis {\n  shape-rendering: crispEdges; }\n\n/*-- Grid --*/\n.bb-grid line {\n  stroke: #aaa; }\n\n.bb-grid text {\n  fill: #aaa; }\n\n.bb-xgrid, .bb-ygrid {\n  stroke-dasharray: 3 3; }\n\n/*-- Text on Chart --*/\n.bb-text.bb-empty {\n  fill: #808080;\n  font-size: 2em; }\n\n/*-- Line --*/\n.bb-line {\n  stroke-width: 1px; }\n\n/*-- Point --*/\n.bb-circle._expanded_ {\n  stroke-width: 1px;\n  stroke: white; }\n\n.bb-selected-circle {\n  fill: white;\n  stroke-width: 2px; }\n\n/*-- Bar --*/\n.bb-bar {\n  stroke-width: 0; }\n  .bb-bar._expanded_ {\n    fill-opacity: 0.75; }\n\n/*-- Focus --*/\n.bb-target.bb-focused {\n  opacity: 1; }\n\n.bb-target.bb-focused path.bb-line, .bb-target.bb-focused path.bb-step {\n  stroke-width: 2px; }\n\n.bb-target.bb-defocused {\n  opacity: 0.3 !important; }\n  .bb-target.bb-defocused .text-overlapping {\n    opacity: .05 !important; }\n\n/*-- Region --*/\n.bb-region {\n  fill: steelblue;\n  fill-opacity: .1; }\n\n/*-- Zoom region --*/\n.bb-zoom-brush {\n  fill-opacity: .1; }\n\n/*-- Brush --*/\n.bb-brush .extent {\n  fill-opacity: .1; }\n\n/*-- Select - Drag --*/\n/*-- Legend --*/\n.bb-legend-item {\n  font-size: 12px;\n  user-select: none; }\n\n.bb-legend-item-hidden {\n  opacity: 0.15; }\n\n.bb-legend-background {\n  opacity: 0.75;\n  fill: white;\n  stroke: lightgray;\n  stroke-width: 1; }\n\n/*-- Title --*/\n.bb-title {\n  font: 14px sans-serif; }\n\n/*-- Tooltip --*/\n.bb-tooltip-container {\n  z-index: 10;\n  user-select: none; }\n\n.bb-tooltip {\n  border-collapse: collapse;\n  border-spacing: 0;\n  background-color: #fff;\n  empty-cells: show;\n  opacity: 0.9;\n  -webkit-box-shadow: 7px 7px 12px -9px #777777;\n  -moz-box-shadow: 7px 7px 12px -9px #777777;\n  box-shadow: 7px 7px 12px -9px #777777; }\n  .bb-tooltip tr {\n    border: 1px solid #CCC; }\n  .bb-tooltip th {\n    background-color: #aaa;\n    font-size: 14px;\n    padding: 2px 5px;\n    text-align: left;\n    color: #FFF; }\n  .bb-tooltip td {\n    font-size: 13px;\n    padding: 3px 6px;\n    background-color: #fff;\n    border-left: 1px dotted #999; }\n    .bb-tooltip td > span, .bb-tooltip td > svg {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      margin-right: 6px; }\n  .bb-tooltip.value {\n    text-align: right; }\n\n/*-- Area --*/\n.bb-area {\n  stroke-width: 0;\n  opacity: 0.2; }\n\n/*-- Arc --*/\n.bb-chart-arcs-title {\n  dominant-baseline: middle;\n  font-size: 1.3em; }\n\n.bb-chart-arcs-gauge-title {\n  dominant-baseline: middle;\n  font-size: 2.7em; }\n\n.bb-chart-arcs .bb-chart-arcs-background {\n  fill: #e0e0e0;\n  stroke: #fff; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-unit {\n  fill: #000;\n  font-size: 16px; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-max {\n  fill: #777; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-min {\n  fill: #777; }\n\n/*-- Radar --*/\n.bb-chart-radars .bb-levels polygon {\n  fill: none;\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-levels text {\n  fill: #848282; }\n\n.bb-chart-radars .bb-axis line {\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-axis text {\n  font-size: 1.15em;\n  cursor: default; }\n\n.bb-chart-radars .bb-shapes polygon {\n  fill-opacity: .2;\n  stroke-width: 1px; }\n\n/*-- Button --*/\n.bb-button {\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n  .bb-button .bb-zoom-reset {\n    font-size: 11px;\n    border: solid 1px #ccc;\n    background-color: #fff;\n    padding: 5px;\n    border-radius: 5px;\n    cursor: pointer; }", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/d3-array/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/array.js ***!
  \********************************************/
/*! exports provided: slice, map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
var array = Array.prototype;

var slice = array.slice;
var map = array.map;


/***/ }),

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});


/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/*! exports provided: bisectRight, bisectLeft, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return bisectRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return bisectLeft; });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisector */ "./node_modules/d3-array/src/bisector.js");



var ascendingBisect = Object(_bisector__WEBPACK_IMPORTED_MODULE_1__["default"])(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ __webpack_exports__["default"] = (bisectRight);


/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");


/* harmony default export */ __webpack_exports__["default"] = (function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function(d, x) {
    return Object(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
  };
}


/***/ }),

/***/ "./node_modules/d3-array/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/constant.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-array/src/cross.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/cross.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pairs */ "./node_modules/d3-array/src/pairs.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = _pairs__WEBPACK_IMPORTED_MODULE_0__["pair"];

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});


/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});


/***/ }),

/***/ "./node_modules/d3-array/src/deviation.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/deviation.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variance */ "./node_modules/d3-array/src/variance.js");


/* harmony default export */ __webpack_exports__["default"] = (function(array, f) {
  var v = Object(_variance__WEBPACK_IMPORTED_MODULE_0__["default"])(array, f);
  return v ? Math.sqrt(v) : v;
});


/***/ }),

/***/ "./node_modules/d3-array/src/extent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/extent.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});


/***/ }),

/***/ "./node_modules/d3-array/src/histogram.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/histogram.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-array/src/constant.js");
/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-array/src/identity.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./range */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");









/* harmony default export */ __webpack_exports__["default"] = (function() {
  var value = _identity__WEBPACK_IMPORTED_MODULE_4__["default"],
      domain = _extent__WEBPACK_IMPORTED_MODULE_3__["default"],
      threshold = _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__["default"];

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = Object(_ticks__WEBPACK_IMPORTED_MODULE_6__["tickStep"])(x0, x1, tz);
      tz = Object(_range__WEBPACK_IMPORTED_MODULE_5__["default"])(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[Object(_bisect__WEBPACK_IMPORTED_MODULE_1__["default"])(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_)) : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : threshold;
  };

  return histogram;
});


/***/ }),

/***/ "./node_modules/d3-array/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/identity.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x;
});


/***/ }),

/***/ "./node_modules/d3-array/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/index.js ***!
  \********************************************/
/*! exports provided: bisect, bisectRight, bisectLeft, ascending, bisector, cross, descending, deviation, extent, histogram, thresholdFreedmanDiaconis, thresholdScott, thresholdSturges, max, mean, median, merge, min, pairs, permute, quantile, range, scan, shuffle, sum, ticks, tickIncrement, tickStep, transpose, variance, zip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisect", function() { return _bisect__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return _bisect__WEBPACK_IMPORTED_MODULE_0__["bisectRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return _bisect__WEBPACK_IMPORTED_MODULE_0__["bisectLeft"]; });

/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ascending", function() { return _ascending__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bisector */ "./node_modules/d3-array/src/bisector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisector", function() { return _bisector__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _cross__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cross */ "./node_modules/d3-array/src/cross.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return _cross__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _descending__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./descending */ "./node_modules/d3-array/src/descending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "descending", function() { return _descending__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./deviation */ "./node_modules/d3-array/src/deviation.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deviation", function() { return _deviation__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extent */ "./node_modules/d3-array/src/extent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extent", function() { return _extent__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _histogram__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./histogram */ "./node_modules/d3-array/src/histogram.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return _histogram__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./threshold/freedmanDiaconis */ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _threshold_scott__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./threshold/scott */ "./node_modules/d3-array/src/threshold/scott.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return _threshold_scott__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./max */ "./node_modules/d3-array/src/max.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _max__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _mean__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mean */ "./node_modules/d3-array/src/mean.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return _mean__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _median__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./median */ "./node_modules/d3-array/src/median.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "median", function() { return _median__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-array/src/merge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _merge__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./min */ "./node_modules/d3-array/src/min.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _min__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./pairs */ "./node_modules/d3-array/src/pairs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return _pairs__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _permute__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./permute */ "./node_modules/d3-array/src/permute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "permute", function() { return _permute__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-array/src/quantile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantile", function() { return _quantile__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./range */ "./node_modules/d3-array/src/range.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _range__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./scan */ "./node_modules/d3-array/src/scan.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return _scan__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _shuffle__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./shuffle */ "./node_modules/d3-array/src/shuffle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return _shuffle__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./sum */ "./node_modules/d3-array/src/sum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return _sum__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ticks", function() { return _ticks__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return _ticks__WEBPACK_IMPORTED_MODULE_23__["tickIncrement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return _ticks__WEBPACK_IMPORTED_MODULE_23__["tickStep"]; });

/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./transpose */ "./node_modules/d3-array/src/transpose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _transpose__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./variance */ "./node_modules/d3-array/src/variance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variance", function() { return _variance__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _zip__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./zip */ "./node_modules/d3-array/src/zip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _zip__WEBPACK_IMPORTED_MODULE_26__["default"]; });






























/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});


/***/ }),

/***/ "./node_modules/d3-array/src/mean.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/mean.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
});


/***/ }),

/***/ "./node_modules/d3-array/src/median.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/median.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-array/src/quantile.js");




/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_1__["default"])(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_1__["default"])(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return Object(_quantile__WEBPACK_IMPORTED_MODULE_2__["default"])(numbers.sort(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]), 0.5);
});


/***/ }),

/***/ "./node_modules/d3-array/src/merge.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/merge.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});


/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});


/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x === null ? NaN : +x;
});


/***/ }),

/***/ "./node_modules/d3-array/src/pairs.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/pairs.js ***!
  \********************************************/
/*! exports provided: default, pair */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pair", function() { return pair; });
/* harmony default export */ __webpack_exports__["default"] = (function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
});

function pair(a, b) {
  return [a, b];
}


/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
});


/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values, p, valueof) {
  if (valueof == null) valueof = _number__WEBPACK_IMPORTED_MODULE_0__["default"];
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});


/***/ }),

/***/ "./node_modules/d3-array/src/range.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/range.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});


/***/ }),

/***/ "./node_modules/d3-array/src/scan.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/scan.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = _ascending__WEBPACK_IMPORTED_MODULE_0__["default"];

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});


/***/ }),

/***/ "./node_modules/d3-array/src/shuffle.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/shuffle.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});


/***/ }),

/***/ "./node_modules/d3-array/src/sum.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/sum.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});


/***/ }),

/***/ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/freedmanDiaconis.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../quantile */ "./node_modules/d3-array/src/quantile.js");





/* harmony default export */ __webpack_exports__["default"] = (function(values, min, max) {
  values = _array__WEBPACK_IMPORTED_MODULE_0__["map"].call(values, _number__WEBPACK_IMPORTED_MODULE_2__["default"]).sort(_ascending__WEBPACK_IMPORTED_MODULE_1__["default"]);
  return Math.ceil((max - min) / (2 * (Object(_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.75) - Object(_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});


/***/ }),

/***/ "./node_modules/d3-array/src/threshold/scott.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/scott.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deviation */ "./node_modules/d3-array/src/deviation.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * Object(_deviation__WEBPACK_IMPORTED_MODULE_0__["default"])(values) * Math.pow(values.length, -1 / 3)));
});


/***/ }),

/***/ "./node_modules/d3-array/src/threshold/sturges.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/sturges.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});


/***/ }),

/***/ "./node_modules/d3-array/src/ticks.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/ticks.js ***!
  \********************************************/
/*! exports provided: default, tickIncrement, tickStep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return tickIncrement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return tickStep; });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ __webpack_exports__["default"] = (function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
});

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ }),

/***/ "./node_modules/d3-array/src/transpose.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/transpose.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./min */ "./node_modules/d3-array/src/min.js");


/* harmony default export */ __webpack_exports__["default"] = (function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = Object(_min__WEBPACK_IMPORTED_MODULE_0__["default"])(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
});

function length(d) {
  return d.length;
}


/***/ }),

/***/ "./node_modules/d3-array/src/variance.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/variance.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});


/***/ }),

/***/ "./node_modules/d3-array/src/zip.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/zip.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transpose */ "./node_modules/d3-array/src/transpose.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_transpose__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments);
});


/***/ }),

/***/ "./node_modules/d3-axis/src/array.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-axis/src/array.js ***!
  \*******************************************/
/*! exports provided: slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
var slice = Array.prototype.slice;


/***/ }),

/***/ "./node_modules/d3-axis/src/axis.js":
/*!******************************************!*\
  !*** ./node_modules/d3-axis/src/axis.js ***!
  \******************************************/
/*! exports provided: axisTop, axisRight, axisBottom, axisLeft */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisTop", function() { return axisTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisRight", function() { return axisRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisBottom", function() { return axisBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisLeft", function() { return axisLeft; });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-axis/src/array.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-axis/src/identity.js");



var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : _identity__WEBPACK_IMPORTED_MODULE_1__["default"]) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "currentColor"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "currentColor")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "currentColor")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = _array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : _array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : _array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}


/***/ }),

/***/ "./node_modules/d3-axis/src/identity.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-axis/src/identity.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x;
});


/***/ }),

/***/ "./node_modules/d3-axis/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-axis/src/index.js ***!
  \*******************************************/
/*! exports provided: axisTop, axisRight, axisBottom, axisLeft */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./axis */ "./node_modules/d3-axis/src/axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisTop", function() { return _axis__WEBPACK_IMPORTED_MODULE_0__["axisTop"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisRight", function() { return _axis__WEBPACK_IMPORTED_MODULE_0__["axisRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisBottom", function() { return _axis__WEBPACK_IMPORTED_MODULE_0__["axisBottom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisLeft", function() { return _axis__WEBPACK_IMPORTED_MODULE_0__["axisLeft"]; });




/***/ }),

/***/ "./node_modules/d3-brush/src/brush.js":
/*!********************************************!*\
  !*** ./node_modules/d3-brush/src/brush.js ***!
  \********************************************/
/*! exports provided: brushSelection, brushX, brushY, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brushSelection", function() { return brushSelection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brushX", function() { return brushX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brushY", function() { return brushY; });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-brush/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-brush/src/event.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-brush/src/noevent.js");









var MODE_DRAG = {name: "drag"},
    MODE_SPACE = {name: "space"},
    MODE_HANDLE = {name: "handle"},
    MODE_CENTER = {name: "center"};

function number1(e) {
  return [+e[0], +e[1]];
}

function number2(e) {
  return [number1(e[0]), number1(e[1])];
}

function toucher(identifier) {
  return function(target) {
    return Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["touch"])(target, d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].touches, identifier);
  };
}

var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) { return xy == null ? null : number2(xy); },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].ctrlKey && !d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

// Like d3.local, but with the name __brush rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush(X);
}

function brushY() {
  return brush(Y);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return brush(XY);
});

function brush(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      touchable = defaultTouchable,
      keys = true,
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .on("mousedown.brush", started)
      .filter(touchable)
        .on("touchstart.brush", started)
        .on("touchmove.brush", touchmoved)
        .on("touchend.brush touchcancel.brush", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["interpolate"])(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && selection1 === null ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 !== null && selection1 !== null ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(that);
            state.selection = selection1 === null ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  brush.clear = function(group) {
    brush.move(group, null);
  };

  function redraw() {
    var group = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args, clean) {
    return (!clean && that.__brush.emitter) || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      else this.emit("brush");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["customEvent"])(new _event_js__WEBPACK_IMPORTED_MODULE_6__["default"](brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (touchending && !d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].touches) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].target.__data__.type,
        mode = (keys && d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx = 0,
        dy = 0,
        moving,
        shifting = signX && signY && keys && d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].shiftKey,
        lockX,
        lockY,
        pointer = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].touches ? toucher(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches[0].identifier) : d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"],
        point0 = pointer(that),
        point = point0,
        emit = emitter(that, arguments, true).beforestart();

    if (type === "overlay") {
      if (selection) moving = true;
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);
      if (keys) view
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true)

      Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragDisable"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view);
    }

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_7__["nopropagation"])();
    Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = pointer(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_7__["default"])();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_7__["nopropagation"])();
      if (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].touches) {
        if (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
      } else {
        Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragEnable"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_7__["default"])();
    }

    function keyupped() {
      switch (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_7__["default"])();
    }
  }

  function touchmoved() {
    emitter(this, arguments).moved();
  }

  function touchended() {
    emitter(this, arguments).ended();
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = number2(extent.apply(this, arguments));
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(number2(_)), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), brush) : filter;
  };

  brush.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), brush) : touchable;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.keyModifiers = function(_) {
    return arguments.length ? (keys = !!_, brush) : keys;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}


/***/ }),

/***/ "./node_modules/d3-brush/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-brush/src/constant.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-brush/src/event.js":
/*!********************************************!*\
  !*** ./node_modules/d3-brush/src/event.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
});


/***/ }),

/***/ "./node_modules/d3-brush/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-brush/src/index.js ***!
  \********************************************/
/*! exports provided: brush, brushX, brushY, brushSelection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _brush_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./brush.js */ "./node_modules/d3-brush/src/brush.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "brush", function() { return _brush_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "brushX", function() { return _brush_js__WEBPACK_IMPORTED_MODULE_0__["brushX"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "brushY", function() { return _brush_js__WEBPACK_IMPORTED_MODULE_0__["brushY"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "brushSelection", function() { return _brush_js__WEBPACK_IMPORTED_MODULE_0__["brushSelection"]; });




/***/ }),

/***/ "./node_modules/d3-brush/src/noevent.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-brush/src/noevent.js ***!
  \**********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-collection/src/entries.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-collection/src/entries.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
});


/***/ }),

/***/ "./node_modules/d3-collection/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-collection/src/index.js ***!
  \*************************************************/
/*! exports provided: nest, set, map, keys, values, entries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nest */ "./node_modules/d3-collection/src/nest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nest", function() { return _nest__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set */ "./node_modules/d3-collection/src/set.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "set", function() { return _set__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./node_modules/d3-collection/src/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _map__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keys */ "./node_modules/d3-collection/src/keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return _keys__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./values */ "./node_modules/d3-collection/src/values.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return _values__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _entries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./entries */ "./node_modules/d3-collection/src/entries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "entries", function() { return _entries__WEBPACK_IMPORTED_MODULE_5__["default"]; });









/***/ }),

/***/ "./node_modules/d3-collection/src/keys.js":
/*!************************************************!*\
  !*** ./node_modules/d3-collection/src/keys.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
});


/***/ }),

/***/ "./node_modules/d3-collection/src/map.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-collection/src/map.js ***!
  \***********************************************/
/*! exports provided: prefix, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefix", function() { return prefix; });
var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

/* harmony default export */ __webpack_exports__["default"] = (map);


/***/ }),

/***/ "./node_modules/d3-collection/src/nest.js":
/*!************************************************!*\
  !*** ./node_modules/d3-collection/src/nest.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "./node_modules/d3-collection/src/map.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = Object(_map__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
});

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return Object(_map__WEBPACK_IMPORTED_MODULE_0__["default"])();
}

function setMap(map, key, value) {
  map.set(key, value);
}


/***/ }),

/***/ "./node_modules/d3-collection/src/set.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-collection/src/set.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "./node_modules/d3-collection/src/map.js");


function Set() {}

var proto = _map__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[_map__WEBPACK_IMPORTED_MODULE_0__["prefix"] + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume its an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

/* harmony default export */ __webpack_exports__["default"] = (set);


/***/ }),

/***/ "./node_modules/d3-collection/src/values.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-collection/src/values.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
});


/***/ }),

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/*! exports provided: Color, darker, brighter, default, rgbConvert, rgb, Rgb, hslConvert, hsl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darker", function() { return darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brighter", function() { return brighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbConvert", function() { return rgbConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rgb", function() { return Rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslConvert", function() { return hslConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return hsl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/cubehelix.js":
/*!************************************************!*\
  !*** ./node_modules/d3-color/src/cubehelix.js ***!
  \************************************************/
/*! exports provided: default, Cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cubehelix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubehelix", function() { return Cubehelix; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math_js__WEBPACK_IMPORTED_MODULE_2__["rad2deg"] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Cubehelix, cubehelix, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["darker"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["darker"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math_js__WEBPACK_IMPORTED_MODULE_2__["deg2rad"],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/*! exports provided: default, extend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony default export */ __webpack_exports__["default"] = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/index.js ***!
  \********************************************/
/*! exports provided: color, rgb, hsl, lab, hcl, lch, gray, cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["rgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["hsl"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-color/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["hcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["lch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["gray"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-color/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });






/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/*! exports provided: gray, default, Lab, lch, hcl, Hcl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return gray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lab", function() { return Lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return lch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return hcl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hcl", function() { return Hcl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Lab, lab, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__["rad2deg"];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__["deg2rad"];
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hcl, hcl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/*! exports provided: deg2rad, rad2deg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deg2rad", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rad2deg", function() { return rad2deg; });
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["default"] = (dispatch);


/***/ }),

/***/ "./node_modules/d3-dispatch/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-dispatch/src/index.js ***!
  \***********************************************/
/*! exports provided: dispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return _dispatch_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./node_modules/d3-drag/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-drag/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-drag/src/drag.js":
/*!******************************************!*\
  !*** ./node_modules/d3-drag/src/drag.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].ctrlKey && !d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].x, y: d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3_selection__WEBPACK_IMPORTED_MODULE_1__["mouse"], this, arguments);
    if (!gesture) return;
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["default"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
    mousemoving = false;
    mousedownx = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientX;
    mousedowny = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientY;
    gesture("start");
  }

  function mousemoved() {
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
    if (!mousemoving) {
      var dx = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientX - mousedownx, dy = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view).on("mousemove.drag mouseup.drag", null);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["yesdrag"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view, mousemoving);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3_selection__WEBPACK_IMPORTED_MODULE_1__["touch"], this, arguments)) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["customEvent"])(new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"](drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["customEvent"])(new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"](drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});


/***/ }),

/***/ "./node_modules/d3-drag/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragEvent; });
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),

/***/ "./node_modules/d3-drag/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/index.js ***!
  \*******************************************/
/*! exports provided: drag, dragDisable, dragEnable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag.js */ "./node_modules/d3-drag/src/drag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return _drag_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["yesdrag"]; });





/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/*! exports provided: default, yesdrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yesdrag", function() { return yesdrag; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(view) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-dsv/src/autoType.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-dsv/src/autoType.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return autoType; });
function autoType(object) {
  for (var key in object) {
    var value = object[key].trim(), number, m;
    if (!value) value = null;
    else if (value === "true") value = true;
    else if (value === "false") value = false;
    else if (value === "NaN") value = NaN;
    else if (!isNaN(number = +value)) value = number;
    else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
      value = new Date(value);
    }
    else continue;
    object[key] = value;
  }
  return object;
}

// https://github.com/d3/d3-dsv/issues/45
var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/*! exports provided: csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows, csvFormatRow, csvFormatValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return csvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return csvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return csvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatBody", function() { return csvFormatBody; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return csvFormatRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatRow", function() { return csvFormatRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatValue", function() { return csvFormatValue; });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var csv = Object(_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ __webpack_exports__["default"] = (function(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
});


/***/ }),

/***/ "./node_modules/d3-dsv/src/index.js":
/*!******************************************!*\
  !*** ./node_modules/d3-dsv/src/index.js ***!
  \******************************************/
/*! exports provided: dsvFormat, csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows, csvFormatRow, csvFormatValue, tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows, tsvFormatRow, tsvFormatValue, autoType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dsvFormat", function() { return _dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _csv_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./csv.js */ "./node_modules/d3-dsv/src/csv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatBody", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvFormatBody"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvFormatRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatRow", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvFormatRow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatValue", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvFormatValue"]; });

/* harmony import */ var _tsv_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tsv.js */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatBody", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvFormatBody"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvFormatRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRow", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvFormatRow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatValue", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvFormatValue"]; });

/* harmony import */ var _autoType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./autoType.js */ "./node_modules/d3-dsv/src/autoType.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "autoType", function() { return _autoType_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/*! exports provided: tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows, tsvFormatRow, tsvFormatValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return tsvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return tsvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return tsvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatBody", function() { return tsvFormatBody; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return tsvFormatRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRow", function() { return tsvFormatRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatValue", function() { return tsvFormatValue; });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var tsv = Object(_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;


/***/ }),

/***/ "./node_modules/d3-ease/src/back.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/back.js ***!
  \******************************************/
/*! exports provided: backIn, backOut, backInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backIn", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backOut", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backInOut", function() { return backInOut; });
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);


/***/ }),

/***/ "./node_modules/d3-ease/src/bounce.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/bounce.js ***!
  \********************************************/
/*! exports provided: bounceIn, bounceOut, bounceInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceIn", function() { return bounceIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceOut", function() { return bounceOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceInOut", function() { return bounceInOut; });
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/circle.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/circle.js ***!
  \********************************************/
/*! exports provided: circleIn, circleOut, circleInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleIn", function() { return circleIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleOut", function() { return circleOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleInOut", function() { return circleInOut; });
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/*! exports provided: cubicIn, cubicOut, cubicInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicIn", function() { return cubicIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicOut", function() { return cubicOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicInOut", function() { return cubicInOut; });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/elastic.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-ease/src/elastic.js ***!
  \*********************************************/
/*! exports provided: elasticIn, elasticOut, elasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticIn", function() { return elasticIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticOut", function() { return elasticOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticInOut", function() { return elasticInOut; });
var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);


/***/ }),

/***/ "./node_modules/d3-ease/src/exp.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/exp.js ***!
  \*****************************************/
/*! exports provided: expIn, expOut, expInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expIn", function() { return expIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expOut", function() { return expOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expInOut", function() { return expInOut; });
function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/index.js ***!
  \*******************************************/
/*! exports provided: easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-ease/src/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return _linear_js__WEBPACK_IMPORTED_MODULE_0__["linear"]; });

/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-ease/src/quad.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony import */ var _cubic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubic.js */ "./node_modules/d3-ease/src/cubic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony import */ var _poly_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./poly.js */ "./node_modules/d3-ease/src/poly.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony import */ var _sin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sin.js */ "./node_modules/d3-ease/src/sin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony import */ var _exp_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exp.js */ "./node_modules/d3-ease/src/exp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./circle.js */ "./node_modules/d3-ease/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony import */ var _bounce_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bounce.js */ "./node_modules/d3-ease/src/bounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceInOut"]; });

/* harmony import */ var _back_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./back.js */ "./node_modules/d3-ease/src/back.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony import */ var _elastic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./elastic.js */ "./node_modules/d3-ease/src/elastic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticInOut"]; });






















/***/ }),

/***/ "./node_modules/d3-ease/src/linear.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/linear.js ***!
  \********************************************/
/*! exports provided: linear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
function linear(t) {
  return +t;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/poly.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/poly.js ***!
  \******************************************/
/*! exports provided: polyIn, polyOut, polyInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyIn", function() { return polyIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyOut", function() { return polyOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyInOut", function() { return polyInOut; });
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);


/***/ }),

/***/ "./node_modules/d3-ease/src/quad.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/quad.js ***!
  \******************************************/
/*! exports provided: quadIn, quadOut, quadInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadIn", function() { return quadIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadOut", function() { return quadOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadInOut", function() { return quadInOut; });
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/sin.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/sin.js ***!
  \*****************************************/
/*! exports provided: sinIn, sinOut, sinInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinIn", function() { return sinIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinOut", function() { return sinOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinInOut", function() { return sinInOut; });
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-format/src/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/defaultLocale.js ***!
  \*****************************************************/
/*! exports provided: format, formatPrefix, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatPrefix", function() { return formatPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return defaultLocale; });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});

function defaultLocale(definition) {
  locale = Object(_locale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-format/src/exponent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/exponent.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x = Object(_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(x)), x ? x[1] : NaN;
});


/***/ }),

/***/ "./node_modules/d3-format/src/formatDecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatDecimal.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
/* harmony default export */ __webpack_exports__["default"] = (function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
});


/***/ }),

/***/ "./node_modules/d3-format/src/formatGroup.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatGroup.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
});


/***/ }),

/***/ "./node_modules/d3-format/src/formatNumerals.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/formatNumerals.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
});


/***/ }),

/***/ "./node_modules/d3-format/src/formatPrefixAuto.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-format/src/formatPrefixAuto.js ***!
  \********************************************************/
/*! exports provided: prefixExponent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefixExponent", function() { return prefixExponent; });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ __webpack_exports__["default"] = (function(x, p) {
  var d = Object(_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + Object(_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, Math.max(0, p + i - 1))[0]; // less than 1y!
});


/***/ }),

/***/ "./node_modules/d3-format/src/formatRounded.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatRounded.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ __webpack_exports__["default"] = (function(x, p) {
  var d = Object(_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
});


/***/ }),

/***/ "./node_modules/d3-format/src/formatSpecifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/formatSpecifier.js ***!
  \*******************************************************/
/*! exports provided: default, FormatSpecifier */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return formatSpecifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormatSpecifier", function() { return FormatSpecifier; });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./node_modules/d3-format/src/formatTrim.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-format/src/formatTrim.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ __webpack_exports__["default"] = (function(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
});


/***/ }),

/***/ "./node_modules/d3-format/src/formatTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatTypes.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "./node_modules/d3-format/src/formatRounded.js");



/* harmony default export */ __webpack_exports__["default"] = ({
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return Object(_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"])(x * 100, p); },
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
});


/***/ }),

/***/ "./node_modules/d3-format/src/identity.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/identity.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x;
});


/***/ }),

/***/ "./node_modules/d3-format/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-format/src/index.js ***!
  \*********************************************/
/*! exports provided: formatDefaultLocale, format, formatPrefix, formatLocale, formatSpecifier, FormatSpecifier, precisionFixed, precisionPrefix, precisionRound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultLocale.js */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatDefaultLocale", function() { return _defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "format", function() { return _defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__["format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatPrefix", function() { return _defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__["formatPrefix"]; });

/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatLocale", function() { return _locale_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatSpecifier", function() { return _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FormatSpecifier", function() { return _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_2__["FormatSpecifier"]; });

/* harmony import */ var _precisionFixed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./precisionFixed.js */ "./node_modules/d3-format/src/precisionFixed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "precisionFixed", function() { return _precisionFixed_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _precisionPrefix_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./precisionPrefix.js */ "./node_modules/d3-format/src/precisionPrefix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "precisionPrefix", function() { return _precisionPrefix_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _precisionRound_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./precisionRound.js */ "./node_modules/d3-format/src/precisionRound.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "precisionRound", function() { return _precisionRound_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });









/***/ }),

/***/ "./node_modules/d3-format/src/locale.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-format/src/locale.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "./node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "./node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTrim.js */ "./node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTypes.js */ "./node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ __webpack_exports__["default"] = (function(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_7__["default"] : Object(_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__["default"])(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_7__["default"] : Object(_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__["default"])(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "-" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = Object(_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_5__["default"][type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_5__["default"][type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = Object(_formatTrim_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__["prefixExponent"] / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = Object(_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(Object(_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
});


/***/ }),

/***/ "./node_modules/d3-format/src/precisionFixed.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionFixed.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ __webpack_exports__["default"] = (function(step) {
  return Math.max(0, -Object(_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
});


/***/ }),

/***/ "./node_modules/d3-format/src/precisionPrefix.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionPrefix.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ __webpack_exports__["default"] = (function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Object(_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) / 3))) * 3 - Object(_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
});


/***/ }),

/***/ "./node_modules/d3-format/src/precisionRound.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionRound.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ __webpack_exports__["default"] = (function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, Object(_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(max) - Object(_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(step)) + 1;
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/*! exports provided: default, genericArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genericArray", function() { return genericArray; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return (Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_1__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] : genericArray)(a, b);
});

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/*! exports provided: basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basis", function() { return basis; });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(_basis_js__WEBPACK_IMPORTED_MODULE_0__["basis"])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/*! exports provided: hue, gamma, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hue", function() { return hue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gamma", function() { return gamma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return nogamma; });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/cubehelix.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/cubehelix.js ***!
  \******************************************************/
/*! exports provided: default, cubehelixLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubehelixLong", function() { return cubehelixLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(end)).h),
          s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
          l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
          opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ __webpack_exports__["default"] = (cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var cubehelixLong = cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/discrete.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/discrete.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hcl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hcl.js ***!
  \************************************************/
/*! exports provided: default, hclLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hclLong", function() { return hclLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(end)).h),
        c = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.c, end.c),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hclLong = hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hsl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hsl.js ***!
  \************************************************/
/*! exports provided: default, hslLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslLong", function() { return hslLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(end)).h),
        s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hslLong = hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hue.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hue.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["hue"])(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/index.js ***!
  \**************************************************/
/*! exports provided: interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateDiscrete, interpolateHue, interpolateNumber, interpolateNumberArray, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, piecewise, quantize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return _value_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return _array_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return _basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return _date_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _discrete_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discrete.js */ "./node_modules/d3-interpolate/src/discrete.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDiscrete", function() { return _discrete_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _hue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hue.js */ "./node_modules/d3-interpolate/src/hue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHue", function() { return _hue_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return _number_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumberArray", function() { return _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return _object_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./round.js */ "./node_modules/d3-interpolate/src/round.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return _round_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return _string_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _transform_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform/index.js */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformSvg"]; });

/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasisClosed"]; });

/* harmony import */ var _hsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hsl.js */ "./node_modules/d3-interpolate/src/hsl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["hslLong"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _hcl_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./hcl.js */ "./node_modules/d3-interpolate/src/hcl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["hclLong"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-interpolate/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["cubehelixLong"]; });

/* harmony import */ var _piecewise_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./piecewise.js */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "piecewise", function() { return _piecewise_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/d3-interpolate/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return _quantize_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });
























/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(start)).l, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(end)).l),
      a = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.a, end.a),
      b = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.b, end.b),
      opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/numberArray.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/numberArray.js ***!
  \********************************************************/
/*! exports provided: default, isNumberArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumberArray", function() { return isNumberArray; });
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
});

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return piecewise; });
function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/quantize.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/quantize.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/*! exports provided: default, rgbBasis, rgbBasisClosed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasis", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasisClosed", function() { return rgbBasisClosed; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ __webpack_exports__["default"] = ((function rgbGamma(y) {
  var color = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["gamma"])(y);

  function rgb(start, end) {
    var r = color((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(start)).r, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_2__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/*! exports provided: identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ __webpack_exports__["default"] = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/*! exports provided: interpolateTransformCss, interpolateTransformSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return interpolateTransformSvg; });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseCss"], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseSvg"], ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/*! exports provided: parseCss, parseSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseCss", function() { return parseCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSvg", function() { return parseSvg; });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  value = value.matrix;
  return Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? Object(_constant_js__WEBPACK_IMPORTED_MODULE_7__["default"])(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_4__["default"]
      : t === "string" ? ((c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : _string_js__WEBPACK_IMPORTED_MODULE_6__["default"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_3__["default"]
      : Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_8__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_2__["genericArray"]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_5__["default"]
      : _number_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
/* harmony default export */ __webpack_exports__["default"] = (function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0  u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    }
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    }
  }

  i.duration = S * 1000;

  return i;
});


/***/ }),

/***/ "./node_modules/d3-path/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-path/src/index.js ***!
  \*******************************************/
/*! exports provided: path */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-path/src/path.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "path", function() { return _path_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./node_modules/d3-path/src/path.js":
/*!******************************************!*\
  !*** ./node_modules/d3-path/src/path.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? Were done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (path);


/***/ }),

/***/ "./node_modules/d3-scale/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-scale/src/array.js ***!
  \********************************************/
/*! exports provided: map, slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
var array = Array.prototype;

var map = array.map;
var slice = array.slice;


/***/ }),

/***/ "./node_modules/d3-scale/src/band.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/band.js ***!
  \*******************************************/
/*! exports provided: default, point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return band; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _ordinal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ordinal */ "./node_modules/d3-scale/src/ordinal.js");




function band() {
  var scale = Object(_ordinal__WEBPACK_IMPORTED_MODULE_2__["default"])().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initRange"].apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}


/***/ }),

/***/ "./node_modules/d3-scale/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/constant.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-scale/src/continuous.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/continuous.js ***!
  \*************************************************/
/*! exports provided: identity, copy, transformer, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformer", function() { return transformer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return continuous; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-scale/src/constant.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number */ "./node_modules/d3-scale/src/number.js");






var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : Object(_constant__WEBPACK_IMPORTED_MODULE_3__["default"])(isNaN(b) ? NaN : 0.5);
}

function clamper(domain) {
  var a = domain[0], b = domain[domain.length - 1], t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolate"],
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"])))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_2__["map"].call(_, _number__WEBPACK_IMPORTED_MODULE_4__["default"]), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_2__["slice"].call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = _array__WEBPACK_IMPORTED_MODULE_2__["slice"].call(_), interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRound"], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous(transform, untransform) {
  return transformer()(transform, untransform);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/diverging.js":
/*!************************************************!*\
  !*** ./node_modules/d3-scale/src/diverging.js ***!
  \************************************************/
/*! exports provided: default, divergingLog, divergingSymlog, divergingPow, divergingSqrt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return diverging; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divergingLog", function() { return divergingLog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divergingSymlog", function() { return divergingSymlog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divergingPow", function() { return divergingPow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divergingSqrt", function() { return divergingSqrt; });
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log */ "./node_modules/d3-scale/src/log.js");
/* harmony import */ var _sequential__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sequential */ "./node_modules/d3-scale/src/sequential.js");
/* harmony import */ var _symlog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symlog */ "./node_modules/d3-scale/src/symlog.js");
/* harmony import */ var _pow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pow */ "./node_modules/d3-scale/src/pow.js");








function transformer() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = _continuous__WEBPACK_IMPORTED_MODULE_0__["identity"],
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
    return scale;
  };
}

function diverging() {
  var scale = Object(_linear__WEBPACK_IMPORTED_MODULE_2__["linearish"])(transformer()(_continuous__WEBPACK_IMPORTED_MODULE_0__["identity"]));

  scale.copy = function() {
    return Object(_sequential__WEBPACK_IMPORTED_MODULE_4__["copy"])(scale, diverging());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function divergingLog() {
  var scale = Object(_log__WEBPACK_IMPORTED_MODULE_3__["loggish"])(transformer()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return Object(_sequential__WEBPACK_IMPORTED_MODULE_4__["copy"])(scale, divergingLog()).base(scale.base());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function divergingSymlog() {
  var scale = Object(_symlog__WEBPACK_IMPORTED_MODULE_5__["symlogish"])(transformer());

  scale.copy = function() {
    return Object(_sequential__WEBPACK_IMPORTED_MODULE_4__["copy"])(scale, divergingSymlog()).constant(scale.constant());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function divergingPow() {
  var scale = Object(_pow__WEBPACK_IMPORTED_MODULE_6__["powish"])(transformer());

  scale.copy = function() {
    return Object(_sequential__WEBPACK_IMPORTED_MODULE_4__["copy"])(scale, divergingPow()).exponent(scale.exponent());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/identity.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return identity; });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number */ "./node_modules/d3-scale/src/number.js");




function identity(domain) {
  var unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_0__["map"].call(_, _number__WEBPACK_IMPORTED_MODULE_2__["default"]), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity(domain).unknown(unknown);
  };

  domain = arguments.length ? _array__WEBPACK_IMPORTED_MODULE_0__["map"].call(domain, _number__WEBPACK_IMPORTED_MODULE_2__["default"]) : [0, 1];

  return Object(_linear__WEBPACK_IMPORTED_MODULE_1__["linearish"])(scale);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-scale/src/index.js ***!
  \********************************************/
/*! exports provided: scaleBand, scalePoint, scaleIdentity, scaleLinear, scaleLog, scaleSymlog, scaleOrdinal, scaleImplicit, scalePow, scaleSqrt, scaleQuantile, scaleQuantize, scaleThreshold, scaleTime, scaleUtc, scaleSequential, scaleSequentialLog, scaleSequentialPow, scaleSequentialSqrt, scaleSequentialSymlog, scaleSequentialQuantile, scaleDiverging, scaleDivergingLog, scaleDivergingPow, scaleDivergingSqrt, scaleDivergingSymlog, tickFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _band__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./band */ "./node_modules/d3-scale/src/band.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleBand", function() { return _band__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalePoint", function() { return _band__WEBPACK_IMPORTED_MODULE_0__["point"]; });

/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-scale/src/identity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return _identity__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleLinear", function() { return _linear__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log */ "./node_modules/d3-scale/src/log.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleLog", function() { return _log__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _symlog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symlog */ "./node_modules/d3-scale/src/symlog.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSymlog", function() { return _symlog__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _ordinal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ordinal */ "./node_modules/d3-scale/src/ordinal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() { return _ordinal__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleImplicit", function() { return _ordinal__WEBPACK_IMPORTED_MODULE_5__["implicit"]; });

/* harmony import */ var _pow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pow */ "./node_modules/d3-scale/src/pow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalePow", function() { return _pow__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSqrt", function() { return _pow__WEBPACK_IMPORTED_MODULE_6__["sqrt"]; });

/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-scale/src/quantile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleQuantile", function() { return _quantile__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _quantize__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./quantize */ "./node_modules/d3-scale/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleQuantize", function() { return _quantize__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _threshold__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./threshold */ "./node_modules/d3-scale/src/threshold.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleThreshold", function() { return _threshold__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./time */ "./node_modules/d3-scale/src/time.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return _time__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _utcTime__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utcTime */ "./node_modules/d3-scale/src/utcTime.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleUtc", function() { return _utcTime__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _sequential__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sequential */ "./node_modules/d3-scale/src/sequential.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequential", function() { return _sequential__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialLog", function() { return _sequential__WEBPACK_IMPORTED_MODULE_12__["sequentialLog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialPow", function() { return _sequential__WEBPACK_IMPORTED_MODULE_12__["sequentialPow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialSqrt", function() { return _sequential__WEBPACK_IMPORTED_MODULE_12__["sequentialSqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialSymlog", function() { return _sequential__WEBPACK_IMPORTED_MODULE_12__["sequentialSymlog"]; });

/* harmony import */ var _sequentialQuantile__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sequentialQuantile */ "./node_modules/d3-scale/src/sequentialQuantile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialQuantile", function() { return _sequentialQuantile__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _diverging__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./diverging */ "./node_modules/d3-scale/src/diverging.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDiverging", function() { return _diverging__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingLog", function() { return _diverging__WEBPACK_IMPORTED_MODULE_14__["divergingLog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingPow", function() { return _diverging__WEBPACK_IMPORTED_MODULE_14__["divergingPow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingSqrt", function() { return _diverging__WEBPACK_IMPORTED_MODULE_14__["divergingSqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingSymlog", function() { return _diverging__WEBPACK_IMPORTED_MODULE_14__["divergingSymlog"]; });

/* harmony import */ var _tickFormat__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tickFormat */ "./node_modules/d3-scale/src/tickFormat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickFormat", function() { return _tickFormat__WEBPACK_IMPORTED_MODULE_15__["default"]; });


































/***/ }),

/***/ "./node_modules/d3-scale/src/init.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/init.js ***!
  \*******************************************/
/*! exports provided: initRange, initInterpolator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initRange", function() { return initRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initInterpolator", function() { return initInterpolator; });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.interpolator(domain); break;
    default: this.interpolator(interpolator).domain(domain); break;
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/linear.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/linear.js ***!
  \*********************************************/
/*! exports provided: linearish, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearish", function() { return linearish; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return linear; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _tickFormat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tickFormat */ "./node_modules/d3-scale/src/tickFormat.js");





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["ticks"])(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return Object(_tickFormat__WEBPACK_IMPORTED_MODULE_3__["default"])(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickIncrement"])(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickIncrement"])(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickIncrement"])(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["default"])(_continuous__WEBPACK_IMPORTED_MODULE_1__["identity"], _continuous__WEBPACK_IMPORTED_MODULE_1__["identity"]);

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["copy"])(scale, linear());
  };

  _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);

  return linearish(scale);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/log.js":
/*!******************************************!*\
  !*** ./node_modules/d3-scale/src/log.js ***!
  \******************************************/
/*! exports provided: loggish, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loggish", function() { return loggish; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return log; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/index.js");
/* harmony import */ var _nice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nice */ "./node_modules/d3-scale/src/nice.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");






function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["ticks"])(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["format"])(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(Object(_nice__WEBPACK_IMPORTED_MODULE_2__["default"])(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish(Object(_continuous__WEBPACK_IMPORTED_MODULE_3__["transformer"])()).domain([1, 10]);

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_3__["copy"])(scale, log()).base(scale.base());
  };

  _init__WEBPACK_IMPORTED_MODULE_4__["initRange"].apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/nice.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/nice.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
});


/***/ }),

/***/ "./node_modules/d3-scale/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/number.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return +x;
});


/***/ }),

/***/ "./node_modules/d3-scale/src/ordinal.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-scale/src/ordinal.js ***!
  \**********************************************/
/*! exports provided: implicit, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "implicit", function() { return implicit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ordinal; });
/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-collection */ "./node_modules/d3-collection/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




var implicit = {name: "implicit"};

function ordinal() {
  var index = Object(d3_collection__WEBPACK_IMPORTED_MODULE_0__["map"])(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = Object(d3_collection__WEBPACK_IMPORTED_MODULE_0__["map"])();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/pow.js":
/*!******************************************!*\
  !*** ./node_modules/d3-scale/src/pow.js ***!
  \******************************************/
/*! exports provided: powish, default, sqrt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "powish", function() { return powish; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(_continuous__WEBPACK_IMPORTED_MODULE_1__["identity"], _continuous__WEBPACK_IMPORTED_MODULE_1__["identity"]),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(_continuous__WEBPACK_IMPORTED_MODULE_1__["identity"], _continuous__WEBPACK_IMPORTED_MODULE_1__["identity"])
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return Object(_linear__WEBPACK_IMPORTED_MODULE_0__["linearish"])(scale);
}

function pow() {
  var scale = powish(Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["transformer"])());

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["copy"])(scale, pow()).exponent(scale.exponent());
  };

  _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantile.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return quantile; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["quantile"])(domain, i / n);
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : range[Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__["ascending"]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantize.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantize.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return quantize; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");





function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x <= x ? range[Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return _init__WEBPACK_IMPORTED_MODULE_3__["initRange"].apply(Object(_linear__WEBPACK_IMPORTED_MODULE_2__["linearish"])(scale), arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/sequential.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/sequential.js ***!
  \*************************************************/
/*! exports provided: copy, default, sequentialLog, sequentialSymlog, sequentialPow, sequentialSqrt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sequential; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequentialLog", function() { return sequentialLog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequentialSymlog", function() { return sequentialSymlog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequentialPow", function() { return sequentialPow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequentialSqrt", function() { return sequentialSqrt; });
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log */ "./node_modules/d3-scale/src/log.js");
/* harmony import */ var _symlog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symlog */ "./node_modules/d3-scale/src/symlog.js");
/* harmony import */ var _pow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pow */ "./node_modules/d3-scale/src/pow.js");







function transformer() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = _continuous__WEBPACK_IMPORTED_MODULE_0__["identity"],
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = Object(_linear__WEBPACK_IMPORTED_MODULE_2__["linearish"])(transformer()(_continuous__WEBPACK_IMPORTED_MODULE_0__["identity"]));

  scale.copy = function() {
    return copy(scale, sequential());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function sequentialLog() {
  var scale = Object(_log__WEBPACK_IMPORTED_MODULE_3__["loggish"])(transformer()).domain([1, 10]);

  scale.copy = function() {
    return copy(scale, sequentialLog()).base(scale.base());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = Object(_symlog__WEBPACK_IMPORTED_MODULE_4__["symlogish"])(transformer());

  scale.copy = function() {
    return copy(scale, sequentialSymlog()).constant(scale.constant());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function sequentialPow() {
  var scale = Object(_pow__WEBPACK_IMPORTED_MODULE_5__["powish"])(transformer());

  scale.copy = function() {
    return copy(scale, sequentialPow()).exponent(scale.exponent());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/sequentialQuantile.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-scale/src/sequentialQuantile.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sequentialQuantile; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




function sequentialQuantile() {
  var domain = [],
      interpolator = _continuous__WEBPACK_IMPORTED_MODULE_1__["identity"];

  function scale(x) {
    if (!isNaN(x = +x)) return interpolator((Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(domain, x) - 1) / (domain.length - 1));
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__["ascending"]);
    return scale;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__["initInterpolator"].apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/symlog.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/symlog.js ***!
  \*********************************************/
/*! exports provided: symlogish, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "symlogish", function() { return symlogish; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return symlog; });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return Object(_linear__WEBPACK_IMPORTED_MODULE_0__["linearish"])(scale);
}

function symlog() {
  var scale = symlogish(Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["transformer"])());

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["copy"])(scale, symlog()).constant(scale.constant());
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/threshold.js":
/*!************************************************!*\
  !*** ./node_modules/d3-scale/src/threshold.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return threshold; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x <= x ? range[Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/tickFormat.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/tickFormat.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(start, stop, count, specifier) {
  var step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickStep"])(start, stop, count),
      precision;
  specifier = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["formatSpecifier"])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["precisionPrefix"])(step, value))) specifier.precision = precision;
      return Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["formatPrefix"])(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["precisionRound"])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["precisionFixed"])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["format"])(specifier);
});


/***/ }),

/***/ "./node_modules/d3-scale/src/time.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/time.js ***!
  \*******************************************/
/*! exports provided: calendar, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calendar", function() { return calendar; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/index.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _nice__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nice */ "./node_modules/d3-scale/src/nice.js");








var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = Object(_continuous__WEBPACK_IMPORTED_MODULE_4__["default"])(_continuous__WEBPACK_IMPORTED_MODULE_4__["identity"], _continuous__WEBPACK_IMPORTED_MODULE_4__["identity"]),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisector"])(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickStep"])(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickStep"])(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(_array__WEBPACK_IMPORTED_MODULE_3__["map"].call(_, number)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(Object(_nice__WEBPACK_IMPORTED_MODULE_6__["default"])(d, interval))
        : scale;
  };

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_4__["copy"])(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return _init__WEBPACK_IMPORTED_MODULE_5__["initRange"].apply(calendar(d3_time__WEBPACK_IMPORTED_MODULE_1__["timeYear"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeMonth"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeWeek"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeDay"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeHour"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeMinute"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeSecond"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeMillisecond"], d3_time_format__WEBPACK_IMPORTED_MODULE_2__["timeFormat"]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
});


/***/ }),

/***/ "./node_modules/d3-scale/src/utcTime.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-scale/src/utcTime.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time */ "./node_modules/d3-scale/src/time.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/index.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/index.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");





/* harmony default export */ __webpack_exports__["default"] = (function() {
  return _init__WEBPACK_IMPORTED_MODULE_3__["initRange"].apply(Object(_time__WEBPACK_IMPORTED_MODULE_0__["calendar"])(d3_time__WEBPACK_IMPORTED_MODULE_2__["utcYear"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcMonth"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcWeek"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcDay"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcHour"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcMinute"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcSecond"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcMillisecond"], d3_time_format__WEBPACK_IMPORTED_MODULE_1__["utcFormat"]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/create.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/create.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select */ "./node_modules/d3-selection/src/select.js");



/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return Object(_select__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces__WEBPACK_IMPORTED_MODULE_1__["xhtml"] && document.documentElement.namespaceURI === _namespaces__WEBPACK_IMPORTED_MODULE_1__["xhtml"]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var fullname = Object(_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/index.js ***!
  \************************************************/
/*! exports provided: create, creator, local, matcher, mouse, namespace, namespaces, clientPoint, select, selectAll, selection, selector, selectorAll, style, touch, touches, window, event, customEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _create__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create */ "./node_modules/d3-selection/src/create.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _create__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator */ "./node_modules/d3-selection/src/creator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return _creator__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _local__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local */ "./node_modules/d3-selection/src/local.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return _local__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matcher */ "./node_modules/d3-selection/src/matcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _matcher__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mouse */ "./node_modules/d3-selection/src/mouse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mouse", function() { return _mouse__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-selection/src/namespace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return _namespace__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-selection/src/namespaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return _namespaces__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./point */ "./node_modules/d3-selection/src/point.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clientPoint", function() { return _point__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select */ "./node_modules/d3-selection/src/select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _select__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return _selectAll__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return _selection_index__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selector */ "./node_modules/d3-selection/src/selector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return _selector__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectorAll */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return _selectorAll__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _selection_style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection/style */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return _selection_style__WEBPACK_IMPORTED_MODULE_13__["styleValue"]; });

/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./touch */ "./node_modules/d3-selection/src/touch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touch", function() { return _touch__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _touches__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./touches */ "./node_modules/d3-selection/src/touches.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touches", function() { return _touches__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./window */ "./node_modules/d3-selection/src/window.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _window__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "event", function() { return _selection_on__WEBPACK_IMPORTED_MODULE_17__["event"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return _selection_on__WEBPACK_IMPORTED_MODULE_17__["customEvent"]; });





















/***/ }),

/***/ "./node_modules/d3-selection/src/local.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/local.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return local; });
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return function() {
    return this.matches(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/mouse.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/mouse.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-selection/src/point.js");



/* harmony default export */ __webpack_exports__["default"] = (function(node) {
  var event = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])();
  if (event.changedTouches) event = event.changedTouches[0];
  return Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, event);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/*! exports provided: xhtml, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhtml", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["default"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/point.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/point.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[selector]], _selection_index__WEBPACK_IMPORTED_MODULE_0__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([selector == null ? [] : selector], _selection_index__WEBPACK_IMPORTED_MODULE_0__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var create = typeof name === "function" ? name : Object(_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ __webpack_exports__["default"] = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./node_modules/d3-selection/src/constant.js");




var keyPrefix = "$"; // Protect against keys like __proto__.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (function(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = Object(_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return !this.node();
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/*! exports provided: default, EnterNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnterNode", function() { return EnterNode; });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._enter || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._exit || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(_matcher__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/*! exports provided: root, Selection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Selection", function() { return Selection; });
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exit */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./join */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./order */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sort */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./call */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nodes */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./node */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./size */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./empty */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./each */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./attr */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./style */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./property */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./classed */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./text */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./html */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./raise */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lower */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./append */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./insert */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./remove */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./clone */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./datum */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./on */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./dispatch */ "./node_modules/d3-selection/src/selection/dispatch.js");
































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll__WEBPACK_IMPORTED_MODULE_1__["default"],
  filter: _filter__WEBPACK_IMPORTED_MODULE_2__["default"],
  data: _data__WEBPACK_IMPORTED_MODULE_3__["default"],
  enter: _enter__WEBPACK_IMPORTED_MODULE_4__["default"],
  exit: _exit__WEBPACK_IMPORTED_MODULE_5__["default"],
  join: _join__WEBPACK_IMPORTED_MODULE_6__["default"],
  merge: _merge__WEBPACK_IMPORTED_MODULE_7__["default"],
  order: _order__WEBPACK_IMPORTED_MODULE_8__["default"],
  sort: _sort__WEBPACK_IMPORTED_MODULE_9__["default"],
  call: _call__WEBPACK_IMPORTED_MODULE_10__["default"],
  nodes: _nodes__WEBPACK_IMPORTED_MODULE_11__["default"],
  node: _node__WEBPACK_IMPORTED_MODULE_12__["default"],
  size: _size__WEBPACK_IMPORTED_MODULE_13__["default"],
  empty: _empty__WEBPACK_IMPORTED_MODULE_14__["default"],
  each: _each__WEBPACK_IMPORTED_MODULE_15__["default"],
  attr: _attr__WEBPACK_IMPORTED_MODULE_16__["default"],
  style: _style__WEBPACK_IMPORTED_MODULE_17__["default"],
  property: _property__WEBPACK_IMPORTED_MODULE_18__["default"],
  classed: _classed__WEBPACK_IMPORTED_MODULE_19__["default"],
  text: _text__WEBPACK_IMPORTED_MODULE_20__["default"],
  html: _html__WEBPACK_IMPORTED_MODULE_21__["default"],
  raise: _raise__WEBPACK_IMPORTED_MODULE_22__["default"],
  lower: _lower__WEBPACK_IMPORTED_MODULE_23__["default"],
  append: _append__WEBPACK_IMPORTED_MODULE_24__["default"],
  insert: _insert__WEBPACK_IMPORTED_MODULE_25__["default"],
  remove: _remove__WEBPACK_IMPORTED_MODULE_26__["default"],
  clone: _clone__WEBPACK_IMPORTED_MODULE_27__["default"],
  datum: _datum__WEBPACK_IMPORTED_MODULE_28__["default"],
  on: _on__WEBPACK_IMPORTED_MODULE_29__["default"],
  dispatch: _dispatch__WEBPACK_IMPORTED_MODULE_30__["default"]
};

/* harmony default export */ __webpack_exports__["default"] = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, before) {
  var create = typeof name === "function" ? name : Object(_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(lower);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](merges, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/*! exports provided: event, default, customEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event", function() { return event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return customEvent; });
var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
});

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(raise);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(remove);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select !== "function") select = Object(_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll */ "./node_modules/d3-selection/src/selectorAll.js");



/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select !== "function") select = Object(_selectorAll__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(update) {
  return new Array(update.length);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/*! exports provided: default, styleValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styleValue", function() { return styleValue; });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || Object(_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function none() {}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-selection/src/selection/on.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var current = _selection_on__WEBPACK_IMPORTED_MODULE_0__["event"], source;
  while (source = current.sourceEvent) current = source;
  return current;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/touch.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/touch.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-selection/src/point.js");



/* harmony default export */ __webpack_exports__["default"] = (function(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touch);
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/touches.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/touches.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-selection/src/point.js");



/* harmony default export */ __webpack_exports__["default"] = (function(node, touches) {
  if (touches == null) touches = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touches[i]);
  }

  return points;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),

/***/ "./node_modules/d3-shape/src/arc.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/arc.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["max"])(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_2__["halfPi"],
        a1 = endAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_2__["halfPi"],
        da = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["abs"])(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__["path"])();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"])) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math_js__WEBPACK_IMPORTED_MODULE_2__["tau"] - _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
      context.moveTo(r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(a0), r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
        context.moveTo(r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(a1), r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) && (padRadius ? +padRadius.apply(this, arguments) : Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(r0 * r0 + r1 * r1)),
          rc = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["min"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["abs"])(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1  r0, da1  da0.
      if (rp > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
        var p0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["asin"])(rp / r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(ap)),
            p1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["asin"])(rp / r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(ap));
        if ((da0 -= p0 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(a01),
          y01 = r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(a01),
          x10 = r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(a10),
          y10 = r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(a10);

      // Apply rounded corners?
      if (rc > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
        var x11 = r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(a11),
            y11 = r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(a11),
            x00 = r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(a00),
            y00 = r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < _math_js__WEBPACK_IMPORTED_MODULE_2__["pi"] && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["acos"])((ax * bx + ay * by) / (Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(ax * ax + ay * ay) * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(bx * bx + by * by))) / 2),
              lc = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["min"])(rc, (r0 - lc) / (kc - 1));
          rc1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["min"])(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"])) context.moveTo(x01, y01);

      // Does the sectors outer ring have rounded corners?
      else if (rc1 > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y01, t0.x01), Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y01, t0.x01), Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.cy + t0.y11, t0.cx + t0.x11), Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y11, t1.x11), Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and its a circular sector?
      // Or perhaps its an annular sector collapsed due to padding?
      if (!(r0 > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) || !(da0 > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"])) context.lineTo(x10, y10);

      // Does the sectors inner ring (or point) have rounded corners?
      else if (rc0 > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y01, t0.x01), Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y01, t0.x01), Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.cy + t0.y11, t0.cx + t0.x11), Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y11, t1.x11), Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math_js__WEBPACK_IMPORTED_MODULE_2__["pi"] / 2;
    return [Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(a) * r, Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/area.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/area.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






/* harmony default export */ __webpack_exports__["default"] = (function() {
  var x0 = _point_js__WEBPACK_IMPORTED_MODULE_4__["x"],
      x1 = null,
      y0 = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(0),
      y1 = _point_js__WEBPACK_IMPORTED_MODULE_4__["y"],
      defined = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_2__["default"],
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__["path"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return Object(_line_js__WEBPACK_IMPORTED_MODULE_3__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/areaRadial.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/areaRadial.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curve_radial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial.js */ "./node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "./node_modules/d3-shape/src/area.js");
/* harmony import */ var _lineRadial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lineRadial.js */ "./node_modules/d3-shape/src/lineRadial.js");




/* harmony default export */ __webpack_exports__["default"] = (function() {
  var a = Object(_area_js__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial_js__WEBPACK_IMPORTED_MODULE_0__["curveRadialLinear"]),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return Object(_lineRadial_js__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return Object(_lineRadial_js__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return Object(_lineRadial_js__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return Object(_lineRadial_js__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(Object(_curve_radial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return a;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/array.js ***!
  \********************************************/
/*! exports provided: slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
var slice = Array.prototype.slice;


/***/ }),

/***/ "./node_modules/d3-shape/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/constant.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function constant() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/basis.js ***!
  \**************************************************/
/*! exports provided: point, Basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Basis", function() { return Basis; });
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Basis(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/basisClosed.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-shape/src/curve/basis.js");



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: Object(_basis_js__WEBPACK_IMPORTED_MODULE_1__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new BasisClosed(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/basisOpen.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/basisOpen.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-shape/src/curve/basis.js");


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: Object(_basis_js__WEBPACK_IMPORTED_MODULE_0__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new BasisOpen(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/bundle.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/bundle.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-shape/src/curve/basis.js");


function Bundle(context, beta) {
  this._basis = new _basis_js__WEBPACK_IMPORTED_MODULE_0__["Basis"](context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new _basis_js__WEBPACK_IMPORTED_MODULE_0__["Basis"](context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/cardinal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/cardinal.js ***!
  \*****************************************************/
/*! exports provided: point, Cardinal, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cardinal", function() { return Cardinal; });
function point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/cardinalClosed.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/cardinalClosed.js ***!
  \***********************************************************/
/*! exports provided: CardinalClosed, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardinalClosed", function() { return CardinalClosed; });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal.js */ "./node_modules/d3-shape/src/curve/cardinal.js");



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: Object(_cardinal_js__WEBPACK_IMPORTED_MODULE_1__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/cardinalOpen.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/cardinalOpen.js ***!
  \*********************************************************/
/*! exports provided: CardinalOpen, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardinalOpen", function() { return CardinalOpen; });
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinal.js */ "./node_modules/d3-shape/src/curve/cardinal.js");


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: Object(_cardinal_js__WEBPACK_IMPORTED_MODULE_0__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/catmullRom.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/catmullRom.js ***!
  \*******************************************************/
/*! exports provided: point, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal.js */ "./node_modules/d3-shape/src/curve/cardinal.js");



function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal_js__WEBPACK_IMPORTED_MODULE_1__["Cardinal"](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/catmullRomClosed.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/catmullRomClosed.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cardinalClosed_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalClosed.js */ "./node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");
/* harmony import */ var _catmullRom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./catmullRom.js */ "./node_modules/d3-shape/src/curve/catmullRom.js");




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: Object(_catmullRom_js__WEBPACK_IMPORTED_MODULE_2__["point"])(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed_js__WEBPACK_IMPORTED_MODULE_0__["CardinalClosed"](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/catmullRomOpen.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/catmullRomOpen.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cardinalOpen_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalOpen.js */ "./node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _catmullRom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./catmullRom.js */ "./node_modules/d3-shape/src/curve/catmullRom.js");



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: Object(_catmullRom_js__WEBPACK_IMPORTED_MODULE_1__["point"])(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen_js__WEBPACK_IMPORTED_MODULE_0__["CardinalOpen"](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/linear.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/linear.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Linear(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/linearClosed.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/linearClosed.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new LinearClosed(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/monotone.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/monotone.js ***!
  \*****************************************************/
/*! exports provided: monotoneX, monotoneY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monotoneX", function() { return monotoneX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monotoneY", function() { return monotoneY; });
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bzier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/natural.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/natural.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Natural(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/radial.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/radial.js ***!
  \***************************************************/
/*! exports provided: curveRadialLinear, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveRadialLinear", function() { return curveRadialLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return curveRadial; });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-shape/src/curve/linear.js");


var curveRadialLinear = curveRadial(_linear_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/step.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/step.js ***!
  \*************************************************/
/*! exports provided: default, stepBefore, stepAfter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stepBefore", function() { return stepBefore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stepAfter", function() { return stepAfter; });
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Step(context, 0.5);
});

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/descending.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/identity.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(d) {
  return d;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/index.js ***!
  \********************************************/
/*! exports provided: arc, area, line, pie, areaRadial, radialArea, lineRadial, radialLine, pointRadial, linkHorizontal, linkVertical, linkRadial, symbol, symbols, symbolCircle, symbolCross, symbolDiamond, symbolSquare, symbolStar, symbolTriangle, symbolWye, curveBasisClosed, curveBasisOpen, curveBasis, curveBundle, curveCardinalClosed, curveCardinalOpen, curveCardinal, curveCatmullRomClosed, curveCatmullRomOpen, curveCatmullRom, curveLinearClosed, curveLinear, curveMonotoneX, curveMonotoneY, curveNatural, curveStep, curveStepAfter, curveStepBefore, stack, stackOffsetExpand, stackOffsetDiverging, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderAppearance, stackOrderAscending, stackOrderDescending, stackOrderInsideOut, stackOrderNone, stackOrderReverse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _arc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arc.js */ "./node_modules/d3-shape/src/arc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arc", function() { return _arc_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "./node_modules/d3-shape/src/area.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "area", function() { return _area_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "line", function() { return _line_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _pie_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pie.js */ "./node_modules/d3-shape/src/pie.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pie", function() { return _pie_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _areaRadial_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./areaRadial.js */ "./node_modules/d3-shape/src/areaRadial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "areaRadial", function() { return _areaRadial_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radialArea", function() { return _areaRadial_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _lineRadial_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lineRadial.js */ "./node_modules/d3-shape/src/lineRadial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lineRadial", function() { return _lineRadial_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radialLine", function() { return _lineRadial_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _pointRadial_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointRadial.js */ "./node_modules/d3-shape/src/pointRadial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointRadial", function() { return _pointRadial_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _link_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./link/index.js */ "./node_modules/d3-shape/src/link/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkHorizontal", function() { return _link_index_js__WEBPACK_IMPORTED_MODULE_7__["linkHorizontal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkVertical", function() { return _link_index_js__WEBPACK_IMPORTED_MODULE_7__["linkVertical"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkRadial", function() { return _link_index_js__WEBPACK_IMPORTED_MODULE_7__["linkRadial"]; });

/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./symbol.js */ "./node_modules/d3-shape/src/symbol.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbol", function() { return _symbol_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbols", function() { return _symbol_js__WEBPACK_IMPORTED_MODULE_8__["symbols"]; });

/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./symbol/circle.js */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolCircle", function() { return _symbol_circle_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./symbol/cross.js */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolCross", function() { return _symbol_cross_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./symbol/diamond.js */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolDiamond", function() { return _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./symbol/square.js */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolSquare", function() { return _symbol_square_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./symbol/star.js */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolStar", function() { return _symbol_star_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./symbol/triangle.js */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolTriangle", function() { return _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./symbol/wye.js */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolWye", function() { return _symbol_wye_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _curve_basisClosed_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./curve/basisClosed.js */ "./node_modules/d3-shape/src/curve/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasisClosed", function() { return _curve_basisClosed_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _curve_basisOpen_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./curve/basisOpen.js */ "./node_modules/d3-shape/src/curve/basisOpen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasisOpen", function() { return _curve_basisOpen_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _curve_basis_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./curve/basis.js */ "./node_modules/d3-shape/src/curve/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasis", function() { return _curve_basis_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _curve_bundle_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./curve/bundle.js */ "./node_modules/d3-shape/src/curve/bundle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBundle", function() { return _curve_bundle_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _curve_cardinalClosed_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./curve/cardinalClosed.js */ "./node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinalClosed", function() { return _curve_cardinalClosed_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _curve_cardinalOpen_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./curve/cardinalOpen.js */ "./node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinalOpen", function() { return _curve_cardinalOpen_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _curve_cardinal_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./curve/cardinal.js */ "./node_modules/d3-shape/src/curve/cardinal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinal", function() { return _curve_cardinal_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _curve_catmullRomClosed_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./curve/catmullRomClosed.js */ "./node_modules/d3-shape/src/curve/catmullRomClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRomClosed", function() { return _curve_catmullRomClosed_js__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _curve_catmullRomOpen_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./curve/catmullRomOpen.js */ "./node_modules/d3-shape/src/curve/catmullRomOpen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRomOpen", function() { return _curve_catmullRomOpen_js__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _curve_catmullRom_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./curve/catmullRom.js */ "./node_modules/d3-shape/src/curve/catmullRom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRom", function() { return _curve_catmullRom_js__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _curve_linearClosed_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./curve/linearClosed.js */ "./node_modules/d3-shape/src/curve/linearClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveLinearClosed", function() { return _curve_linearClosed_js__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveLinear", function() { return _curve_linear_js__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _curve_monotone_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./curve/monotone.js */ "./node_modules/d3-shape/src/curve/monotone.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneX", function() { return _curve_monotone_js__WEBPACK_IMPORTED_MODULE_28__["monotoneX"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneY", function() { return _curve_monotone_js__WEBPACK_IMPORTED_MODULE_28__["monotoneY"]; });

/* harmony import */ var _curve_natural_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./curve/natural.js */ "./node_modules/d3-shape/src/curve/natural.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveNatural", function() { return _curve_natural_js__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _curve_step_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./curve/step.js */ "./node_modules/d3-shape/src/curve/step.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStep", function() { return _curve_step_js__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStepAfter", function() { return _curve_step_js__WEBPACK_IMPORTED_MODULE_30__["stepAfter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStepBefore", function() { return _curve_step_js__WEBPACK_IMPORTED_MODULE_30__["stepBefore"]; });

/* harmony import */ var _stack_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./stack.js */ "./node_modules/d3-shape/src/stack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return _stack_js__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _offset_expand_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./offset/expand.js */ "./node_modules/d3-shape/src/offset/expand.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetExpand", function() { return _offset_expand_js__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _offset_diverging_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./offset/diverging.js */ "./node_modules/d3-shape/src/offset/diverging.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetDiverging", function() { return _offset_diverging_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _offset_none_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./offset/none.js */ "./node_modules/d3-shape/src/offset/none.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetNone", function() { return _offset_none_js__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _offset_silhouette_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./offset/silhouette.js */ "./node_modules/d3-shape/src/offset/silhouette.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetSilhouette", function() { return _offset_silhouette_js__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony import */ var _offset_wiggle_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./offset/wiggle.js */ "./node_modules/d3-shape/src/offset/wiggle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetWiggle", function() { return _offset_wiggle_js__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _order_appearance_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./order/appearance.js */ "./node_modules/d3-shape/src/order/appearance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderAppearance", function() { return _order_appearance_js__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _order_ascending_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./order/ascending.js */ "./node_modules/d3-shape/src/order/ascending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderAscending", function() { return _order_ascending_js__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _order_descending_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./order/descending.js */ "./node_modules/d3-shape/src/order/descending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderDescending", function() { return _order_descending_js__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _order_insideOut_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./order/insideOut.js */ "./node_modules/d3-shape/src/order/insideOut.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderInsideOut", function() { return _order_insideOut_js__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _order_none_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./order/none.js */ "./node_modules/d3-shape/src/order/none.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderNone", function() { return _order_none_js__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _order_reverse_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./order/reverse.js */ "./node_modules/d3-shape/src/order/reverse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderReverse", function() { return _order_reverse_js__WEBPACK_IMPORTED_MODULE_42__["default"]; });





 // Note: radialArea is deprecated!
 // Note: radialLine is deprecated!










































/***/ }),

/***/ "./node_modules/d3-shape/src/line.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/line.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");





/* harmony default export */ __webpack_exports__["default"] = (function() {
  var x = _point_js__WEBPACK_IMPORTED_MODULE_3__["x"],
      y = _point_js__WEBPACK_IMPORTED_MODULE_3__["y"],
      defined = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_2__["default"],
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__["path"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/lineRadial.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/lineRadial.js ***!
  \*************************************************/
/*! exports provided: lineRadial, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineRadial", function() { return lineRadial; });
/* harmony import */ var _curve_radial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial.js */ "./node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");



function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(Object(_curve_radial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return l;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return lineRadial(Object(_line_js__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial_js__WEBPACK_IMPORTED_MODULE_0__["curveRadialLinear"]));
});


/***/ }),

/***/ "./node_modules/d3-shape/src/link/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/link/index.js ***!
  \*************************************************/
/*! exports provided: linkHorizontal, linkVertical, linkRadial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linkHorizontal", function() { return linkHorizontal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linkVertical", function() { return linkVertical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linkRadial", function() { return linkRadial; });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../point.js */ "./node_modules/d3-shape/src/point.js");
/* harmony import */ var _pointRadial_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pointRadial.js */ "./node_modules/d3-shape/src/pointRadial.js");






function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x = _point_js__WEBPACK_IMPORTED_MODULE_3__["x"],
      y = _point_js__WEBPACK_IMPORTED_MODULE_3__["y"],
      context = null;

  function link() {
    var buffer, argv = _array_js__WEBPACK_IMPORTED_MODULE_1__["slice"].call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__["path"])();
    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), link) : x;
  };

  link.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), link) : y;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial(context, x0, y0, x1, y1) {
  var p0 = Object(_pointRadial_js__WEBPACK_IMPORTED_MODULE_4__["default"])(x0, y0),
      p1 = Object(_pointRadial_js__WEBPACK_IMPORTED_MODULE_4__["default"])(x0, y0 = (y0 + y1) / 2),
      p2 = Object(_pointRadial_js__WEBPACK_IMPORTED_MODULE_4__["default"])(x1, y0),
      p3 = Object(_pointRadial_js__WEBPACK_IMPORTED_MODULE_4__["default"])(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/math.js ***!
  \*******************************************/
/*! exports provided: abs, atan2, cos, max, min, sin, sqrt, epsilon, pi, halfPi, tau, acos, asin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pi", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPi", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tau", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/noop.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/noop.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {});


/***/ }),

/***/ "./node_modules/d3-shape/src/offset/diverging.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/offset/diverging.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/offset/expand.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/offset/expand.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/offset/none.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/offset/none.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/offset/silhouette.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-shape/src/offset/silhouette.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/offset/wiggle.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/offset/wiggle.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/order/appearance.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/order/appearance.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/order/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var peaks = series.map(peak);
  return Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
});

function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/order/ascending.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/order/ascending.js ***!
  \******************************************************/
/*! exports provided: default, sum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return sum; });
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/order/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var sums = series.map(sum);
  return Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return sums[a] - sums[b]; });
});

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/order/descending.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/order/descending.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-shape/src/order/ascending.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  return Object(_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
});


/***/ }),

/***/ "./node_modules/d3-shape/src/order/insideOut.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/order/insideOut.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _appearance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./appearance.js */ "./node_modules/d3-shape/src/order/appearance.js");
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-shape/src/order/ascending.js");



/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(_ascending_js__WEBPACK_IMPORTED_MODULE_1__["sum"]),
      order = Object(_appearance_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/order/none.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/order/none.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/order/reverse.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/order/reverse.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/order/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  return Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
});


/***/ }),

/***/ "./node_modules/d3-shape/src/pie.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/pie.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-shape/src/descending.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-shape/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");





/* harmony default export */ __webpack_exports__["default"] = (function() {
  var value = _identity_js__WEBPACK_IMPORTED_MODULE_2__["default"],
      sortValues = _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      sort = null,
      startAngle = Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      endAngle = Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_math_js__WEBPACK_IMPORTED_MODULE_3__["tau"]),
      padAngle = Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math_js__WEBPACK_IMPORTED_MODULE_3__["tau"], Math.max(-_math_js__WEBPACK_IMPORTED_MODULE_3__["tau"], endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : padAngle;
  };

  return pie;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/point.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/point.js ***!
  \********************************************/
/*! exports provided: x, y */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return x; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return y; });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/d3-shape/src/pointRadial.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/pointRadial.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
});


/***/ }),

/***/ "./node_modules/d3-shape/src/stack.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/stack.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _offset_none_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./offset/none.js */ "./node_modules/d3-shape/src/offset/none.js");
/* harmony import */ var _order_none_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./order/none.js */ "./node_modules/d3-shape/src/order/none.js");





function stackValue(d, key) {
  return d[key];
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var keys = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([]),
      order = _order_none_js__WEBPACK_IMPORTED_MODULE_3__["default"],
      offset = _offset_none_js__WEBPACK_IMPORTED_MODULE_2__["default"],
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_array_js__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? _order_none_js__WEBPACK_IMPORTED_MODULE_3__["default"] : typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_array_js__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? _offset_none_js__WEBPACK_IMPORTED_MODULE_2__["default"] : _, stack) : offset;
  };

  return stack;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-shape/src/symbol.js ***!
  \*********************************************/
/*! exports provided: symbols, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "symbols", function() { return symbols; });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/index.js");
/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/circle.js */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/cross.js */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/diamond.js */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/star.js */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/square.js */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/triangle.js */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./symbol/wye.js */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");










var symbols = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _symbol_cross_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_square_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  _symbol_wye_js__WEBPACK_IMPORTED_MODULE_7__["default"]
];

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var type = Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__["default"])(_symbol_circle_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
      size = Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__["default"])(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__["path"])();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__["default"])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__["default"])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/circle.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/circle.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / _math_js__WEBPACK_IMPORTED_MODULE_0__["pi"]);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__["tau"]);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/cross.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/cross.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/star.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/star.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


var ka = 0.89081309152928522810,
    kr = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__["pi"] / 10) / Math.sin(7 * _math_js__WEBPACK_IMPORTED_MODULE_0__["pi"] / 10),
    kx = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__["tau"] / 10) * kr,
    ky = -Math.cos(_math_js__WEBPACK_IMPORTED_MODULE_0__["tau"] / 10) * kr;

/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = _math_js__WEBPACK_IMPORTED_MODULE_0__["tau"] * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var sqrt3 = Math.sqrt(3);

/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/wye.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/wye.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-time-format/src/defaultLocale.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-time-format/src/defaultLocale.js ***!
  \**********************************************************/
/*! exports provided: timeFormat, timeParse, utcFormat, utcParse, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeFormat", function() { return timeFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeParse", function() { return timeParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcFormat", function() { return utcFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcParse", function() { return utcParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return defaultLocale; });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-time-format/src/locale.js");


var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = Object(_locale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-time-format/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-time-format/src/index.js ***!
  \**************************************************/
/*! exports provided: timeFormatDefaultLocale, timeFormat, timeParse, utcFormat, utcParse, timeFormatLocale, isoFormat, isoParse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultLocale.js */ "./node_modules/d3-time-format/src/defaultLocale.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFormatDefaultLocale", function() { return _defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFormat", function() { return _defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__["timeFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeParse", function() { return _defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__["timeParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcFormat", function() { return _defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__["utcFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcParse", function() { return _defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__["utcParse"]; });

/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-time-format/src/locale.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFormatLocale", function() { return _locale_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _isoFormat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isoFormat.js */ "./node_modules/d3-time-format/src/isoFormat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isoFormat", function() { return _isoFormat_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _isoParse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isoParse.js */ "./node_modules/d3-time-format/src/isoParse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isoParse", function() { return _isoParse_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./node_modules/d3-time-format/src/isoFormat.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-time-format/src/isoFormat.js ***!
  \******************************************************/
/*! exports provided: isoSpecifier, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isoSpecifier", function() { return isoSpecifier; });
/* harmony import */ var _defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultLocale.js */ "./node_modules/d3-time-format/src/defaultLocale.js");


var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : Object(_defaultLocale_js__WEBPACK_IMPORTED_MODULE_0__["utcFormat"])(isoSpecifier);

/* harmony default export */ __webpack_exports__["default"] = (formatIso);


/***/ }),

/***/ "./node_modules/d3-time-format/src/isoParse.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-time-format/src/isoParse.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _isoFormat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isoFormat.js */ "./node_modules/d3-time-format/src/isoFormat.js");
/* harmony import */ var _defaultLocale_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultLocale.js */ "./node_modules/d3-time-format/src/defaultLocale.js");



function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : Object(_defaultLocale_js__WEBPACK_IMPORTED_MODULE_1__["utcParse"])(_isoFormat_js__WEBPACK_IMPORTED_MODULE_0__["isoSpecifier"]);

/* harmony default export */ __webpack_exports__["default"] = (parseIso);


/***/ }),

/***/ "./node_modules/d3-time-format/src/locale.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-time-format/src/locale.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return formatLocale; });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/index.js");


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_0__["utcMonday"].ceil(week) : Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcMonday"])(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_0__["utcDay"].offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_0__["timeMonday"].ceil(week) : Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeMonday"])(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_0__["timeDay"].offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_0__["timeDay"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeYear"])(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeSunday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeYear"])(d) - 1, d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeThursday"])(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__["timeThursday"].ceil(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeThursday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeYear"])(d), d) + (Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeYear"])(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeMonday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeYear"])(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_0__["utcDay"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcYear"])(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcSunday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcYear"])(d) - 1, d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcThursday"])(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__["utcThursday"].ceil(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcThursday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcYear"])(d), d) + (Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcYear"])(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcMonday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcYear"])(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}


/***/ }),

/***/ "./node_modules/d3-time/src/day.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-time/src/day.js ***!
  \*****************************************/
/*! exports provided: default, days */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "days", function() { return days; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var day = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationMinute"]) / _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationDay"];
}, function(date) {
  return date.getDate() - 1;
});

/* harmony default export */ __webpack_exports__["default"] = (day);
var days = day.range;


/***/ }),

/***/ "./node_modules/d3-time/src/duration.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-time/src/duration.js ***!
  \**********************************************/
/*! exports provided: durationSecond, durationMinute, durationHour, durationDay, durationWeek */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "durationSecond", function() { return durationSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "durationMinute", function() { return durationMinute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "durationHour", function() { return durationHour; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "durationDay", function() { return durationDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "durationWeek", function() { return durationWeek; });
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;


/***/ }),

/***/ "./node_modules/d3-time/src/hour.js":
/*!******************************************!*\
  !*** ./node_modules/d3-time/src/hour.js ***!
  \******************************************/
/*! exports provided: default, hours */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hours", function() { return hours; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var hour = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationSecond"] - date.getMinutes() * _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationMinute"]);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationHour"]);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationHour"];
}, function(date) {
  return date.getHours();
});

/* harmony default export */ __webpack_exports__["default"] = (hour);
var hours = hour.range;


/***/ }),

/***/ "./node_modules/d3-time/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-time/src/index.js ***!
  \*******************************************/
/*! exports provided: timeInterval, timeMillisecond, timeMilliseconds, utcMillisecond, utcMilliseconds, timeSecond, timeSeconds, utcSecond, utcSeconds, timeMinute, timeMinutes, timeHour, timeHours, timeDay, timeDays, timeWeek, timeWeeks, timeSunday, timeSundays, timeMonday, timeMondays, timeTuesday, timeTuesdays, timeWednesday, timeWednesdays, timeThursday, timeThursdays, timeFriday, timeFridays, timeSaturday, timeSaturdays, timeMonth, timeMonths, timeYear, timeYears, utcMinute, utcMinutes, utcHour, utcHours, utcDay, utcDays, utcWeek, utcWeeks, utcSunday, utcSundays, utcMonday, utcMondays, utcTuesday, utcTuesdays, utcWednesday, utcWednesdays, utcThursday, utcThursdays, utcFriday, utcFridays, utcSaturday, utcSaturdays, utcMonth, utcMonths, utcYear, utcYears */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeInterval", function() { return _interval_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _millisecond_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./millisecond.js */ "./node_modules/d3-time/src/millisecond.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMillisecond", function() { return _millisecond_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMilliseconds", function() { return _millisecond_js__WEBPACK_IMPORTED_MODULE_1__["milliseconds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMillisecond", function() { return _millisecond_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMilliseconds", function() { return _millisecond_js__WEBPACK_IMPORTED_MODULE_1__["milliseconds"]; });

/* harmony import */ var _second_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./second.js */ "./node_modules/d3-time/src/second.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSecond", function() { return _second_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSeconds", function() { return _second_js__WEBPACK_IMPORTED_MODULE_2__["seconds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSecond", function() { return _second_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSeconds", function() { return _second_js__WEBPACK_IMPORTED_MODULE_2__["seconds"]; });

/* harmony import */ var _minute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./minute.js */ "./node_modules/d3-time/src/minute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMinute", function() { return _minute_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMinutes", function() { return _minute_js__WEBPACK_IMPORTED_MODULE_3__["minutes"]; });

/* harmony import */ var _hour_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hour.js */ "./node_modules/d3-time/src/hour.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeHour", function() { return _hour_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeHours", function() { return _hour_js__WEBPACK_IMPORTED_MODULE_4__["hours"]; });

/* harmony import */ var _day_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./day.js */ "./node_modules/d3-time/src/day.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeDay", function() { return _day_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeDays", function() { return _day_js__WEBPACK_IMPORTED_MODULE_5__["days"]; });

/* harmony import */ var _week_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./week.js */ "./node_modules/d3-time/src/week.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWeek", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["sunday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWeeks", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["sundays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSunday", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["sunday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSundays", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["sundays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMonday", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["monday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMondays", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["mondays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeTuesday", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["tuesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeTuesdays", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["tuesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWednesday", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["wednesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWednesdays", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["wednesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeThursday", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["thursday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeThursdays", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["thursdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFriday", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["friday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFridays", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["fridays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSaturday", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["saturday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSaturdays", function() { return _week_js__WEBPACK_IMPORTED_MODULE_6__["saturdays"]; });

/* harmony import */ var _month_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./month.js */ "./node_modules/d3-time/src/month.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMonth", function() { return _month_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMonths", function() { return _month_js__WEBPACK_IMPORTED_MODULE_7__["months"]; });

/* harmony import */ var _year_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./year.js */ "./node_modules/d3-time/src/year.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeYear", function() { return _year_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeYears", function() { return _year_js__WEBPACK_IMPORTED_MODULE_8__["years"]; });

/* harmony import */ var _utcMinute_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utcMinute.js */ "./node_modules/d3-time/src/utcMinute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMinute", function() { return _utcMinute_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMinutes", function() { return _utcMinute_js__WEBPACK_IMPORTED_MODULE_9__["utcMinutes"]; });

/* harmony import */ var _utcHour_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utcHour.js */ "./node_modules/d3-time/src/utcHour.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcHour", function() { return _utcHour_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcHours", function() { return _utcHour_js__WEBPACK_IMPORTED_MODULE_10__["utcHours"]; });

/* harmony import */ var _utcDay_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utcDay.js */ "./node_modules/d3-time/src/utcDay.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcDay", function() { return _utcDay_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcDays", function() { return _utcDay_js__WEBPACK_IMPORTED_MODULE_11__["utcDays"]; });

/* harmony import */ var _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utcWeek.js */ "./node_modules/d3-time/src/utcWeek.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWeek", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcSunday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWeeks", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcSundays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSunday", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcSunday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSundays", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcSundays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMonday", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcMonday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMondays", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcMondays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcTuesday", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcTuesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcTuesdays", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcTuesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWednesday", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcWednesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWednesdays", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcWednesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcThursday", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcThursday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcThursdays", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcThursdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcFriday", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcFriday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcFridays", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcFridays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSaturday", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcSaturday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSaturdays", function() { return _utcWeek_js__WEBPACK_IMPORTED_MODULE_12__["utcSaturdays"]; });

/* harmony import */ var _utcMonth_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utcMonth.js */ "./node_modules/d3-time/src/utcMonth.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMonth", function() { return _utcMonth_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMonths", function() { return _utcMonth_js__WEBPACK_IMPORTED_MODULE_13__["utcMonths"]; });

/* harmony import */ var _utcYear_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utcYear.js */ "./node_modules/d3-time/src/utcYear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcYear", function() { return _utcYear_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcYears", function() { return _utcYear_js__WEBPACK_IMPORTED_MODULE_14__["utcYears"]; });
































/***/ }),

/***/ "./node_modules/d3-time/src/interval.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-time/src/interval.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return newInterval; });
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}


/***/ }),

/***/ "./node_modules/d3-time/src/millisecond.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-time/src/millisecond.js ***!
  \*************************************************/
/*! exports provided: default, milliseconds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "milliseconds", function() { return milliseconds; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var millisecond = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ __webpack_exports__["default"] = (millisecond);
var milliseconds = millisecond.range;


/***/ }),

/***/ "./node_modules/d3-time/src/minute.js":
/*!********************************************!*\
  !*** ./node_modules/d3-time/src/minute.js ***!
  \********************************************/
/*! exports provided: default, minutes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minutes", function() { return minutes; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var minute = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationSecond"]);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationMinute"]);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationMinute"];
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ __webpack_exports__["default"] = (minute);
var minutes = minute.range;


/***/ }),

/***/ "./node_modules/d3-time/src/month.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-time/src/month.js ***!
  \*******************************************/
/*! exports provided: default, months */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "months", function() { return months; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var month = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ __webpack_exports__["default"] = (month);
var months = month.range;


/***/ }),

/***/ "./node_modules/d3-time/src/second.js":
/*!********************************************!*\
  !*** ./node_modules/d3-time/src/second.js ***!
  \********************************************/
/*! exports provided: default, seconds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "seconds", function() { return seconds; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var second = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationSecond"]);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationSecond"];
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ __webpack_exports__["default"] = (second);
var seconds = second.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcDay.js":
/*!********************************************!*\
  !*** ./node_modules/d3-time/src/utcDay.js ***!
  \********************************************/
/*! exports provided: default, utcDays */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcDays", function() { return utcDays; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var utcDay = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationDay"];
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ __webpack_exports__["default"] = (utcDay);
var utcDays = utcDay.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcHour.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-time/src/utcHour.js ***!
  \*********************************************/
/*! exports provided: default, utcHours */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcHours", function() { return utcHours; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var utcHour = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationHour"]);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationHour"];
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ __webpack_exports__["default"] = (utcHour);
var utcHours = utcHour.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcMinute.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-time/src/utcMinute.js ***!
  \***********************************************/
/*! exports provided: default, utcMinutes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcMinutes", function() { return utcMinutes; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var utcMinute = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationMinute"]);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationMinute"];
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ __webpack_exports__["default"] = (utcMinute);
var utcMinutes = utcMinute.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcMonth.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-time/src/utcMonth.js ***!
  \**********************************************/
/*! exports provided: default, utcMonths */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcMonths", function() { return utcMonths; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var utcMonth = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ __webpack_exports__["default"] = (utcMonth);
var utcMonths = utcMonth.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcWeek.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-time/src/utcWeek.js ***!
  \*********************************************/
/*! exports provided: utcSunday, utcMonday, utcTuesday, utcWednesday, utcThursday, utcFriday, utcSaturday, utcSundays, utcMondays, utcTuesdays, utcWednesdays, utcThursdays, utcFridays, utcSaturdays */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcSunday", function() { return utcSunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcMonday", function() { return utcMonday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcTuesday", function() { return utcTuesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcWednesday", function() { return utcWednesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcThursday", function() { return utcThursday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcFriday", function() { return utcFriday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcSaturday", function() { return utcSaturday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcSundays", function() { return utcSundays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcMondays", function() { return utcMondays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcTuesdays", function() { return utcTuesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcWednesdays", function() { return utcWednesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcThursdays", function() { return utcThursdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcFridays", function() { return utcFridays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcSaturdays", function() { return utcSaturdays; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



function utcWeekday(i) {
  return Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationWeek"];
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcYear.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-time/src/utcYear.js ***!
  \*********************************************/
/*! exports provided: default, utcYears */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcYears", function() { return utcYears; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var utcYear = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (utcYear);
var utcYears = utcYear.range;


/***/ }),

/***/ "./node_modules/d3-time/src/week.js":
/*!******************************************!*\
  !*** ./node_modules/d3-time/src/week.js ***!
  \******************************************/
/*! exports provided: sunday, monday, tuesday, wednesday, thursday, friday, saturday, sundays, mondays, tuesdays, wednesdays, thursdays, fridays, saturdays */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sunday", function() { return sunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monday", function() { return monday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tuesday", function() { return tuesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wednesday", function() { return wednesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "thursday", function() { return thursday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "friday", function() { return friday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saturday", function() { return saturday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sundays", function() { return sundays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mondays", function() { return mondays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tuesdays", function() { return tuesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wednesdays", function() { return wednesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "thursdays", function() { return thursdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fridays", function() { return fridays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saturdays", function() { return saturdays; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



function weekday(i) {
  return Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationMinute"]) / _duration_js__WEBPACK_IMPORTED_MODULE_1__["durationWeek"];
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;


/***/ }),

/***/ "./node_modules/d3-time/src/year.js":
/*!******************************************!*\
  !*** ./node_modules/d3-time/src/year.js ***!
  \******************************************/
/*! exports provided: default, years */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "years", function() { return years; });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var year = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (year);
var years = year.range;


/***/ }),

/***/ "./node_modules/d3-timer/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/index.js ***!
  \********************************************/
/*! exports provided: now, timer, timerFlush, timeout, interval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timerFlush"]; });

/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timeout.js */ "./node_modules/d3-timer/src/timeout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return _timeout_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-timer/src/interval.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return _interval_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });








/***/ }),

/***/ "./node_modules/d3-timer/src/interval.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-timer/src/interval.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"], total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? Object(_timer_js__WEBPACK_IMPORTED_MODULE_0__["now"])() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"];
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/*! exports provided: now, Timer, timer, timerFlush */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return Timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return timerFlush; });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["SCHEDULED"] && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]([[node]], root, name, +i);
      }
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/*! exports provided: transition, active, interrupt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "active", function() { return _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["STARTING"] && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDING"];
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDED"];
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return this.each(function() {
    Object(_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_2__["easeCubicInOut"]
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), defaultTiming;
    }
  }
  return timing;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]) {
    id = name._id, name = name._name;
  } else {
    id = Object(_transition_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])(), (timing = defaultTiming).time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        Object(_transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["namespace"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformSvg"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_2__["tweenValue"])(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["namespace"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).delay;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).duration;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).ease;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["matcher"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/*! exports provided: Transition, default, newId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return Transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newId", function() { return newId; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");





















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_19__["default"]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"]
      : (c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateString"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](merges, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"] : _schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"];
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.on("end.remove", removeFunction(this._id));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/*! exports provided: CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED, default, init, set, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATED", function() { return CREATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCHEDULED", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING", function() { return STARTING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTED", function() { return STARTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUNNING", function() { return RUNNING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDING", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDED", function() { return ENDED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");



var emptyOn = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ __webpack_exports__["default"] = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timer"])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selector"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(subgroup[i], name, id, i, subgroup, Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selectorAll"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.constructor;

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new Selection(this._groups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        string1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["set"])(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformCss"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_4__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_3__["tweenValue"])(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(Object(_tween_js__WEBPACK_IMPORTED_MODULE_0__["tweenValue"])(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["get"])(node, id0);
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id1);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/*! exports provided: default, tweenValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tweenValue", function() { return tweenValue; });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZoomEvent; });
function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/*! exports provided: zoom, zoomTransform, zoomIdentity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["identity"]; });





/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/*! exports provided: Transform, identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].ctrlKey && !d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"];
}

function defaultWheelDelta() {
  return -d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].deltaY * (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].deltaMode === 1 ? 0.05 : d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].deltaMode ? 1 : 0.002);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["interpolateZoom"],
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p);
  };

  zoom.scaleTo = function(selection, k, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p);
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"].translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["customEvent"])(new _event_js__WEBPACK_IMPORTED_MODULE_6__["default"](zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments, true),
        v = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this),
        x0 = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientX,
        y0 = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientY;

    Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragDisable"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();
    g.mouse = [p, this.__zoom.invert(p)];
    Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
    g.start();

    function mousemoved() {
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])();
      if (!g.moved) {
        var dx = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientX - x0, dy = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragEnable"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view, g.moved);
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])();
    if (duration > 0) Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).transition().duration(duration).call(schedule, t1, p0);
    else Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].touches,
        n = touches.length,
        g = gesture(this, arguments, d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches.length === n),
        started, i, t, p;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["touch"])(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }
  }

  function touchmoved() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches,
        n = touches.length, i, t, p, l;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    g.taps = 0;
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["touch"])(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches,
        n = touches.length, i, t;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        var p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
});


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!./styles.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),

/***/ "./src/trendgraph.js":
/*!***************************!*\
  !*** ./src/trendgraph.js ***!
  \***************************/
/*! exports provided: graph */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "graph", function() { return graph; });
/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.css */ "./src/styles.css");
/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_styles_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var billboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! billboard.js */ "./node_modules/billboard.js/dist/billboard.js");
/* harmony import */ var billboard_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(billboard_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var billboard_js_dist_billboard_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! billboard.js/dist/billboard.css */ "./node_modules/billboard.js/dist/billboard.css");
/* harmony import */ var billboard_js_dist_billboard_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(billboard_js_dist_billboard_css__WEBPACK_IMPORTED_MODULE_2__);






function graph(options) {
    //the output object
    let out = {};
    out.data_ = {};
    out.grid_ = {};
    out.axis_ = {};
    out.bindto_ = ''

    //definition of generic accessors based on the name of each parameter name
    for (let p in out)
        (function () {
            let p_ = p;
            out[p_.substring(0, p_.length - 1)] = function (v) {
                if (!arguments.length) return out[p_];
                out[p_] = v;
                return out;
            };
        })();

    out.build = function () {
        var chart = billboard_js__WEBPACK_IMPORTED_MODULE_1___default.a.generate({
            data: out.data_,
            grid: out.grid_,
            axis: out.axis_,
            bindto: out.bindto_
        });
    }

    return out;
}

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmVuZGdyYXBoL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly90cmVuZGdyYXBoL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvYmlsbGJvYXJkLmpzL2Rpc3QvYmlsbGJvYXJkLmNzcz80Yjg0Iiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvYmlsbGJvYXJkLmpzL2Rpc3QvYmlsbGJvYXJkLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvYmlsbGJvYXJkLmpzL2Rpc3QvYmlsbGJvYXJkLmNzcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vc3JjL3N0eWxlcy5jc3MiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYXNjZW5kaW5nLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9iaXNlY3Rvci5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9jcm9zcy5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9kZXNjZW5kaW5nLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2RldmlhdGlvbi5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9leHRlbnQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvaGlzdG9ncmFtLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21heC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZWFuLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21lZGlhbi5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZXJnZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9taW4uanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3BhaXJzLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3Blcm11dGUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcXVhbnRpbGUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc2Nhbi5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9zaHVmZmxlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3N1bS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aHJlc2hvbGQvZnJlZWRtYW5EaWFjb25pcy5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aHJlc2hvbGQvc2NvdHQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGhyZXNob2xkL3N0dXJnZXMuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGlja3MuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdHJhbnNwb3NlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3ZhcmlhbmNlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3ppcC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWF4aXMvc3JjL2FycmF5LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXhpcy9zcmMvYXhpcy5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWF4aXMvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtYXhpcy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1icnVzaC9zcmMvYnJ1c2guanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1icnVzaC9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1icnVzaC9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1icnVzaC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1icnVzaC9zcmMvbm9ldmVudC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWNvbGxlY3Rpb24vc3JjL2VudHJpZXMuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1jb2xsZWN0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWNvbGxlY3Rpb24vc3JjL2tleXMuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1jb2xsZWN0aW9uL3NyYy9tYXAuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1jb2xsZWN0aW9uL3NyYy9uZXN0LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtY29sbGVjdGlvbi9zcmMvc2V0LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtY29sbGVjdGlvbi9zcmMvdmFsdWVzLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2NvbG9yLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2N1YmVoZWxpeC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvbGFiLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9zcmMvZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2RyYWcuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ldmVudC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9kcmFnLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9ldmVudC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWRzdi9zcmMvYXV0b1R5cGUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1kc3Yvc3JjL2Nzdi5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWRzdi9zcmMvZHN2LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZHN2L3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWRzdi9zcmMvdHN2LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvYmFjay5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2JvdW5jZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2N1YmljLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvZWxhc3RpYy5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2V4cC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvbGluZWFyLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvcG9seS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL3F1YWQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9zaW4uanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2RlZmF1bHRMb2NhbGUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2V4cG9uZW50LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXREZWNpbWFsLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRHcm91cC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0TnVtZXJhbHMuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFByZWZpeEF1dG8uanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFJvdW5kZWQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFNwZWNpZmllci5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHJpbS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHlwZXMuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvbG9jYWxlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9wcmVjaXNpb25GaXhlZC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvcHJlY2lzaW9uUHJlZml4LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9wcmVjaXNpb25Sb3VuZC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpcy5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpc0Nsb3NlZC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jdWJlaGVsaXguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvZGF0ZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9kaXNjcmV0ZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9oY2wuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvaHNsLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2h1ZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9sYWIuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL251bWJlckFycmF5LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL29iamVjdC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9waWVjZXdpc2UuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcXVhbnRpemUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcmdiLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JvdW5kLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3N0cmluZy5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vZGVjb21wb3NlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9pbmRleC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vcGFyc2UuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdmFsdWUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXBhdGgvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtcGF0aC9zcmMvcGF0aC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9iYW5kLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnRpbnVvdXMuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvZGl2ZXJnaW5nLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2luaXQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbGluZWFyLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2xvZy5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9uaWNlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL251bWJlci5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9vcmRpbmFsLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3Bvdy5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGlsZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGl6ZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zZXF1ZW50aWFsLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3NlcXVlbnRpYWxRdWFudGlsZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zeW1sb2cuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGhyZXNob2xkLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpY2tGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGltZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy91dGNUaW1lLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdG9yLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbG9jYWwuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL21hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL21vdXNlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2UuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3BvaW50LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2FwcGVuZC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jYWxsLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vY2xhc3NlZC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Nsb25lLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0YS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2RhdHVtLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lYWNoLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW1wdHkuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbnRlci5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2V4aXQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9odG1sLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbnNlcnQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9qb2luLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbG93ZXIuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9ub2Rlcy5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29uLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vb3JkZXIuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JhaXNlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcmVtb3ZlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2l6ZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NvcnQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zcGFyc2UuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdG9yLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3RvckFsbC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc291cmNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3RvdWNoLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy90b3VjaGVzLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy93aW5kb3cuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJjLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FyZWEuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJlYVJhZGlhbC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9iYXNpcy5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9iYXNpc0Nsb3NlZC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9iYXNpc09wZW4uanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYnVuZGxlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhcmRpbmFsLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhcmRpbmFsQ2xvc2VkLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhcmRpbmFsT3Blbi5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhdG11bGxSb21DbG9zZWQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2F0bXVsbFJvbU9wZW4uanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvbGluZWFyLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2xpbmVhckNsb3NlZC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9tb25vdG9uZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9uYXR1cmFsLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL3JhZGlhbC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9zdGVwLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2Rlc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbGluZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9saW5lUmFkaWFsLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2xpbmsvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9ub29wLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29mZnNldC9kaXZlcmdpbmcuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb2Zmc2V0L2V4cGFuZC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvbm9uZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvc2lsaG91ZXR0ZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvd2lnZ2xlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29yZGVyL2FwcGVhcmFuY2UuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvYXNjZW5kaW5nLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29yZGVyL2Rlc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvaW5zaWRlT3V0LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29yZGVyL25vbmUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvcmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9waWUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcG9pbnQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcG9pbnRSYWRpYWwuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3RhY2suanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9jaXJjbGUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2Nyb3NzLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9kaWFtb25kLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9zcXVhcmUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3N0YXIuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3RyaWFuZ2xlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC93eWUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10aW1lLWZvcm1hdC9zcmMvZGVmYXVsdExvY2FsZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUtZm9ybWF0L3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUtZm9ybWF0L3NyYy9pc29Gb3JtYXQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10aW1lLWZvcm1hdC9zcmMvaXNvUGFyc2UuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10aW1lLWZvcm1hdC9zcmMvbG9jYWxlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvZGF5LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvZHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy9ob3VyLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy9pbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL21pbGxpc2Vjb25kLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvbWludXRlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvbW9udGguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy9zZWNvbmQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy91dGNEYXkuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy91dGNIb3VyLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdXRjTWludXRlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdXRjTW9udGguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy91dGNXZWVrLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdXRjWWVhci5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL3dlZWsuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy95ZWFyLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL2ludGVydmFsLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL3RpbWVvdXQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvdGltZXIuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9hY3RpdmUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL2ludGVycnVwdC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi9pbnRlcnJ1cHQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vdHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vYXR0ci5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vYXR0clR3ZWVuLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9kZWxheS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2UuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2VuZC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZmlsdGVyLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vaW50ZXJwb2xhdGUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL21lcmdlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vcmVtb3ZlLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zY2hlZHVsZS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zZWxlY3RBbGwuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3N0eWxlVHdlZW4uanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHRUd2Vlbi5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vdHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vdHdlZW4uanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL2V2ZW50LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdHJlbmRncmFwaC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly90cmVuZGdyYXBoLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9zcmMvc3R5bGVzLmNzcz80NGIyIiwid2VicGFjazovL3RyZW5kZ3JhcGgvLi9zcmMvdHJlbmRncmFwaC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtE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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQSw4QkFBOEI7QUFDOUI7O0FBRUEsOEJBQThCO0FBQzlCOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsMkdBQTJHLGFBQWE7O0FBRXhIO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0RBQWdELHNCQUFzQjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUZBQXFGO0FBQ3JGOztBQUVBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCwyRkFBMkYsZUFBZTs7QUFFMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxtS0FBbUssT0FBTzs7QUFFMUs7QUFDQSxD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QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7QUFHRDs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLOztBQUVMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUpBQXVKO0FBQzlKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNB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QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdDQUFnQztBQUNsRCxrQkFBa0IsZ0NBQWdDO0FBQ2xELGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEIsa0JBQWtCLFlBQVk7QUFDOUIsa0JBQWtCLFlBQVk7QUFDOUIsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakMsa0JBQWtCLFNBQVM7QUFDM0Isa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMENBQTBDLE1BQU07QUFDaEQsc0NBQXNDLE1BQU07QUFDNUMseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtB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Y0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0NBQXdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0NBQXdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztB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YUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDLHNDQUFzQyxNQUFNO0FBQzVDLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsTUFBTTtBQUN4QjtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDLGNBQWMsK0NBQStDO0FBQzdELGNBQWM7QUFDZDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlDQUFpQztBQUMvQyxjQUFjLHFEQUFxRDtBQUNuRSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLE9BQU87QUFDekI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEIsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQyxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CLE9BQU87QUFDMUIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixnQkFBZ0I7QUFDbEMsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLGVBQWU7QUFDakM7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxNQUFNO0FBQ25CLGlCQUFpQixNQUFNO0FBQ3ZCLHVCQUF1QixnR0FBZ0c7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0NBQXdDLEVBQUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFNBQVM7QUFDM0Isa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLGdCQUFnQjtBQUNsQyxrQkFBa0IsZUFBZTtBQUNqQyxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsY0FBYztBQUNoQyxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsU0FBUztBQUMzQixrQkFBa0IsU0FBUztBQUMzQixrQkFBa0IsUUFBUTtBQUMxQixtQkFBbUIsT0FBTztBQUMxQixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFNBQVM7QUFDM0Isa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLGdCQUFnQjtBQUNsQyxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGtCQUFrQixPQUFPO0FBQ3pCLHdDQUF3QyxrQkFBa0I7QUFDMUQsb0VBQW9FLEtBQUs7QUFDekU7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTyx5QkFBeUIsd0JBQXdCO0FBQzFFLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0IsRUFBRTtBQUMxRCx3REFBd0QsYUFBYSxFQUFFO0FBQ3ZFLDBEQUEwRCxjQUFjO0FBQ3hFLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQixhQUFhO0FBQ3ZELGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlLEdBQUc7QUFDckQsNEJBQTRCLG9CQUFvQixTQUFTLE9BQU87QUFDaEUsbUNBQW1DLE9BQU8sRUFBRSxNQUFNO0FBQ2xELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLEtBQUs7QUFDakY7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1DQUFtQyxlQUFlLEdBQUc7QUFDckQsNEJBQTRCLG9CQUFvQixTQUFTLE9BQU8sUUFBUSxNQUFNO0FBQzlFLG1DQUFtQyxPQUFPLEVBQUUsTUFBTSxRQUFRLE1BQU07QUFDaEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esc0JBQXNCLHVEQUF1RDtBQUM3RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHNCQUFzQix1REFBdUQ7QUFDN0U7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxzQkFBc0IsdURBQXVEO0FBQzdFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esc0JBQXNCLHVEQUF1RDtBQUM3RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUyxRQUFRLHFCQUFxQjs7QUFFdEM7QUFDQSxPQUFPLFFBQVEsNEJBQTRCO0FBQzNDLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLE1BQU07QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZSxNQUFNLE9BQU8sUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGOztBQUVyRjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBbUI7QUFDekUsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGFBQWE7O0FBRXJHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtB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QTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLGVBQWU7QUFDNUMsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0ZBQWdGLGtFQUFrRTs7QUFFbEo7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSw4SEFBOEgsYUFBYTs7QUFFM0k7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZSxxQkFBcUIsT0FBTyxZQUFZLGFBQWEsb0JBQW9CLDZEQUE2RCxPQUFPLHFDQUFxQyxPQUFPLGVBQWUsTUFBTSxzQ0FBc0MsT0FBTyxzQkFBc0IsZ0VBQWdFLE1BQU07QUFDN1ksR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxZQUFZO0FBQ3pCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLHFaQUFxWjs7O0FBRzFaO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksY0FBYztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FB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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FB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O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixhQUFhOztBQUV0QztBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsK0ZBQStGLFdBQVc7QUFDMUcsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDSkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEyQzs7QUFFcEM7O0FBRUE7QUFDQTs7QUFFUDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ25LRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE4QztBQUN5RTtBQUNBO0FBQ3JFOzs7Ozs7Ozs7Ozs7O0FDSGxEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEyQjs7QUFFM0IsVUFBVSx1REFBRzs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZQO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVNO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUNwQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUFBO0FBQUE7QUFBQTtBQUFPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFBQTtBQUFBO0FBQUE7QUFBTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQy9ERDtBQUFBO0FBQUE7QUFBQTtBQUEwQzs7Ozs7Ozs7Ozs7OztBQ0ExQztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVlLG1FQUFJLEVBQUM7Ozs7Ozs7Ozs7Ozs7QUNqSXBCO0FBQUE7QUFBQTtBQUFBOztBQUVPO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIUDtBQUFBO0FBQUE7QUFBQTtBQUFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpREFBUyxjQUFjLHlEQUFTO0FBQ3hFLGlCQUFpQiw4Q0FBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0Msa0RBQVUsY0FBYywwREFBVTtBQUMxRSxpQkFBaUIsK0NBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsK0NBQU8sT0FBTyx3REFBUTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrREFBVSxPQUFPLHdEQUFRO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsNERBQVksTUFBTSxvREFBWTtBQUM5RCxhQUFhLG9EQUFZLE9BQU8sd0RBQVEsV0FBVyx3REFBUTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtEQUFVLE9BQU8sd0RBQVE7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsOENBQU0sT0FBTyx1REFBTztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpREFBUyxPQUFPLHVEQUFPO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQVcsTUFBTSxtREFBVztBQUM1RCxhQUFhLG1EQUFXLE9BQU8sdURBQU8sV0FBVyx1REFBTztBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGlEQUFTLE9BQU8sdURBQU87QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0cEJBO0FBQUE7QUFBQTtBQUFBO0FBQXFDO0FBQ3FCOztBQUUxRCxVQUFVLDREQUFRO0FBQ2xCO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNELGdGQUFnRiwyREFBYyxJQUFJLHdEQUFXO0FBQzdHLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRWMsa0VBQUcsRUFBQztBQUNaOzs7Ozs7Ozs7Ozs7O0FDZFA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQU87QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0pQO0FBQUE7QUFBQTtBQUFBO0FBQXFDO0FBQ3NDOztBQUUzRSxXQUFXLDREQUFRO0FBQ25CLG1FQUFtRSwyREFBYyx1QkFBdUIsMkRBQWM7QUFDdEgsQ0FBQztBQUNELDhCQUE4Qix5REFBWTtBQUMxQyxDQUFDO0FBQ0QseUJBQXlCLHlEQUFZO0FBQ3JDLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRWMsbUVBQUksRUFBQztBQUNiOzs7Ozs7Ozs7Ozs7O0FDZFA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRXVCOztBQU9HOztBQU9MOztBQUtBOztBQUtGOztBQUtEOztBQW1CQzs7QUFLQzs7QUFLRDs7QUFLSzs7QUFLRjs7QUFLRDs7QUFtQkM7O0FBS0M7O0FBS0Q7Ozs7Ozs7Ozs7Ozs7QUN4R3RCO0FBQUE7QUFBQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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OztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7Ozs7Ozs7QUNuQkEsVUFBVSxtQkFBTyxDQUFDLG1KQUF3RTtBQUMxRiwwQkFBMEIsbUJBQU8sQ0FBQyxvSEFBdUQ7O0FBRXpGOztBQUVBO0FBQ0EsMEJBQTBCLFFBQVM7QUFDbkM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7OztBQUlBLHNDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJxQjtBQUNTO0FBQ1c7O0FBRWxDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0IsbURBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxDIiwiZmlsZSI6InRyZW5kZ3JhcGguanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJ0cmVuZGdyYXBoXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInRyZW5kZ3JhcGhcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiYnVpbGRcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvdHJlbmRncmFwaC5qc1wiKTtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vYmlsbGJvYXJkLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBcclxuICogYmlsbGJvYXJkLmpzLCBKYXZhU2NyaXB0IGNoYXJ0IGxpYnJhcnlcclxuICogaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL1xyXG4gKiBcclxuICogQHZlcnNpb24gMS4xMi4xMVxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJkMy10aW1lLWZvcm1hdFwiKSwgcmVxdWlyZShcImQzLXNlbGVjdGlvblwiKSwgcmVxdWlyZShcImQzLXRyYW5zaXRpb25cIiksIHJlcXVpcmUoXCJkMy1heGlzXCIpLCByZXF1aXJlKFwiZDMtc2NhbGVcIiksIHJlcXVpcmUoXCJkMy1icnVzaFwiKSwgcmVxdWlyZShcImQzLWRzdlwiKSwgcmVxdWlyZShcImQzLWRyYWdcIiksIHJlcXVpcmUoXCJkMy1zaGFwZVwiKSwgcmVxdWlyZShcImQzLWludGVycG9sYXRlXCIpLCByZXF1aXJlKFwiZDMtY29sb3JcIiksIHJlcXVpcmUoXCJkMy16b29tXCIpLCByZXF1aXJlKFwiZDMtZWFzZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJkMy10aW1lLWZvcm1hdFwiLCBcImQzLXNlbGVjdGlvblwiLCBcImQzLXRyYW5zaXRpb25cIiwgXCJkMy1heGlzXCIsIFwiZDMtc2NhbGVcIiwgXCJkMy1icnVzaFwiLCBcImQzLWRzdlwiLCBcImQzLWRyYWdcIiwgXCJkMy1zaGFwZVwiLCBcImQzLWludGVycG9sYXRlXCIsIFwiZDMtY29sb3JcIiwgXCJkMy16b29tXCIsIFwiZDMtZWFzZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZmFjdG9yeShyZXF1aXJlKFwiZDMtdGltZS1mb3JtYXRcIiksIHJlcXVpcmUoXCJkMy1zZWxlY3Rpb25cIiksIHJlcXVpcmUoXCJkMy10cmFuc2l0aW9uXCIpLCByZXF1aXJlKFwiZDMtYXhpc1wiKSwgcmVxdWlyZShcImQzLXNjYWxlXCIpLCByZXF1aXJlKFwiZDMtYnJ1c2hcIiksIHJlcXVpcmUoXCJkMy1kc3ZcIiksIHJlcXVpcmUoXCJkMy1kcmFnXCIpLCByZXF1aXJlKFwiZDMtc2hhcGVcIiksIHJlcXVpcmUoXCJkMy1pbnRlcnBvbGF0ZVwiKSwgcmVxdWlyZShcImQzLWNvbG9yXCIpLCByZXF1aXJlKFwiZDMtem9vbVwiKSwgcmVxdWlyZShcImQzLWVhc2VcIikpIDogZmFjdG9yeShyb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0pO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzRfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX182X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzdfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fOF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX185X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzEwX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzExX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzEyX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzEzX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzE0X18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzJfXztcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fM19fO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180X187XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzVfXztcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNl9fO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX183X187XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzhfXztcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fOV9fO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMTBfXztcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzExX187XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xMl9fO1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMTNfXztcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzE0X187XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYmJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGJiOyB9KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanNcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qc1xuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanNcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanNcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlUmVzdC5qc1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanNcblxuXG5cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qc1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtdGltZS1mb3JtYXRcIixcImNvbW1vbmpzMlwiOlwiZDMtdGltZS1mb3JtYXRcIixcImFtZFwiOlwiZDMtdGltZS1mb3JtYXRcIixcInJvb3RcIjpcImQzXCJ9XG52YXIgZXh0ZXJuYWxfY29tbW9uanNfZDNfdGltZV9mb3JtYXRfY29tbW9uanMyX2QzX3RpbWVfZm9ybWF0X2FtZF9kM190aW1lX2Zvcm1hdF9yb290X2QzXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNlbGVjdGlvblwiLFwiY29tbW9uanMyXCI6XCJkMy1zZWxlY3Rpb25cIixcImFtZFwiOlwiZDMtc2VsZWN0aW9uXCIsXCJyb290XCI6XCJkM1wifVxudmFyIGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy10cmFuc2l0aW9uXCIsXCJjb21tb25qczJcIjpcImQzLXRyYW5zaXRpb25cIixcImFtZFwiOlwiZDMtdHJhbnNpdGlvblwiLFwicm9vdFwiOlwiZDNcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc19kM190cmFuc2l0aW9uX2NvbW1vbmpzMl9kM190cmFuc2l0aW9uX2FtZF9kM190cmFuc2l0aW9uX3Jvb3RfZDNfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtYXhpc1wiLFwiY29tbW9uanMyXCI6XCJkMy1heGlzXCIsXCJhbWRcIjpcImQzLWF4aXNcIixcInJvb3RcIjpcImQzXCJ9XG52YXIgZXh0ZXJuYWxfY29tbW9uanNfZDNfYXhpc19jb21tb25qczJfZDNfYXhpc19hbWRfZDNfYXhpc19yb290X2QzXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNjYWxlXCIsXCJjb21tb25qczJcIjpcImQzLXNjYWxlXCIsXCJhbWRcIjpcImQzLXNjYWxlXCIsXCJyb290XCI6XCJkM1wifVxudmFyIGV4dGVybmFsX2NvbW1vbmpzX2QzX3NjYWxlX2NvbW1vbmpzMl9kM19zY2FsZV9hbWRfZDNfc2NhbGVfcm9vdF9kM18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb25maWcvY2xhc3Nlcy5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIENTUyBjbGFzcyBuYW1lcyBkZWZpbml0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb25maWdfY2xhc3NlcyA9ICh7XG4gIGFyYzogXCJiYi1hcmNcIixcbiAgYXJjTGFiZWxMaW5lOiBcImJiLWFyYy1sYWJlbC1saW5lXCIsXG4gIGFyY3M6IFwiYmItYXJjc1wiLFxuICBhcmVhOiBcImJiLWFyZWFcIixcbiAgYXJlYXM6IFwiYmItYXJlYXNcIixcbiAgYXhpczogXCJiYi1heGlzXCIsXG4gIGF4aXNYOiBcImJiLWF4aXMteFwiLFxuICBheGlzWExhYmVsOiBcImJiLWF4aXMteC1sYWJlbFwiLFxuICBheGlzWTogXCJiYi1heGlzLXlcIixcbiAgYXhpc1kyOiBcImJiLWF4aXMteTJcIixcbiAgYXhpc1kyTGFiZWw6IFwiYmItYXhpcy15Mi1sYWJlbFwiLFxuICBheGlzWUxhYmVsOiBcImJiLWF4aXMteS1sYWJlbFwiLFxuICBiYXI6IFwiYmItYmFyXCIsXG4gIGJhcnM6IFwiYmItYmFyc1wiLFxuICBicnVzaDogXCJiYi1icnVzaFwiLFxuICBidXR0b246IFwiYmItYnV0dG9uXCIsXG4gIGJ1dHRvblpvb21SZXNldDogXCJiYi16b29tLXJlc2V0XCIsXG4gIGNoYXJ0OiBcImJiLWNoYXJ0XCIsXG4gIGNoYXJ0QXJjOiBcImJiLWNoYXJ0LWFyY1wiLFxuICBjaGFydEFyY3M6IFwiYmItY2hhcnQtYXJjc1wiLFxuICBjaGFydEFyY3NCYWNrZ3JvdW5kOiBcImJiLWNoYXJ0LWFyY3MtYmFja2dyb3VuZFwiLFxuICBjaGFydEFyY3NHYXVnZU1heDogXCJiYi1jaGFydC1hcmNzLWdhdWdlLW1heFwiLFxuICBjaGFydEFyY3NHYXVnZU1pbjogXCJiYi1jaGFydC1hcmNzLWdhdWdlLW1pblwiLFxuICBjaGFydEFyY3NHYXVnZVVuaXQ6IFwiYmItY2hhcnQtYXJjcy1nYXVnZS11bml0XCIsXG4gIGNoYXJ0QXJjc1RpdGxlOiBcImJiLWNoYXJ0LWFyY3MtdGl0bGVcIixcbiAgY2hhcnRBcmNzR2F1Z2VUaXRsZTogXCJiYi1jaGFydC1hcmNzLWdhdWdlLXRpdGxlXCIsXG4gIGNoYXJ0QmFyOiBcImJiLWNoYXJ0LWJhclwiLFxuICBjaGFydEJhcnM6IFwiYmItY2hhcnQtYmFyc1wiLFxuICBjaGFydExpbmU6IFwiYmItY2hhcnQtbGluZVwiLFxuICBjaGFydExpbmVzOiBcImJiLWNoYXJ0LWxpbmVzXCIsXG4gIGNoYXJ0UmFkYXI6IFwiYmItY2hhcnQtcmFkYXJcIixcbiAgY2hhcnRSYWRhcnM6IFwiYmItY2hhcnQtcmFkYXJzXCIsXG4gIGNoYXJ0VGV4dDogXCJiYi1jaGFydC10ZXh0XCIsXG4gIGNoYXJ0VGV4dHM6IFwiYmItY2hhcnQtdGV4dHNcIixcbiAgY2lyY2xlOiBcImJiLWNpcmNsZVwiLFxuICBjaXJjbGVzOiBcImJiLWNpcmNsZXNcIixcbiAgY29sb3JQYXR0ZXJuOiBcImJiLWNvbG9yLXBhdHRlcm5cIixcbiAgY29sb3JTY2FsZTogXCJiYi1jb2xvcnNjYWxlXCIsXG4gIGRlZm9jdXNlZDogXCJiYi1kZWZvY3VzZWRcIixcbiAgZHJhZ2FyZWE6IFwiYmItZHJhZ2FyZWFcIixcbiAgZW1wdHk6IFwiYmItZW1wdHlcIixcbiAgZXZlbnRSZWN0OiBcImJiLWV2ZW50LXJlY3RcIixcbiAgZXZlbnRSZWN0czogXCJiYi1ldmVudC1yZWN0c1wiLFxuICBldmVudFJlY3RzTXVsdGlwbGU6IFwiYmItZXZlbnQtcmVjdHMtbXVsdGlwbGVcIixcbiAgZXZlbnRSZWN0c1NpbmdsZTogXCJiYi1ldmVudC1yZWN0cy1zaW5nbGVcIixcbiAgZm9jdXNlZDogXCJiYi1mb2N1c2VkXCIsXG4gIGdhdWdlVmFsdWU6IFwiYmItZ2F1Z2UtdmFsdWVcIixcbiAgZ3JpZDogXCJiYi1ncmlkXCIsXG4gIGdyaWRMaW5lczogXCJiYi1ncmlkLWxpbmVzXCIsXG4gIGxlZ2VuZEJhY2tncm91bmQ6IFwiYmItbGVnZW5kLWJhY2tncm91bmRcIixcbiAgbGVnZW5kSXRlbTogXCJiYi1sZWdlbmQtaXRlbVwiLFxuICBsZWdlbmRJdGVtRXZlbnQ6IFwiYmItbGVnZW5kLWl0ZW0tZXZlbnRcIixcbiAgbGVnZW5kSXRlbUZvY3VzZWQ6IFwiYmItbGVnZW5kLWl0ZW0tZm9jdXNlZFwiLFxuICBsZWdlbmRJdGVtSGlkZGVuOiBcImJiLWxlZ2VuZC1pdGVtLWhpZGRlblwiLFxuICBsZWdlbmRJdGVtUG9pbnQ6IFwiYmItbGVnZW5kLWl0ZW0tcG9pbnRcIixcbiAgbGVnZW5kSXRlbVRpbGU6IFwiYmItbGVnZW5kLWl0ZW0tdGlsZVwiLFxuICBsZXZlbDogXCJiYi1sZXZlbFwiLFxuICBsZXZlbHM6IFwiYmItbGV2ZWxzXCIsXG4gIGxpbmU6IFwiYmItbGluZVwiLFxuICBsaW5lczogXCJiYi1saW5lc1wiLFxuICByZWdpb246IFwiYmItcmVnaW9uXCIsXG4gIHJlZ2lvbnM6IFwiYmItcmVnaW9uc1wiLFxuICBzZWxlY3RlZENpcmNsZTogXCJiYi1zZWxlY3RlZC1jaXJjbGVcIixcbiAgc2VsZWN0ZWRDaXJjbGVzOiBcImJiLXNlbGVjdGVkLWNpcmNsZXNcIixcbiAgc2hhcGU6IFwiYmItc2hhcGVcIixcbiAgc2hhcGVzOiBcImJiLXNoYXBlc1wiLFxuICBzdGFuZm9yZEVsZW1lbnRzOiBcImJiLXN0YW5mb3JkLWVsZW1lbnRzXCIsXG4gIHN0YW5mb3JkTGluZTogXCJiYi1zdGFuZm9yZC1saW5lXCIsXG4gIHN0YW5mb3JkTGluZXM6IFwiYmItc3RhbmZvcmQtbGluZXNcIixcbiAgc3RhbmZvcmRSZWdpb246IFwiYmItc3RhbmZvcmQtcmVnaW9uXCIsXG4gIHN0YW5mb3JkUmVnaW9uczogXCJiYi1zdGFuZm9yZC1yZWdpb25zXCIsXG4gIHRhcmdldDogXCJiYi10YXJnZXRcIixcbiAgdGV4dDogXCJiYi10ZXh0XCIsXG4gIHRleHRzOiBcImJiLXRleHRzXCIsXG4gIHRpdGxlOiBcImJiLXRpdGxlXCIsXG4gIHRvb2x0aXA6IFwiYmItdG9vbHRpcFwiLFxuICB0b29sdGlwQ29udGFpbmVyOiBcImJiLXRvb2x0aXAtY29udGFpbmVyXCIsXG4gIHRvb2x0aXBOYW1lOiBcImJiLXRvb2x0aXAtbmFtZVwiLFxuICB4Z3JpZDogXCJiYi14Z3JpZFwiLFxuICB4Z3JpZEZvY3VzOiBcImJiLXhncmlkLWZvY3VzXCIsXG4gIHhncmlkTGluZTogXCJiYi14Z3JpZC1saW5lXCIsXG4gIHhncmlkTGluZXM6IFwiYmIteGdyaWQtbGluZXNcIixcbiAgeGdyaWRzOiBcImJiLXhncmlkc1wiLFxuICB5Z3JpZDogXCJiYi15Z3JpZFwiLFxuICB5Z3JpZEZvY3VzOiBcImJiLXlncmlkLWZvY3VzXCIsXG4gIHlncmlkTGluZTogXCJiYi15Z3JpZC1saW5lXCIsXG4gIHlncmlkTGluZXM6IFwiYmIteWdyaWQtbGluZXNcIixcbiAgeWdyaWRzOiBcImJiLXlncmlkc1wiLFxuICB6b29tQnJ1c2g6IFwiYmItem9vbS1icnVzaFwiLFxuICB6b29tUmVjdDogXCJiYi16b29tLXJlY3RcIixcbiAgRVhQQU5ERUQ6IFwiX2V4cGFuZGVkX1wiLFxuICBTRUxFQ1RFRDogXCJfc2VsZWN0ZWRfXCIsXG4gIElOQ0xVREVEOiBcIl9pbmNsdWRlZF9cIixcbiAgVGV4dE92ZXJsYXBwaW5nOiBcInRleHQtb3ZlcmxhcHBpbmdcIlxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qc1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZC5qc1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzXG5cblxuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qc1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtYnJ1c2hcIixcImNvbW1vbmpzMlwiOlwiZDMtYnJ1c2hcIixcImFtZFwiOlwiZDMtYnJ1c2hcIixcInJvb3RcIjpcImQzXCJ9XG52YXIgZXh0ZXJuYWxfY29tbW9uanNfZDNfYnJ1c2hfY29tbW9uanMyX2QzX2JydXNoX2FtZF9kM19icnVzaF9yb290X2QzXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ludGVybmFscy9icm93c2VyLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cbi8qKlxuICogV2luZG93IG9iamVjdFxuICogQG1vZHVsZVxuICogQGlnbm9yZVxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jLCBuby11bmRlZiAqL1xudmFyIHdpbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRlZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvICE9PSBcInVuZGVmaW5lZFwiICYmIG87XG4gIH07XG5cbiAgcmV0dXJuIGRlZihzZWxmKSB8fCBkZWYod2luZG93KSB8fCBkZWYoZ2xvYmFsKSB8fCBkZWYoZ2xvYmFsVGhpcykgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSgpLFxuICAgIGJyb3dzZXJfZG9jID0gd2luICYmIHdpbi5kb2N1bWVudDtcbi8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMsIG5vLXVuZGVmICovXG5cblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbnRlcm5hbHMvdXRpbC5qc1xuXG5cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIEBpZ25vcmVcbiAqL1xuXG5cblxuXG5cbnZhciBpc1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIHYgfHwgdiA9PT0gMDtcbn0sXG4gICAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBpc1N0cmluZyA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgaXNOdW1iZXIgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCI7XG59LFxuICAgIGlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBpc0RlZmluZWQgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gdHlwZW9mIHYgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIGlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJib29sZWFuXCI7XG59LFxuICAgIGNlaWwxMCA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBNYXRoLmNlaWwodiAvIDEwKSAqIDEwO1xufSxcbiAgICBhc0hhbGZQaXhlbCA9IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBNYXRoLmNlaWwobikgKyAuNTtcbn0sXG4gICAgZGlmZkRvbWFpbiA9IGZ1bmN0aW9uIChkKSB7XG4gIHJldHVybiBkWzFdIC0gZFswXTtcbn0sXG4gICAgaXNPYmplY3RUeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIF90eXBlb2YodikgPT09IFwib2JqZWN0XCI7XG59LFxuICAgIGlzRW1wdHkgPSBmdW5jdGlvbiAobykge1xuICByZXR1cm4gaXNVbmRlZmluZWQobykgfHwgbyA9PT0gbnVsbCB8fCBpc1N0cmluZyhvKSAmJiBvLmxlbmd0aCA9PT0gMCB8fCBpc09iamVjdFR5cGUobykgJiYgIShvIGluc3RhbmNlb2YgRGF0ZSkgJiYgT2JqZWN0LmtleXMobykubGVuZ3RoID09PSAwIHx8IGlzTnVtYmVyKG8pICYmIGlzTmFOKG8pO1xufSxcbiAgICBub3RFbXB0eSA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiAhaXNFbXB0eShvKTtcbn0sXG4gICAgaXNBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIGFyciAmJiBhcnIuY29uc3RydWN0b3IgPT09IEFycmF5O1xufSxcbiAgICBpc09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiAhb2JqLm5vZGVUeXBlICYmIGlzT2JqZWN0VHlwZShvYmopICYmICFpc0FycmF5KG9iaik7XG59LFxuICAgIGdldE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gaXNEZWZpbmVkKG9wdGlvbnNba2V5XSkgPyBvcHRpb25zW2tleV0gOiBkZWZhdWx0VmFsdWU7XG59LFxuICAgIHV0aWxfaGFzVmFsdWUgPSBmdW5jdGlvbiAoZGljdCwgdmFsdWUpIHtcbiAgdmFyIGZvdW5kID0gITE7XG4gIHJldHVybiBPYmplY3Qua2V5cyhkaWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gZGljdFtrZXldID09PSB2YWx1ZSAmJiAoZm91bmQgPSAhMCk7XG4gIH0pLCBmb3VuZDtcbn0sXG4gICAgY2FsbEZuID0gZnVuY3Rpb24gKGZuKSB7XG4gIGZvciAodmFyIGlzRm4gPSBpc0Z1bmN0aW9uKGZuKSwgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblxuICByZXR1cm4gaXNGbiAmJiBmbi5jYWxsLmFwcGx5KGZuLCBhcmdzKSwgaXNGbjtcbn0sXG4gICAgc2FuaXRpc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBpc1N0cmluZyhzdHIpID8gc3RyLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpIDogc3RyO1xufSxcbiAgICBzZXRUZXh0VmFsdWUgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICB2YXIgZHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFstMSwgMV0sXG4gICAgICB0b01pZGRsZSA9ICEhKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkKSAmJiBhcmd1bWVudHNbM107XG4gIGlmIChub2RlICYmIGlzU3RyaW5nKHRleHQpKSBpZiAodGV4dC5pbmRleE9mKFwiXFxuXCIpID09PSAtMSkgbm9kZS50ZXh0KHRleHQpO2Vsc2Uge1xuICAgIHZhciBkaWZmID0gW25vZGUudGV4dCgpLCB0ZXh0XS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2LnJlcGxhY2UoL1tcXHNcXG5dL2csIFwiXCIpO1xuICAgIH0pO1xuXG4gICAgaWYgKGRpZmZbMF0gIT09IGRpZmZbMV0pIHtcbiAgICAgIHZhciBtdWx0aWxpbmUgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgIGxlbiA9IHRvTWlkZGxlID8gbXVsdGlsaW5lLmxlbmd0aCAtIDEgOiAxO1xuICAgICAgbm9kZS5odG1sKFwiXCIpLCBtdWx0aWxpbmUuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICBub2RlLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJkeVwiLCBcIlwiLmNvbmNhdChpID09PSAwID8gZHlbMF0gKiBsZW4gOiBkeVsxXSwgXCJlbVwiKSkudGV4dCh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBnZXRSZWN0U2VnTGlzdCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIC8qXG4gICAqIHNlZzEgLS0tLS0tLS0tLSBzZWcyXG4gICAqICAgfCAgICAgICAgICAgICAgIHxcbiAgICogICB8ICAgICAgICAgICAgICAgfFxuICAgKiAgIHwgICAgICAgICAgICAgICB8XG4gICAqIHNlZzAgLS0tLS0tLS0tLSBzZWczXG4gICAqICovXG4gIHZhciBfcGF0aCRnZXRCQm94ID0gcGF0aC5nZXRCQm94KCksXG4gICAgICB4ID0gX3BhdGgkZ2V0QkJveC54LFxuICAgICAgeSA9IF9wYXRoJGdldEJCb3gueSxcbiAgICAgIHdpZHRoID0gX3BhdGgkZ2V0QkJveC53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9wYXRoJGdldEJCb3guaGVpZ2h0O1xuXG4gIHJldHVybiBbe1xuICAgIHg6IHgsXG4gICAgeTogeSArIGhlaWdodFxuICB9LCAvLyBzZWcwXG4gIHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSwgLy8gc2VnMVxuICB7XG4gICAgeDogeCArIHdpZHRoLFxuICAgIHk6IHlcbiAgfSwgLy8gc2VnMlxuICB7XG4gICAgeDogeCArIHdpZHRoLFxuICAgIHk6IHkgKyBoZWlnaHRcbiAgfSAvLyBzZWczXG4gIF07XG59LFxuICAgIGdldFBhdGhCb3ggPSBmdW5jdGlvbiAocGF0aCkge1xuICB2YXIgX3BhdGgkZ2V0Qm91bmRpbmdDbGllID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHdpZHRoID0gX3BhdGgkZ2V0Qm91bmRpbmdDbGllLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3BhdGgkZ2V0Qm91bmRpbmdDbGllLmhlaWdodCxcbiAgICAgIGl0ZW1zID0gZ2V0UmVjdFNlZ0xpc3QocGF0aCksXG4gICAgICB4ID0gaXRlbXNbMF0ueCxcbiAgICAgIHkgPSBNYXRoLm1pbihpdGVtc1swXS55LCBpdGVtc1sxXS55KTtcblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0sXG4gICAgZ2V0QnJ1c2hTZWxlY3Rpb24gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHZhciBzZWxlY3Rpb24gPSBudWxsLFxuICAgICAgZXZlbnQgPSBleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wiZXZlbnRcIl0sXG4gICAgICBtYWluID0gY3R4LmNvbnRleHQgfHwgY3R4Lm1haW47XG4gIHJldHVybiBldmVudCAmJiBldmVudC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkJydXNoRXZlbnRcIiA/IHNlbGVjdGlvbiA9IGV2ZW50LnNlbGVjdGlvbiA6IG1haW4gJiYgKHNlbGVjdGlvbiA9IG1haW4uc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5icnVzaCkpLm5vZGUoKSkgJiYgKHNlbGVjdGlvbiA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19icnVzaF9jb21tb25qczJfZDNfYnJ1c2hfYW1kX2QzX2JydXNoX3Jvb3RfZDNfW1wiYnJ1c2hTZWxlY3Rpb25cIl0pKHNlbGVjdGlvbikpLCBzZWxlY3Rpb247XG59LFxuICAgIGdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlLnJlY3QgfHwgKG5vZGUucmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xufSxcbiAgICBnZXRSYW5kb20gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhc1N0ciA9ICEoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQpIHx8IGFyZ3VtZW50c1swXTtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKyAoYXNTdHIgPyBcIlwiIDogMCk7XG59LFxuICAgIGJydXNoRW1wdHkgPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHZhciBzZWxlY3Rpb24gPSBnZXRCcnVzaFNlbGVjdGlvbihjdHgpO1xuICByZXR1cm4gIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb25bMF0gPT09IHNlbGVjdGlvblsxXTtcbn0sXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gIGZvciAodmFyIHAgaW4gc291cmNlKSB0YXJnZXRbcF0gPSBzb3VyY2VbcF07XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0sXG4gICAgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn0sXG4gICAgdG9BcnJheSA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKHYpO1xufSxcbiAgICBnZXRDc3NSdWxlcyA9IGZ1bmN0aW9uIChzdHlsZVNoZWV0cykge1xuICB2YXIgcnVsZXMgPSBbXTtcbiAgcmV0dXJuIHN0eWxlU2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHNoZWV0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHNoZWV0LmNzc1J1bGVzICYmIHNoZWV0LmNzc1J1bGVzLmxlbmd0aCAmJiAocnVsZXMgPSBydWxlcy5jb25jYXQodG9BcnJheShzaGVldC5jc3NSdWxlcykpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2hpbGUgcmVhZGluZyBydWxlcyBmcm9tIFwiLmNvbmNhdChzaGVldC5ocmVmLCBcIjogXCIpLmNvbmNhdChlLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gIH0pLCBydWxlcztcbn0sXG4gICAgZ2V0VHJhbnNsYXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgdHJhbnNmb3JtID0gbm9kZSA/IG5vZGUudHJhbnNmb3JtIDogbnVsbCxcbiAgICAgIGJhc2VWYWwgPSB0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtLmJhc2VWYWw7XG4gIHJldHVybiBiYXNlVmFsICYmIGJhc2VWYWwubnVtYmVyT2ZJdGVtcyA/IGJhc2VWYWwuZ2V0SXRlbSgwKS5tYXRyaXggOiB7XG4gICAgYTogMCxcbiAgICBiOiAwLFxuICAgIGM6IDAsXG4gICAgZDogMCxcbiAgICBlOiAwLFxuICAgIGY6IDBcbiAgfTtcbn0sXG4gICAgZ2V0VW5pcXVlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIGlzRGF0ZSA9IGRhdGFbMF0gaW5zdGFuY2VvZiBEYXRlLFxuICAgICAgZCA9IChpc0RhdGUgPyBkYXRhLm1hcChOdW1iZXIpIDogZGF0YSkuZmlsdGVyKGZ1bmN0aW9uICh2LCBpLCBzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGYuaW5kZXhPZih2KSA9PT0gaTtcbiAgfSk7XG4gIHJldHVybiBpc0RhdGUgPyBkLm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBuZXcgRGF0ZSh2KTtcbiAgfSkgOiBkO1xufSxcbiAgICBtZXJnZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gYXJyICYmIGFyci5sZW5ndGggPyBhcnIucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgcmV0dXJuIHAuY29uY2F0KGMpO1xuICB9KSA6IFtdO1xufSxcbiAgICBtZXJnZU9iaiA9IGZ1bmN0aW9uIChfbWVyZ2VPYmopIHtcbiAgZnVuY3Rpb24gbWVyZ2VPYmooKSB7XG4gICAgcmV0dXJuIF9tZXJnZU9iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIG1lcmdlT2JqLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbWVyZ2VPYmoudG9TdHJpbmcoKTtcbiAgfSwgbWVyZ2VPYmo7XG59KGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBvYmplY3ROID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykgb2JqZWN0Tltfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcblxuICBpZiAoIW9iamVjdE4ubGVuZ3RoIHx8IG9iamVjdE4ubGVuZ3RoID09PSAxICYmICFvYmplY3ROWzBdKSByZXR1cm4gdGFyZ2V0O1xuICB2YXIgc291cmNlID0gb2JqZWN0Ti5zaGlmdCgpO1xuICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpICYmIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XG4gICAgaXNPYmplY3QodmFsdWUpID8gKCF0YXJnZXRba2V5XSAmJiAodGFyZ2V0W2tleV0gPSB7fSksIHRhcmdldFtrZXldID0gbWVyZ2VPYmoodGFyZ2V0W2tleV0sIHZhbHVlKSkgOiB0YXJnZXRba2V5XSA9IGlzQXJyYXkodmFsdWUpID8gdmFsdWUuY29uY2F0KCkgOiB2YWx1ZTtcbiAgfSksIG1lcmdlT2JqLmFwcGx5KHZvaWQgMCwgW3RhcmdldF0uY29uY2F0KG9iamVjdE4pKTtcbn0pLFxuICAgIHNvcnRWYWx1ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBmbixcbiAgICAgIGlzQXNjID0gIShhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCkgfHwgYXJndW1lbnRzWzFdO1xuICByZXR1cm4gZGF0YVswXSBpbnN0YW5jZW9mIERhdGUgPyBmbiA9IGlzQXNjID8gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0gOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiIC0gYTtcbiAgfSA6IGlzQXNjICYmICFkYXRhLmV2ZXJ5KGlzTmFOKSA/IGZuID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0gOiAhaXNBc2MgJiYgKGZuID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGIgJiYgLTEgfHwgYSA8IGIgJiYgMSB8fCBhID09PSBiICYmIDA7XG4gIH0pLCBkYXRhLmNvbmNhdCgpLnNvcnQoZm4pO1xufSxcbiAgICBnZXRNaW5NYXggPSBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xuICB2YXIgcmVzID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gbm90RW1wdHkodik7XG4gIH0pO1xuICByZXR1cm4gcmVzLmxlbmd0aCA/IGlzTnVtYmVyKHJlc1swXSkgPyByZXMgPSBNYXRoW3R5cGVdLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShyZXMpKSA6IHJlc1swXSBpbnN0YW5jZW9mIERhdGUgJiYgKHJlcyA9IHNvcnRWYWx1ZShyZXMsIHR5cGUgPT09IFwibWluXCIpWzBdKSA6IHJlcyA9IHVuZGVmaW5lZCwgcmVzO1xufSxcbiAgICBnZXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIGZvciAodmFyIHN0ZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDEsIHJlcyA9IFtdLCBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChlbmQgLSBzdGFydCkgLyBzdGVwKSkgfCAwLCBpID0gc3RhcnQ7IGkgPCBuOyBpKyspIHJlcy5wdXNoKHN0YXJ0ICsgaSAqIHN0ZXApO1xuXG4gIHJldHVybiByZXM7XG59LFxuICAgIGVtdWxhdGVFdmVudCA9IHtcbiAgbW91c2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ2V0UGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnViYmxlczogITEsXG4gICAgICAgIGNhbmNlbGFibGU6ICExLFxuICAgICAgICBzY3JlZW5YOiAwLFxuICAgICAgICBzY3JlZW5ZOiAwLFxuICAgICAgICBjbGllbnRYOiAwLFxuICAgICAgICBjbGllbnRZOiAwXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBNb3VzZUV2ZW50KFwidFwiKSwgZnVuY3Rpb24gKGVsLCBldmVudFR5cGUpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZ2V0UGFyYW1zKCk7XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMpKTtcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUG9seWZpbGxzIERPTTQgTW91c2VFdmVudFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbCwgZXZlbnRUeXBlKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGdldFBhcmFtcygpLFxuICAgICAgICAgICAgbW91c2VFdmVudCA9IGJyb3dzZXJfZG9jLmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcbiAgICAgICAgbW91c2VFdmVudC5pbml0TW91c2VFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgd2luLCAwLCAvLyB0aGUgZXZlbnQncyBtb3VzZSBjbGljayBjb3VudFxuICAgICAgICBwYXJhbXMuc2NyZWVuWCwgcGFyYW1zLnNjcmVlblksIHBhcmFtcy5jbGllbnRYLCBwYXJhbXMuY2xpZW50WSwgITEsICExLCAhMSwgITEsIDAsIG51bGwpLCBlbC5kaXNwYXRjaEV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgfTtcbiAgICB9XG4gIH0oKSxcbiAgdG91Y2g6IGZ1bmN0aW9uIHRvdWNoKGVsLCBldmVudFR5cGUsIHBhcmFtcykge1xuICAgIHZhciB0b3VjaE9iaiA9IG5ldyBUb3VjaChtZXJnZU9iaih7XG4gICAgICBpZGVudGlmaWVyOiBEYXRlLm5vdygpLFxuICAgICAgdGFyZ2V0OiBlbCxcbiAgICAgIHJhZGl1c1g6IDIuNSxcbiAgICAgIHJhZGl1c1k6IDIuNSxcbiAgICAgIHJvdGF0aW9uQW5nbGU6IDEwLFxuICAgICAgZm9yY2U6IC41XG4gICAgfSwgcGFyYW1zKSk7XG4gICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgVG91Y2hFdmVudChldmVudFR5cGUsIHtcbiAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgYnViYmxlczogITAsXG4gICAgICBzaGlmdEtleTogITAsXG4gICAgICB0b3VjaGVzOiBbdG91Y2hPYmpdLFxuICAgICAgdGFyZ2V0VG91Y2hlczogW10sXG4gICAgICBjaGFuZ2VkVG91Y2hlczogW3RvdWNoT2JqXVxuICAgIH0pKTtcbiAgfVxufSxcbiAgICB0cGxQcm9jZXNzID0gZnVuY3Rpb24gKHRwbCwgZGF0YSkge1xuICB2YXIgcmVzID0gdHBsO1xuXG4gIGZvciAodmFyIHggaW4gZGF0YSkgcmVzID0gcmVzLnJlcGxhY2UobmV3IFJlZ0V4cChcIns9XCIuY29uY2F0KHgsIFwifVwiKSwgXCJnXCIpLCBkYXRhW3hdKTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9heGlzL0F4aXNSZW5kZXJlckhlbHBlci5qc1xuXG5cblxuXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBAaWdub3JlXG4gKi9cblxuXG5cbnZhciBBeGlzUmVuZGVyZXJIZWxwZXJfQXhpc1JlbmRlcmVySGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXhpc1JlbmRlcmVySGVscGVyKG93bmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF4aXNSZW5kZXJlckhlbHBlcik7XG5cbiAgICB2YXIgc2NhbGUgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2NhbGVfY29tbW9uanMyX2QzX3NjYWxlX2FtZF9kM19zY2FsZV9yb290X2QzX1tcInNjYWxlTGluZWFyXCJdKSgpLFxuICAgICAgICBjb25maWcgPSBvd25lci5jb25maWcsXG4gICAgICAgIHBhcmFtcyA9IG93bmVyLnBhcmFtcztcbiAgICB0aGlzLm93bmVyID0gb3duZXIsIHRoaXMuY29uZmlnID0gY29uZmlnLCB0aGlzLnNjYWxlID0gc2NhbGUsIChjb25maWcubm9UcmFuc2l0aW9uIHx8ICFwYXJhbXMuY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pICYmIChjb25maWcud2l0aG91dFRyYW5zaXRpb24gPSAhMCksIGNvbmZpZy5yYW5nZSA9IHNjYWxlLnJhbmdlRXh0ZW50ID8gc2NhbGUucmFuZ2VFeHRlbnQoKSA6IHRoaXMuc2NhbGVFeHRlbnQoKHBhcmFtcy5vcmdYU2NhbGUgfHwgc2NhbGUpLnJhbmdlKCkpO1xuICB9XG4gIC8qKlxuICAgKiBDb21wdXRlIGEgY2hhcmFjdGVyIGRpbWVuc2lvblxuICAgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gbm9kZVxuICAgKiBAcmV0dXJuIHt7dzogbnVtYmVyLCBoOiBudW1iZXJ9fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQXhpc1JlbmRlcmVySGVscGVyLCBbe1xuICAgIGtleTogXCJnZXRUaWNrVHJhbnNmb3JtU2V0dGVyXCIsXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGljayB0cmFuc2Zvcm0gc2V0dGVyIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIEF4aXMgaWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaWNrVHJhbnNmb3JtU2V0dGVyKGlkKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgICAgZm4gPSBpZCA9PT0gXCJ4XCIgPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiLmNvbmNhdCh2YWx1ZSArIGNvbmZpZy50aWNrT2Zmc2V0LCBcIiwwKVwiKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsXCIuY29uY2F0KHZhbHVlLCBcIilcIik7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3Rpb24sIHNjYWxlKSB7XG4gICAgICAgIHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKE1hdGguY2VpbChzY2FsZShkKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjYWxlRXh0ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYWxlRXh0ZW50KGRvbWFpbikge1xuICAgICAgdmFyIHN0YXJ0ID0gZG9tYWluWzBdLFxuICAgICAgICAgIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHN0YXJ0IDwgc3RvcCA/IFtzdGFydCwgc3RvcF0gOiBbc3RvcCwgc3RhcnRdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZVRpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlVGlja3Moc2NhbGUsIGlzWUF4ZXMpIHtcbiAgICAgIHZhciB0aWNrU3RlcFNpemUgPSB0aGlzLm93bmVyLnBhcmFtcy50aWNrU3RlcFNpemUsXG4gICAgICAgICAgdGlja3MgPSBbXTtcbiAgICAgIC8vIFdoZW4gJ2F4aXNbeXx5Ml0udGljay5zdGVwU2l6ZScgb3B0aW9uIGlzIHNldFxuICAgICAgaWYgKGlzWUF4ZXMgJiYgdGlja1N0ZXBTaXplKSBmb3IgKHZhciBfc2NhbGUkZG9tYWluID0gc2NhbGUuZG9tYWluKCksIF9zY2FsZSRkb21haW4yID0gX3NsaWNlZFRvQXJyYXkoX3NjYWxlJGRvbWFpbiwgMiksIHN0YXJ0ID0gX3NjYWxlJGRvbWFpbjJbMF0sIGVuZCA9IF9zY2FsZSRkb21haW4yWzFdLCBpbnRlcnZhbCA9IHN0YXJ0OyBpbnRlcnZhbCA8PSBlbmQ7KSB0aWNrcy5wdXNoKGludGVydmFsKSwgaW50ZXJ2YWwgKz0gdGlja1N0ZXBTaXplO2Vsc2UgaWYgKHNjYWxlLnRpY2tzKSB0aWNrcyA9IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5jb25maWcudGlja0FyZ3VtZW50cyB8fCBbXSkpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gKC8vIHJvdW5kIHRoZSB0aWNrIHZhbHVlIGlmIGlzIG51bWJlclxuICAgICAgICAgIGlzU3RyaW5nKHYpICYmIGlzTnVtYmVyKHYpICYmICFpc05hTih2KSAmJiBNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMCB8fCB2XG4gICAgICAgICk7XG4gICAgICB9KTtlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluKCksIGkgPSBNYXRoLmNlaWwoZG9tYWluWzBdKTsgaSA8IGRvbWFpblsxXTsgaSsrKSB0aWNrcy5wdXNoKGkpO1xuXG4gICAgICAgIHRpY2tzLmxlbmd0aCA+IDAgJiYgdGlja3NbMF0gPiAwICYmIHRpY2tzLnVuc2hpZnQodGlja3NbMF0gLSAodGlja3NbMV0gLSB0aWNrc1swXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5U2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weVNjYWxlKCkge1xuICAgICAgdmFyIG5ld1NjYWxlID0gdGhpcy5zY2FsZS5jb3B5KCk7XG4gICAgICByZXR1cm4gbmV3U2NhbGUuZG9tYWluKCkubGVuZ3RoIHx8IG5ld1NjYWxlLmRvbWFpbih0aGlzLnNjYWxlLmRvbWFpbigpKSwgbmV3U2NhbGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRGb3JtYXR0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dEZvcm1hdHRlZCh2KSB7XG4gICAgICB2YXIgdGlja0Zvcm1hdCA9IHRoaXMuY29uZmlnLnRpY2tGb3JtYXQsXG4gICAgICAgICAgdmFsdWUgPSAvXFxkK1xcLlxcZCswezUsfVxcZCQvLnRlc3QodikgPyArKHYgKyBcIlwiKS5yZXBsYWNlKC8wK1xcZCQvLCBcIlwiKSA6IHYsXG4gICAgICAgICAgZm9ybWF0dGVkID0gdGlja0Zvcm1hdCA/IHRpY2tGb3JtYXQodmFsdWUpIDogdmFsdWU7IC8vIHRvIHJvdW5kIGZsb2F0IG51bWJlcnMgZnJvbSAnYmluYXJ5IGZsb2F0aW5nIHBvaW50J1xuICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91YmxlLXByZWNpc2lvbl9mbG9hdGluZy1wb2ludF9mb3JtYXRcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3ODQ5MTAxL2xheW1hbnMtZXhwbGFuYXRpb24tZm9yLXdoeS1qYXZhc2NyaXB0LWhhcy13ZWlyZC1mbG9hdGluZy1tYXRoLWllZWUtNzU0LXN0YW5kXG5cbiAgICAgIHJldHVybiBpc0RlZmluZWQoZm9ybWF0dGVkKSA/IGZvcm1hdHRlZCA6IFwiXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zaXRpb25pc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNpdGlvbmlzZShzZWxlY3Rpb24pIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIHJldHVybiBjb25maWcud2l0aG91dFRyYW5zaXRpb24gPyBzZWxlY3Rpb24uaW50ZXJydXB0KCkgOiBzZWxlY3Rpb24udHJhbnNpdGlvbihjb25maWcudHJhbnNpdGlvbik7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0U2l6ZUZvcjFDaGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNpemVGb3IxQ2hhcihub2RlKSB7XG4gICAgICAvLyBkZWZhdWx0IHNpemUgZm9yIG9uZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBzaXplID0ge1xuICAgICAgICB3OiA1LjUsXG4gICAgICAgIGg6IDExLjVcbiAgICAgIH07XG4gICAgICByZXR1cm4gbm9kZS5lbXB0eSgpIHx8IG5vZGUuc2VsZWN0KFwidGV4dFwiKS50ZXh0KFwiMFwiKS5jYWxsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBfZWwkbm9kZSRnZXRCQm94ID0gZWwubm9kZSgpLmdldEJCb3goKSxcbiAgICAgICAgICAgICAgd2lkdGggPSBfZWwkbm9kZSRnZXRCQm94LndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQgPSBfZWwkbm9kZSRnZXRCQm94LmhlaWdodDtcblxuICAgICAgICAgIHdpZHRoICYmIGhlaWdodCAmJiAoc2l6ZS53ID0gd2lkdGgsIHNpemUuaCA9IGhlaWdodCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9IGZpbmFsbHkge1xuICAgICAgICAgIGVsLnRleHQoXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH0pLCB0aGlzLmdldFNpemVGb3IxQ2hhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICB9LCBzaXplO1xuICAgIH1cbiAgfV0pLCBBeGlzUmVuZGVyZXJIZWxwZXI7XG59KCk7XG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYXhpcy9BeGlzUmVuZGVyZXIuanNcblxuXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBAaWdub3JlXG4gKi9cblxuXG5cblxudmFyIEF4aXNSZW5kZXJlcl9BeGlzUmVuZGVyZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBeGlzUmVuZGVyZXIoKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXhpc1JlbmRlcmVyKTtcblxuICAgIHZhciBjb25maWcgPSB7XG4gICAgICBpbm5lclRpY2tTaXplOiA2LFxuICAgICAgb3V0ZXJUaWNrU2l6ZTogcGFyYW1zLm91dGVyVGljayA/IDYgOiAwLFxuICAgICAgb3JpZW50OiBcImJvdHRvbVwiLFxuICAgICAgcmFuZ2U6IFtdLFxuICAgICAgdGlja0FyZ3VtZW50czogbnVsbCxcbiAgICAgIHRpY2tDZW50ZXJlZDogbnVsbCxcbiAgICAgIHRpY2tDdWxsaW5nOiAhMCxcbiAgICAgIHRpY2tGb3JtYXQ6IG51bGwsXG4gICAgICB0aWNrTGVuZ3RoOiA5LFxuICAgICAgdGlja09mZnNldDogMCxcbiAgICAgIHRpY2tQYWRkaW5nOiAzLFxuICAgICAgdGlja1ZhbHVlczogbnVsbCxcbiAgICAgIHRyYW5zaXRpb246IG51bGwsXG4gICAgICBub1RyYW5zaXRpb246IHBhcmFtcy5ub1RyYW5zaXRpb25cbiAgICB9O1xuICAgIGNvbmZpZy50aWNrTGVuZ3RoID0gTWF0aC5tYXgoY29uZmlnLmlubmVyVGlja1NpemUsIDApICsgY29uZmlnLnRpY2tQYWRkaW5nLCB0aGlzLmNvbmZpZyA9IGNvbmZpZywgdGhpcy5wYXJhbXMgPSBwYXJhbXMsIHRoaXMuaGVscGVyID0gbmV3IEF4aXNSZW5kZXJlckhlbHBlcl9BeGlzUmVuZGVyZXJIZWxwZXIodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBheGlzIGVsZW1lbnRcbiAgICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IGdcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF4aXNSZW5kZXJlciwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShnKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcyxcbiAgICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICBoZWxwZXIgPSB0aGlzLmhlbHBlcixcbiAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcyxcbiAgICAgICAgICBzY2FsZSA9IGhlbHBlci5zY2FsZSxcbiAgICAgICAgICBvcmllbnQgPSBjb25maWcub3JpZW50LFxuICAgICAgICAgIHNwbGl0VGlja1RleHQgPSB0aGlzLnNwbGl0VGlja1RleHQuYmluZCh0aGlzKSxcbiAgICAgICAgICBpc0xlZnRSaWdodCA9IC9eKGxlZnR8cmlnaHQpJC8udGVzdChvcmllbnQpLFxuICAgICAgICAgIGlzVG9wQm90dG9tID0gL14odG9wfGJvdHRvbSkkLy50ZXN0KG9yaWVudCksXG4gICAgICAgICAgdGlja1RyYW5zZm9ybSA9IGhlbHBlci5nZXRUaWNrVHJhbnNmb3JtU2V0dGVyKGlzVG9wQm90dG9tID8gXCJ4XCIgOiBcInlcIiksXG4gICAgICAgICAgYXhpc1B4ID0gdGlja1RyYW5zZm9ybSA9PT0gaGVscGVyLmF4aXNYID8gXCJ5XCIgOiBcInhcIixcbiAgICAgICAgICBzaWduID0gL14odG9wfGxlZnQpJC8udGVzdChvcmllbnQpID8gLTEgOiAxLFxuICAgICAgICAgIHJvdGF0ZSA9IHBhcmFtcy50aWNrVGV4dFJvdGF0ZTtcbiAgICAgIHRoaXMuY29uZmlnLnJhbmdlID0gc2NhbGUucmFuZ2VFeHRlbnQgPyBzY2FsZS5yYW5nZUV4dGVudCgpIDogaGVscGVyLnNjYWxlRXh0ZW50KChwYXJhbXMub3JnWFNjYWxlIHx8IHNjYWxlKS5yYW5nZSgpKTtcbiAgICAgIHZhciBfY29uZmlnMiA9IGNvbmZpZyxcbiAgICAgICAgICBpbm5lclRpY2tTaXplID0gX2NvbmZpZzIuaW5uZXJUaWNrU2l6ZSxcbiAgICAgICAgICB0aWNrTGVuZ3RoID0gX2NvbmZpZzIudGlja0xlbmd0aCxcbiAgICAgICAgICByYW5nZSA9IF9jb25maWcyLnJhbmdlLFxuICAgICAgICAgIG5hbWUgPSBwYXJhbXMubmFtZSxcbiAgICAgICAgICB0aWNrVGV4dFBvcyA9IG5hbWUgJiYgL14oeHx5fHkyKSQvLnRlc3QobmFtZSkgPyBwYXJhbXMuY29uZmlnW1wiYXhpc19cIi5jb25jYXQobmFtZSwgXCJfdGlja190ZXh0X3Bvc2l0aW9uXCIpXSA6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgICAgICBwcmVmaXggPSBuYW1lID09PSBcInN1YlhcIiA/IFwic3ViY2hhcnRfYXhpc194XCIgOiBcImF4aXNfXCIuY29uY2F0KG5hbWUpLFxuICAgICAgICAgIGF4aXNTaG93ID0gcGFyYW1zLmNvbmZpZ1tcIlwiLmNvbmNhdChwcmVmaXgsIFwiX3Nob3dcIildLFxuICAgICAgICAgIHRpY2tTaG93ID0ge1xuICAgICAgICB0aWNrOiAhIWF4aXNTaG93ICYmIHBhcmFtcy5jb25maWdbXCJcIi5jb25jYXQocHJlZml4LCBcIl90aWNrX3Nob3dcIildLFxuICAgICAgICB0ZXh0OiAhIWF4aXNTaG93ICYmIHBhcmFtcy5jb25maWdbXCJcIi5jb25jYXQocHJlZml4LCBcIl90aWNrX3RleHRfc2hvd1wiKV1cbiAgICAgIH0sXG4gICAgICAgICAgJGcgPSBudWxsOyAvLyAvLyBnZXQgdGhlIGF4aXMnIHRpY2sgcG9zaXRpb24gY29uZmlndXJhdGlvblxuXG4gICAgICBnLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZyA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKSh0aGlzKSxcbiAgICAgICAgICAgIHNjYWxlMCA9IHRoaXMuX19jaGFydF9fIHx8IHNjYWxlLFxuICAgICAgICAgICAgc2NhbGUxID0gaGVscGVyLmNvcHlTY2FsZSgpO1xuICAgICAgICAkZyA9IGcsIHRoaXMuX19jaGFydF9fID0gc2NhbGUxLCBjb25maWcudGlja09mZnNldCA9IHBhcmFtcy5pc0NhdGVnb3J5ID8gTWF0aC5jZWlsKChzY2FsZTEoMSkgLSBzY2FsZTEoMCkpIC8gMikgOiAwO1xuICAgICAgICAvLyB1cGRhdGUgc2VsZWN0aW9uIC0gZGF0YSBqb2luXG4gICAgICAgIHZhciBwYXRoID0gZy5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLmRhdGEoWzBdKTsgLy8gZW50ZXIgKyB1cGRhdGUgc2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKHBhdGguZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpblwiKS5tZXJnZShoZWxwZXIudHJhbnNpdGlvbmlzZShwYXRoKSkuYXR0cihcImRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBvdXRlclRpY2tTaXplZCA9IGNvbmZpZy5vdXRlclRpY2tTaXplICogc2lnbjtcbiAgICAgICAgICByZXR1cm4gaXNUb3BCb3R0b20gPyBcIk1cIi5jb25jYXQocmFuZ2VbMF0sIFwiLFwiKS5jb25jYXQob3V0ZXJUaWNrU2l6ZWQsIFwiVjBIXCIpLmNvbmNhdChyYW5nZVsxXSwgXCJWXCIpLmNvbmNhdChvdXRlclRpY2tTaXplZCkgOiBcIk1cIi5jb25jYXQob3V0ZXJUaWNrU2l6ZWQsIFwiLFwiKS5jb25jYXQocmFuZ2VbMF0sIFwiSDBWXCIpLmNvbmNhdChyYW5nZVsxXSwgXCJIXCIpLmNvbmNhdChvdXRlclRpY2tTaXplZCk7XG4gICAgICAgIH0pLCB0aWNrU2hvdy50aWNrIHx8IHRpY2tTaG93LnRleHQpIHtcbiAgICAgICAgICAvLyBjb3VudCBvZiB0aWNrIGRhdGEgaW4gYXJyYXlcbiAgICAgICAgICB2YXIgdGlja3MgPSBjb25maWcudGlja1ZhbHVlcyB8fCBoZWxwZXIuZ2VuZXJhdGVUaWNrcyhzY2FsZTEsIGlzTGVmdFJpZ2h0KSxcbiAgICAgICAgICAgICAgdGljayA9IGcuc2VsZWN0QWxsKFwiLnRpY2tcIikuZGF0YSh0aWNrcywgc2NhbGUxKSxcbiAgICAgICAgICAgICAgdGlja0VudGVyID0gdGljay5lbnRlcigpLmluc2VydChcImdcIiwgXCIuZG9tYWluXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRpY2tcIikuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKSxcbiAgICAgICAgICAgICAgdGlja0V4aXQgPSB0aWNrLmV4aXQoKS5yZW1vdmUoKTsgLy8gdXBkYXRlIHNlbGVjdGlvblxuXG4gICAgICAgICAgdGljayA9IHRpY2tFbnRlci5tZXJnZSh0aWNrKSwgdGlja1Nob3cudGljayAmJiB0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKSwgdGlja1Nob3cudGV4dCAmJiB0aWNrRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcbiAgICAgICAgICB2YXIgc2l6ZUZvcjFDaGFyID0gQXhpc1JlbmRlcmVySGVscGVyX0F4aXNSZW5kZXJlckhlbHBlci5nZXRTaXplRm9yMUNoYXIodGljayksXG4gICAgICAgICAgICAgIGNvdW50cyA9IFtdLFxuICAgICAgICAgICAgICB0c3BhbiA9IHRpY2suc2VsZWN0KFwidGV4dFwiKS5zZWxlY3RBbGwoXCJ0c3BhblwiKS5kYXRhKGZ1bmN0aW9uIChkLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHNwbGl0ID0gcGFyYW1zLnRpY2tNdWx0aWxpbmUgPyBzcGxpdFRpY2tUZXh0KGQsIHNjYWxlMSwgdGlja3MsIGlzTGVmdFJpZ2h0LCBzaXplRm9yMUNoYXIudykgOiBpc0FycmF5KGhlbHBlci50ZXh0Rm9ybWF0dGVkKGQpKSA/IGhlbHBlci50ZXh0Rm9ybWF0dGVkKGQpLmNvbmNhdCgpIDogW2hlbHBlci50ZXh0Rm9ybWF0dGVkKGQpXTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudHNbaW5kZXhdID0gc3BsaXQubGVuZ3RoLCBzcGxpdC5tYXAoZnVuY3Rpb24gKHNwbGl0dGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIHNwbGl0dGVkOiBzcGxpdHRlZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHNwYW4uZXhpdCgpLnJlbW92ZSgpLCB0c3BhbiA9IHRzcGFuLmVudGVyKCkuYXBwZW5kKFwidHNwYW5cIikubWVyZ2UodHNwYW4pLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLnNwbGl0dGVkO1xuICAgICAgICAgIH0pLCB0c3Bhbi5hdHRyKFwieFwiLCBpc1RvcEJvdHRvbSA/IDAgOiB0aWNrTGVuZ3RoICogc2lnbikuYXR0cihcImR4XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gLyh0b3B8Ym90dG9tKS8udGVzdChvcmllbnQpICYmIHJvdGF0ZSAmJiAoZHggPSA4ICogTWF0aC5zaW4oTWF0aC5QSSAqIChyb3RhdGUgLyAxODApKSAqIChvcmllbnQgPT09IFwidG9wXCIgPyAtMSA6IDEpKSwgZHggKyAodGlja1RleHRQb3MueCB8fCAwKTtcbiAgICAgICAgICB9KCkpLmF0dHIoXCJkeVwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgdmFyIGR5ID0gMDtcbiAgICAgICAgICAgIHJldHVybiBvcmllbnQgIT09IFwidG9wXCIgJiYgKGR5ID0gc2l6ZUZvcjFDaGFyLmgsIGkgPT09IDAgJiYgKGR5ID0gaXNMZWZ0UmlnaHQgPyAtKChjb3VudHNbZC5pbmRleF0gLSAxKSAqIChzaXplRm9yMUNoYXIuaCAvIDIpIC0gMykgOiB0aWNrVGV4dFBvcy55ID09PSAwID8gXCIuNzFlbVwiIDogMCkpLCBpc051bWJlcihkeSkgJiYgdGlja1RleHRQb3MueSA/IGR5ICsgdGlja1RleHRQb3MueSA6IGR5IHx8IFwiLjcxZW1cIjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgbGluZVVwZGF0ZSA9IHRpY2suc2VsZWN0KFwibGluZVwiKSxcbiAgICAgICAgICAgICAgdGV4dFVwZGF0ZSA9IHRpY2suc2VsZWN0KFwidGV4dFwiKTtcblxuICAgICAgICAgIC8vIEFwcGVuZCA8dGl0bGU+IGZvciB0b29sdGlwIGRpc3BsYXlcbiAgICAgICAgICBpZiAodGlja0VudGVyLnNlbGVjdChcImxpbmVcIikuYXR0cihcIlwiLmNvbmNhdChheGlzUHgsIFwiMlwiKSwgaW5uZXJUaWNrU2l6ZSAqIHNpZ24pLCB0aWNrRW50ZXIuc2VsZWN0KFwidGV4dFwiKS5hdHRyKGF4aXNQeCwgdGlja0xlbmd0aCAqIHNpZ24pLCBjdHguc2V0VGlja0xpbmVUZXh0UG9zaXRpb24obGluZVVwZGF0ZSwgdGV4dFVwZGF0ZSksIHBhcmFtcy50aWNrVGl0bGUpIHtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IHRleHRVcGRhdGUuc2VsZWN0KFwidGl0bGVcIik7XG4gICAgICAgICAgICAodGl0bGUuZW1wdHkoKSA/IHRleHRVcGRhdGUuYXBwZW5kKFwidGl0bGVcIikgOiB0aXRsZSkudGV4dChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy50aWNrVGl0bGVbaW5kZXhdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNjYWxlMS5iYW5kd2lkdGgpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2NhbGUxLFxuICAgICAgICAgICAgICAgIGR4ID0geC5iYW5kd2lkdGgoKSAvIDI7XG4gICAgICAgICAgICBzY2FsZTAgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICByZXR1cm4geChkKSArIGR4O1xuICAgICAgICAgICAgfSwgc2NhbGUxID0gc2NhbGUwO1xuICAgICAgICAgIH0gZWxzZSBzY2FsZTAuYmFuZHdpZHRoID8gc2NhbGUwID0gc2NhbGUxIDogdGlja1RyYW5zZm9ybSh0aWNrRXhpdCwgc2NhbGUxKTtcblxuICAgICAgICAgIHRpY2tUcmFuc2Zvcm0odGlja0VudGVyLCBzY2FsZTApLCB0aWNrVHJhbnNmb3JtKGhlbHBlci50cmFuc2l0aW9uaXNlKHRpY2spLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIiksIHNjYWxlMSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCB0aGlzLmcgPSAkZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRpY2sgeC95IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaWNrWFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGlja1hZKCkge1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgIHBvcyA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5pc0NhdGVnb3J5ICYmIChwb3MueCA9IGNvbmZpZy50aWNrQ2VudGVyZWQgPyAwIDogY29uZmlnLnRpY2tPZmZzZXQsIHBvcy55ID0gY29uZmlnLnRpY2tDZW50ZXJlZCA/IGNvbmZpZy50aWNrT2Zmc2V0IDogMCksIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRpY2sgc2l6ZVxuICAgICAqIEBwYXJhbSBkXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaWNrU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaWNrU2l6ZShkKSB7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLmhlbHBlci5zY2FsZSxcbiAgICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICBpbm5lclRpY2tTaXplID0gY29uZmlnLmlubmVyVGlja1NpemUsXG4gICAgICAgICAgcmFuZ2UgPSBjb25maWcucmFuZ2UsXG4gICAgICAgICAgdGlja1Bvc2l0aW9uID0gc2NhbGUoZCkgKyAoY29uZmlnLnRpY2tDZW50ZXJlZCA/IDAgOiBjb25maWcudGlja09mZnNldCk7XG4gICAgICByZXR1cm4gcmFuZ2VbMF0gPCB0aWNrUG9zaXRpb24gJiYgdGlja1Bvc2l0aW9uIDwgcmFuZ2VbMV0gPyBpbm5lclRpY2tTaXplIDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRpY2sncyBsaW5lICYgdGV4dCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBsaW5lVXBkYXRlXG4gICAgICogQHBhcmFtIHRleHRVcGRhdGVcbiAgICAgKiBAcGFyYW0gc2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGlja0xpbmVUZXh0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGlja0xpbmVUZXh0UG9zaXRpb24obGluZVVwZGF0ZSwgdGV4dFVwZGF0ZSkge1xuICAgICAgdmFyIHRpY2tQb3MgPSB0aGlzLmdldFRpY2tYWSgpLFxuICAgICAgICAgIF90aGlzJGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgIGlubmVyVGlja1NpemUgPSBfdGhpcyRjb25maWcuaW5uZXJUaWNrU2l6ZSxcbiAgICAgICAgICBvcmllbnQgPSBfdGhpcyRjb25maWcub3JpZW50LFxuICAgICAgICAgIHRpY2tMZW5ndGggPSBfdGhpcyRjb25maWcudGlja0xlbmd0aCxcbiAgICAgICAgICB0aWNrT2Zmc2V0ID0gX3RoaXMkY29uZmlnLnRpY2tPZmZzZXQsXG4gICAgICAgICAgcm90YXRlID0gdGhpcy5wYXJhbXMudGlja1RleHRSb3RhdGUsXG4gICAgICAgICAgdGV4dEFuY2hvckZvclRleHQgPSBmdW5jdGlvbiAocikge1xuICAgICAgICB2YXIgdmFsdWUgPSBbXCJzdGFydFwiLCBcImVuZFwiXTtcbiAgICAgICAgcmV0dXJuIG9yaWVudCA9PT0gXCJ0b3BcIiAmJiB2YWx1ZS5yZXZlcnNlKCksIHIgPyByID4gMCA/IHZhbHVlWzBdIDogdmFsdWVbMV0gOiBcIm1pZGRsZVwiO1xuICAgICAgfSxcbiAgICAgICAgICB0ZXh0VHJhbnNmb3JtID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIHIgPyBcInJvdGF0ZShcIi5jb25jYXQociwgXCIpXCIpIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICAgICAgeUZvclRleHQgPSBmdW5jdGlvbiAocikge1xuICAgICAgICB2YXIgcjIgPSByIC8gKG9yaWVudCA9PT0gXCJib3R0b21cIiA/IDE1IDogMjMpO1xuICAgICAgICByZXR1cm4gciA/IDExLjUgLSAyLjUgKiByMiAqIChyID4gMCA/IDEgOiAtMSkgOiB0aWNrTGVuZ3RoO1xuICAgICAgfTtcblxuICAgICAgb3JpZW50ID09PSBcImJvdHRvbVwiID8gKGxpbmVVcGRhdGUuYXR0cihcIngxXCIsIHRpY2tQb3MueCkuYXR0cihcIngyXCIsIHRpY2tQb3MueCkuYXR0cihcInkyXCIsIHRoaXMuZ2V0VGlja1NpemUuYmluZCh0aGlzKSksIHRleHRVcGRhdGUuYXR0cihcInhcIiwgMCkuYXR0cihcInlcIiwgeUZvclRleHQocm90YXRlKSkuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCB0ZXh0QW5jaG9yRm9yVGV4dChyb3RhdGUpKS5hdHRyKFwidHJhbnNmb3JtXCIsIHRleHRUcmFuc2Zvcm0ocm90YXRlKSkpIDogb3JpZW50ID09PSBcInRvcFwiID8gKGxpbmVVcGRhdGUuYXR0cihcIngyXCIsIDApLmF0dHIoXCJ5MlwiLCAtaW5uZXJUaWNrU2l6ZSksIHRleHRVcGRhdGUuYXR0cihcInhcIiwgMCkuYXR0cihcInlcIiwgLXlGb3JUZXh0KHJvdGF0ZSkgKiAyKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRleHRBbmNob3JGb3JUZXh0KHJvdGF0ZSkpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdGV4dFRyYW5zZm9ybShyb3RhdGUpKSkgOiBvcmllbnQgPT09IFwibGVmdFwiID8gKGxpbmVVcGRhdGUuYXR0cihcIngyXCIsIC1pbm5lclRpY2tTaXplKS5hdHRyKFwieTFcIiwgdGlja1Bvcy55KS5hdHRyKFwieTJcIiwgdGlja1Bvcy55KSwgdGV4dFVwZGF0ZS5hdHRyKFwieFwiLCAtdGlja0xlbmd0aCkuYXR0cihcInlcIiwgdGlja09mZnNldCkuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKSkgOiBvcmllbnQgPT09IFwicmlnaHRcIiA/IChsaW5lVXBkYXRlLmF0dHIoXCJ4MlwiLCBpbm5lclRpY2tTaXplKS5hdHRyKFwieTJcIiwgMCksIHRleHRVcGRhdGUuYXR0cihcInhcIiwgdGlja0xlbmd0aCkuYXR0cihcInlcIiwgMCkuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcInN0YXJ0XCIpKSA6IHZvaWQgMDtcbiAgICB9IC8vIHRoaXMgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IHdoZW4gY2F0ZWdvcnkgYXhpc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3BsaXRUaWNrVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdFRpY2tUZXh0KGQsIHNjYWxlLCB0aWNrcywgaXNMZWZ0UmlnaHQsIGNoYXJXaWR0aCkge1xuICAgICAgZnVuY3Rpb24gc3BsaXQoc3BsaXR0ZWQsIHRleHQpIHtcbiAgICAgICAgZm9yICh2YXIgc3VidGV4dCwgc3BhY2VJbmRleCwgdGV4dFdpZHRoLCBpID0gMTsgaSA8IHRleHQubGVuZ3RoOyBpKyspIC8vIGlmIHRleHQgd2lkdGggZ2V0cyBvdmVyIHRpY2sgd2lkdGgsIHNwbGl0IGJ5IHNwYWNlIGluZGV4IG9yIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgaWYgKHRleHQuY2hhckF0KGkpID09PSBcIiBcIiAmJiAoc3BhY2VJbmRleCA9IGkpLCBzdWJ0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgaSArIDEpLCB0ZXh0V2lkdGggPSBjaGFyV2lkdGggKiBzdWJ0ZXh0Lmxlbmd0aCwgdGlja1dpZHRoIDwgdGV4dFdpZHRoKSByZXR1cm4gc3BsaXQoc3BsaXR0ZWQuY29uY2F0KHRleHQuc3Vic3RyKDAsIHNwYWNlSW5kZXggfHwgaSkpLCB0ZXh0LnNsaWNlKHNwYWNlSW5kZXggPyBzcGFjZUluZGV4ICsgMSA6IGkpKTtcblxuICAgICAgICByZXR1cm4gc3BsaXR0ZWQuY29uY2F0KHRleHQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXMsXG4gICAgICAgICAgdGlja1RleHQgPSB0aGlzLmhlbHBlci50ZXh0Rm9ybWF0dGVkKGQpLFxuICAgICAgICAgIHNwbGl0dGVkID0gaXNTdHJpbmcodGlja1RleHQpICYmIHRpY2tUZXh0LmluZGV4T2YoXCJcXG5cIikgPiAtMSA/IHRpY2tUZXh0LnNwbGl0KFwiXFxuXCIpIDogW107XG4gICAgICBpZiAoc3BsaXR0ZWQubGVuZ3RoKSByZXR1cm4gc3BsaXR0ZWQ7XG4gICAgICBpZiAoaXNBcnJheSh0aWNrVGV4dCkpIHJldHVybiB0aWNrVGV4dDtcbiAgICAgIHZhciB0aWNrV2lkdGggPSBwYXJhbXMudGlja1dpZHRoO1xuICAgICAgcmV0dXJuICghdGlja1dpZHRoIHx8IHRpY2tXaWR0aCA8PSAwKSAmJiAodGlja1dpZHRoID0gaXNMZWZ0UmlnaHQgPyA5NSA6IHBhcmFtcy5pc0NhdGVnb3J5ID8gTWF0aC5jZWlsKHNjYWxlKHRpY2tzWzFdKSAtIHNjYWxlKHRpY2tzWzBdKSkgLSAxMiA6IDExMCksIHNwbGl0KHNwbGl0dGVkLCB0aWNrVGV4dCArIFwiXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLmhlbHBlci5zY2FsZSA9IHgsIHRoaXMpIDogdGhpcy5oZWxwZXIuc2NhbGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9yaWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcmllbnQoeCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5jb25maWcub3JpZW50ID0geCBpbiB7XG4gICAgICAgIHRvcDogMSxcbiAgICAgICAgcmlnaHQ6IDEsXG4gICAgICAgIGJvdHRvbTogMSxcbiAgICAgICAgbGVmdDogMVxuICAgICAgfSA/IHggKyBcIlwiIDogXCJib3R0b21cIiwgdGhpcykgOiB0aGlzLmNvbmZpZy5vcmllbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpY2tGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGlja0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuY29uZmlnLnRpY2tGb3JtYXQgPSBmb3JtYXQsIHRoaXMpIDogdGhpcy5jb25maWcudGlja0Zvcm1hdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGlja0NlbnRlcmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpY2tDZW50ZXJlZChpc0NlbnRlcmVkKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb25maWcudGlja0NlbnRlcmVkID0gaXNDZW50ZXJlZCwgdGhpcykgOiBjb25maWcudGlja0NlbnRlcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGljaydzIG9mZnNldCB2YWx1ZS5cbiAgICAgKiBUaGUgdmFsdWUgd2lsbCBiZSBzZXQgZm9yICdjYXRlZ29yeScgYXhpcyB0eXBlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidGlja09mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aWNrT2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnRpY2tPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aWNrIGludGVydmFsIGNvdW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBUb3RhbCBkYXRhIHNpemVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0aWNrSW50ZXJ2YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGlja0ludGVydmFsKHNpemUpIHtcbiAgICAgIHZhciBpbnRlcnZhbDtcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5pc0NhdGVnb3J5KSBpbnRlcnZhbCA9IHRoaXMuY29uZmlnLnRpY2tPZmZzZXQgKiAyO2Vsc2Uge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5nLnNlbGVjdChcInBhdGguZG9tYWluXCIpLm5vZGUoKS5nZXRUb3RhbExlbmd0aCgpIC0gdGhpcy5jb25maWcub3V0ZXJUaWNrU2l6ZSAqIDI7XG4gICAgICAgIGludGVydmFsID0gbGVuZ3RoIC8gKHNpemUgfHwgdGhpcy5nLnNlbGVjdEFsbChcImxpbmVcIikuc2l6ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRlcnZhbCA9PT0gSW5maW5pdHkgPyAwIDogaW50ZXJ2YWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpY2tzKCkge1xuICAgICAgZm9yICh2YXIgY29uZmlnID0gdGhpcy5jb25maWcsIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPyAoY29uZmlnLnRpY2tBcmd1bWVudHMgPSB0b0FycmF5KGFyZ3MpLCB0aGlzKSA6IGNvbmZpZy50aWNrQXJndW1lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aWNrQ3VsbGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aWNrQ3VsbGluZyhjdWxsaW5nKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb25maWcudGlja0N1bGxpbmcgPSBjdWxsaW5nLCB0aGlzKSA6IGNvbmZpZy50aWNrQ3VsbGluZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGlja1ZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aWNrVmFsdWVzKHgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHgpKSBjb25maWcudGlja1ZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHgoX3RoaXMuaGVscGVyLnNjYWxlLmRvbWFpbigpKTtcbiAgICAgIH07ZWxzZSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbmZpZy50aWNrVmFsdWVzO1xuICAgICAgICBjb25maWcudGlja1ZhbHVlcyA9IHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VHJhbnNpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy50cmFuc2l0aW9uID0gdCwgdGhpcztcbiAgICB9XG4gIH1dKSwgQXhpc1JlbmRlcmVyO1xufSgpO1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2F4aXMvQXhpcy5qc1xuXG5cblxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuXG5cblxuXG52YXIgaXNIb3Jpem9udGFsID0gZnVuY3Rpb24gKCQkLCBmb3JIb3Jpem9udGFsKSB7XG4gIHZhciBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkO1xuICByZXR1cm4gZm9ySG9yaXpvbnRhbCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQ7XG59LFxuICAgIGdldEF4aXNDbGFzc05hbWUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmF4aXMsIFwiIFwiKS5jb25jYXQoY29uZmlnX2NsYXNzZXNbXCJheGlzXCIuY29uY2F0KGNhcGl0YWxpemUoaWQpKV0pO1xufTtcblxudmFyIEF4aXNfQXhpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF4aXMob3duZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXhpcyksIHRoaXMub3duZXIgPSBvd25lciwgdGhpcy5zZXRPcmllbnQoKTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQXhpcywgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgIGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQsXG4gICAgICAgICAgbWFpbiA9ICQkLm1haW4sXG4gICAgICAgICAgdGFyZ2V0ID0gW1wieFwiLCBcInlcIl07XG5cbiAgICAgIGNvbmZpZy5heGlzX3kyX3Nob3cgJiYgdGFyZ2V0LnB1c2goXCJ5MlwiKSwgJCQuYXhlc0xpc3QgPSB7fSwgdGFyZ2V0LmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIGNsYXNzQXhpcyA9IGdldEF4aXNDbGFzc05hbWUodiksXG4gICAgICAgICAgICBjbGFzc0xhYmVsID0gY29uZmlnX2NsYXNzZXNbXCJheGlzXCIuY29uY2F0KHYudG9VcHBlckNhc2UoKSwgXCJMYWJlbFwiKV07XG4gICAgICAgICQkLmF4ZXNbdl0gPSBtYWluLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzQXhpcykuYXR0cihcImNsaXAtcGF0aFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHYgPT09IFwieFwiID8gcmVzID0gJCQuY2xpcFBhdGhGb3JYQXhpcyA6IHYgPT09IFwieVwiICYmIGNvbmZpZy5heGlzX3lfaW5uZXIgJiYgKHJlcyA9ICQkLmNsaXBQYXRoRm9yWUF4aXMpLCByZXM7XG4gICAgICAgIH0pLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKHYpKS5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnW1wiYXhpc19cIi5jb25jYXQodiwgXCJfc2hvd1wiKV0gPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpLCAkJC5heGVzW3ZdLmFwcGVuZChcInRleHRcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzTGFiZWwpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgW1wicm90YXRlKC05MClcIiwgbnVsbF1bdiA9PT0gXCJ4XCIgPyArIWlzUm90YXRlZCA6ICtpc1JvdGF0ZWRdKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMudGV4dEFuY2hvckZvckF4aXNMYWJlbCh2KTtcbiAgICAgICAgfSksIF90aGlzLmdlbmVyYXRlQXhlcyh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYXhpcyBvcmllbnQgYWNjb3JkaW5nIG9wdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcmllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3JpZW50KCkge1xuICAgICAgdmFyICQkID0gdGhpcy5vd25lcixcbiAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZCxcbiAgICAgICAgICB5SW5uZXIgPSBjb25maWcuYXhpc195X2lubmVyLFxuICAgICAgICAgIHkySW5uZXIgPSBjb25maWcuYXhpc195Ml9pbm5lcjtcbiAgICAgICQkLnhPcmllbnQgPSBpc1JvdGF0ZWQgPyBcImxlZnRcIiA6IFwiYm90dG9tXCIsICQkLnlPcmllbnQgPSBpc1JvdGF0ZWQgPyB5SW5uZXIgPyBcInRvcFwiIDogXCJib3R0b21cIiA6IHlJbm5lciA/IFwicmlnaHRcIiA6IFwibGVmdFwiLCAkJC55Mk9yaWVudCA9IGlzUm90YXRlZCA/IHkySW5uZXIgPyBcImJvdHRvbVwiIDogXCJ0b3BcIiA6IHkySW5uZXIgPyBcImxlZnRcIiA6IFwicmlnaHRcIiwgJCQuc3ViWE9yaWVudCA9IGlzUm90YXRlZCA/IFwibGVmdFwiIDogXCJib3R0b21cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYXhlc1xuICAgICAqIEl0J3MgdXNlZCB3aGVuIGF4aXMnIGF4ZXMgb3B0aW9uIGlzIHNldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBBeGlzIGlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlQXhlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUF4ZXMoaWQpIHtcbiAgICAgIHZhciBkM0F4aXMsXG4gICAgICAgICAgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICBheGVzID0gW10sXG4gICAgICAgICAgYXhlc0NvbmZpZyA9IGNvbmZpZ1tcImF4aXNfXCIuY29uY2F0KGlkLCBcIl9heGVzXCIpXSxcbiAgICAgICAgICBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuICAgICAgaWQgPT09IFwieFwiID8gZDNBeGlzID0gaXNSb3RhdGVkID8gZXh0ZXJuYWxfY29tbW9uanNfZDNfYXhpc19jb21tb25qczJfZDNfYXhpc19hbWRfZDNfYXhpc19yb290X2QzX1tcImF4aXNMZWZ0XCJdIDogZXh0ZXJuYWxfY29tbW9uanNfZDNfYXhpc19jb21tb25qczJfZDNfYXhpc19hbWRfZDNfYXhpc19yb290X2QzX1tcImF4aXNCb3R0b21cIl0gOiBpZCA9PT0gXCJ5XCIgPyBkM0F4aXMgPSBpc1JvdGF0ZWQgPyBleHRlcm5hbF9jb21tb25qc19kM19heGlzX2NvbW1vbmpzMl9kM19heGlzX2FtZF9kM19heGlzX3Jvb3RfZDNfW1wiYXhpc0JvdHRvbVwiXSA6IGV4dGVybmFsX2NvbW1vbmpzX2QzX2F4aXNfY29tbW9uanMyX2QzX2F4aXNfYW1kX2QzX2F4aXNfcm9vdF9kM19bXCJheGlzTGVmdFwiXSA6IGlkID09PSBcInkyXCIgJiYgKGQzQXhpcyA9IGlzUm90YXRlZCA/IGV4dGVybmFsX2NvbW1vbmpzX2QzX2F4aXNfY29tbW9uanMyX2QzX2F4aXNfYW1kX2QzX2F4aXNfcm9vdF9kM19bXCJheGlzVG9wXCJdIDogZXh0ZXJuYWxfY29tbW9uanNfZDNfYXhpc19jb21tb25qczJfZDNfYXhpc19hbWRfZDNfYXhpc19yb290X2QzX1tcImF4aXNSaWdodFwiXSksIGF4ZXNDb25maWcubGVuZ3RoICYmIGF4ZXNDb25maWcuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgdGljayA9IHYudGljayB8fCB7fSxcbiAgICAgICAgICAgIHNjYWxlID0gJCRbaWRdLmNvcHkoKTtcbiAgICAgICAgdi5kb21haW4gJiYgc2NhbGUuZG9tYWluKHYuZG9tYWluKSwgYXhlcy5wdXNoKGQzQXhpcyhzY2FsZSkudGlja3ModGljay5jb3VudCkudGlja0Zvcm1hdCh0aWNrLmZvcm1hdCB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KS50aWNrVmFsdWVzKHRpY2sudmFsdWVzKS50aWNrU2l6ZU91dGVyKHRpY2sub3V0ZXIgPT09ICExID8gMCA6IDYpKTtcbiAgICAgIH0pLCAkJC5heGVzTGlzdFtpZF0gPSBheGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYXhlcyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVBeGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUF4ZXMoKSB7XG4gICAgICB2YXIgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgIE9iamVjdC5rZXlzKCQkLmF4ZXNMaXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXhlc0NvbmZpZyA9IGNvbmZpZ1tcImF4aXNfXCIuY29uY2F0KGlkLCBcIl9heGVzXCIpXSxcbiAgICAgICAgICAgIHNjYWxlID0gJCRbaWRdLmNvcHkoKSxcbiAgICAgICAgICAgIHJhbmdlID0gc2NhbGUucmFuZ2UoKTtcbiAgICAgICAgJCQuYXhlc0xpc3RbaWRdLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICB2YXIgYXhpc1JhbmdlID0gdi5zY2FsZSgpLnJhbmdlKCk7IC8vIGFkanVzdCByYW5nZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvODU5XG5cbiAgICAgICAgICByYW5nZS5ldmVyeShmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHYgPT09IGF4aXNSYW5nZVtpXTtcbiAgICAgICAgICB9KSB8fCB2LnNjYWxlKCkucmFuZ2UocmFuZ2UpO1xuICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBcIlwiLmNvbmNhdChnZXRBeGlzQ2xhc3NOYW1lKGlkKSwgXCItXCIpLmNvbmNhdChpICsgMSksXG4gICAgICAgICAgICAgIGcgPSAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY2xhc3NOYW1lLnJlcGxhY2UoL1xccy8sIFwiLlwiKSkpO1xuICAgICAgICAgIGcuZW1wdHkoKSA/IGcgPSAkJC5tYWluLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzTmFtZSkuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZ1tcImF4aXNfXCIuY29uY2F0KGlkLCBcIl9zaG93XCIpXSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIikuY2FsbCh2KSA6IChheGVzQ29uZmlnW2ldLmRvbWFpbiAmJiBzY2FsZS5kb21haW4oYXhlc0NvbmZpZ1tpXS5kb21haW4pLCAkJC54QXhpcy5oZWxwZXIudHJhbnNpdGlvbmlzZShnKS5jYWxsKHYuc2NhbGUoc2NhbGUpKSksIGcuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoaWQsIGkgKyAxKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBjYWxsZWQgZnJvbSA6IHVwZGF0ZVNjYWxlcygpICYgZ2V0TWF4VGlja1dpZHRoKClcblxuICB9LCB7XG4gICAga2V5OiBcImdldEF4aXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXhpcyhuYW1lLCBzY2FsZSwgb3V0ZXJUaWNrLCBub1RyYW5zaXRpb24sIG5vVGlja1RleHRSb3RhdGUpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgIGlzWCA9IC9eKHh8c3ViWCkkLy50ZXN0KG5hbWUpLFxuICAgICAgICAgIHR5cGUgPSBpc1ggPyBcInhcIiA6IG5hbWUsXG4gICAgICAgICAgaXNDYXRlZ29yeSA9IGlzWCAmJiAkJC5pc0NhdGVnb3JpemVkKCksXG4gICAgICAgICAgb3JpZW50ID0gJCRbXCJcIi5jb25jYXQobmFtZSwgXCJPcmllbnRcIildLFxuICAgICAgICAgIHRpY2tGb3JtYXQgPSBpc1ggPyAkJC54QXhpc1RpY2tGb3JtYXQgOiBjb25maWdbXCJheGlzX1wiLmNvbmNhdChuYW1lLCBcIl90aWNrX2Zvcm1hdFwiKV0sXG4gICAgICAgICAgdGlja1RleHRSb3RhdGUgPSBub1RpY2tUZXh0Um90YXRlID8gMCA6ICQkLmdldEF4aXNUaWNrUm90YXRlKHR5cGUpLFxuICAgICAgICAgIHRpY2tWYWx1ZXMgPSBpc1ggPyAkJC54QXhpc1RpY2tWYWx1ZXMgOiAkJFtcIlwiLmNvbmNhdChuYW1lLCBcIkF4aXNUaWNrVmFsdWVzXCIpXSxcbiAgICAgICAgICBheGlzUGFyYW1zID0gbWVyZ2VPYmooe1xuICAgICAgICBvdXRlclRpY2s6IG91dGVyVGljayxcbiAgICAgICAgbm9UcmFuc2l0aW9uOiBub1RyYW5zaXRpb24sXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0aWNrVGV4dFJvdGF0ZTogdGlja1RleHRSb3RhdGVcbiAgICAgIH0sIGlzWCAmJiB7XG4gICAgICAgIGlzQ2F0ZWdvcnk6IGlzQ2F0ZWdvcnksXG4gICAgICAgIHRpY2tNdWx0aWxpbmU6IGNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUsXG4gICAgICAgIHRpY2tXaWR0aDogY29uZmlnLmF4aXNfeF90aWNrX3dpZHRoLFxuICAgICAgICB0aWNrVGl0bGU6IGlzQ2F0ZWdvcnkgJiYgY29uZmlnLmF4aXNfeF90aWNrX3Rvb2x0aXAgJiYgJCQuYXBpLmNhdGVnb3JpZXMoKSxcbiAgICAgICAgb3JnWFNjYWxlOiAkJC54XG4gICAgICB9KTtcbiAgICAgIGlzWCB8fCAoYXhpc1BhcmFtcy50aWNrU3RlcFNpemUgPSBjb25maWdbXCJheGlzX1wiLmNvbmNhdCh0eXBlLCBcIl90aWNrX3N0ZXBTaXplXCIpXSk7XG4gICAgICB2YXIgYXhpcyA9IG5ldyBBeGlzUmVuZGVyZXJfQXhpc1JlbmRlcmVyKGF4aXNQYXJhbXMpLnNjYWxlKGlzWCAmJiAkJC56b29tU2NhbGUgfHwgc2NhbGUpLm9yaWVudChvcmllbnQpO1xuICAgICAgaXNYICYmICQkLmlzVGltZVNlcmllcygpICYmIHRpY2tWYWx1ZXMgJiYgIWlzRnVuY3Rpb24odGlja1ZhbHVlcykgPyB0aWNrVmFsdWVzID0gdGlja1ZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuICQkLnBhcnNlRGF0ZSh2KTtcbiAgICAgIH0pIDogIWlzWCAmJiAkJC5pc1RpbWVTZXJpZXNZKCkgJiYgKGF4aXMudGlja3MoY29uZmlnLmF4aXNfeV90aWNrX3RpbWVfdmFsdWUpLCB0aWNrVmFsdWVzID0gbnVsbCksIHRpY2tWYWx1ZXMgJiYgYXhpcy50aWNrVmFsdWVzKHRpY2tWYWx1ZXMpLCBheGlzLnRpY2tGb3JtYXQodGlja0Zvcm1hdCB8fCAhaXNYICYmICQkLmlzU3RhY2tOb3JtYWxpemVkKCkgJiYgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHgsIFwiJVwiKTtcbiAgICAgIH0pLCBpc0NhdGVnb3J5ICYmIChheGlzLnRpY2tDZW50ZXJlZChjb25maWcuYXhpc194X3RpY2tfY2VudGVyZWQpLCBpc0VtcHR5KGNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nKSAmJiAoY29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcgPSAhMSkpO1xuICAgICAgdmFyIHRpY2tDb3VudCA9IGNvbmZpZ1tcImF4aXNfXCIuY29uY2F0KHR5cGUsIFwiX3RpY2tfY291bnRcIildO1xuICAgICAgcmV0dXJuIHRpY2tDb3VudCAmJiBheGlzLnRpY2tzKHRpY2tDb3VudCksIGF4aXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVhBeGlzVGlja1ZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0cywgYXhpcykge1xuICAgICAgdmFyIHZhbHVlcyxcbiAgICAgICAgICAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgIGZpdCA9IGNvbmZpZy5heGlzX3hfdGlja19maXQsXG4gICAgICAgICAgY291bnQgPSBjb25maWcuYXhpc194X3RpY2tfY291bnQ7XG4gICAgICByZXR1cm4gKGZpdCB8fCBjb3VudCAmJiBmaXQpICYmICh2YWx1ZXMgPSAkJC5tYXBUYXJnZXRzVG9VbmlxdWVYcyh0YXJnZXRzKSwgJCQuaXNDYXRlZ29yaXplZCgpICYmIGNvdW50ID4gdmFsdWVzLmxlbmd0aCAmJiAoY291bnQgPSB2YWx1ZXMubGVuZ3RoKSwgdmFsdWVzID0gdGhpcy5nZW5lcmF0ZVRpY2tWYWx1ZXModmFsdWVzLCBjb3VudCwgJCQuaXNUaW1lU2VyaWVzKCkpKSwgYXhpcyA/IGF4aXMudGlja1ZhbHVlcyh2YWx1ZXMpIDogJCQueEF4aXMgJiYgKCQkLnhBeGlzLnRpY2tWYWx1ZXModmFsdWVzKSwgJCQuc3ViWEF4aXMudGlja1ZhbHVlcyh2YWx1ZXMpKSwgdmFsdWVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJZChpZCkge1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMub3duZXIuY29uZmlnO1xuICAgICAgcmV0dXJuIGlkIGluIGNvbmZpZy5kYXRhX2F4ZXMgPyBjb25maWcuZGF0YV9heGVzW2lkXSA6IFwieVwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRYQXhpc1RpY2tGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WEF4aXNUaWNrRm9ybWF0KCkge1xuICAgICAgdmFyIGZvcm1hdCxcbiAgICAgICAgICAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgIHRpY2tGb3JtYXQgPSBjb25maWcuYXhpc194X3RpY2tfZm9ybWF0LFxuICAgICAgICAgIGlzVGltZVNlcmllcyA9ICQkLmlzVGltZVNlcmllcygpLFxuICAgICAgICAgIGlzQ2F0ZWdvcml6ZWQgPSAkJC5pc0NhdGVnb3JpemVkKCk7XG4gICAgICByZXR1cm4gdGlja0Zvcm1hdCA/IGlzRnVuY3Rpb24odGlja0Zvcm1hdCkgPyBmb3JtYXQgPSB0aWNrRm9ybWF0IDogaXNUaW1lU2VyaWVzICYmIChmb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZSA/ICQkLmF4aXNUaW1lRm9ybWF0KHRpY2tGb3JtYXQpKGRhdGUpIDogXCJcIjtcbiAgICAgIH0pIDogZm9ybWF0ID0gaXNUaW1lU2VyaWVzID8gJCQuZGVmYXVsdEF4aXNUaW1lRm9ybWF0IDogaXNDYXRlZ29yaXplZCA/ICQkLmNhdGVnb3J5TmFtZSA6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2IDwgMCA/IHYudG9GaXhlZCgwKSA6IHY7XG4gICAgICB9LCBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gZm9ybWF0LmFwcGx5KCQkLCBpc0NhdGVnb3JpemVkID8gW3YsICQkLmNhdGVnb3J5TmFtZSh2KV0gOiBbdl0pO1xuICAgICAgfSA6IGZvcm1hdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGlja1ZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaWNrVmFsdWVzKGlkKSB7XG4gICAgICB2YXIgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgIHRpY2tWYWx1ZXMgPSAkJC5jb25maWdbXCJheGlzX1wiLmNvbmNhdChpZCwgXCJfdGlja192YWx1ZXNcIildLFxuICAgICAgICAgIGF4aXMgPSAkJFtcIlwiLmNvbmNhdChpZCwgXCJBeGlzXCIpXTtcbiAgICAgIHJldHVybiAoaXNGdW5jdGlvbih0aWNrVmFsdWVzKSA/IHRpY2tWYWx1ZXMoKSA6IHRpY2tWYWx1ZXMpIHx8IChheGlzID8gYXhpcy50aWNrVmFsdWVzKCkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYWJlbE9wdGlvbkJ5QXhpc0lkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bmVyLmNvbmZpZ1tcImF4aXNfXCIuY29uY2F0KGlkLCBcIl9sYWJlbFwiKV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbFRleHQoaWQpIHtcbiAgICAgIHZhciBvcHRpb24gPSB0aGlzLmdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQpO1xuICAgICAgcmV0dXJuIGlzU3RyaW5nKG9wdGlvbikgPyBvcHRpb24gOiBvcHRpb24gPyBvcHRpb24udGV4dCA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldExhYmVsVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMYWJlbFRleHQoaWQsIHRleHQpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgIG9wdGlvbiA9IHRoaXMuZ2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCk7XG4gICAgICBpc1N0cmluZyhvcHRpb24pID8gY29uZmlnW1wiYXhpc19cIi5jb25jYXQoaWQsIFwiX2xhYmVsXCIpXSA9IHRleHQgOiBvcHRpb24gJiYgKG9wdGlvbi50ZXh0ID0gdGV4dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxQb3NpdGlvbihpZCwgZGVmYXVsdFBvc2l0aW9uKSB7XG4gICAgICB2YXIgaXNSb3RhdGVkID0gdGhpcy5vd25lci5jb25maWcuYXhpc19yb3RhdGVkLFxuICAgICAgICAgIG9wdGlvbiA9IHRoaXMuZ2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCksXG4gICAgICAgICAgcG9zaXRpb24gPSBpc09iamVjdFR5cGUob3B0aW9uKSAmJiBvcHRpb24ucG9zaXRpb24gPyBvcHRpb24ucG9zaXRpb24gOiBkZWZhdWx0UG9zaXRpb25bKyFpc1JvdGF0ZWRdLFxuICAgICAgICAgIGhhcyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiAhIX5wb3NpdGlvbi5pbmRleE9mKHYpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNJbm5lcjogaGFzKFwiaW5uZXJcIiksXG4gICAgICAgIGlzT3V0ZXI6IGhhcyhcIm91dGVyXCIpLFxuICAgICAgICBpc0xlZnQ6IGhhcyhcImxlZnRcIiksXG4gICAgICAgIGlzQ2VudGVyOiBoYXMoXCJjZW50ZXJcIiksXG4gICAgICAgIGlzUmlnaHQ6IGhhcyhcInJpZ2h0XCIpLFxuICAgICAgICBpc1RvcDogaGFzKFwidG9wXCIpLFxuICAgICAgICBpc01pZGRsZTogaGFzKFwibWlkZGxlXCIpLFxuICAgICAgICBpc0JvdHRvbTogaGFzKFwiYm90dG9tXCIpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBeGlzTGFiZWxQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBeGlzTGFiZWxQb3NpdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFiZWxQb3NpdGlvbihpZCwgaWQgPT09IFwieFwiID8gW1wiaW5uZXItdG9wXCIsIFwiaW5uZXItcmlnaHRcIl0gOiBbXCJpbm5lci1yaWdodFwiLCBcImlubmVyLXRvcFwiXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsUG9zaXRpb25CeUlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsUG9zaXRpb25CeUlkKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBeGlzTGFiZWxQb3NpdGlvbihpZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInhGb3JBeGlzTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geEZvckF4aXNMYWJlbChpZCkge1xuICAgICAgdmFyICQkID0gdGhpcy5vd25lcixcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0QXhpc0xhYmVsUG9zaXRpb24oaWQpLFxuICAgICAgICAgIHggPSBwb3NpdGlvbi5pc01pZGRsZSA/IC0kJC5oZWlnaHQgLyAyIDogMDtcbiAgICAgIHJldHVybiBpc0hvcml6b250YWwoJCQsIGlkICE9PSBcInhcIikgPyB4ID0gcG9zaXRpb24uaXNMZWZ0ID8gMCA6IHBvc2l0aW9uLmlzQ2VudGVyID8gJCQud2lkdGggLyAyIDogJCQud2lkdGggOiBwb3NpdGlvbi5pc0JvdHRvbSAmJiAoeCA9IC0kJC5oZWlnaHQpLCB4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkeEZvckF4aXNMYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkeEZvckF4aXNMYWJlbChpZCkge1xuICAgICAgdmFyICQkID0gdGhpcy5vd25lcixcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0QXhpc0xhYmVsUG9zaXRpb24oaWQpLFxuICAgICAgICAgIGR4ID0gcG9zaXRpb24uaXNCb3R0b20gPyBcIjAuNWVtXCIgOiBcIjBcIjtcbiAgICAgIHJldHVybiBpc0hvcml6b250YWwoJCQsIGlkICE9PSBcInhcIikgPyBkeCA9IHBvc2l0aW9uLmlzTGVmdCA/IFwiMC41ZW1cIiA6IHBvc2l0aW9uLmlzUmlnaHQgPyBcIi0wLjVlbVwiIDogXCIwXCIgOiBwb3NpdGlvbi5pc1RvcCAmJiAoZHggPSBcIi0wLjVlbVwiKSwgZHg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRBbmNob3JGb3JBeGlzTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dEFuY2hvckZvckF4aXNMYWJlbChpZCkge1xuICAgICAgdmFyICQkID0gdGhpcy5vd25lcixcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0QXhpc0xhYmVsUG9zaXRpb24oaWQpLFxuICAgICAgICAgIGFuY2hvciA9IHBvc2l0aW9uLmlzTWlkZGxlID8gXCJtaWRkbGVcIiA6IFwiZW5kXCI7XG4gICAgICByZXR1cm4gaXNIb3Jpem9udGFsKCQkLCBpZCAhPT0gXCJ4XCIpID8gYW5jaG9yID0gcG9zaXRpb24uaXNMZWZ0ID8gXCJzdGFydFwiIDogcG9zaXRpb24uaXNDZW50ZXIgPyBcIm1pZGRsZVwiIDogXCJlbmRcIiA6IHBvc2l0aW9uLmlzQm90dG9tICYmIChhbmNob3IgPSBcInN0YXJ0XCIpLCBhbmNob3I7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR5Rm9yQXhpc0xhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGR5Rm9yQXhpc0xhYmVsKGlkKSB7XG4gICAgICB2YXIgZHksXG4gICAgICAgICAgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkLFxuICAgICAgICAgIGlzSW5uZXIgPSB0aGlzLmdldEF4aXNMYWJlbFBvc2l0aW9uKGlkKS5pc0lubmVyLFxuICAgICAgICAgIHRpY2tSb3RhdGUgPSBjb25maWdbXCJheGlzX1wiLmNvbmNhdChpZCwgXCJfdGlja19yb3RhdGVcIildID8gJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoaWQpIDogMCxcbiAgICAgICAgICBtYXhUaWNrV2lkdGggPSB0aGlzLmdldE1heFRpY2tXaWR0aChpZCk7XG5cbiAgICAgIGlmIChpZCA9PT0gXCJ4XCIpIHtcbiAgICAgICAgdmFyIHhIZWlnaHQgPSBjb25maWcuYXhpc194X2hlaWdodDtcbiAgICAgICAgZHkgPSBpc1JvdGF0ZWQgPyBpc0lubmVyID8gXCIxLjJlbVwiIDogLTI1IC0gbWF4VGlja1dpZHRoIDogaXNJbm5lciA/IFwiLTAuNWVtXCIgOiB4SGVpZ2h0ID8geEhlaWdodCAtIDEwIDogdGlja1JvdGF0ZSA/IHRpY2tSb3RhdGUgLSAxMCA6IFwiM2VtXCI7XG4gICAgICB9IGVsc2UgZHkgPSB7XG4gICAgICAgIHk6IFtcIi0wLjVlbVwiLCAxMCwgXCIzZW1cIiwgXCIxLjJlbVwiLCAxMF0sXG4gICAgICAgIHkyOiBbXCIxLjJlbVwiLCAtMjAsIFwiLTIuMmVtXCIsIFwiLTAuNWVtXCIsIDE1XVxuICAgICAgfVtpZF0sIGR5ID0gaXNSb3RhdGVkID8gaXNJbm5lciA/IGR5WzBdIDogdGlja1JvdGF0ZSA/IHRpY2tSb3RhdGUgKiAoaWQgPT09IFwieTJcIiA/IC0xIDogMSkgLSBkeVsxXSA6IGR5WzJdIDogaXNJbm5lciA/IGR5WzNdIDogKGR5WzRdICsgKGNvbmZpZ1tcImF4aXNfXCIuY29uY2F0KGlkLCBcIl9pbm5lclwiKV0gPyAwIDogbWF4VGlja1dpZHRoICsgZHlbNF0pKSAqIChpZCA9PT0gXCJ5XCIgPyAtMSA6IDEpO1xuXG4gICAgICByZXR1cm4gZHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1heFRpY2tXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhUaWNrV2lkdGgoaWQsIHdpdGhvdXRSZWNvbXB1dGUpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgIGN1cnJlbnRUaWNrTWF4ID0gJCQuY3VycmVudE1heFRpY2tXaWR0aHNbaWRdLFxuICAgICAgICAgIG1heFdpZHRoID0gMDtcbiAgICAgIGlmICh3aXRob3V0UmVjb21wdXRlIHx8ICFjb25maWdbXCJheGlzX1wiLmNvbmNhdChpZCwgXCJfc2hvd1wiKV0gfHwgJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XG5cbiAgICAgIGlmICgkJC5zdmcpIHtcbiAgICAgICAgdmFyIGlzWUF4aXMgPSAvXnkyPyQvLnRlc3QoaWQpLFxuICAgICAgICAgICAgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKSxcbiAgICAgICAgICAgIHNjYWxlID0gJCRbaWRdLmNvcHkoKS5kb21haW4oJCRbXCJnZXRcIi5jb25jYXQoaXNZQXhpcyA/IFwiWVwiIDogXCJYXCIsIFwiRG9tYWluXCIpXSh0YXJnZXRzVG9TaG93LCBpZCkpLFxuICAgICAgICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluKCk7XG4gICAgICAgIC8vIGRvIG5vdCBjb21wdXRlIGlmIGRvbWFpbiBpcyBzYW1lXG4gICAgICAgIGlmIChkb21haW5bMF0gPT09IGRvbWFpblsxXSAmJiBkb21haW4uZXZlcnkoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gdiA+IDA7XG4gICAgICAgIH0pIHx8IGlzQXJyYXkoY3VycmVudFRpY2tNYXguZG9tYWluKSAmJiBjdXJyZW50VGlja01heC5kb21haW5bMF0gPT09IGN1cnJlbnRUaWNrTWF4LmRvbWFpblsxXSkgcmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XG4gICAgICAgIGN1cnJlbnRUaWNrTWF4LmRvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgdmFyIGF4aXMgPSB0aGlzLmdldEF4aXMoaWQsIHNjYWxlLCAhMSwgITEsICEwKSxcbiAgICAgICAgICAgIHRpY2tDb3VudCA9IGNvbmZpZ1tcImF4aXNfXCIuY29uY2F0KGlkLCBcIl90aWNrX2NvdW50XCIpXSxcbiAgICAgICAgICAgIHRpY2tWYWx1ZXMgPSBjb25maWdbXCJheGlzX1wiLmNvbmNhdChpZCwgXCJfdGlja192YWx1ZXNcIildO1xuICAgICAgICAhdGlja1ZhbHVlcyAmJiB0aWNrQ291bnQgJiYgYXhpcy50aWNrVmFsdWVzKHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKGRvbWFpbiwgdGlja0NvdW50LCBpc1lBeGlzID8gJCQuaXNUaW1lU2VyaWVzWSgpIDogJCQuaXNUaW1lU2VyaWVzKCkpKSwgaXNZQXhpcyB8fCB0aGlzLnVwZGF0ZVhBeGlzVGlja1ZhbHVlcyh0YXJnZXRzVG9TaG93LCBheGlzKTtcbiAgICAgICAgdmFyIGR1bW15ID0gJCQuc2VsZWN0Q2hhcnQuYXBwZW5kKFwic3ZnXCIpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKS5zdHlsZShcInBvc2l0aW9uXCIsIFwiZml4ZWRcIikuc3R5bGUoXCJ0b3BcIiwgXCIwcHhcIikuc3R5bGUoXCJsZWZ0XCIsIFwiMHB4XCIpO1xuICAgICAgICBheGlzLmNyZWF0ZShkdW1teSksIGR1bW15LnNlbGVjdEFsbChcInRleHRcIikuZWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHZhciBjdXJyZW50VGV4dFdpZHRoID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoLCBjdXJyZW50VGV4dFdpZHRoKSwgaWQgPT09IFwieFwiICYmICgkJC5jdXJyZW50TWF4VGlja1dpZHRocy54LnRpY2tzW2ldID0gY3VycmVudFRleHRXaWR0aCk7XG4gICAgICAgIH0pLCBkdW1teS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1heFdpZHRoID4gMCAmJiAoY3VycmVudFRpY2tNYXguc2l6ZSA9IG1heFdpZHRoKSwgY3VycmVudFRpY2tNYXguc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0WEF4aXNUaWNrVGV4dFkyT3ZlcmZsb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WEF4aXNUaWNrVGV4dFkyT3ZlcmZsb3coZGVmYXVsdFBhZGRpbmcpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgIHhBeGlzVGlja1JvdGF0ZSA9ICQkLmdldEF4aXNUaWNrUm90YXRlKFwieFwiKTtcblxuICAgICAgaWYgKCgkJC5pc0NhdGVnb3JpemVkKCkgfHwgJCQuaXNUaW1lU2VyaWVzKCkpICYmIGNvbmZpZy5heGlzX3hfdGlja19maXQgJiYgIWNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nICYmICFjb25maWcuYXhpc194X3RpY2tfbXVsdGlsaW5lICYmIHhBeGlzVGlja1JvdGF0ZSA+IDAgJiYgeEF4aXNUaWNrUm90YXRlIDwgOTApIHtcbiAgICAgICAgdmFyIHdpZHRoV2l0aG91dEN1cnJlbnRQYWRkaW5nTGVmdCA9ICQkLmN1cnJlbnRXaWR0aCAtICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCgpLFxuICAgICAgICAgICAgbWF4T3ZlcmZsb3cgPSB0aGlzLmdldFhBeGlzVGlja01heE92ZXJmbG93KHhBeGlzVGlja1JvdGF0ZSwgd2lkdGhXaXRob3V0Q3VycmVudFBhZGRpbmdMZWZ0IC0gZGVmYXVsdFBhZGRpbmcpLFxuICAgICAgICAgICAgeEF4aXNUaWNrVGV4dFkyT3ZlcmZsb3cgPSBNYXRoLm1heCgwLCBtYXhPdmVyZmxvdykgKyBkZWZhdWx0UGFkZGluZztcbiAgICAgICAgLy8gZm9yIGRpc3BsYXkgaW5jb25zaXN0ZW5jaWVzIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHhBeGlzVGlja1RleHRZMk92ZXJmbG93LCB3aWR0aFdpdGhvdXRDdXJyZW50UGFkZGluZ0xlZnQgLyAyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFhBeGlzVGlja01heE92ZXJmbG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFhBeGlzVGlja01heE92ZXJmbG93KHhBeGlzVGlja1JvdGF0ZSwgd2lkdGhXaXRob3V0Q3VycmVudFBhZGRpbmdMZWZ0KSB7XG4gICAgICBmb3IgKHZhciAkJCA9IHRoaXMub3duZXIsIGNvbmZpZyA9ICQkLmNvbmZpZywgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCksIHRpY2tUZXh0V2lkdGhzID0gJCQuY3VycmVudE1heFRpY2tXaWR0aHMueC50aWNrcywgdGlja0NvdW50ID0gdGlja1RleHRXaWR0aHMubGVuZ3RoLCBfdGhpcyR4JHBhZGRpbmcgPSB0aGlzLngucGFkZGluZywgbGVmdCA9IF90aGlzJHgkcGFkZGluZy5sZWZ0LCByaWdodCA9IF90aGlzJHgkcGFkZGluZy5yaWdodCwgbWF4T3ZlcmZsb3cgPSAwLCByZW1haW5pbmcgPSB0aWNrQ291bnQgLSAoaXNUaW1lU2VyaWVzICYmIGNvbmZpZy5heGlzX3hfdGlja19maXQgPyAuNSA6IDApLCBpID0gMDsgaSA8IHRpY2tDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciB0aWNrSW5kZXggPSBpICsgMSxcbiAgICAgICAgICAgIHJvdGF0ZWRUaWNrVGV4dFdpZHRoID0gTWF0aC5jb3MoTWF0aC5QSSAqIHhBeGlzVGlja1JvdGF0ZSAvIDE4MCkgKiB0aWNrVGV4dFdpZHRoc1tpXSxcbiAgICAgICAgICAgIHRpY2tzQmVmb3JlVGlja1RleHQgPSB0aWNrSW5kZXggLSAoaXNUaW1lU2VyaWVzID8gMSA6IC41KSArIGxlZnQ7XG5cbiAgICAgICAgLy8gU2tpcCB0aWNrcyBpZiB0aGVyZSBhcmUgbm8gdGlja3MgYmVmb3JlIHRoZW1cbiAgICAgICAgaWYgKCEodGlja3NCZWZvcmVUaWNrVGV4dCA8PSAwKSkge1xuICAgICAgICAgIHZhciB0aWNrTGVuZ3RoID0gKHdpZHRoV2l0aG91dEN1cnJlbnRQYWRkaW5nTGVmdCAtIHJvdGF0ZWRUaWNrVGV4dFdpZHRoKSAvIHRpY2tzQmVmb3JlVGlja1RleHQ7XG4gICAgICAgICAgbWF4T3ZlcmZsb3cgPSBNYXRoLm1heChtYXhPdmVyZmxvdywgcm90YXRlZFRpY2tUZXh0V2lkdGggLSB0aWNrTGVuZ3RoIC8gMiAtICgocmVtYWluaW5nIC0gdGlja0luZGV4KSAqIHRpY2tMZW5ndGggKyByaWdodCAqIHRpY2tMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGlja09mZnNldCA9IDA7XG5cbiAgICAgIGlmICghaXNUaW1lU2VyaWVzKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zY2FsZV9jb21tb25qczJfZDNfc2NhbGVfYW1kX2QzX3NjYWxlX3Jvb3RfZDNfW1wic2NhbGVMaW5lYXJcIl0pKCkuZG9tYWluKFtsZWZ0ICogLTEsICQkLmdldFhEb21haW5NYXgoJCQuZGF0YS50YXJnZXRzKSArIDEgKyByaWdodF0pLnJhbmdlKFswLCB3aWR0aFdpdGhvdXRDdXJyZW50UGFkZGluZ0xlZnQgLSBtYXhPdmVyZmxvd10pO1xuICAgICAgICB0aWNrT2Zmc2V0ID0gTWF0aC5jZWlsKChzY2FsZSgxKSAtIHNjYWxlKDApKSAvIDIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4T3ZlcmZsb3cgKyB0aWNrT2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgeCBBeGlzIHBhZGRpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGlja0NvdW50IFRpY2sgY291bnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFBhZGRpbmcgb2JqZWN0IHZhbHVlcyB3aXRoICdsZWZ0JyAmICdyaWdodCcga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFhBeGlzUGFkZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRYQXhpc1BhZGRpbmcodGlja0NvdW50KSB7XG4gICAgICB2YXIgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgIHBhZGRpbmcgPSAkJC5jb25maWcuYXhpc194X3BhZGRpbmc7XG5cbiAgICAgIGlmIChpc0VtcHR5KHBhZGRpbmcpID8gcGFkZGluZyA9IHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDBcbiAgICAgIH0gOiAocGFkZGluZy5sZWZ0ID0gcGFkZGluZy5sZWZ0IHx8IDAsIHBhZGRpbmcucmlnaHQgPSBwYWRkaW5nLnJpZ2h0IHx8IDApLCAkJC5pc1RpbWVTZXJpZXMoKSkge1xuICAgICAgICB2YXIgZmlyc3RYID0gKyQkLmdldFhEb21haW5NaW4oJCQuZGF0YS50YXJnZXRzKSxcbiAgICAgICAgICAgIGxhc3RYID0gKyQkLmdldFhEb21haW5NYXgoJCQuZGF0YS50YXJnZXRzKSxcbiAgICAgICAgICAgIHRpbWVEaWZmID0gbGFzdFggLSBmaXJzdFgsXG4gICAgICAgICAgICByYW5nZSA9IHRpbWVEaWZmICsgcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodCxcbiAgICAgICAgICAgIHJlbGF0aXZlVGlja1dpZHRoID0gdGltZURpZmYgLyB0aWNrQ291bnQgLyByYW5nZSxcbiAgICAgICAgICAgIGxlZnQgPSBwYWRkaW5nLmxlZnQgLyByYW5nZSAvIHJlbGF0aXZlVGlja1dpZHRoIHx8IDAsXG4gICAgICAgICAgICBfcmlnaHQgPSBwYWRkaW5nLnJpZ2h0IC8gcmFuZ2UgLyByZWxhdGl2ZVRpY2tXaWR0aCB8fCAwO1xuXG4gICAgICAgIHBhZGRpbmcgPSB7XG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICByaWdodDogX3JpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYWRkaW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGFiZWxzKHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcyxcbiAgICAgICAgICAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgbGFiZWxzID0ge1xuICAgICAgICB4OiAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYXhpc1gsIFwiIC5cIikuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmF4aXNYTGFiZWwpKSxcbiAgICAgICAgeTogJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmF4aXNZLCBcIiAuXCIpLmNvbmNhdChjb25maWdfY2xhc3Nlcy5heGlzWUxhYmVsKSksXG4gICAgICAgIHkyOiAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYXhpc1kyLCBcIiAuXCIpLmNvbmNhdChjb25maWdfY2xhc3Nlcy5heGlzWTJMYWJlbCkpXG4gICAgICB9O1xuXG4gICAgICBPYmplY3Qua2V5cyhsYWJlbHMpLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuICFsYWJlbHNbaWRdLmVtcHR5KCk7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBub2RlID0gbGFiZWxzW3ZdO1xuICAgICAgICAod2l0aFRyYW5zaXRpb24gPyBub2RlLnRyYW5zaXRpb24oKSA6IG5vZGUpLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnhGb3JBeGlzTGFiZWwodik7XG4gICAgICAgIH0pLmF0dHIoXCJkeFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5keEZvckF4aXNMYWJlbCh2KTtcbiAgICAgICAgfSkuYXR0cihcImR5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmR5Rm9yQXhpc0xhYmVsKHYpO1xuICAgICAgICB9KS50ZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmdldExhYmVsVGV4dCh2KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFkZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWRkaW5nKHBhZGRpbmcsIGtleSwgZGVmYXVsdFZhbHVlLCBkb21haW5MZW5ndGgpIHtcbiAgICAgIHZhciBwID0gaXNOdW1iZXIocGFkZGluZykgPyBwYWRkaW5nIDogcGFkZGluZ1trZXldO1xuICAgICAgcmV0dXJuIGlzVmFsdWUocCkgPyB0aGlzLmNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nKHAsIGRvbWFpbkxlbmd0aCkgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nKHBpeGVscywgZG9tYWluTGVuZ3RoKSB7XG4gICAgICB2YXIgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgIGxlbmd0aCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgPyAkJC53aWR0aCA6ICQkLmhlaWdodDtcbiAgICAgIHJldHVybiBkb21haW5MZW5ndGggKiAocGl4ZWxzIC8gbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVUaWNrVmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlVGlja1ZhbHVlcyh2YWx1ZXMsIHRpY2tDb3VudCwgZm9yVGltZVNlcmllcykge1xuICAgICAgdmFyIHRpY2tWYWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICAgIGlmICh0aWNrQ291bnQpIHtcbiAgICAgICAgdmFyIHRhcmdldENvdW50ID0gaXNGdW5jdGlvbih0aWNrQ291bnQpID8gdGlja0NvdW50KCkgOiB0aWNrQ291bnQ7IC8vIGNvbXB1dGUgdGlja3MgYWNjb3JkaW5nIHRvIHRpY2tDb3VudFxuXG4gICAgICAgIGlmICh0YXJnZXRDb3VudCA9PT0gMSkgdGlja1ZhbHVlcyA9IFt2YWx1ZXNbMF1dO2Vsc2UgaWYgKHRhcmdldENvdW50ID09PSAyKSB0aWNrVmFsdWVzID0gW3ZhbHVlc1swXSwgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXV07ZWxzZSBpZiAodGFyZ2V0Q291bnQgPiAyKSB7XG4gICAgICAgICAgdmFyIHRpY2tWYWx1ZSxcbiAgICAgICAgICAgICAgaXNDYXRlZ29yaXplZCA9IHRoaXMub3duZXIuaXNDYXRlZ29yaXplZCgpLFxuICAgICAgICAgICAgICBjb3VudCA9IHRhcmdldENvdW50IC0gMixcbiAgICAgICAgICAgICAgc3RhcnQgPSB2YWx1ZXNbMF0sXG4gICAgICAgICAgICAgIGVuZCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgdGlja1ZhbHVlcyA9IFtzdGFydF07XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHRpY2tWYWx1ZSA9ICtzdGFydCArIChlbmQgLSBzdGFydCkgLyAoY291bnQgKyAxKSAqIChpICsgMSksIHRpY2tWYWx1ZXMucHVzaChmb3JUaW1lU2VyaWVzID8gbmV3IERhdGUodGlja1ZhbHVlKSA6IGlzQ2F0ZWdvcml6ZWQgPyBNYXRoLnJvdW5kKHRpY2tWYWx1ZSkgOiB0aWNrVmFsdWUpO1xuXG4gICAgICAgICAgdGlja1ZhbHVlcy5wdXNoKGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvclRpbWVTZXJpZXMgfHwgKHRpY2tWYWx1ZXMgPSB0aWNrVmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfSkpLCB0aWNrVmFsdWVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZVRyYW5zaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlVHJhbnNpdGlvbnMoZHVyYXRpb24pIHtcbiAgICAgIHZhciAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgYXhlcyA9ICQkLmF4ZXMsXG4gICAgICAgICAgX21hcCA9IFtcInhcIiwgXCJ5XCIsIFwieTJcIiwgXCJzdWJ4XCJdLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgYXhpcyA9IGF4ZXNbdl07XG4gICAgICAgIHJldHVybiBheGlzICYmIGR1cmF0aW9uICYmIChheGlzID0gYXhpcy50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pKSwgYXhpcztcbiAgICAgIH0pLFxuICAgICAgICAgIF9tYXAyID0gX3NsaWNlZFRvQXJyYXkoX21hcCwgNCksXG4gICAgICAgICAgYXhpc1ggPSBfbWFwMlswXSxcbiAgICAgICAgICBheGlzWSA9IF9tYXAyWzFdLFxuICAgICAgICAgIGF4aXNZMiA9IF9tYXAyWzJdLFxuICAgICAgICAgIGF4aXNTdWJYID0gX21hcDJbM107XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF4aXNYOiBheGlzWCxcbiAgICAgICAgYXhpc1k6IGF4aXNZLFxuICAgICAgICBheGlzWTI6IGF4aXNZMixcbiAgICAgICAgYXhpc1N1Ylg6IGF4aXNTdWJYXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3KHRyYW5zaXRpb25zLCBpc0hpZGRlbiwgaXNJbml0KSB7XG4gICAgICB2YXIgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgIG9wYWNpdHkgPSBpc0hpZGRlbiA/IFwiMFwiIDogXCIxXCI7XG4gICAgICBbXCJ4XCIsIFwieVwiLCBcInkyXCIsIFwic3ViWFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXhpcyA9ICQkW1wiXCIuY29uY2F0KGlkLCBcIkF4aXNcIildO1xuICAgICAgICBheGlzICYmICghaXNJbml0ICYmIChheGlzLmNvbmZpZy53aXRob3V0VHJhbnNpdGlvbiA9ICEkJC5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbiksICQkLmF4ZXNbaWQudG9Mb3dlckNhc2UoKV0uc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHkpLCBheGlzLmNyZWF0ZSh0cmFuc2l0aW9uc1tcImF4aXNcIi5jb25jYXQoY2FwaXRhbGl6ZShpZCkpXSkpO1xuICAgICAgfSksIHRoaXMudXBkYXRlQXhlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYXhpc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzVG9TaG93IHRhcmdldHMgZGF0YSB0byBiZSBzaG93blxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3dGhcbiAgICAgKiBAcGFyYW0ge09qYmVjdH0gdHJhbnNpdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmxvd1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdBeGlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHJhd0F4aXModGFyZ2V0c1RvU2hvdywgd3RoLCB0cmFuc2l0aW9ucywgZmxvdywgaXNJbml0KSB7XG4gICAgICB2YXIgeERvbWFpbkZvclpvb20sXG4gICAgICAgICAgX3RoaXMzID0gdGhpcyxcbiAgICAgICAgICAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgIGhhc1pvb20gPSAhISQkLnpvb21TY2FsZTtcblxuICAgICAgIWhhc1pvb20gJiYgJCQuaXNDYXRlZ29yaXplZCgpICYmIHRhcmdldHNUb1Nob3cubGVuZ3RoID09PSAwICYmICQkLnguZG9tYWluKFswLCAkJC5heGVzLnguc2VsZWN0QWxsKFwiLnRpY2tcIikuc2l6ZSgpXSksICQkLnggJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPyAoIWhhc1pvb20gJiYgJCQudXBkYXRlWERvbWFpbih0YXJnZXRzVG9TaG93LCB3dGguVXBkYXRlWERvbWFpbiwgd3RoLlVwZGF0ZU9yZ1hEb21haW4sIHd0aC5UcmltWERvbWFpbiksICFjb25maWcuYXhpc194X3RpY2tfdmFsdWVzICYmIHRoaXMudXBkYXRlWEF4aXNUaWNrVmFsdWVzKHRhcmdldHNUb1Nob3cpKSA6ICQkLnhBeGlzICYmICgkJC54QXhpcy50aWNrVmFsdWVzKFtdKSwgJCQuc3ViWEF4aXMudGlja1ZhbHVlcyhbXSkpLCBjb25maWcuem9vbV9yZXNjYWxlICYmICFmbG93ICYmICh4RG9tYWluRm9yWm9vbSA9ICQkLngub3JnRG9tYWluKCkpLCBbXCJ5XCIsIFwieTJcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBheGlzID0gJCRba2V5XTtcblxuICAgICAgICBpZiAoYXhpcykge1xuICAgICAgICAgIHZhciB0aWNrVmFsdWVzID0gY29uZmlnW1wiYXhpc19cIi5jb25jYXQoa2V5LCBcIl90aWNrX3ZhbHVlc1wiKV0sXG4gICAgICAgICAgICAgIHRpY2tDb3VudCA9IGNvbmZpZ1tcImF4aXNfXCIuY29uY2F0KGtleSwgXCJfdGlja19jb3VudFwiKV07XG5cbiAgICAgICAgICBpZiAoYXhpcy5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBrZXksIHhEb21haW5Gb3Jab29tKSksICF0aWNrVmFsdWVzICYmIHRpY2tDb3VudCkge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGF4aXMuZG9tYWluKCk7XG4gICAgICAgICAgICAkJFtcIlwiLmNvbmNhdChrZXksIFwiQXhpc1wiKV0udGlja1ZhbHVlcyhfdGhpczMuZ2VuZXJhdGVUaWNrVmFsdWVzKGRvbWFpbiwgZG9tYWluLmV2ZXJ5KGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIHJldHVybiB2ID09PSAwO1xuICAgICAgICAgICAgfSkgPyAxIDogdGlja0NvdW50LCAkJC5pc1RpbWVTZXJpZXNZKCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLCB0aGlzLnJlZHJhdyh0cmFuc2l0aW9ucywgJCQuaGFzQXJjVHlwZSgpLCBpc0luaXQpLCB0aGlzLnVwZGF0ZUxhYmVscyh3dGguVHJhbnNpdGlvbiksICh3dGguVXBkYXRlWERvbWFpbiB8fCB3dGguVXBkYXRlWEF4aXMgfHwgd3RoLlkpICYmIHRhcmdldHNUb1Nob3cubGVuZ3RoICYmIHRoaXMuc2V0Q3VsbGluZygpLCB3dGguWSAmJiAoJCQuc3ViWSAmJiAkJC5zdWJZLmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csIFwieVwiKSksICQkLnN1YlkyICYmICQkLnN1YlkyLmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csIFwieTJcIikpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IG1hbnVhbCBjdWxsaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEN1bGxpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VsbGluZygpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgW1wic3VieFwiLCBcInhcIiwgXCJ5XCIsIFwieTJcIl0uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYXhpcyA9ICQkLmF4ZXNbdHlwZV0sXG4gICAgICAgICAgICBpZCA9IHR5cGUgPT09IFwic3VieFwiID8gXCJ4XCIgOiB0eXBlLFxuICAgICAgICAgICAgdG9DdWxsID0gY29uZmlnW1wiYXhpc19cIi5jb25jYXQoaWQsIFwiX3RpY2tfY3VsbGluZ1wiKV07IC8vIHN1YmNoYXJ0IHggYXhpcyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHggYXhpcyBjdWxsaW5nXG5cbiAgICAgICAgaWYgKGF4aXMgJiYgdG9DdWxsKSB7XG4gICAgICAgICAgdmFyIGludGVydmFsRm9yQ3VsbGluZyxcbiAgICAgICAgICAgICAgdGlja1RleHQgPSBheGlzLnNlbGVjdEFsbChcIi50aWNrIHRleHRcIiksXG4gICAgICAgICAgICAgIHRpY2tWYWx1ZXMgPSBzb3J0VmFsdWUodGlja1RleHQuZGF0YSgpKSxcbiAgICAgICAgICAgICAgdGlja1NpemUgPSB0aWNrVmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgY3VsbGluZ01heCA9IGNvbmZpZ1tcImF4aXNfXCIuY29uY2F0KGlkLCBcIl90aWNrX2N1bGxpbmdfbWF4XCIpXTtcblxuICAgICAgICAgIGlmICh0aWNrU2l6ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aWNrU2l6ZTsgaSsrKSBpZiAodGlja1NpemUgLyBpIDwgY3VsbGluZ01heCkge1xuICAgICAgICAgICAgICBpbnRlcnZhbEZvckN1bGxpbmcgPSBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGlja1RleHQuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSB0aWNrVmFsdWVzLmluZGV4T2YoZCkgJSBpbnRlcnZhbEZvckN1bGxpbmcgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB0aWNrVGV4dC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTsgLy8gc2V0L3Vuc2V0IHhfYXhpc190aWNrX2NsaXBwYXRoXG5cblxuICAgICAgICAgIGlmICh0eXBlID09PSBcInhcIikge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gJCQuY2xpcFhBeGlzVGlja01heFdpZHRoID8gJCQuY2xpcFBhdGhGb3JYQXhpc1RpY2tUZXh0cyA6IG51bGw7XG4gICAgICAgICAgICAkJC5zdmcuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5heGlzWCwgXCIgLnRpY2sgdGV4dFwiKSkuYXR0cihcImNsaXAtcGF0aFwiLCBjbGlwUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKSwgQXhpcztcbn0oKTtcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbC5qc1xuXG5cblxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogQGlnbm9yZVxuICovXG5cblxuXG5cblxuXG5cbi8qKlxuICogSW50ZXJuYWwgY2hhcnQgY2xhc3MuXG4gKiAtIE5vdGU6IEluc3RhbnRpYXRlZCBpbnRlcm5hbGx5LCBub3QgZXhwb3NlZCBmb3IgcHVibGljLlxuICogQGNsYXNzIENoYXJ0SW50ZXJuYWxcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIENoYXJ0SW50ZXJuYWxfQ2hhcnRJbnRlcm5hbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENoYXJ0SW50ZXJuYWwoYXBpKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXJ0SW50ZXJuYWwpO1xuXG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC5hcGkgPSBhcGksICQkLmNvbmZpZyA9ICQkLmdldE9wdGlvbnMoKSwgJCQuZGF0YSA9IHt9LCAkJC5jYWNoZSA9IHt9LCAkJC5heGVzID0ge30sICQkLnJlbmRlcmVkID0gITE7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENoYXJ0SW50ZXJuYWwsIFt7XG4gICAga2V5OiBcImJlZm9yZUluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlSW5pdCgpIHtcbiAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAkJC5jYWxsUGx1Z2luSG9vayhcIiRiZWZvcmVJbml0XCIpLCBjYWxsRm4oJCQuY29uZmlnLm9uYmVmb3JlaW5pdCwgJCQsICQkLmFwaSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFmdGVySW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlckluaXQoKSB7XG4gICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgJCQuY2FsbFBsdWdpbkhvb2soXCIkYWZ0ZXJJbml0XCIpLCBjYWxsRm4oJCQuY29uZmlnLm9uYWZ0ZXJpbml0LCAkJCwgJCQuYXBpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICAkJC5pbml0UGFyYW1zKCk7XG4gICAgICB2YXIgYmluZHRvID0ge1xuICAgICAgICBlbGVtZW50OiBjb25maWcuYmluZHRvLFxuICAgICAgICBjbGFzc25hbWU6IFwiYmJcIlxuICAgICAgfTtcbiAgICAgIGlzT2JqZWN0KGNvbmZpZy5iaW5kdG8pICYmIChiaW5kdG8uZWxlbWVudCA9IGNvbmZpZy5iaW5kdG8uZWxlbWVudCB8fCBcIiNjaGFydFwiLCBiaW5kdG8uY2xhc3NuYW1lID0gY29uZmlnLmJpbmR0by5jbGFzc25hbWUgfHwgYmluZHRvLmNsYXNzbmFtZSksICQkLnNlbGVjdENoYXJ0ID0gaXNGdW5jdGlvbihiaW5kdG8uZWxlbWVudC5ub2RlKSA/IGNvbmZpZy5iaW5kdG8uZWxlbWVudCA6IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKShiaW5kdG8uZWxlbWVudCB8fCBbXSksICQkLnNlbGVjdENoYXJ0LmVtcHR5KCkgJiYgKCQkLnNlbGVjdENoYXJ0ID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKGJyb3dzZXJfZG9jLmJvZHkuYXBwZW5kQ2hpbGQoYnJvd3Nlcl9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSkpKSwgJCQuc2VsZWN0Q2hhcnQuaHRtbChcIlwiKS5jbGFzc2VkKGJpbmR0by5jbGFzc25hbWUsICEwKSwgJCQuaW5pdFRvUmVuZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHJlbmRlcmluZyBwcm9jZXNzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZWQgRm9yY2UgdG8gcmVuZGVyIHByb2Nlc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFRvUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRUb1JlbmRlcihmb3JjZWQpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgIHRhcmdldCA9ICQkLnNlbGVjdENoYXJ0LFxuICAgICAgICAgIGlzSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LnN0eWxlKFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCIgfHwgdGFyZ2V0LnN0eWxlKFwidmlzaWJpbGl0eVwiKSA9PT0gXCJoaWRkZW5cIjtcbiAgICAgIH0sXG4gICAgICAgICAgaXNMYXp5ID0gY29uZmlnLnJlbmRlci5sYXp5IHx8IGlzSGlkZGVuKCksXG4gICAgICAgICAgTXV0YXRpb25PYnNlcnZlciA9IHdpbi5NdXRhdGlvbk9ic2VydmVyO1xuXG4gICAgICBpZiAoaXNMYXp5ICYmIE11dGF0aW9uT2JzZXJ2ZXIgJiYgY29uZmlnLnJlbmRlci5vYnNlcnZlICE9PSAhMSAmJiAhZm9yY2VkICYmIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbiwgb2JzZXJ2ZXIpIHtcbiAgICAgICAgaXNIaWRkZW4oKSB8fCAob2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCAhJCQucmVuZGVyZWQgJiYgJCQuaW5pdFRvUmVuZGVyKCEwKSk7XG4gICAgICB9KS5vYnNlcnZlKHRhcmdldC5ub2RlKCksIHtcbiAgICAgICAgYXR0cmlidXRlczogITAsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wiY2xhc3NcIiwgXCJzdHlsZVwiXVxuICAgICAgfSksICFpc0xhenkgfHwgZm9yY2VkKSB7XG4gICAgICAgIHZhciBjb252ZXJ0ZWREYXRhID0gJCQuY29udmVydERhdGEoY29uZmlnLCAkJC5pbml0V2l0aERhdGEpO1xuICAgICAgICBjb252ZXJ0ZWREYXRhICYmICQkLmluaXRXaXRoRGF0YShjb252ZXJ0ZWREYXRhKSwgJCQuYWZ0ZXJJbml0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRQYXJhbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFBhcmFtcygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXG4gICAgICAkJC5kYXRldGltZUlkID0gXCJiYi1cIi5jb25jYXQoK25ldyBEYXRlKCkpLCAkJC5pbml0Q2xpcCgpLCAkJC5kcmFnU3RhcnQgPSBudWxsLCAkJC5kcmFnZ2luZyA9ICExLCAkJC5mbG93aW5nID0gITEsICQkLmNhbmNlbENsaWNrID0gITEsICQkLm1vdXNlb3ZlciA9ICExLCAkJC50cmFuc2l0aW5nID0gITEsICQkLmNvbG9yID0gJCQuZ2VuZXJhdGVDb2xvcigpLCAkJC5sZXZlbENvbG9yID0gJCQuZ2VuZXJhdGVMZXZlbENvbG9yKCksICQkLnBvaW50ID0gJCQuZ2VuZXJhdGVQb2ludCgpLCAkJC5leHRyYUxpbmVDbGFzc2VzID0gJCQuZ2VuZXJhdGVFeHRyYUxpbmVDbGFzcygpLCAkJC5kYXRhVGltZUZvcm1hdCA9IGNvbmZpZy5kYXRhX3hMb2NhbHRpbWUgPyBleHRlcm5hbF9jb21tb25qc19kM190aW1lX2Zvcm1hdF9jb21tb25qczJfZDNfdGltZV9mb3JtYXRfYW1kX2QzX3RpbWVfZm9ybWF0X3Jvb3RfZDNfW1widGltZVBhcnNlXCJdIDogZXh0ZXJuYWxfY29tbW9uanNfZDNfdGltZV9mb3JtYXRfY29tbW9uanMyX2QzX3RpbWVfZm9ybWF0X2FtZF9kM190aW1lX2Zvcm1hdF9yb290X2QzX1tcInV0Y1BhcnNlXCJdLCAkJC5heGlzVGltZUZvcm1hdCA9IGNvbmZpZy5heGlzX3hfbG9jYWx0aW1lID8gZXh0ZXJuYWxfY29tbW9uanNfZDNfdGltZV9mb3JtYXRfY29tbW9uanMyX2QzX3RpbWVfZm9ybWF0X2FtZF9kM190aW1lX2Zvcm1hdF9yb290X2QzX1tcInRpbWVGb3JtYXRcIl0gOiBleHRlcm5hbF9jb21tb25qc19kM190aW1lX2Zvcm1hdF9jb21tb25qczJfZDNfdGltZV9mb3JtYXRfYW1kX2QzX3RpbWVfZm9ybWF0X3Jvb3RfZDNfW1widXRjRm9ybWF0XCJdO1xuICAgICAgdmFyIGlzRHJhZ1pvb20gPSAkJC5jb25maWcuem9vbV9lbmFibGVkICYmICQkLmNvbmZpZy56b29tX2VuYWJsZWQudHlwZSA9PT0gXCJkcmFnXCI7XG4gICAgICAkJC5kZWZhdWx0QXhpc1RpbWVGb3JtYXQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgaXNab29tZWQgPSBpc0RyYWdab29tID8gX3RoaXMuem9vbVNjYWxlIDogX3RoaXMuem9vbVNjYWxlICYmICQkLngub3JnRG9tYWluKCkudG9TdHJpbmcoKSAhPT0gX3RoaXMuem9vbVNjYWxlLmRvbWFpbigpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBzcGVjaWZpZXIgPSBkLmdldE1pbGxpc2Vjb25kcygpICYmIFwiLiVMXCIgfHwgZC5nZXRTZWNvbmRzKCkgJiYgXCIuOiVTXCIgfHwgZC5nZXRNaW51dGVzKCkgJiYgXCIlSTolTVwiIHx8IGQuZ2V0SG91cnMoKSAmJiBcIiVJICVwXCIgfHwgZC5nZXREYXRlKCkgIT09IDEgJiYgXCIlYiAlZFwiIHx8IGlzWm9vbWVkICYmIGQuZ2V0RGF0ZSgpID09PSAxICYmIFwiJWJcXCcleVwiIHx8IGQuZ2V0TW9udGgoKSAmJiBcIiUtbS8lLWRcIiB8fCBcIiVZXCI7XG4gICAgICAgIHJldHVybiAkJC5heGlzVGltZUZvcm1hdChzcGVjaWZpZXIpKGQpO1xuICAgICAgfSwgJCQuaGlkZGVuVGFyZ2V0SWRzID0gW10sICQkLmhpZGRlbkxlZ2VuZElkcyA9IFtdLCAkJC5mb2N1c2VkVGFyZ2V0SWRzID0gW10sICQkLmRlZm9jdXNlZFRhcmdldElkcyA9IFtdLCAkJC5pc0xlZ2VuZFJpZ2h0ID0gY29uZmlnLmxlZ2VuZF9wb3NpdGlvbiA9PT0gXCJyaWdodFwiLCAkJC5pc0xlZ2VuZEluc2V0ID0gY29uZmlnLmxlZ2VuZF9wb3NpdGlvbiA9PT0gXCJpbnNldFwiLCAkJC5pc0xlZ2VuZFRvcCA9IGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSBcInRvcC1sZWZ0XCIgfHwgY29uZmlnLmxlZ2VuZF9pbnNldF9hbmNob3IgPT09IFwidG9wLXJpZ2h0XCIsICQkLmlzTGVnZW5kTGVmdCA9IGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSBcInRvcC1sZWZ0XCIgfHwgY29uZmlnLmxlZ2VuZF9pbnNldF9hbmNob3IgPT09IFwiYm90dG9tLWxlZnRcIiwgJCQubGVnZW5kU3RlcCA9IDAsICQkLmxlZ2VuZEl0ZW1XaWR0aCA9IDAsICQkLmxlZ2VuZEl0ZW1IZWlnaHQgPSAwLCAkJC5jdXJyZW50TWF4VGlja1dpZHRocyA9IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgdGlja3M6IFtdLFxuICAgICAgICAgIGRvbWFpbjogXCJcIlxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICBkb21haW46IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgeTI6IHtcbiAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgIGRvbWFpbjogXCJcIlxuICAgICAgICB9XG4gICAgICB9LCAkJC5yb3RhdGVkX3BhZGRpbmdfbGVmdCA9IDMwLCAkJC5yb3RhdGVkX3BhZGRpbmdfcmlnaHQgPSBpc1JvdGF0ZWQgJiYgIWNvbmZpZy5heGlzX3hfc2hvdyA/IDAgOiAzMCwgJCQucm90YXRlZF9wYWRkaW5nX3RvcCA9IDUsICQkLndpdGhvdXRGYWRlSW4gPSB7fSwgJCQuaW5wdXRUeXBlID0gJCQuY29udmVydElucHV0VHlwZSgpLCAkJC5heGVzLnN1YnggPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdEFsbFwiXSkoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0V2l0aERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFdpdGhEYXRhKGRhdGEpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuXG4gICAgICBpZiAoJCQuYXhpcyA9IG5ldyBBeGlzX0F4aXMoJCQpLCBjb25maWcuem9vbV9lbmFibGVkICYmICQkLmluaXRab29tKCksICQkLmRhdGEueHMgPSB7fSwgJCQuZGF0YS50YXJnZXRzID0gJCQuY29udmVydERhdGFUb1RhcmdldHMoZGF0YSksIGNvbmZpZy5kYXRhX2ZpbHRlciAmJiAoJCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmZpbHRlcihjb25maWcuZGF0YV9maWx0ZXIpKSwgY29uZmlnLmRhdGFfaGlkZSAmJiAkJC5hZGRIaWRkZW5UYXJnZXRJZHMoY29uZmlnLmRhdGFfaGlkZSA9PT0gITAgPyAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpIDogY29uZmlnLmRhdGFfaGlkZSksIGNvbmZpZy5sZWdlbmRfaGlkZSAmJiAkJC5hZGRIaWRkZW5MZWdlbmRJZHMoY29uZmlnLmxlZ2VuZF9oaWRlID09PSAhMCA/ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cykgOiBjb25maWcubGVnZW5kX2hpZGUpLCAkJC51cGRhdGVTaXplcygpLCAkJC51cGRhdGVTY2FsZXMoITApLCAkJC54ICYmICgkJC54LmRvbWFpbihzb3J0VmFsdWUoJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpKSksICQkLnN1YlguZG9tYWluKCQkLnguZG9tYWluKCkpLCAkJC5vcmdYRG9tYWluID0gJCQueC5kb21haW4oKSksICQkLnkgJiYgKCQkLnkuZG9tYWluKCQkLmdldFlEb21haW4oJCQuZGF0YS50YXJnZXRzLCBcInlcIikpLCAkJC5zdWJZLmRvbWFpbigkJC55LmRvbWFpbigpKSksICQkLnkyICYmICgkJC55Mi5kb21haW4oJCQuZ2V0WURvbWFpbigkJC5kYXRhLnRhcmdldHMsIFwieTJcIikpLCAkJC5zdWJZMiAmJiAkJC5zdWJZMi5kb21haW4oJCQueTIuZG9tYWluKCkpKSwgJCQuc3ZnID0gJCQuc2VsZWN0Q2hhcnQuYXBwZW5kKFwic3ZnXCIpLnN0eWxlKFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIikuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIiksIGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICQkLmlucHV0VHlwZSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9ICQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xuICAgICAgICAkJC5zdmcub24oaXNUb3VjaCA/IFwidG91Y2hzdGFydFwiIDogXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbEZuKGNvbmZpZy5vbm92ZXIsICQkLCAkJC5hcGkpO1xuICAgICAgICB9KS5vbihpc1RvdWNoID8gXCJ0b3VjaGVuZFwiIDogXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbEZuKGNvbmZpZy5vbm91dCwgJCQsICQkLmFwaSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25maWcuc3ZnX2NsYXNzbmFtZSAmJiAkJC5zdmcuYXR0cihcImNsYXNzXCIsIGNvbmZpZy5zdmdfY2xhc3NuYW1lKSwgJCQuZGVmcyA9ICQkLnN2Zy5hcHBlbmQoXCJkZWZzXCIpLCAkJC5jbGlwQ2hhcnQgPSAkJC5hcHBlbmRDbGlwKCQkLmRlZnMsICQkLmNsaXBJZCksICQkLmNsaXBYQXhpcyA9ICQkLmFwcGVuZENsaXAoJCQuZGVmcywgJCQuY2xpcElkRm9yWEF4aXMpLCAkJC5jbGlwWUF4aXMgPSAkJC5hcHBlbmRDbGlwKCQkLmRlZnMsICQkLmNsaXBJZEZvcllBeGlzKSwgJCQuY2xpcEdyaWQgPSAkJC5hcHBlbmRDbGlwKCQkLmRlZnMsICQkLmNsaXBJZEZvckdyaWQpLCBpc0Z1bmN0aW9uKGNvbmZpZy5jb2xvcl90aWxlcykgJiYgJCQucGF0dGVybnMgJiYgJCQucGF0dGVybnMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gJCQuZGVmcy5hcHBlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwLm5vZGU7XG4gICAgICAgIH0pO1xuICAgICAgfSksICQkLnVwZGF0ZVN2Z1NpemUoKSwgJCQuYmluZFJlc2l6ZSgpO1xuICAgICAgLy8gRGVmaW5lIHJlZ2lvbnNcbiAgICAgIHZhciBtYWluID0gJCQuc3ZnLmFwcGVuZChcImdcIikuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJtYWluXCIpKTtcblxuICAgICAgLy8gZGF0YS5vbm1pbi9tYXggY2FsbGJhY2tcbiAgICAgIGlmICgkJC5tYWluID0gbWFpbiwgY29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgJCQuaW5pdFN1YmNoYXJ0KCksICQkLmluaXRUb29sdGlwICYmICQkLmluaXRUb29sdGlwKCksICQkLmluaXRMZWdlbmQgJiYgJCQuaW5pdExlZ2VuZCgpLCAkJC5pbml0VGl0bGUgJiYgJCQuaW5pdFRpdGxlKCksIGNvbmZpZy5kYXRhX2VtcHR5X2xhYmVsX3RleHQgJiYgbWFpbi5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCBcIlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy50ZXh0LCBcIiBcIikuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmVtcHR5KSkuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpIC8vIGhvcml6b250YWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeCBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMuXG4gICAgICAuYXR0cihcImRvbWluYW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpLCAkJC5pbml0UmVnaW9uKCksIGNvbmZpZy5jbGlwUGF0aCB8fCAkJC5heGlzLmluaXQoKSwgbWFpbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjb25maWdfY2xhc3Nlcy5jaGFydCkuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5jbGlwUGF0aCksICQkLmNhbGxQbHVnaW5Ib29rKFwiJGluaXRcIiksICQkLmluaXRFdmVudFJlY3QoKSwgJCQuaW5pdENoYXJ0RWxlbWVudHMoKSwgJCQuaW5pdEdyaWQoKSwgbWFpbi5pbnNlcnQoXCJyZWN0XCIsIGNvbmZpZy56b29tX3ByaXZpbGVnZWQgPyBudWxsIDogXCJnLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5yZWdpb25zKSkuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLnpvb21SZWN0KS5hdHRyKFwid2lkdGhcIiwgJCQud2lkdGgpLmF0dHIoXCJoZWlnaHRcIiwgJCQuaGVpZ2h0KS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLm9uKFwiZGJsY2xpY2suem9vbVwiLCBudWxsKSwgY29uZmlnLmNsaXBQYXRoICYmICQkLmF4aXMuaW5pdCgpLCAkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyksICQkLnVwZGF0ZURpbWVuc2lvbigpLCBjYWxsRm4oY29uZmlnLm9uaW5pdCwgJCQsICQkLmFwaSksICQkLnNldEJhY2tncm91bmQoKSwgJCQucmVkcmF3KHtcbiAgICAgICAgd2l0aFRyYW5zaXRpb246ICExLFxuICAgICAgICB3aXRoVHJhbnNmb3JtOiAhMCxcbiAgICAgICAgd2l0aFVwZGF0ZVhEb21haW46ICEwLFxuICAgICAgICB3aXRoVXBkYXRlT3JnWERvbWFpbjogITAsXG4gICAgICAgIHdpdGhUcmFuc2l0aW9uRm9yQXhpczogITEsXG4gICAgICAgIGluaXRpYWxpemluZzogITBcbiAgICAgIH0pLCBjb25maWcuZGF0YV9vbm1pbiB8fCBjb25maWcuZGF0YV9vbm1heCkge1xuICAgICAgICB2YXIgbWluTWF4ID0gJCQuZ2V0TWluTWF4RGF0YSgpO1xuICAgICAgICBjYWxsRm4oY29uZmlnLmRhdGFfb25taW4sICQkLCBtaW5NYXgubWluKSwgY2FsbEZuKGNvbmZpZy5kYXRhX29ubWF4LCAkJCwgbWluTWF4Lm1heCk7XG4gICAgICB9IC8vIGV4cG9ydCBlbGVtZW50IG9mIHRoZSBjaGFydFxuXG5cbiAgICAgICQkLmFwaS5lbGVtZW50ID0gJCQuc2VsZWN0Q2hhcnQubm9kZSgpLCAkJC5yZW5kZXJlZCA9ICEwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0Q2hhcnRFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0Q2hhcnRFbGVtZW50cygpIHtcbiAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICBbXCJCYXJcIiwgXCJSYWRhclwiLCBcIkxpbmVcIiwgXCJCdWJibGVcIiwgXCJBcmNcIiwgXCJHYXVnZVwiLCBcIlBpZVwiXS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICQkW1wiaW5pdFwiLmNvbmNhdCh2KV0oKTtcbiAgICAgIH0pLCBub3RFbXB0eSgkJC5jb25maWcuZGF0YV9sYWJlbHMpICYmICQkLmluaXRUZXh0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldENoYXJ0RWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2hhcnRFbGVtZW50cygpIHtcbiAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAkJC5hcGkuJCA9IHtcbiAgICAgICAgY2hhcnQ6ICQkLnNlbGVjdENoYXJ0LFxuICAgICAgICBzdmc6ICQkLnN2ZyxcbiAgICAgICAgZGVmczogJCQuZGVmcyxcbiAgICAgICAgbWFpbjogJCQubWFpbixcbiAgICAgICAgdG9vbHRpcDogJCQudG9vbHRpcCxcbiAgICAgICAgbGVnZW5kOiAkJC5sZWdlbmQsXG4gICAgICAgIHRpdGxlOiAkJC50aXRsZSxcbiAgICAgICAgZ3JpZDogJCQuZ3JpZCxcbiAgICAgICAgYXJjOiAkJC5hcmNzLFxuICAgICAgICBiYXI6IHtcbiAgICAgICAgICBiYXJzOiAkJC5tYWluQmFyXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBsaW5lczogJCQubWFpbkxpbmUsXG4gICAgICAgICAgYXJlYXM6ICQkLm1haW5BcmVhLFxuICAgICAgICAgIGNpcmNsZXM6ICQkLm1haW5DaXJjbGVcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIHRleHRzOiAkJC5tYWluVGV4dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYmFja2dyb3VuZCBlbGVtZW50L2ltYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEJhY2tncm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QmFja2dyb3VuZCgpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgYmcgPSAkJC5jb25maWcuYmFja2dyb3VuZDtcblxuICAgICAgaWYgKG5vdEVtcHR5KGJnKSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICQkLnN2Zy5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzWyQkLmhhc0FyY1R5cGUoKSA/IFwiY2hhcnRcIiA6IFwicmVnaW9uc1wiXSkpLmluc2VydChiZy5pbWdVcmwgPyBcImltYWdlXCIgOiBcInJlY3RcIiwgXCI6Zmlyc3QtY2hpbGRcIik7XG4gICAgICAgIGJnLmltZ1VybCA/IGVsZW1lbnQuYXR0cihcImhyZWZcIiwgYmcuaW1nVXJsKSA6IGJnLmNvbG9yICYmIGVsZW1lbnQuc3R5bGUoXCJmaWxsXCIsIGJnLmNvbG9yKSwgZWxlbWVudC5hdHRyKFwiY2xhc3NcIiwgYmdbXCJjbGFzc1wiXSB8fCBudWxsKS5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzbW9vdGhMaW5lc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbW9vdGhMaW5lcyhlbCwgdHlwZSkge1xuICAgICAgdHlwZSA9PT0gXCJncmlkXCIgJiYgZWwuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMpO1xuICAgICAgICBbXCJ4MVwiLCBcIngyXCIsIFwieTFcIiwgXCJ5MlwiXS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIGcuYXR0cih2LCBNYXRoLmNlaWwoZy5hdHRyKHYpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzaXplIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbml0IElmIGlzIGNhbGxlZCBhdCBpbml0aWFsaXphdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTaXplc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTaXplcyhpc0luaXQpIHtcbiAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICBpc0luaXQgfHwgJCQuc2V0Q29udGFpbmVyU2l6ZSgpO1xuICAgICAgdmFyIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkLFxuICAgICAgICAgIGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKSxcbiAgICAgICAgICBsZWdlbmQgPSB7XG4gICAgICAgIHdpZHRoOiAkJC5sZWdlbmQgPyAkJC5nZXRMZWdlbmRXaWR0aCgpIDogMCxcbiAgICAgICAgaGVpZ2h0OiAkJC5sZWdlbmQgPyAkJC5nZXRMZWdlbmRIZWlnaHQoKSA6IDBcbiAgICAgIH0sXG4gICAgICAgICAgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tID0gJCQuaXNMZWdlbmRSaWdodCB8fCAkJC5pc0xlZ2VuZEluc2V0ID8gMCA6IGxlZ2VuZC5oZWlnaHQsXG4gICAgICAgICAgeEF4aXNIZWlnaHQgPSBpc1JvdGF0ZWQgfHwgaGFzQXJjID8gMCA6ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieFwiKSxcbiAgICAgICAgICBzdWJjaGFydFhBeGlzSGVpZ2h0ID0gY29uZmlnLnN1YmNoYXJ0X2F4aXNfeF9zaG93ICYmIGNvbmZpZy5zdWJjaGFydF9heGlzX3hfdGlja190ZXh0X3Nob3cgPyB4QXhpc0hlaWdodCA6IDMwLFxuICAgICAgICAgIHN1YmNoYXJ0SGVpZ2h0ID0gY29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgIWhhc0FyYyA/IGNvbmZpZy5zdWJjaGFydF9zaXplX2hlaWdodCArIHN1YmNoYXJ0WEF4aXNIZWlnaHQgOiAwO1xuICAgICAgJCQubWFyZ2luID0gaXNSb3RhdGVkID8ge1xuICAgICAgICB0b3A6ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieTJcIikgKyAkJC5nZXRDdXJyZW50UGFkZGluZ1RvcCgpLFxuICAgICAgICByaWdodDogaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSxcbiAgICAgICAgYm90dG9tOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInlcIikgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20gKyAkJC5nZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpLFxuICAgICAgICBsZWZ0OiBzdWJjaGFydEhlaWdodCArIChoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCkpXG4gICAgICB9IDoge1xuICAgICAgICB0b3A6IDQgKyAkJC5nZXRDdXJyZW50UGFkZGluZ1RvcCgpLFxuICAgICAgICAvLyBmb3IgdG9wIHRpY2sgdGV4dFxuICAgICAgICByaWdodDogaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSxcbiAgICAgICAgYm90dG9tOiB4QXhpc0hlaWdodCArIHN1YmNoYXJ0SGVpZ2h0ICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdCb3R0b20oKSxcbiAgICAgICAgbGVmdDogaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCgpXG4gICAgICB9LCAkJC5tYXJnaW4yID0gaXNSb3RhdGVkID8ge1xuICAgICAgICB0b3A6ICQkLm1hcmdpbi50b3AsXG4gICAgICAgIHJpZ2h0OiBOYU4sXG4gICAgICAgIGJvdHRvbTogMjAgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20sXG4gICAgICAgIGxlZnQ6ICQkLnJvdGF0ZWRfcGFkZGluZ19sZWZ0XG4gICAgICB9IDoge1xuICAgICAgICB0b3A6ICQkLmN1cnJlbnRIZWlnaHQgLSBzdWJjaGFydEhlaWdodCAtIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcbiAgICAgICAgcmlnaHQ6IE5hTixcbiAgICAgICAgYm90dG9tOiBzdWJjaGFydFhBeGlzSGVpZ2h0ICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tLFxuICAgICAgICBsZWZ0OiAkJC5tYXJnaW4ubGVmdFxuICAgICAgfSwgJCQubWFyZ2luMyA9IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogTmFOLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH0sICQkLnVwZGF0ZVNpemVGb3JMZWdlbmQgJiYgJCQudXBkYXRlU2l6ZUZvckxlZ2VuZChsZWdlbmQpLCAkJC53aWR0aCA9ICQkLmN1cnJlbnRXaWR0aCAtICQkLm1hcmdpbi5sZWZ0IC0gJCQubWFyZ2luLnJpZ2h0LCAkJC5oZWlnaHQgPSAkJC5jdXJyZW50SGVpZ2h0IC0gJCQubWFyZ2luLnRvcCAtICQkLm1hcmdpbi5ib3R0b20sICQkLndpZHRoIDwgMCAmJiAoJCQud2lkdGggPSAwKSwgJCQuaGVpZ2h0IDwgMCAmJiAoJCQuaGVpZ2h0ID0gMCksICQkLndpZHRoMiA9IGlzUm90YXRlZCA/ICQkLm1hcmdpbi5sZWZ0IC0gJCQucm90YXRlZF9wYWRkaW5nX2xlZnQgLSAkJC5yb3RhdGVkX3BhZGRpbmdfcmlnaHQgOiAkJC53aWR0aCwgJCQuaGVpZ2h0MiA9IGlzUm90YXRlZCA/ICQkLmhlaWdodCA6ICQkLmN1cnJlbnRIZWlnaHQgLSAkJC5tYXJnaW4yLnRvcCAtICQkLm1hcmdpbjIuYm90dG9tLCAkJC53aWR0aDIgPCAwICYmICgkJC53aWR0aDIgPSAwKSwgJCQuaGVpZ2h0MiA8IDAgJiYgKCQkLmhlaWdodDIgPSAwKSwgJCQuYXJjV2lkdGggPSAkJC53aWR0aCAtICgkJC5pc0xlZ2VuZFJpZ2h0ID8gbGVnZW5kLndpZHRoICsgMTAgOiAwKSwgJCQuYXJjSGVpZ2h0ID0gJCQuaGVpZ2h0IC0gKCQkLmlzTGVnZW5kUmlnaHQgPyAwIDogMTApLCAkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlICYmICgkJC5hcmNIZWlnaHQgKz0gJCQuaGVpZ2h0IC0gJCQuZ2V0R2F1Z2VMYWJlbEhlaWdodCgpKSwgJCQudXBkYXRlUmFkaXVzICYmICQkLnVwZGF0ZVJhZGl1cygpLCAkJC5pc0xlZ2VuZFJpZ2h0ICYmIGhhc0FyYyAmJiAoJCQubWFyZ2luMy5sZWZ0ID0gJCQuYXJjV2lkdGggLyAyICsgJCQucmFkaXVzRXhwYW5kZWQgKiAxLjEpLCAhaGFzQXJjICYmIGNvbmZpZy5heGlzX3hfc2hvdyAmJiBjb25maWcuYXhpc194X3RpY2tfYXV0b3JvdGF0ZSAmJiAkJC51cGRhdGVYQXhpc1RpY2tDbGlwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0YXJnZXRlZCBlbGVtZW50IHdpdGggZ2l2ZW4gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzIERhdGEgb2JqZWN0IGZvcm1hdHRlZCBhcyAndGFyZ2V0J1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVUYXJnZXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVRhcmdldHModGFyZ2V0cykge1xuICAgICAgdmFyICQkID0gdGhpczsgLy8gVGV4dFxuXG4gICAgICAkJC51cGRhdGVUYXJnZXRzRm9yVGV4dCh0YXJnZXRzKSwgJCQudXBkYXRlVGFyZ2V0c0ZvckJhcih0YXJnZXRzKSwgJCQudXBkYXRlVGFyZ2V0c0ZvckxpbmUodGFyZ2V0cyksICQkLmhhc0FyY1R5cGUodGFyZ2V0cykgJiYgKCQkLmhhc1R5cGUoXCJyYWRhclwiKSA/ICQkLnVwZGF0ZVRhcmdldHNGb3JSYWRhcih0YXJnZXRzKSA6ICQkLnVwZGF0ZVRhcmdldHNGb3JBcmModGFyZ2V0cykpLCAkJC51cGRhdGVUYXJnZXRzRm9yU3ViY2hhcnQgJiYgJCQudXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0KHRhcmdldHMpLCAkJC5zaG93VGFyZ2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHRhcmdldGVkIGVsZW1lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNob3dUYXJnZXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dUYXJnZXRzKCkge1xuICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICQkLnN2Zy5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnRhcmdldCkpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gJCQuaXNUYXJnZXRUb1Nob3coZC5pZCk7XG4gICAgICB9KS50cmFuc2l0aW9uKCkuZHVyYXRpb24oJCQuY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFdpdGhPcHRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2l0aE9wdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgd2l0aE9wdGlvbnMgPSB7XG4gICAgICAgIFk6ICEwLFxuICAgICAgICBTdWJjaGFydDogITAsXG4gICAgICAgIFRyYW5zaXRpb246ICEwLFxuICAgICAgICBFdmVudFJlY3Q6ICEwLFxuICAgICAgICBEaW1lbnNpb246ICEwLFxuICAgICAgICBUcmltWERvbWFpbjogITAsXG4gICAgICAgIFRyYW5zZm9ybTogITEsXG4gICAgICAgIFVwZGF0ZVhEb21haW46ICExLFxuICAgICAgICBVcGRhdGVPcmdYRG9tYWluOiAhMSxcbiAgICAgICAgTGVnZW5kOiAhMSxcbiAgICAgICAgVXBkYXRlWEF4aXM6IFwiVXBkYXRlWERvbWFpblwiLFxuICAgICAgICBUcmFuc2l0aW9uRm9yRXhpdDogXCJUcmFuc2l0aW9uXCIsXG4gICAgICAgIFRyYW5zaXRpb25Gb3JBeGlzOiBcIlRyYW5zaXRpb25cIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh3aXRoT3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBkZWZWYWwgPSB3aXRoT3B0aW9uc1trZXldO1xuICAgICAgICBpc1N0cmluZyhkZWZWYWwpICYmIChkZWZWYWwgPSB3aXRoT3B0aW9uc1tkZWZWYWxdKSwgd2l0aE9wdGlvbnNba2V5XSA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhcIi5jb25jYXQoa2V5KSwgZGVmVmFsKTtcbiAgICAgIH0pLCB3aXRoT3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICB0cmFuc2l0aW9uc1ZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICAgIG1haW4gPSAkJC5tYWluLFxuICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLFxuICAgICAgICAgIGluaXRpYWxpemluZyA9IG9wdGlvbnMuaW5pdGlhbGl6aW5nLFxuICAgICAgICAgIGZsb3cgPSBvcHRpb25zLmZsb3csXG4gICAgICAgICAgd3RoID0gJCQuZ2V0V2l0aE9wdGlvbihvcHRpb25zKSxcbiAgICAgICAgICBkdXJhdGlvbiA9IHd0aC5UcmFuc2l0aW9uID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwLFxuICAgICAgICAgIGR1cmF0aW9uRm9yRXhpdCA9IHd0aC5UcmFuc2l0aW9uRm9yRXhpdCA/IGR1cmF0aW9uIDogMCxcbiAgICAgICAgICBkdXJhdGlvbkZvckF4aXMgPSB3dGguVHJhbnNpdGlvbkZvckF4aXMgPyBkdXJhdGlvbiA6IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uc1ZhbHVlIHx8ICQkLmF4aXMuZ2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbkZvckF4aXMpO1xuICAgICAgJCQudXBkYXRlU2l6ZXMoaW5pdGlhbGl6aW5nKSwgd3RoLkxlZ2VuZCAmJiBjb25maWcubGVnZW5kX3Nob3cgPyAkJC51cGRhdGVMZWdlbmQoJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSwgb3B0aW9ucywgdHJhbnNpdGlvbnMpIDogd3RoLkRpbWVuc2lvbiAmJiAkJC51cGRhdGVEaW1lbnNpb24oITApLCAkJC5heGlzLnJlZHJhd0F4aXModGFyZ2V0c1RvU2hvdywgd3RoLCB0cmFuc2l0aW9ucywgZmxvdywgaW5pdGlhbGl6aW5nKSwgJCQudXBkYXRlQ2lyY2xlWSgpLCBjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0ICYmIG1haW4uc2VsZWN0KFwidGV4dC5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMudGV4dCwgXCIuXCIpLmNvbmNhdChjb25maWdfY2xhc3Nlcy5lbXB0eSkpLmF0dHIoXCJ4XCIsICQkLndpZHRoIC8gMikuYXR0cihcInlcIiwgJCQuaGVpZ2h0IC8gMikudGV4dChjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0KS5zdHlsZShcImRpc3BsYXlcIiwgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPyBcIm5vbmVcIiA6IG51bGwpLCAkJC51cGRhdGVHcmlkKGR1cmF0aW9uKSwgJCQudXBkYXRlUmVnaW9uKGR1cmF0aW9uKSwgJCQudXBkYXRlQmFyKGR1cmF0aW9uRm9yRXhpdCksICQkLnVwZGF0ZUxpbmUoZHVyYXRpb25Gb3JFeGl0KSwgJCQudXBkYXRlQXJlYShkdXJhdGlvbkZvckV4aXQpLCAkJC51cGRhdGVDaXJjbGUoKSwgJCQuaGFzRGF0YUxhYmVsKCkgJiYgJCQudXBkYXRlVGV4dChkdXJhdGlvbkZvckV4aXQpLCAkJC5yZWRyYXdUaXRsZSAmJiAkJC5yZWRyYXdUaXRsZSgpLCAkJC5hcmNzICYmICQkLnJlZHJhd0FyYyhkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0LCB3dGguVHJhbnNmb3JtKSwgJCQucmFkYXJzICYmICQkLnJlZHJhd1JhZGFyKGR1cmF0aW9uRm9yRXhpdCksICQkLm1haW5UZXh0ICYmIG1haW4uc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5zZWxlY3RlZENpcmNsZXMpKS5maWx0ZXIoJCQuaXNCYXJUeXBlLmJpbmQoJCQpKS5zZWxlY3RBbGwoXCJjaXJjbGVcIikucmVtb3ZlKCksIGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICFmbG93ICYmIHd0aC5FdmVudFJlY3QgJiYgJCQuYmluZFpvb21FdmVudCgpLCBpbml0aWFsaXppbmcgJiYgJCQuc2V0Q2hhcnRFbGVtZW50cygpLCAkJC5nZW5lcmF0ZVJlZHJhd0xpc3QodGFyZ2V0c1RvU2hvdywgZmxvdywgZHVyYXRpb24sIHd0aC5TdWJjaGFydCksICQkLmNhbGxQbHVnaW5Ib29rKFwiJHJlZHJhd1wiLCBvcHRpb25zLCBkdXJhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHJlZHJhdyBsaXN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHMgdGFyZ2V0cyBkYXRhIHRvIGJlIHNob3duXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZsb3dcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZHVyYXRpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhTdWJjaGFydCB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHN1YmNoYXJ0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlUmVkcmF3TGlzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVJlZHJhd0xpc3QodGFyZ2V0cywgZmxvdywgZHVyYXRpb24sIHdpdGhTdWJjaGFydCkge1xuICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgc2hhcGUgPSAkJC5nZXREcmF3U2hhcGUoKTtcbiAgICAgIGNvbmZpZy5zdWJjaGFydF9zaG93ICYmICQkLnJlZHJhd1N1YmNoYXJ0KHdpdGhTdWJjaGFydCwgZHVyYXRpb24sIHNoYXBlKTtcbiAgICAgIC8vIGdlbmVyYXRlIGZsb3dcbiAgICAgIHZhciBmbG93Rm4gPSBmbG93ICYmICQkLmdlbmVyYXRlRmxvdyh7XG4gICAgICAgIHRhcmdldHM6IHRhcmdldHMsXG4gICAgICAgIGZsb3c6IGZsb3csXG4gICAgICAgIGR1cmF0aW9uOiBmbG93LmR1cmF0aW9uLFxuICAgICAgICBzaGFwZTogc2hhcGUsXG4gICAgICAgIHh2OiAkJC54di5iaW5kKCQkKVxuICAgICAgfSksXG4gICAgICAgICAgaXNUcmFuc2l0aW9uID0gKGR1cmF0aW9uIHx8IGZsb3dGbikgJiYgJCQuaXNUYWJWaXNpYmxlKCksXG4gICAgICAgICAgcmVkcmF3TGlzdCA9ICQkLmdldFJlZHJhd0xpc3Qoc2hhcGUsIGZsb3csIGZsb3dGbiwgaXNUcmFuc2l0aW9uKSxcbiAgICAgICAgICBhZnRlclJlZHJhdyA9IGZsb3cgfHwgY29uZmlnLm9ucmVuZGVyZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZsb3dGbiAmJiBmbG93Rm4oKSwgY2FsbEZuKGNvbmZpZy5vbnJlbmRlcmVkLCAkJCwgJCQuYXBpKTtcbiAgICAgIH0gOiBudWxsO1xuICAgICAgaWYgKGFmdGVyUmVkcmF3KSAvLyBPbmx5IHVzZSB0cmFuc2l0aW9uIHdoZW4gY3VycmVudCB0YWIgaXMgdmlzaWJsZS5cbiAgICAgICAgaWYgKGlzVHJhbnNpdGlvbiAmJiByZWRyYXdMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIFdhaXQgZm9yIGVuZCBvZiB0cmFuc2l0aW9ucyBmb3IgY2FsbGJhY2tcbiAgICAgICAgICB2YXIgd2FpdEZvckRyYXcgPSAkJC5nZW5lcmF0ZVdhaXQoKTsgLy8gdHJhbnNpdGlvbiBzaG91bGQgYmUgZGVyaXZlZCBmcm9tIG9uZSB0cmFuc2l0aW9uXG5cbiAgICAgICAgICBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfdHJhbnNpdGlvbl9jb21tb25qczJfZDNfdHJhbnNpdGlvbl9hbWRfZDNfdHJhbnNpdGlvbl9yb290X2QzX1tcInRyYW5zaXRpb25cIl0pKCkuZHVyYXRpb24oZHVyYXRpb24pLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVkcmF3TGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQodDEpO1xuICAgICAgICAgICAgfSwgW10pLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdhaXRGb3JEcmF3LmFkZCh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLmNhbGwod2FpdEZvckRyYXcsIGFmdGVyUmVkcmF3KTtcbiAgICAgICAgfSBlbHNlICQkLnRyYW5zaXRpbmcgfHwgYWZ0ZXJSZWRyYXcoKTsgLy8gdXBkYXRlIGZhZGVpbiBjb25kaXRpb25cblxuICAgICAgJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAkJC53aXRob3V0RmFkZUluW2lkXSA9ICEwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2hhcGUgZHJhdyBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RHJhd1NoYXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERyYXdTaGFwZSgpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZCxcbiAgICAgICAgICBoYXNSYWRhciA9ICQkLmhhc1R5cGUoXCJyYWRhclwiKSxcbiAgICAgICAgICBzaGFwZSA9IHtcbiAgICAgICAgdHlwZToge30sXG4gICAgICAgIGluZGljZXM6IHt9XG4gICAgICB9O1xuXG4gICAgICAvLyBzZXR1cCBkcmF3ZXIgLSBNRU1POiB0aGVzZSBtdXN0IGJlIGNhbGxlZCBhZnRlciBheGlzIHVwZGF0ZWRcbiAgICAgIGlmICgkJC5oYXNUeXBlT2YoXCJMaW5lXCIpIHx8ICQkLmhhc1R5cGUoXCJidWJibGVcIikgfHwgJCQuaGFzVHlwZShcInNjYXR0ZXJcIikpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSAkJC5nZXRTaGFwZUluZGljZXMoJCQuaXNMaW5lVHlwZSk7XG5cbiAgICAgICAgaWYgKHNoYXBlLmluZGljZXMubGluZSA9IGluZGljZXMsIHNoYXBlLnR5cGUubGluZSA9ICQkLmdlbmVyYXRlRHJhd0xpbmUgPyAkJC5nZW5lcmF0ZURyYXdMaW5lKGluZGljZXMsICExKSA6IHVuZGVmaW5lZCwgJCQuaGFzVHlwZU9mKFwiQXJlYVwiKSkge1xuICAgICAgICAgIHZhciBfaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0FyZWFUeXBlKTtcblxuICAgICAgICAgIHNoYXBlLmluZGljZXMuYXJlYSA9IF9pbmRpY2VzLCBzaGFwZS50eXBlLmFyZWEgPSAkJC5nZW5lcmF0ZURyYXdBcmVhID8gJCQuZ2VuZXJhdGVEcmF3QXJlYShfaW5kaWNlcywgITEpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgkJC5oYXNUeXBlKFwiYmFyXCIpKSB7XG4gICAgICAgIHZhciBfaW5kaWNlczIgPSAkJC5nZXRTaGFwZUluZGljZXMoJCQuaXNCYXJUeXBlKTtcblxuICAgICAgICBzaGFwZS5pbmRpY2VzLmJhciA9IF9pbmRpY2VzMiwgc2hhcGUudHlwZS5iYXIgPSAkJC5nZW5lcmF0ZURyYXdCYXIgPyAkJC5nZW5lcmF0ZURyYXdCYXIoX2luZGljZXMyKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNoYXBlLnBvcyA9IHtcbiAgICAgICAgeEZvclRleHQ6ICQkLmdlbmVyYXRlWFlGb3JUZXh0KHNoYXBlLmluZGljZXMsICEwKSxcbiAgICAgICAgeUZvclRleHQ6ICQkLmdlbmVyYXRlWFlGb3JUZXh0KHNoYXBlLmluZGljZXMsICExKSxcbiAgICAgICAgLy8gZ2VuZXJhdGUgY2lyY2xlIHgveSBmdW5jdGlvbnMgZGVwZW5kaW5nIG9uIHVwZGF0ZWQgcGFyYW1zXG4gICAgICAgIGN4OiAoaGFzUmFkYXIgPyAkJC5yYWRhckNpcmNsZVggOiBpc1JvdGF0ZWQgPyAkJC5jaXJjbGVZIDogJCQuY2lyY2xlWCkuYmluZCgkJCksXG4gICAgICAgIGN5OiAoaGFzUmFkYXIgPyAkJC5yYWRhckNpcmNsZVkgOiBpc1JvdGF0ZWQgPyAkJC5jaXJjbGVYIDogJCQuY2lyY2xlWSkuYmluZCgkJClcbiAgICAgIH0sIHNoYXBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZWRyYXdMaXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlZHJhd0xpc3Qoc2hhcGUsIGZsb3csIGZsb3dGbiwgaXNUcmFuc2l0aW9uKSB7XG4gICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICBoYXNBcmNUeXBlID0gJCQuaGFzQXJjVHlwZSgpLFxuICAgICAgICAgIF9zaGFwZSRwb3MgPSBzaGFwZS5wb3MsXG4gICAgICAgICAgY3ggPSBfc2hhcGUkcG9zLmN4LFxuICAgICAgICAgIGN5ID0gX3NoYXBlJHBvcy5jeSxcbiAgICAgICAgICB4Rm9yVGV4dCA9IF9zaGFwZSRwb3MueEZvclRleHQsXG4gICAgICAgICAgeUZvclRleHQgPSBfc2hhcGUkcG9zLnlGb3JUZXh0LFxuICAgICAgICAgIGxpc3QgPSBbXTtcblxuICAgICAgaWYgKCFoYXNBcmNUeXBlKSB7XG4gICAgICAgIHZhciBfc2hhcGUkdHlwZSA9IHNoYXBlLnR5cGUsXG4gICAgICAgICAgICBhcmVhID0gX3NoYXBlJHR5cGUuYXJlYSxcbiAgICAgICAgICAgIGJhciA9IF9zaGFwZSR0eXBlLmJhcixcbiAgICAgICAgICAgIGxpbmUgPSBfc2hhcGUkdHlwZS5saW5lO1xuICAgICAgICAoY29uZmlnLmdyaWRfeF9saW5lcy5sZW5ndGggfHwgY29uZmlnLmdyaWRfeV9saW5lcy5sZW5ndGgpICYmIGxpc3QucHVzaCgkJC5yZWRyYXdHcmlkKGlzVHJhbnNpdGlvbikpLCBjb25maWcucmVnaW9ucy5sZW5ndGggJiYgbGlzdC5wdXNoKCQkLnJlZHJhd1JlZ2lvbihpc1RyYW5zaXRpb24pKSwgJCQuaGFzVHlwZU9mKFwiTGluZVwiKSAmJiAobGlzdC5wdXNoKCQkLnJlZHJhd0xpbmUobGluZSwgaXNUcmFuc2l0aW9uKSksICQkLmhhc1R5cGVPZihcIkFyZWFcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0FyZWEoYXJlYSwgaXNUcmFuc2l0aW9uKSkpLCAkJC5oYXNUeXBlKFwiYmFyXCIpICYmIGxpc3QucHVzaCgkJC5yZWRyYXdCYXIoYmFyLCBpc1RyYW5zaXRpb24pKSwgZmxvdyB8fCBsaXN0LnB1c2goJCQudXBkYXRlR3JpZEZvY3VzKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKCFoYXNBcmNUeXBlIHx8ICQkLmhhc1R5cGUoXCJyYWRhclwiKSkgJiYgKG5vdEVtcHR5KGNvbmZpZy5kYXRhX2xhYmVscykgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd1RleHQoeEZvclRleHQsIHlGb3JUZXh0LCBmbG93LCBpc1RyYW5zaXRpb24pKSwgbGlzdC5wdXNoKCQkLnJlZHJhd0NpcmNsZShjeCwgY3ksIGlzVHJhbnNpdGlvbiwgZmxvd0ZuKSkpLCBsaXN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVBbmRSZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQW5kUmVkcmF3KCkge1xuICAgICAgdmFyIHRyYW5zaXRpb25zLFxuICAgICAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgICQkID0gdGhpcyxcbiAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICBvcHRpb25zLndpdGhUcmFuc2l0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zaXRpb25cIiwgITApLCBvcHRpb25zLndpdGhUcmFuc2Zvcm0gPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoVHJhbnNmb3JtXCIsICExKSwgb3B0aW9ucy53aXRoTGVnZW5kID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aExlZ2VuZFwiLCAhMSksIG9wdGlvbnMud2l0aFVwZGF0ZVhEb21haW4gPSAhMCwgb3B0aW9ucy53aXRoVXBkYXRlT3JnWERvbWFpbiA9ICEwLCBvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yRXhpdCA9ICExLCBvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm1cIiwgb3B0aW9ucy53aXRoVHJhbnNpdGlvbiksIG9wdGlvbnMud2l0aExlZ2VuZCAmJiBjb25maWcubGVnZW5kX3Nob3cgfHwgKHRyYW5zaXRpb25zID0gJCQuYXhpcy5nZW5lcmF0ZVRyYW5zaXRpb25zKG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JBeGlzID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwKSwgJCQudXBkYXRlU2NhbGVzKCksICQkLnVwZGF0ZVN2Z1NpemUoKSwgJCQudHJhbnNmb3JtQWxsKG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0sIHRyYW5zaXRpb25zKSksICQkLnJlZHJhdyhvcHRpb25zLCB0cmFuc2l0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZHJhd1dpdGhvdXRSZXNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHJhd1dpdGhvdXRSZXNjYWxlKCkge1xuICAgICAgdGhpcy5yZWRyYXcoe1xuICAgICAgICB3aXRoWTogITEsXG4gICAgICAgIHdpdGhTdWJjaGFydDogITEsXG4gICAgICAgIHdpdGhFdmVudFJlY3Q6ICExLFxuICAgICAgICB3aXRoVHJhbnNpdGlvbkZvckF4aXM6ICExXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNUaW1lU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVGltZVNlcmllcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5heGlzX3hfdHlwZSA9PT0gXCJ0aW1lc2VyaWVzXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQ2F0ZWdvcml6ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNDYXRlZ29yaXplZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5heGlzX3hfdHlwZS5pbmRleE9mKFwiY2F0ZWdvcnlcIikgPj0gMCB8fCB0aGlzLmhhc1R5cGUoXCJyYWRhclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDdXN0b21YXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ3VzdG9tWCgpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgcmV0dXJuICEkJC5pc1RpbWVTZXJpZXMoKSAmJiAoY29uZmlnLmRhdGFfeCB8fCBub3RFbXB0eShjb25maWcuZGF0YV94cykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1RpbWVTZXJpZXNZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVGltZVNlcmllc1koKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcuYXhpc195X3R5cGUgPT09IFwidGltZXNlcmllc1wiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFuc2xhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhbnNsYXRlKHRhcmdldCkge1xuICAgICAgdmFyIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMCxcbiAgICAgICAgICAkJCA9IHRoaXMsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgIGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQsXG4gICAgICAgICAgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIiksXG4gICAgICAgICAgcGFkZGluZyA9IDA7XG4gICAgICBpZiAoaW5kZXggJiYgL14oeHx5Mj8pJC8udGVzdCh0YXJnZXQpICYmIChwYWRkaW5nID0gJCQuZ2V0QXhpc1NpemUodGFyZ2V0KSAqIGluZGV4KSwgdGFyZ2V0ID09PSBcIm1haW5cIikgeCA9IGFzSGFsZlBpeGVsKCQkLm1hcmdpbi5sZWZ0KSwgeSA9IGFzSGFsZlBpeGVsKCQkLm1hcmdpbi50b3ApO2Vsc2UgaWYgKHRhcmdldCA9PT0gXCJjb250ZXh0XCIpIHggPSBhc0hhbGZQaXhlbCgkJC5tYXJnaW4yLmxlZnQpLCB5ID0gYXNIYWxmUGl4ZWwoJCQubWFyZ2luMi50b3ApO2Vsc2UgaWYgKHRhcmdldCA9PT0gXCJsZWdlbmRcIikgeCA9ICQkLm1hcmdpbjMubGVmdCwgeSA9ICQkLm1hcmdpbjMudG9wICsgKGhhc0dhdWdlID8gMTAgOiAwKTtlbHNlIGlmICh0YXJnZXQgPT09IFwieFwiKSB4ID0gaXNSb3RhdGVkID8gLXBhZGRpbmcgOiAwLCB5ID0gaXNSb3RhdGVkID8gMCA6ICQkLmhlaWdodCArIHBhZGRpbmc7ZWxzZSBpZiAodGFyZ2V0ID09PSBcInlcIikgeCA9IGlzUm90YXRlZCA/IDAgOiAtcGFkZGluZywgeSA9IGlzUm90YXRlZCA/ICQkLmhlaWdodCArIHBhZGRpbmcgOiAwO2Vsc2UgaWYgKHRhcmdldCA9PT0gXCJ5MlwiKSB4ID0gaXNSb3RhdGVkID8gMCA6ICQkLndpZHRoICsgcGFkZGluZywgeSA9IGlzUm90YXRlZCA/IDEgLSBwYWRkaW5nIDogMDtlbHNlIGlmICh0YXJnZXQgPT09IFwic3VieFwiKSB4ID0gMCwgeSA9IGlzUm90YXRlZCA/IDAgOiAkJC5oZWlnaHQyO2Vsc2UgaWYgKHRhcmdldCA9PT0gXCJhcmNcIikgeCA9ICQkLmFyY1dpZHRoIC8gMiwgeSA9ICQkLmFyY0hlaWdodCAvIDI7ZWxzZSBpZiAodGFyZ2V0ID09PSBcInJhZGFyXCIpIHtcbiAgICAgICAgdmFyIF8kJCRnZXRSYWRhclNpemUgPSAkJC5nZXRSYWRhclNpemUoKSxcbiAgICAgICAgICAgIF8kJCRnZXRSYWRhclNpemUyID0gX3NsaWNlZFRvQXJyYXkoXyQkJGdldFJhZGFyU2l6ZSwgMSksXG4gICAgICAgICAgICB3aWR0aCA9IF8kJCRnZXRSYWRhclNpemUyWzBdO1xuXG4gICAgICAgIHggPSAkJC53aWR0aCAvIDIgLSB3aWR0aCwgeSA9IGFzSGFsZlBpeGVsKCQkLm1hcmdpbi50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiLmNvbmNhdCh4LCBcIiwgXCIpLmNvbmNhdCh5LCBcIilcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxPcGFjaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxPcGFjaXR5KGQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCAmJiB0aGlzLndpdGhvdXRGYWRlSW5bZC5pZF0gPyBcIjFcIiA6IFwiMFwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsT3BhY2l0eUZvckNpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsT3BhY2l0eUZvckNpcmNsZShkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwgJiYgdGhpcy53aXRob3V0RmFkZUluW2QuaWRdID8gdGhpcy5vcGFjaXR5Rm9yQ2lyY2xlKGQpIDogXCIwXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wYWNpdHlGb3JDaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BhY2l0eUZvckNpcmNsZShkKSB7XG4gICAgICB2YXIgb3BhY2l0eSA9IHRoaXMuY29uZmlnLnBvaW50X3Nob3cgPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgcmV0dXJuIGlzVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoZCkpID8gdGhpcy5pc0J1YmJsZVR5cGUoZCkgfHwgdGhpcy5pc1NjYXR0ZXJUeXBlKGQpID8gXCIwLjVcIiA6IG9wYWNpdHkgOiBcIjBcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3BhY2l0eUZvclRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BhY2l0eUZvclRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNEYXRhTGFiZWwoKSA/IFwiMVwiIDogXCIwXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgem9vbSBvciB1bnpvb21lZCBzY2FsZWQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfE9iamVjdH0gZCBEYXRhIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInh4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHh4KGQpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgZm4gPSAkJC5jb25maWcuem9vbV9lbmFibGVkICYmICQkLnpvb21TY2FsZSA/ICQkLnpvb21TY2FsZSA6IHRoaXMueDtcbiAgICAgIHJldHVybiBkID8gZm4oaXNWYWx1ZShkLngpID8gZC54IDogZCkgOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4dlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB4dihkKSB7XG4gICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgIHZhbHVlID0gJCQuZ2V0QmFzZVZhbHVlKGQpO1xuICAgICAgcmV0dXJuICQkLmlzVGltZVNlcmllcygpID8gdmFsdWUgPSAkJC5wYXJzZURhdGUodmFsdWUpIDogJCQuaXNDYXRlZ29yaXplZCgpICYmIGlzU3RyaW5nKHZhbHVlKSAmJiAodmFsdWUgPSAkJC5jb25maWcuYXhpc194X2NhdGVnb3JpZXMuaW5kZXhPZih2YWx1ZSkpLCBNYXRoLmNlaWwoJCQueCh2YWx1ZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5dlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB5dihkKSB7XG4gICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgIHlTY2FsZSA9IGQuYXhpcyAmJiBkLmF4aXMgPT09IFwieTJcIiA/ICQkLnkyIDogJCQueTtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoeVNjYWxlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJ4eFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ4eChkKSB7XG4gICAgICByZXR1cm4gZCA/IHRoaXMuc3ViWChkLngpIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtTWFpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1NYWluKHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucykge1xuICAgICAgdmFyIHhBeGlzLFxuICAgICAgICAgIHlBeGlzLFxuICAgICAgICAgIHkyQXhpcyxcbiAgICAgICAgICAkJCA9IHRoaXM7XG4gICAgICB0cmFuc2l0aW9ucyAmJiB0cmFuc2l0aW9ucy5heGlzWCA/IHhBeGlzID0gdHJhbnNpdGlvbnMuYXhpc1ggOiAoeEF4aXMgPSAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYXhpc1gpKSwgd2l0aFRyYW5zaXRpb24gJiYgKHhBeGlzID0geEF4aXMudHJhbnNpdGlvbigpKSksIHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNZID8geUF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWSA6ICh5QXhpcyA9ICQkLm1haW4uc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5heGlzWSkpLCB3aXRoVHJhbnNpdGlvbiAmJiAoeUF4aXMgPSB5QXhpcy50cmFuc2l0aW9uKCkpKSwgdHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1kyID8geTJBeGlzID0gdHJhbnNpdGlvbnMuYXhpc1kyIDogKHkyQXhpcyA9ICQkLm1haW4uc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5heGlzWTIpKSwgd2l0aFRyYW5zaXRpb24gJiYgKHkyQXhpcyA9IHkyQXhpcy50cmFuc2l0aW9uKCkpKSwgKHdpdGhUcmFuc2l0aW9uID8gJCQubWFpbi50cmFuc2l0aW9uKCkgOiAkJC5tYWluKS5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcIm1haW5cIikpLCB4QXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInhcIikpLCB5QXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInlcIikpLCB5MkF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJ5MlwiKSksICQkLm1haW4uc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaGFydEFyY3MpKS5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImFyY1wiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybUFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1BbGwod2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKSB7XG4gICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgJCQudHJhbnNmb3JtTWFpbih3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpLCAkJC5jb25maWcuc3ViY2hhcnRfc2hvdyAmJiAkJC50cmFuc2Zvcm1Db250ZXh0KHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucyksICQkLmxlZ2VuZCAmJiAkJC50cmFuc2Zvcm1MZWdlbmQod2l0aFRyYW5zaXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTdmdTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN2Z1NpemUoKSB7XG4gICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgIGJydXNoID0gJCQuc3ZnLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYnJ1c2gsIFwiIC5vdmVybGF5XCIpKSxcbiAgICAgICAgICBicnVzaFNpemUgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICBicnVzaC5zaXplKCkgJiYgKGJydXNoU2l6ZS53aWR0aCA9ICticnVzaC5hdHRyKFwid2lkdGhcIiksIGJydXNoU2l6ZS5oZWlnaHQgPSArYnJ1c2guYXR0cihcImhlaWdodFwiKSksICQkLnN2Zy5hdHRyKFwid2lkdGhcIiwgJCQuY3VycmVudFdpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsICQkLmN1cnJlbnRIZWlnaHQpLCAkJC5zdmcuc2VsZWN0QWxsKFtcIiNcIi5jb25jYXQoJCQuY2xpcElkKSwgXCIjXCIuY29uY2F0KCQkLmNsaXBJZEZvckdyaWQpXSkuc2VsZWN0KFwicmVjdFwiKS5hdHRyKFwid2lkdGhcIiwgJCQud2lkdGgpLmF0dHIoXCJoZWlnaHRcIiwgJCQuaGVpZ2h0KSwgJCQuc3ZnLnNlbGVjdChcIiNcIi5jb25jYXQoJCQuY2xpcElkRm9yWEF4aXMpKS5zZWxlY3QoXCJyZWN0XCIpLmF0dHIoXCJ4XCIsICQkLmdldFhBeGlzQ2xpcFguYmluZCgkJCkpLmF0dHIoXCJ5XCIsICQkLmdldFhBeGlzQ2xpcFkuYmluZCgkJCkpLmF0dHIoXCJ3aWR0aFwiLCAkJC5nZXRYQXhpc0NsaXBXaWR0aC5iaW5kKCQkKSkuYXR0cihcImhlaWdodFwiLCAkJC5nZXRYQXhpc0NsaXBIZWlnaHQuYmluZCgkJCkpLCAkJC5zdmcuc2VsZWN0KFwiI1wiLmNvbmNhdCgkJC5jbGlwSWRGb3JZQXhpcykpLnNlbGVjdChcInJlY3RcIikuYXR0cihcInhcIiwgJCQuZ2V0WUF4aXNDbGlwWC5iaW5kKCQkKSkuYXR0cihcInlcIiwgJCQuZ2V0WUF4aXNDbGlwWS5iaW5kKCQkKSkuYXR0cihcIndpZHRoXCIsICQkLmdldFlBeGlzQ2xpcFdpZHRoLmJpbmQoJCQpKS5hdHRyKFwiaGVpZ2h0XCIsICQkLmdldFlBeGlzQ2xpcEhlaWdodC5iaW5kKCQkKSksICQkLnN2Zy5zZWxlY3QoXCIjXCIuY29uY2F0KCQkLmNsaXBJZEZvclN1YmNoYXJ0KSkuc2VsZWN0KFwicmVjdFwiKS5hdHRyKFwid2lkdGhcIiwgJCQud2lkdGgpLmF0dHIoXCJoZWlnaHRcIiwgYnJ1c2hTaXplLmhlaWdodCksICQkLnN2Zy5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnpvb21SZWN0KSkuYXR0cihcIndpZHRoXCIsICQkLndpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsICQkLmhlaWdodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZURpbWVuc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaW1lbnNpb24od2l0aG91dEF4aXMpIHtcbiAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICB3aXRob3V0QXhpcyB8fCAoJCQueEF4aXMgJiYgJCQuY29uZmlnLmF4aXNfcm90YXRlZCA/ICgkJC54QXhpcy5jcmVhdGUoJCQuYXhlcy54KSwgJCQuc3ViWEF4aXMuY3JlYXRlKCQkLmF4ZXMuc3VieCkpIDogKCQkLnlBeGlzICYmICQkLnlBeGlzLmNyZWF0ZSgkJC5heGVzLnkpLCAkJC55MkF4aXMgJiYgJCQueTJBeGlzLmNyZWF0ZSgkJC5heGVzLnkyKSkpLCAkJC51cGRhdGVTY2FsZXMod2l0aG91dEF4aXMpLCAkJC51cGRhdGVTdmdTaXplKCksICQkLnRyYW5zZm9ybUFsbCghMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmRSZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZFJlc2l6ZSgpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgIHJlc2l6ZUZ1bmN0aW9uID0gJCQuZ2VuZXJhdGVSZXNpemUoKSxcbiAgICAgICAgICBsaXN0ID0gW107XG4gICAgICBsaXN0LnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbEZuKGNvbmZpZy5vbnJlc2l6ZSwgJCQsICQkLmFwaSk7XG4gICAgICB9KSwgY29uZmlnLnJlc2l6ZV9hdXRvICYmIGxpc3QucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAkJC5hcGkuZmx1c2goITEsICEwKTtcbiAgICAgIH0pLCBsaXN0LnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbEZuKGNvbmZpZy5vbnJlc2l6ZWQsICQkLCAkJC5hcGkpO1xuICAgICAgfSksIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gcmVzaXplRnVuY3Rpb24uYWRkKHYpO1xuICAgICAgfSksIHdpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsICQkLnJlc2l6ZUZ1bmN0aW9uID0gcmVzaXplRnVuY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZVJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVJlc2l6ZSgpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxSZXNpemVGbigpIHtcbiAgICAgICAgY2FsbFJlc2l6ZUZuLnRpbWVvdXQgJiYgKHdpbi5jbGVhclRpbWVvdXQoY2FsbFJlc2l6ZUZuLnRpbWVvdXQpLCBjYWxsUmVzaXplRm4udGltZW91dCA9IG51bGwpLCBjYWxsUmVzaXplRm4udGltZW91dCA9IHdpbi5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmbi5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZm4gPSBbXTtcbiAgICAgIHJldHVybiBjYWxsUmVzaXplRm4uYWRkID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZuLnB1c2goZik7XG4gICAgICB9LCBjYWxsUmVzaXplRm4ucmVtb3ZlID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZuLnNwbGljZShmbi5pbmRleE9mKGYpLCAxKTtcbiAgICAgIH0sIGNhbGxSZXNpemVGbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kYWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZGFsbCh0cmFuc2l0aW9uLCBjYWxsYmFjaykge1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgdHJhbnNpdGlvbi5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICsrbjtcbiAgICAgIH0pLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cbiAgICAgICAgLS1uIHx8IGNhbGxiYWNrLmFwcGx5LmFwcGx5KGNhbGxiYWNrLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZVdhaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVXYWl0KCkge1xuICAgICAgdmFyIHRyYW5zaXRpb25zVG9XYWl0ID0gW10sXG4gICAgICAgICAgZiA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgIGZvciAodmFyIHQsIGRvbmUgPSAwLCBpID0gMDsgdCA9IHRyYW5zaXRpb25zVG9XYWl0W2ldOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0ID09PSAhMCB8fCB0LmVtcHR5ICYmIHQuZW1wdHkoKSkge1xuICAgICAgICAgICAgICBkb25lKys7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0LnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgZG9uZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lciksIGRvbmUgPT09IHRyYW5zaXRpb25zVG9XYWl0Lmxlbmd0aCA/IGNhbGxiYWNrICYmIGNhbGxiYWNrKCkgOiB0aW1lciA9IHNldFRpbWVvdXQobG9vcCwgNTApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRpbWVyO1xuICAgICAgICBsb29wKCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZi5hZGQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICAgICAgICBpc0FycmF5KHRyYW5zaXRpb24pID8gdHJhbnNpdGlvbnNUb1dhaXQgPSB0cmFuc2l0aW9uc1RvV2FpdC5jb25jYXQodHJhbnNpdGlvbikgOiB0cmFuc2l0aW9uc1RvV2FpdC5wdXNoKHRyYW5zaXRpb24pO1xuICAgICAgfSwgZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VEYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlKSB7XG4gICAgICB2YXIgcGFyc2VkRGF0ZSxcbiAgICAgICAgICAkJCA9IHRoaXM7XG4gICAgICByZXR1cm4gZGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBwYXJzZWREYXRlID0gZGF0ZSA6IGlzU3RyaW5nKGRhdGUpID8gcGFyc2VkRGF0ZSA9ICQkLmRhdGFUaW1lRm9ybWF0KCQkLmNvbmZpZy5kYXRhX3hGb3JtYXQpKGRhdGUpIDogaXNOdW1iZXIoZGF0ZSkgJiYgIWlzTmFOKGRhdGUpICYmIChwYXJzZWREYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgKCFwYXJzZWREYXRlIHx8IGlzTmFOKCtwYXJzZWREYXRlKSkgJiYgY29uc29sZSAmJiBjb25zb2xlLmVycm9yICYmIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgeCAnXCIuY29uY2F0KGRhdGUsIFwiJyB0byBEYXRlIG9iamVjdFwiKSksIHBhcnNlZERhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVGFiVmlzaWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1RhYlZpc2libGUoKSB7XG4gICAgICByZXR1cm4gIWJyb3dzZXJfZG9jLmhpZGRlbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udmVydElucHV0VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0SW5wdXRUeXBlKCkge1xuICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgaXNNb2JpbGUgPSAhMTtcblxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9Ccm93c2VyX2RldGVjdGlvbl91c2luZ190aGVfdXNlcl9hZ2VudCNNb2JpbGVfVGFibGV0X29yX0Rlc2t0b3BcbiAgICAgIGlmICgvTW9iaS8udGVzdCh3aW4ubmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgY29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaCkge1xuICAgICAgICAvLyBTb21lIEVkZ2UgZGVza3RvcCByZXR1cm4gdHJ1ZTogaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMjA0MTcwNzQvXG4gICAgICAgIHZhciBoYXNUb3VjaFBvaW50cyA9IHdpbi5uYXZpZ2F0b3IgJiYgXCJtYXhUb3VjaFBvaW50c1wiIGluIHdpbi5uYXZpZ2F0b3IgJiYgd2luLm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAsXG4gICAgICAgICAgICBoYXNUb3VjaCA9IFwib250b3VjaG1vdmVcIiBpbiB3aW4gfHwgd2luLkRvY3VtZW50VG91Y2ggJiYgYnJvd3Nlcl9kb2MgaW5zdGFuY2VvZiB3aW4uRG9jdW1lbnRUb3VjaDsgLy8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvdG91Y2hldmVudHMuanNcbiAgICAgICAgLy8gT24gSUUxMSB3aXRoIElFOSBlbXVsYXRpb24gbW9kZSwgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgaXMgcmV0dXJuaW5nIHRydWVcblxuICAgICAgICBpc01vYmlsZSA9IGhhc1RvdWNoUG9pbnRzIHx8IGhhc1RvdWNoO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzTW91c2UgPSBjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlICYmICFpc01vYmlsZSAmJiBcIm9ubW91c2VvdmVyXCIgaW4gd2luO1xuICAgICAgcmV0dXJuIGhhc01vdXNlICYmIFwibW91c2VcIiB8fCBpc01vYmlsZSAmJiBcInRvdWNoXCIgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBwbHVnaW4gaG9va1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwaGFzZSBUaGUgbGlmZWN5Y2xlIHBoYXNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbGxQbHVnaW5Ib29rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGxQbHVnaW5Ib29rKHBoYXNlKSB7XG4gICAgICBmb3IgKHZhciBfdGhpczIgPSB0aGlzLCBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuXG4gICAgICB0aGlzLmNvbmZpZy5wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcGhhc2UgPT09IFwiJGJlZm9yZUluaXRcIiAmJiAodi4kJCA9IF90aGlzMiwgX3RoaXMyLmFwaS5wbHVnaW5zLnB1c2godikpLCB2W3BoYXNlXS5hcHBseSh2LCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pLCBDaGFydEludGVybmFsO1xufSgpO1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ludGVybmFscy9DaGFydC5qc1xuXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuLyoqXG4gKiBNYWluIGNoYXJ0IGNsYXNzLlxuICogLSBOb3RlOiBJbnN0YW50aWF0ZWQgdmlhIGBiYi5nZW5lcmF0ZSgpYC5cbiAqIEBjbGFzcyBDaGFydFxuICogQGV4YW1wbGVcbiAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcbiAqICBkYXRhOiB7XG4gKiAgICBjb2x1bW5zOiBbXG4gKlx0ICAgIFtcInhcIiwgXCIyMDE1LTExLTAyXCIsIFwiMjAxNS0xMi0wMVwiLCBcIjIwMTYtMDEtMDFcIiwgXCIyMDE2LTAyLTAxXCIsIFwiMjAxNi0wMy0wMVwiXSxcbiAqIFx0ICAgIFtcImNvdW50MVwiLCAxMSwgOCwgNywgNiwgNSBdLFxuICpcdCAgICBbXCJjb3VudDJcIiwgOSwgMywgNiwgMiwgOCBdXG4gKiAgIF19XG4gKiB9XG4gKiBAc2VlIHtAbGluayBiYi5nZW5lcmF0ZX0gZm9yIHRoZSBpbml0aWFsaXphdGlvbi5cbiovXG5cbi8qKlxuICogQWNjZXNzIGluc3RhbmNlJ3MgcHJpbWFyeSBub2RlIGVsZW1lbnRzXG4gKiBAbWVtYmVyIHtPYmplY3R9ICRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5jaGFydCBXcmFwcGVyIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnN2ZyBNYWluIHN2ZyBlbGVtZW50XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5kZWZzIERlZmluaXRpb24gZWxlbWVudFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubWFpbiBNYWluIGdyb3VwaW5nIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRvb2x0aXAgVG9vbHRpcCBlbGVtZW50XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5sZWdlbmQgTGVnZW5kIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRpdGxlIFRpdGxlIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmdyaWQgR3JpZCBlbGVtZW50XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5hcmMgQXJjIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkLmJhclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuYmFyLmJhcnMgQmFyIGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gJC5saW5lXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5saW5lLmxpbmVzIExpbmUgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxpbmUuYXJlYXMgQXJlYXMgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxpbmUuY2lyY2xlcyBEYXRhIHBvaW50IGNpcmNsZSBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9ICQudGV4dFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQudGV4dC50ZXh0cyBEYXRhIGxhYmVsIHRleHQgZWxlbWVudHNcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQGV4YW1wbGVcbiAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xuICpcbiAqIGNoYXJ0LiQuY2hhcnQ7IC8vIHdyYXBwZXIgZWxlbWVudFxuICogY2hhcnQuJC5saW5lLmNpcmNsZXM7ICAvLyBhbGwgZGF0YSBwb2ludCBjaXJjbGUgZWxlbWVudHNcbiAqL1xuXG52YXIgQ2hhcnRfQ2hhcnQgPSBmdW5jdGlvbiBDaGFydChjb25maWcpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXJ0KTtcblxuICB2YXIgJCQgPSBuZXcgQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsKHRoaXMpO1xuICAvKipcbiAgICogUGx1Z2luIGluc3RhbmNlIGFycmF5XG4gICAqIEBtZW1iZXIge0FycmF5fSBwbHVnaW5zXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAaW5zdGFuY2VcbiAgIFx0ICogQGV4YW1wbGVcbiAgICogIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcbiAgICogICAgIC4uLlxuICAgKiAgICAgcGx1Z2luczogW1xuICAgKiAgICAgICAgbmV3IGJiLnBsdWdpbi5zdGFuZm9yZCh7IC4uLiB9KSxcbiAgICogICAgICAgIG5ldyBQbHVnaW5BKClcbiAgICogICAgIF1cbiAgICogIH0pO1xuICAgKlxuICAgKiAgY2hhcnQucGx1Z2luczsgLy8gW1N0YW5mb3JkLCBQbHVnaW5BXSAtIGluc3RhbmNlIGFycmF5XG4gICAqL1xuXG4gIC8vIGJpbmQgXCJ0aGlzXCIgdG8gbmVzdGVkIEFQSVxuICB0aGlzLnBsdWdpbnMgPSBbXSwgdGhpcy5pbnRlcm5hbCA9ICQkLCAkJC5sb2FkQ29uZmlnKGNvbmZpZyksICQkLmJlZm9yZUluaXQoY29uZmlnKSwgJCQuaW5pdCgpLCBmdW5jdGlvbiBiaW5kVGhpcyhmbiwgdGFyZ2V0LCBhcmdUaGlzKSB7XG4gICAgT2JqZWN0LmtleXMoZm4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBmbltrZXldLmJpbmQoYXJnVGhpcyksIE9iamVjdC5rZXlzKGZuW2tleV0pLmxlbmd0aCAmJiBiaW5kVGhpcyhmbltrZXldLCB0YXJnZXRba2V5XSwgYXJnVGhpcyk7XG4gICAgfSk7XG4gIH0oQ2hhcnQucHJvdG90eXBlLCB0aGlzLCB0aGlzKTtcbn07XG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29uZmlnL09wdGlvbnMuanNcblxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cbi8qKlxuICogQ2xhc3MgdG8gc2V0IG9wdGlvbnMgb24gZ2VuZXJhdGluZyBjaGFydC5cbiAqIC0gSXQncyBpbnN0YW50aWF0ZWQgaW50ZXJuYWxseSwgbm90IGV4cG9zZWQgZm9yIHB1YmxpYy5cbiAqIEBjbGFzcyBPcHRpb25zXG4gKiBAc2VlIHtAbGluayBiYi5nZW5lcmF0ZX0gdG8gdXNlIHRoZXNlIG9wdGlvbnMgb24gZ2VuZXJhdGluZyB0aGUgY2hhcnRcbiAqL1xudmFyIE9wdGlvbnNfT3B0aW9ucyA9IGZ1bmN0aW9uIE9wdGlvbnMoKSB7XG4gIHJldHVybiBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3B0aW9ucyksIHtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBDU1Mgc2VsZWN0b3Igb3IgdGhlIGVsZW1lbnQgd2hpY2ggdGhlIGNoYXJ0IHdpbGwgYmUgc2V0IHRvLiBEMyBzZWxlY3Rpb24gb2JqZWN0IGNhbiBiZSBzcGVjaWZpZWQgYWxzby48YnI+XG4gICAgICogSWYgb3RoZXIgY2hhcnQgaXMgc2V0IGFscmVhZHksIGl0IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IG9uZSAob25seSBvbmUgY2hhcnQgY2FuIGJlIHNldCBpbiBvbmUgZWxlbWVudCkuXG4gICAgICogLSAqKk5PVEU6KiogSW4gY2FzZSBvZiBlbGVtZW50IGRvZXNuJ3QgZXhpc3Qgb3Igbm90IHNwZWNpZmllZCwgd2lsbCBhZGQgYSBgPGRpdj5gIGVsZW1lbnQgdG8gdGhlIGJvZHkuXG4gICAgICogQG5hbWUgYmluZHRvXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudHxkMy5zZWxlY3Rpb259IGJpbmR0bz0jY2hhcnQgU3BlY2lmeSB0aGUgZWxlbWVudCB3aGVyZSBjaGFydCB3aWxsIGJlIGRyYXduLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfEhUTUxFbGVtZW50fGQzLnNlbGVjdGlvbn0gYmluZHRvLmVsZW1lbnQ9I2NoYXJ0IFNwZWNpZnkgdGhlIGVsZW1lbnQgd2hlcmUgY2hhcnQgd2lsbCBiZSBkcmF3bi5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2JpbmR0by5jbGFzc25hbWU9YmJdIFNwZWNpZnkgdGhlIGNsYXNzIG5hbWUgb2YgYmluZCBlbGVtZW50Ljxicj5cbiAgICAgKiAgICAgKipOT1RFOioqIFdoZW4gY2xhc3MgbmFtZSBpc24ndCBgYmJgLCB0aGVuIHlvdSBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSBkZWZhdWx0IENTUyB0byBiZSByZW5kZXJlZCBjb3JyZWN0bHkuXG4gICAgICogQGRlZmF1bHQgI2NoYXJ0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBiaW5kdG86IFwiI215Q29udGFpbmVyXCJcbiAgICAgKlxuICAgICAqIC8vIG9yIEhUTUxFbGVtZW50XG4gICAgICogYmluZHRvOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15Q29udGFpbmVyXCIpXG4gICAgICpcbiAgICAgKiAvLyBvciBEMyBzZWxlY3Rpb24gb2JqZWN0XG4gICAgICogYmluZHRvOiBkMy5zZWxlY3QoXCIjbXlDb250YWluZXJcIilcbiAgICAgKlxuICAgICAqIC8vIG9yIHRvIGNoYW5nZSBkZWZhdWx0IGNsYXNzbmFtZVxuICAgICAqIGJpbmR0bzoge1xuICAgICAqICAgIGVsZW1lbnQ6IFwiI2NoYXJ0XCIsXG4gICAgICogICAgY2xhc3NuYW1lOiBcImJpbGwtYm9hcmRcIiAgLy8gZXgpIDxkaXYgaWQ9J2NoYXJ0JyBjbGFzcz0nYmlsbC1ib2FyZCc+XG4gICAgICogfVxuICAgICAqL1xuICAgIGJpbmR0bzogXCIjY2hhcnRcIixcblxuICAgIC8qKlxuICAgICAqIFNldCBjaGFydCBiYWNrZ3JvdW5kLlxuICAgICAqIEBuYW1lIGJhY2tncm91bmRcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBiYWNrZ3JvdW5kLmNsYXNzIFNwZWNpZnkgdGhlIGNsYXNzIG5hbWUgZm9yIGJhY2tncm91bmQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gYmFja2dyb3VuZC5jb2xvciBTcGVjaWZ5IHRoZSBmaWxsIGNvbG9yIGZvciBiYWNrZ3JvdW5kIGVsZW1lbnQuPGJyPioqTk9URToqKiBXaWxsIGJlIGlnbm9yZWQgaWYgYGltZ1VybGAgb3B0aW9uIGlzIHNldC5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gYmFja2dyb3VuZC5pbWdVcmwgU3BlY2lmeSB0aGUgaW1hZ2UgdXJsIHN0cmluZyBmb3IgYmFja2dyb3VuZC5cbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnRPcHRpb25zLkJhY2tncm91bmQpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBiYWNrZ3JvdW5kOiB7XG4gICAgICogICAgY2xhc3M6IFwibXlDbGFzc1wiLFxuICAgICAqICAgIGNvbG9yOiBcInJlZFwiLFxuICAgICAqXG4gICAgICogICAgLy8gU2V0IGltYWdlIHVybCBmb3IgYmFja2dyb3VuZC5cbiAgICAgKiAgICAvLyBJZiBzcGVjaWZpZWQsICdjb2xvcicgb3B0aW9uIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiAgICBpbWdVcmw6IFwiaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2ltZy9sb2dvL2JpbGxib2FyZC5qcy5zdmdcIixcbiAgICAgKiB9XG4gICAgICovXG4gICAgYmFja2dyb3VuZDoge30sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlIGZvciBjaGFydCBlbGVtZW50XG4gICAgICogLSAqKk5PVEU6KipcbiAgICAgKiAgPiBXaGVuIGlzIGZhbHNlLCBjaGFydCBub2RlIGVsZW1lbnQgaXMgcG9zaXRpb25lZCBhZnRlciB0aGUgYXhpcyBub2RlIGluIERPTSB0cmVlIGhpZXJhcmNoeS5cbiAgICAgKiAgPiBJcyB0byBtYWtlIGNoYXJ0IGVsZW1lbnQgcG9zaXRpb25lZCBvdmVyIGF4aXMgZWxlbWVudC5cbiAgICAgKiBAbmFtZSBjbGlwUGF0aFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuY2xpcFBhdGgpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBkb24ndCBzZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlXG4gICAgICogY2xpcFBhdGg6IGZhbHNlXG4gICAgICovXG4gICAgY2xpcFBhdGg6ICEwLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHN2ZyBlbGVtZW50J3MgY2xhc3MgbmFtZVxuICAgICAqIEBuYW1lIHN2Z1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N2Zy5jbGFzc25hbWVdIGNsYXNzIG5hbWUgZm9yIHN2ZyBlbGVtZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzdmc6IHtcbiAgICAgICAgICAgICAgKiAgIGNsYXNzbmFtZTogXCJ0ZXN0X2NsYXNzXCJcbiAgICAgKiB9XG4gICAgICovXG4gICAgc3ZnX2NsYXNzbmFtZTogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgY2hhcnQgZWxlbWVudC5cbiAgICAgKiBJZiB2YWx1ZSBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgd2lkdGggb2YgdGhlIGNoYXJ0IHdpbGwgYmUgY2FsY3VsYXRlZCBieSB0aGUgc2l6ZSBvZiB0aGUgcGFyZW50IGVsZW1lbnQgaXQncyBhcHBlbmRlZCB0by5cbiAgICAgKiBAbmFtZSBzaXplXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2l6ZS53aWR0aF0gd2lkdGggb2YgdGhlIGNoYXJ0IGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3NpemUuaGVpZ2h0XSBoZWlnaHQgb2YgdGhlIGNoYXJ0IGVsZW1lbnRcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnRPcHRpb25zLkNoYXJ0U2l6ZSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNpemU6IHtcbiAgICAgICAgICAgICAgKiAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICAgICogICBoZWlnaHQ6IDQ4MFxuICAgICAqIH1cbiAgICAgKi9cbiAgICBzaXplX3dpZHRoOiB1bmRlZmluZWQsXG4gICAgc2l6ZV9oZWlnaHQ6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYWRkaW5nIG9mIHRoZSBjaGFydCBlbGVtZW50LlxuICAgICAqIEBuYW1lIHBhZGRpbmdcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwYWRkaW5nLnRvcF0gcGFkZGluZyBvbiB0aGUgdG9wIG9mIGNoYXJ0XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwYWRkaW5nLnJpZ2h0XSBwYWRkaW5nIG9uIHRoZSByaWdodCBvZiBjaGFydFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy5ib3R0b21dIHBhZGRpbmcgb24gdGhlIGJvdHRvbSBvZiBjaGFydFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy5sZWZ0XSBwYWRkaW5nIG9uIHRoZSBsZWZ0IG9mIGNoYXJ0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBwYWRkaW5nOiB7XG4gICAgICAgICAgICAgICogICB0b3A6IDIwLFxuICAgICAgICAgICAgICAqICAgcmlnaHQ6IDIwLFxuICAgICAgICAgICAgICAqICAgYm90dG9tOiAyMCxcbiAgICAgICAgICAgICAgKiAgIGxlZnQ6IDIwXG4gICAgICogfVxuICAgICAqL1xuICAgIHBhZGRpbmdfbGVmdDogdW5kZWZpbmVkLFxuICAgIHBhZGRpbmdfcmlnaHQ6IHVuZGVmaW5lZCxcbiAgICBwYWRkaW5nX3RvcDogdW5kZWZpbmVkLFxuICAgIHBhZGRpbmdfYm90dG9tOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgY2hhcnQgcmVzaXplIG9wdGlvbnNcbiAgICAgKiBAbmFtZSByZXNpemVcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcmVzaXplLmF1dG89dHJ1ZV0gU2V0IGNoYXJ0IHJlc2l6ZSBhdXRvbWF0aWNhbGx5IG9uIHZpZXdwb3J0IGNoYW5nZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgcmVzaXplOiB7XG4gICAgICogICAgICBhdXRvOiBmYWxzZVxuICAgICAqICB9XG4gICAgICovXG4gICAgcmVzaXplX2F1dG86ICEwLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHpvb20gb3B0aW9uc1xuICAgICAqIEBuYW1lIHpvb21cbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbem9vbS5lbmFibGVkPWZhbHNlXSBFbmFibGUgem9vbWluZy5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3pvb20uZW5hYmxlZC50eXBlPSd3aGVlbCddIFNldCB6b29tIGludGVyYWN0aW9uIHR5cGUuXG4gICAgICogIC0gKipBdmFpbGFibGUgdHlwZXM6KipcbiAgICAgKiAgICAtIHdoZWVsXG4gICAgICogICAgLSBkcmFnXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbem9vbS5yZXNjYWxlPWZhbHNlXSBFbmFibGUgdG8gcmVzY2FsZSBhZnRlciB6b29taW5nLjxicj5cbiAgICAgKiAgSWYgdHJ1ZSBzZXQsIHkgZG9tYWluIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmcgdG8gdGhlIHpvb21lZCByZWdpb24uXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gW3pvb20uZXh0ZW50PVsxLCAxMF1dIENoYW5nZSB6b29tIGV4dGVudC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxEYXRlfSBbem9vbS54Lm1pbl0gU2V0IHggQXhpcyBtaW5pbXVtIHpvb20gcmFuZ2VcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxEYXRlfSBbem9vbS54Lm1heF0gU2V0IHggQXhpcyBtYXhpbXVtIHpvb20gcmFuZ2VcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbem9vbS5vbnpvb21zdGFydD11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHpvb21pbmcgc3RhcnRzLjxicj5cbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLm9uem9vbT11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBjaGFydCBpcyB6b29taW5nLjxicj5cbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tZWQgZG9tYWluLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLm9uem9vbWVuZD11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHpvb21pbmcgZW5kcy48YnI+XG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgem9vbWVkIGRvbWFpbi5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW58T2JqZWN0fSBbem9vbS5yZXNldEJ1dHRvbj10cnVlXSBTZXQgdG8gZGlzcGxheSB6b29tIHJlc2V0IGJ1dHRvbiBmb3IgJ2RyYWcnIHR5cGUgem9vbVxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLnJlc2V0QnV0dG9uLm9uY2xpY2tdIFNldCBjYWxsYmFjayB3aGVuIGNsaWNrcyB0aGUgcmVzZXQgYnV0dG9uLiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHJlc2V0IGJ1dHRvbiBlbGVtZW50IHJlZmVyZW5jZSBhcyBhcmd1bWVudC5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3pvb20ucmVzZXRCdXR0b24udGV4dD0nUmVzZXQgWm9vbSddIFRleHQgdmFsdWUgZm9yIHpvb20gcmVzZXQgYnV0dG9uLlxuICAgICAqIEBzZWUgW0RlbW86em9vbV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLlpvb20pXG4gICAgICogQHNlZSBbRGVtbzpkcmFnIHpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5EcmFnWm9vbSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB6b29tOiB7XG4gICAgICogICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICAgICogICAgICAgICAgdHlwZTogXCJkcmFnXCJcbiAgICAgICAgICAgICAgKiAgICAgIH0sXG4gICAgICogICAgICByZXNjYWxlOiB0cnVlLFxuICAgICAqICAgICAgZXh0ZW50OiBbMSwgMTAwXSAgLy8gZW5hYmxlIG1vcmUgem9vbWluZ1xuICAgICAqICAgICAgeDoge1xuICAgICAqICAgICAgICAgIG1pbjogLTEsICAvLyBzZXQgbWluIHJhbmdlXG4gICAgICogICAgICAgICAgbWF4OiAxMCAgLy8gc2V0IG1heCByYW5nZVxuICAgICAqICAgICAgfSxcbiAgICAgKiAgICAgIG9uem9vbXN0YXJ0OiBmdW5jdGlvbihldmVudCkgeyAuLi4gfSxcbiAgICAgKiAgICAgIG9uem9vbTogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9LFxuICAgICAqICAgICAgb256b29tZW5kOiBmdW5jdGlvbihkb21haW4pIHsgLi4uIH0sXG4gICAgICpcbiAgICAgKiAgICAgIC8vIHNob3cgcmVzZXQgYnV0dG9uIHdoZW4gaXMgem9vbWVkLWluXG4gICAgICogICAgICByZXNldEJ1dHRvbjogdHJ1ZSxcbiAgICAgKlxuICAgICAqICAgICAgcmVzZXRCdXR0b246IHtcbiAgICAgKiAgICAgICAgICAvLyBvbmNsaWNrIGNhbGxiYWNrIHdoZW4gcmVzZXQgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbihidXR0b24pIHtcbiAgICAgKiAgICAgICAgICAgIGJ1dHRvbjsgLy8gUmVzZXQgYnV0dG9uIGVsZW1lbnQgcmVmZXJlbmNlXG4gICAgICogICAgICAgICAgICAuLi5cbiAgICAgKiAgICAgICAgICB9LFxuICAgICAqXG4gICAgICogICAgICAgICAgLy8gY3VzdG9taXplZCB0ZXh0IHZhbHVlIGZvciByZXNldCB6b29tIGJ1dHRvblxuICAgICAqICAgICAgICAgIHRleHQ6IFwiVW56b29tXCJcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgfVxuICAgICAqL1xuICAgIHpvb21fZW5hYmxlZDogdW5kZWZpbmVkLFxuICAgIHpvb21fZXh0ZW50OiB1bmRlZmluZWQsXG4gICAgem9vbV9wcml2aWxlZ2VkOiAhMSxcbiAgICB6b29tX3Jlc2NhbGU6ICExLFxuICAgIHpvb21fb256b29tOiB1bmRlZmluZWQsXG4gICAgem9vbV9vbnpvb21zdGFydDogdW5kZWZpbmVkLFxuICAgIHpvb21fb256b29tZW5kOiB1bmRlZmluZWQsXG4gICAgem9vbV9yZXNldEJ1dHRvbjogITAsXG4gICAgem9vbV94X21pbjogdW5kZWZpbmVkLFxuICAgIHpvb21feF9tYXg6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIEludGVyYWN0aW9uIG9wdGlvbnNcbiAgICAgKiBAbmFtZSBpbnRlcmFjdGlvblxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbnRlcmFjdGlvbi5lbmFibGVkPXRydWVdIEluZGljYXRlIGlmIHRoZSBjaGFydCBzaG91bGQgaGF2ZSBpbnRlcmFjdGlvbnMuPGJyPlxuICAgICAqICAgICBJZiBgZmFsc2VgIGlzIHNldCwgYWxsIG9mIGludGVyYWN0aW9ucyAoc2hvd2luZy9oaWRpbmcgdG9vbHRpcCwgc2VsZWN0aW9uLCBtb3VzZSBldmVudHMsIGV0Yykgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbnRlcmFjdGlvbi5icmlnaHRlbj10cnVlXSBNYWtlIGJyaWdodGVyIGZvciB0aGUgc2VsZWN0ZWQgYXJlYSAoZXguICdwaWUnIHR5cGUgZGF0YSBzZWxlY3RlZCBhcmVhKVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludGVyYWN0aW9uLmlucHV0VHlwZS5tb3VzZT10cnVlXSBlbmFibGUgb3IgZGlzYWJsZSBtb3VzZSBpbnRlcmFjdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludGVyYWN0aW9uLmlucHV0VHlwZS50b3VjaD10cnVlXSBlbmFibGUgb3IgZGlzYWJsZSAgdG91Y2ggaW50ZXJhY3Rpb25cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW58TnVtYmVyfSBbaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoLnByZXZlbnREZWZhdWx0PWZhbHNlXSBlbmFibGUgb3IgZGlzYWJsZSB0byBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0IG9uIHRvdWNoc3RhcnQgJiB0b3VjaG1vdmUgZXZlbnQuIEl0J3MgdXN1YWxseSB1c2VkIHRvIHByZXZlbnQgZG9jdW1lbnQgc2Nyb2xsaW5nLlxuICAgICAqIEBzZWUgW0RlbW86IHRvdWNoLnByZXZlbnREZWZhdWx0XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jSW50ZXJhY3Rpb24uUHJldmVudFNjcm9sbE9uVG91Y2gpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbnRlcmFjdGlvbjoge1xuICAgICAgICAgICAgICAqICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAqICAgIGJyaWdodGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgKiAgICBpbnB1dFR5cGU6IHtcbiAgICAgICAgICAgICAgKiAgICAgICAgbW91c2U6IHRydWUsXG4gICAgICAgICAgICAgICogICAgICAgIHRvdWNoOiBmYWxzZVxuICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICogICAgICAgIC8vIG9yIGRlY2xhcmUgcHJldmVudERlZmF1bHQgZXhwbGljaXRseS5cbiAgICAgICAgICAgICAgKiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHRvdWNoIGlucHV0VHlwZSBpcyBlbmFibGVkIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgKiAgICAgICAgdG91Y2g6IHtcbiAgICAgICAgICAgICAgKiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXG4gICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgKiAgICAgICAgICAgIC8vIG9yIHRocmVzaG9sZCBwaXhlbCB2YWx1ZSAocGl4ZWwgbW92ZWQgZnJvbSB0b3VjaHN0YXJ0IHRvIHRvdWNobW92ZSlcbiAgICAgICAgICAgICAgKiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiA1XG4gICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgKiAgICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGludGVyYWN0aW9uX2VuYWJsZWQ6ICEwLFxuICAgIGludGVyYWN0aW9uX2JyaWdodGVuOiAhMCxcbiAgICBpbnRlcmFjdGlvbl9pbnB1dFR5cGVfbW91c2U6ICEwLFxuICAgIGludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaDoge30sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gbW91c2UvdG91Y2ggZW50ZXJzIHRoZSBjaGFydC5cbiAgICAgKiBAbmFtZSBvbm92ZXJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxuICAgICAqIG9ub3ZlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICogICAuLi5cbiAgICAgKiB9XG4gICAgICovXG4gICAgb25vdmVyOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gbW91c2UvdG91Y2ggbGVhdmVzIHRoZSBjaGFydC5cbiAgICAgKiBAbmFtZSBvbm91dFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXG4gICAgICogb25vdXQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAqICAgLi4uXG4gICAgICogfVxuICAgICAqL1xuICAgIG9ub3V0OiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdXNlciByZXNpemVzIHRoZSBzY3JlZW4uXG4gICAgICogQG5hbWUgb25yZXNpemVcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxuICAgICAqIG9ucmVzaXplOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgKiAgIC4uLlxuICAgICAqIH1cbiAgICAgKi9cbiAgICBvbnJlc2l6ZTogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHNjcmVlbiByZXNpemUgZmluaXNoZWQuXG4gICAgICogQG5hbWUgb25yZXNpemVkXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcbiAgICAgKiBvbnJlc2l6ZWQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAqICAgLi4uXG4gICAgICogfVxuICAgICAqL1xuICAgIG9ucmVzaXplZDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgdGhlIGNoYXJ0IGlzIGluaXRpYWxpemVkXG4gICAgICogQG5hbWUgb25iZWZvcmVpbml0XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcbiAgICAgKiBvbmJlZm9yZWluaXQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAqICAgLi4uXG4gICAgICogfVxuICAgICAqL1xuICAgIG9uYmVmb3JlaW5pdDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZC5cbiAgICAgKiBAbmFtZSBvbmluaXRcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxuICAgICAqIG9uaW5pdDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICogICAuLi5cbiAgICAgKiB9XG4gICAgICovXG4gICAgb25pbml0OiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIGFmdGVyIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZFxuICAgICAqIEBuYW1lIG9uYWZ0ZXJpbml0XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcbiAgICAgKiBvbmFmdGVyaW5pdDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICogICAuLi5cbiAgICAgKiB9XG4gICAgICovXG4gICAgb25hZnRlcmluaXQ6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGNhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYXJ0IGlzIHJlbmRlcmVkLiBCYXNpY2FsbHksIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaW4gZWFjaCB0aW1lIHdoZW4gdGhlIGNoYXJ0IGlzIHJlZHJhd2VkLlxuICAgICAqIEBuYW1lIG9ucmVuZGVyZWRcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxuICAgICAqIG9ucmVuZGVyZWQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAqICAgLi4uXG4gICAgICogfVxuICAgICAqL1xuICAgIG9ucmVuZGVyZWQ6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFNldCBkdXJhdGlvbiBvZiB0cmFuc2l0aW9uIChpbiBtaWxsaXNlY29uZHMpIGZvciBjaGFydCBhbmltYXRpb24uPGJyPjxicj5cbiAgICAgKiAtICoqTk9URToqKiBJZiBgMCBgb3IgYG51bGxgIHNldCwgdHJhbnNpdGlvbiB3aWxsIGJlIHNraXBwZWQuIFNvLCB0aGlzIG1ha2VzIGluaXRpYWwgcmVuZGVyaW5nIGZhc3RlciBlc3BlY2lhbGx5IGluIGNhc2UgeW91IGhhdmUgYSBsb3Qgb2YgZGF0YS5cbiAgICAgKiBAbmFtZSB0cmFuc2l0aW9uXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdHJhbnNpdGlvbi5kdXJhdGlvbj0zNTBdIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogdHJhbnNpdGlvbjoge1xuICAgICAqICAgIGR1cmF0aW9uOiA1MDBcbiAgICAgKiB9XG4gICAgICovXG4gICAgdHJhbnNpdGlvbl9kdXJhdGlvbjogMzUwLFxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUga2V5IG9mIHggdmFsdWVzIGluIHRoZSBkYXRhLjxicj48YnI+XG4gICAgICogV2UgY2FuIHNob3cgdGhlIGRhdGEgd2l0aCBub24taW5kZXggeCB2YWx1ZXMgYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIGlzIHJlcXVpcmVkIHdoZW4gdGhlIHR5cGUgb2YgeCBheGlzIGlzIHRpbWVzZXJpZXMuIElmIHRoaXMgb3B0aW9uIGlzIHNldCBvbiBjYXRlZ29yeSBheGlzLCB0aGUgdmFsdWVzIG9mIHRoZSBkYXRhIG9uIHRoZSBrZXkgd2lsbCBiZSB1c2VkIGZvciBjYXRlZ29yeSBuYW1lcy5cbiAgICAgKiBAbmFtZSBkYXRh4oCkeFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgICAgICAgICAgKiAgIHg6IFwiZGF0ZVwiXG4gICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfeDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUga2V5cyBvZiB0aGUgeCB2YWx1ZXMgZm9yIGVhY2ggZGF0YS48YnI+PGJyPlxuICAgICAqIFRoaXMgb3B0aW9uIGNhbiBiZSB1c2VkIGlmIHdlIHdhbnQgdG8gc2hvdyB0aGUgZGF0YSB0aGF0IGhhcyBkaWZmZXJlbnQgeCB2YWx1ZXMuXG4gICAgICogQG5hbWUgZGF0YeKApHhzXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IHt9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICAgICAgICAgICogICB4czoge1xuICAgICAgICAgICAgICAqICAgICAgZGF0YTE6IFwieDFcIixcbiAgICAgICAgICAgICAgKiAgICAgIGRhdGEyOiBcIngyXCJcbiAgICAgICAgICAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV94czoge30sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBmb3JtYXQgc3BlY2lmaWVyIHRvIHBhcnNlIHN0cmluZyBzcGVjaWZlZCBhcyB4LlxuICAgICAqIEBuYW1lIGRhdGHigKR4Rm9ybWF0XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICVZLSVtLSVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICogICAgeDogXCJ4XCIsXG4gICAgICogICAgY29sdW1uczogW1xuICAgICAqICAgICAgICBbXCJ4XCIsIFwiMDEwMTIwMTlcIiwgXCIwMjAxMjAxOVwiLCBcIjAzMDEyMDE5XCJdLFxuICAgICAqICAgICAgICBbXCJkYXRhMVwiLCAzMCwgMjAwLCAxMDBdXG4gICAgICogICAgXSxcbiAgICAgKiAgICAvLyBGb3JtYXQgc3BlY2lmaWVyIHRvIHBhcnNlIGFzIGRhdGV0aW1lIGZvciBnaXZlbiAneCcgc3RyaW5nIHZhbHVlXG4gICAgICogICAgeEZvcm1hdDogXCIlbSVkJVlcIlxuICAgICAqIH0sXG4gICAgICogYXhpczoge1xuICAgICAqICAgIHg6IHtcbiAgICAgKiAgICAgICAgdHlwZTogXCJ0aW1lc2VyaWVzXCJcbiAgICAgKiAgICB9XG4gICAgICogfVxuICAgICAqIEBzZWUgW0QzJ3MgdGltZSBzcGVjaWZpZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lLWZvcm1hdCNsb2NhbGVfZm9ybWF0KVxuICAgICAqL1xuICAgIGRhdGFfeEZvcm1hdDogXCIlWS0lbS0lZFwiLFxuXG4gICAgLyoqXG4gICAgICogU2V0IGxvY2FsdGltZSBmb3JtYXQgdG8gcGFyc2UgeCBheGlzLlxuICAgICAqIEBuYW1lIGRhdGHigKR4TG9jYWx0aW1lXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICAgICAgICAgICogICB4TG9jYWx0aW1lOiBmYWxzZVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX3hMb2NhbHRpbWU6ICEwLFxuXG4gICAgLyoqXG4gICAgICogU29ydCBvbiB4IGF4aXMuXG4gICAgICogQG5hbWUgZGF0YeKApHhTb3J0XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICAgICAgICAgICogICB4U29ydDogZmFsc2VcbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV94U29ydDogITAsXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBkYXRhIGlkIHZhbHVlXG4gICAgICogQG5hbWUgZGF0YeKApGlkQ29udmVydGVyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGlkOyB9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICAgICAgICAgICogICAgaWRDb252ZXJ0ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICogICAgICAgLy8gd2hlbiBpZCBpcyAnZGF0YTEnLCBjb252ZXJ0cyB0byBiZSAnZGF0YTInXG4gICAgICAgICAgICAgICogICAgICAgLy8gJ2RhdGEyJyBzaG91bGQgYmUgZ2l2ZW4gYXMgdGhlIGluaXRpYWwgZGF0YSB2YWx1ZVxuICAgICAgICAgICAgICAqICAgICAgIGlmIChpZCA9PT0gXCJkYXRhMVwiKSB7XG4gICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIFwiZGF0YTJcIjtcbiAgICAgICAgICAgICAgKiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgKiAgICAgICB9XG4gICAgICAgICAgICAgICogICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX2lkQ29udmVydGVyOiBmdW5jdGlvbiBkYXRhX2lkQ29udmVydGVyKGlkKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBjdXN0b20gZGF0YSBuYW1lLlxuICAgICAqIEBuYW1lIGRhdGHigKRuYW1lc1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVmYXVsdCB7fVxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFOYW1lKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGF0YToge1xuICAgICAgICAgICAgICAqICAgbmFtZXM6IHtcbiAgICAgICAgICAgICAgKiAgICAgZGF0YTE6IFwiRGF0YSBOYW1lIDFcIixcbiAgICAgICAgICAgICAgKiAgICAgZGF0YTI6IFwiRGF0YSBOYW1lIDJcIlxuICAgICAgICAgICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX25hbWVzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIFNldCBjdXN0b20gZGF0YSBjbGFzcy48YnI+PGJyPlxuICAgICAqIElmIHRoaXMgb3B0aW9uIGlzIHNwZWNpZmllZCwgdGhlIGVsZW1lbnQgZyBmb3IgdGhlIGRhdGEgaGFzIGFuIGFkZGl0aW9uYWwgY2xhc3MgdGhhdCBoYXMgdGhlIHByZWZpeCAnYmItdGFyZ2V0LScgKGVnLiBiYi10YXJnZXQtYWRkaXRpb25hbC1kYXRhMS1jbGFzcykuXG4gICAgICogQG5hbWUgZGF0YeKApGNsYXNzZXNcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHQge31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgICAgICAgICAgKiAgIGNsYXNzZXM6IHtcbiAgICAgICAgICAgICAgKiAgICAgZGF0YTE6IFwiYWRkaXRpb25hbC1kYXRhMS1jbGFzc1wiLFxuICAgICAgICAgICAgICAqICAgICBkYXRhMjogXCJhZGRpdGlvbmFsLWRhdGEyLWNsYXNzXCJcbiAgICAgICAgICAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV9jbGFzc2VzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIFNldCBncm91cHMgZm9yIHRoZSBkYXRhIGZvciBzdGFja2luZy5cbiAgICAgKiBAbmFtZSBkYXRh4oCkZ3JvdXBzXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQGRlZmF1bHQgW11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgICAgICAgICAgKiAgIGdyb3VwczogW1xuICAgICAgICAgICAgICAqICAgICBbXCJkYXRhMVwiLCBcImRhdGEyXCJdLFxuICAgICAgICAgICAgICAqICAgICBbXCJkYXRhM1wiXVxuICAgICAgICAgICAgICAqICAgXVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX2dyb3VwczogW10sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgeSBheGlzIHRoZSBkYXRhIHJlbGF0ZWQgdG8uIHkgYW5kIHkyIGNhbiBiZSB1c2VkLlxuICAgICAqIC0gKipOT1RFOioqIElmIGFsbCBkYXRhIGlzIHJlbGF0ZWQgdG8gb25lIG9mIHRoZSBheGVzLCB0aGUgZG9tYWluIG9mIGF4aXMgd2l0aG91dCByZWxhdGVkIGRhdGEgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgZG9tYWluIGZyb20gdGhlIGF4aXMgd2l0aCByZWxhdGVkIGRhdGFcbiAgICAgKiBAbmFtZSBkYXRh4oCkYXhlc1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVmYXVsdCB7fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGF0YToge1xuICAgICAqICAgYXhlczoge1xuICAgICAqICAgICBkYXRhMTogXCJ5XCIsXG4gICAgICogICAgIGRhdGEyOiBcInkyXCJcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV9heGVzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIFNldCBjaGFydCB0eXBlIGF0IG9uY2UuPGJyPjxicj5cbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSB0eXBlIHdpbGwgYmUgYXBwbGllZCB0byBldmVyeSBkYXRhLiBUaGlzIHNldHRpbmcgY2FuIGJlIG92ZXJ3cml0dGVuIGJ5IGRhdGEudHlwZXMuPGJyPjxicj5cbiAgICAgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcbiAgICAgKiAtIGFyZWFcbiAgICAgKiAtIGFyZWEtbGluZS1yYW5nZVxuICAgICAqIC0gYXJlYS1zcGxpbmVcbiAgICAgKiAtIGFyZWEtc3BsaW5lLXJhbmdlXG4gICAgICogLSBhcmVhLXN0ZXBcbiAgICAgKiAtIGJhclxuICAgICAqIC0gYnViYmxlXG4gICAgICogLSBkb251dFxuICAgICAqIC0gZ2F1Z2VcbiAgICAgKiAtIGxpbmVcbiAgICAgKiAtIHBpZVxuICAgICAqIC0gcmFkYXJcbiAgICAgKiAtIHNjYXR0ZXJcbiAgICAgKiAtIHNwbGluZVxuICAgICAqIC0gc3RlcFxuICAgICAqIEBuYW1lIGRhdGHigKR0eXBlXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IGxpbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgICB0eXBlOiBcImJhclwiXG4gICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfdHlwZTogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU2V0IGNoYXJ0IHR5cGUgZm9yIGVhY2ggZGF0YS48YnI+XG4gICAgICogVGhpcyBzZXR0aW5nIG92ZXJ3cml0ZXMgZGF0YS50eXBlIHNldHRpbmcuXG4gICAgICogLSAqKk5PVEU6KiogYHJhZGFyYCB0eXBlIGNhbid0IGJlIGNvbWJpbmVkIHdpdGggb3RoZXIgdHlwZXMuXG4gICAgICogQG5hbWUgZGF0YeKApHR5cGVzXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IHt9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICogICB0eXBlczoge1xuICAgICAqICAgICBkYXRhMTogXCJiYXJcIixcbiAgICAgKiAgICAgZGF0YTI6IFwic3BsaW5lXCJcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV90eXBlczoge30sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgbGFiZWxzIG9wdGlvbnNcbiAgICAgKiBAbmFtZSBkYXRh4oCkbGFiZWxzXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RhdGEubGFiZWxzPWZhbHNlXSBTaG93IG9yIGhpZGUgbGFiZWxzIG9uIGVhY2ggZGF0YSBwb2ludHNcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtkYXRhLmxhYmVscy5jZW50ZXJlZD1mYWxzZV0gQ2VudGVyaXplIGxhYmVscyBvbiBgYmFyYCBzaGFwZS4gKCoqTk9URToqKiB3b3JrcyBvbmx5IGZvciAnYmFyJyB0eXBlKVxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtkYXRhLmxhYmVscy5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZnVuY3Rpb24gZm9yIGRhdGEgbGFiZWxzLjxicj5cbiAgICAgKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9uIHJlY2VpdmVzIDQgYXJndW1lbnRzIHN1Y2ggYXMgdiwgaWQsIGksIGogYW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSBzaG93biBhcyB0aGUgbGFiZWwuIFRoZSBhcmd1bWVudHMgYXJlOjxicj5cbiAgICAgKiAgLSBgdmAgaXMgdGhlIHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50IHdoZXJlIHRoZSBsYWJlbCBpcyBzaG93bi5cbiAgICAgKiAgLSBgaWRgIGlzIHRoZSBpZCBvZiB0aGUgZGF0YSB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXG4gICAgICogIC0gYGlgIGlzIHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXG4gICAgICogIC0gYGpgIGlzIHRoZSBzdWIgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLjxicj48YnI+XG4gICAgICogRm9ybWF0dGVyIGZ1bmN0aW9uIGNhbiBiZSBkZWZpbmVkIGZvciBlYWNoIGRhdGEgYnkgc3BlY2lmeWluZyBhcyBhbiBvYmplY3QgYW5kIEQzIGZvcm1hdHRlciBmdW5jdGlvbiBjYW4gYmUgc2V0IChleC4gZDMuZm9ybWF0KCckJykpXG4gICAgXHQgKiBAcHJvcGVydHkge1N0cmluZ3xPYmplY3R9IFtkYXRhLmxhYmVscy5jb2xvcnNdIFNldCBsYWJlbCB0ZXh0IGNvbG9ycy5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gW2RhdGEubGFiZWxzLnBvc2l0aW9uXSBTZXQgZWFjaCBkYXRhc2V0IHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkYXRhLmxhYmVscy5wb3NpdGlvbi54PTBdIHggY29vcmRpbmF0ZSBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGF0YS5sYWJlbHMucG9zaXRpb24ueT0wXSB5IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHQge31cbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWwpXG4gICAgICogQHNlZSBbRGVtbzogbGFiZWwgY29sb3JzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxDb2xvcnMpXG4gICAgICogQHNlZSBbRGVtbzogbGFiZWwgZm9ybWF0XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxGb3JtYXQpXG4gICAgICogQHNlZSBbRGVtbzogbGFiZWwgb3ZlcmxhcF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsT3ZlcmxhcClcbiAgICAgKiBAc2VlIFtEZW1vOiBsYWJlbCBwb3NpdGlvbl0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsUG9zaXRpb24pXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICogICBsYWJlbHM6IHRydWUsXG4gICAgICpcbiAgICAgKiAgIC8vIG9yIHNldCBzcGVjaWZpYyBvcHRpb25zXG4gICAgICogICBsYWJlbHM6IHtcbiAgICAgKiAgICAgZm9ybWF0OiBmdW5jdGlvbih2LCBpZCwgaSwgaikgeyAuLi4gfSxcbiAgICAgKlxuICAgICAqICAgICAvLyBpdCdzIHBvc3NpYmxlIHRvIHNldCBmb3IgZWFjaCBkYXRhXG4gICAgICogICAgIGZvcm1hdDoge1xuICAgICAqICAgICAgICAgZGF0YTE6IGZ1bmN0aW9uKHYsIGlkLCBpLCBqKSB7IC4uLiB9LFxuICAgICAqICAgICAgICAgLi4uXG4gICAgICogICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgLy8gYWxpZ24gdGV4dCB0byBjZW50ZXIgb2YgdGhlICdiYXInIHNoYXBlICh3b3JrcyBvbmx5IGZvciAnYmFyJyB0eXBlKVxuICAgICAqICAgICBjZW50ZXJlZDogdHJ1ZSxcbiAgICAgKlxuICAgICAqICAgICAvLyBhcHBseSBmb3IgYWxsIGxhYmVsIHRleHRzXG4gICAgICogICAgIGNvbG9yczogXCJyZWRcIixcbiAgICAgKlxuICAgICAqICAgICAvLyBvciBzZXQgZGlmZmVyZW50IGNvbG9ycyBwZXIgZGF0YXNldFxuICAgICAqICAgICAvLyBmb3Igbm90IHNwZWNpZmllZCBkYXRhc2V0LCB3aWxsIGhhdmUgdGhlIGRlZmF1bHQgY29sb3IgdmFsdWVcbiAgICAgKiAgICAgY29sb3JzOiB7XG4gICAgICogICAgICAgIGRhdGExOiBcInllbGxvd1wiLFxuICAgICAqICAgICAgICBkYXRhMzogXCJncmVlblwiXG4gICAgICogICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgLy8gc2V0IHgsIHkgY29vcmRpbmF0ZSBwb3NpdGlvblxuICAgICAqICAgICBwb3NpdGlvbjoge1xuICAgICAqICAgICAgICB4OiAtMTAsXG4gICAgICogICAgICAgIHk6IDEwXG4gICAgICogICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgLy8gb3Igc2V0IHgsIHkgY29vcmRpbmF0ZSBwb3NpdGlvbiBieSBlYWNoIGRhdGFzZXRcbiAgICAgKiAgICAgcG9zaXRpb246IHtcbiAgICAgKiAgICAgICAgZGF0YTE6IHt4OiA1LCB5OiA1fSxcbiAgICAgKiAgICAgICAgZGF0YTI6IHt4OiAxMCwgeTogLTIwfVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfbGFiZWxzOiB7fSxcbiAgICBkYXRhX2xhYmVsc19jb2xvcnM6IHVuZGVmaW5lZCxcbiAgICBkYXRhX2xhYmVsc19wb3NpdGlvbjoge30sXG5cbiAgICAvKipcbiAgICAgKiAgVGhpcyBvcHRpb24gY2hhbmdlcyB0aGUgb3JkZXIgb2Ygc3RhY2tpbmcgZGF0YSBhbmQgcGllY2VzIG9mIHBpZS9kb251dC5cbiAgICAgKiAgLSBJZiBgbnVsbGAgc3BlY2lmaWVkLCBpdCB3aWxsIGJlIHRoZSBvcmRlciB0aGUgZGF0YSBsb2FkZWQuXG4gICAgICogIC0gSWYgZnVuY3Rpb24gc3BlY2lmaWVkLCBpdCB3aWxsIGJlIHVzZWQgYXMgW0FycmF5LnNvcnQgY29tcGFyZUZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0I1BhcmFtZXRlcnMpPGJyPjxicj5cbiAgICAgKlxuICAgICAqICAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcbiAgICAgKiAgLSBgZGVzY2A6IEluIGRlc2NlbmRpbmcgb3JkZXJcbiAgICAgKiAgLSBgYXNjYDogSW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICogIC0gYG51bGxgOiBJdCBrZWVwcyB0aGUgZGF0YSBsb2FkIG9yZGVyXG4gICAgICogIC0gYGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyAuLi4gfWA6IEFycmF5LnNvcnQgY29tcGFyZUZ1bmN0aW9uXG4gICAgICogQG5hbWUgZGF0YeKApG9yZGVyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufG51bGx9XG4gICAgICogQGRlZmF1bHQgZGVzY1xuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFPcmRlcilcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgIC8vIGluIGRlc2NlbmRpbmcgb3JkZXIgKGRlZmF1bHQpXG4gICAgICogICBvcmRlcjogXCJkZXNjXCJcbiAgICAgKlxuICAgICAqICAgLy8gaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICogICBvcmRlcjogXCJhc2NcIlxuICAgICAqXG4gICAgICogICAvLyBrZWVwcyBkYXRhIGlucHV0IG9yZGVyXG4gICAgICogICBvcmRlcjogbnVsbFxuICAgICAqXG4gICAgICogICAvLyBzcGVjaWZ5aW5nIHNvcnQgZnVuY3Rpb25cbiAgICAgKiAgIG9yZGVyOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICAgICAgLy8gcGFyYW0gZGF0YSBwYXNzZWQgZm9ybWF0XG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgIGlkOiBcImRhdGExXCIsIGlkX29yZzogXCJkYXRhMVwiLCB2YWx1ZXM6IFtcbiAgICAgKiAgICAgICAgICAgICAge3g6IDUsIHZhbHVlOiAyNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA1LCBuYW1lOiBcImRhdGExXCJ9LFxuICAgICAqICAgICAgICAgICAgICAuLi5cbiAgICAgKiAgICAgICAgICBdXG4gICAgICogICAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX29yZGVyOiBcImRlc2NcIixcblxuICAgIC8qKlxuICAgICAqIERlZmluZSByZWdpb25zIGZvciBlYWNoIGRhdGEuPGJyPlxuICAgICAqIFRoZSB2YWx1ZXMgbXVzdCBiZSBhbiBhcnJheSBmb3IgZWFjaCBkYXRhIGFuZCBpdCBzaG91bGQgaW5jbHVkZSBhbiBvYmplY3QgdGhhdCBoYXMgYHN0YXJ0YCwgYGVuZGAgYW5kIGBzdHlsZWAuXG4gICAgICogLSBUaGUgb2JqZWN0IHR5cGUgc2hvdWxkIGJlIGFzOlxuICAgICAqICAgLSBzdGFydCB7TnVtYmVyfTogU3RhcnQgZGF0YSBwb2ludCBudW1iZXIuIElmIG5vdCBzZXQsIHRoZSBzdGFydCB3aWxsIGJlIHRoZSBmaXJzdCBkYXRhIHBvaW50LlxuICAgICAqICAgLSBbZW5kXSB7TnVtYmVyfTogRW5kIGRhdGEgcG9pbnQgbnVtYmVyLiBJZiBub3Qgc2V0LCB0aGUgZW5kIHdpbGwgYmUgdGhlIGxhc3QgZGF0YSBwb2ludC5cbiAgICAgKiAgIC0gW3N0eWxlLmRhc2hhcnJheT1cIjIgMlwiXSB7T2JqZWN0fTogVGhlIGZpcnN0IG51bWJlciBzcGVjaWZpZXMgYSBkaXN0YW5jZSBmb3IgdGhlIGZpbGxlZCBhcmVhLCBhbmQgdGhlIHNlY29uZCBhIGRpc3RhbmNlIGZvciB0aGUgdW5maWxsZWQgYXJlYS5cbiAgICAgKiAtICoqTk9URToqKiBDdXJyZW50bHkgdGhpcyBvcHRpb24gc3VwcG9ydHMgb25seSBsaW5lIGNoYXJ0IGFuZCBkYXNoZWQgc3R5bGUuIElmIHRoaXMgb3B0aW9uIHNwZWNpZmllZCwgdGhlIGxpbmUgd2lsbCBiZSBkYXNoZWQgb25seSBpbiB0aGUgcmVnaW9ucy5cbiAgICAgKiBAbmFtZSBkYXRh4oCkcmVnaW9uc1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVmYXVsdCB7fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGF0YToge1xuICAgICAqICAgcmVnaW9uczoge1xuICAgICAqICAgICBkYXRhMTogW3tcbiAgICAgKiAgICAgICAgIHN0YXJ0OiAxLFxuICAgICAqICAgICAgICAgZW5kOiAyLFxuICAgICAqICAgICAgICAgc3R5bGU6IHtcbiAgICAgKiAgICAgICAgICAgICBkYXNoYXJyYXk6IFwiNSAyXCJcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgfSwge1xuICAgICAqICAgICAgICAgc3RhcnQ6IDNcbiAgICAgKiAgICAgfV0sXG4gICAgICogICAgIC4uLlxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX3JlZ2lvbnM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGNvbG9yIGNvbnZlcnRlciBmdW5jdGlvbi48YnI+PGJyPlxuICAgICAqIFRoaXMgb3B0aW9uIHNob3VsZCBhIGZ1bmN0aW9uIGFuZCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIGNvbG9yIChlLmcuICcjZmYwMDAwJykgYW5kIGQgdGhhdCBoYXMgZGF0YSBwYXJhbWV0ZXJzIGxpa2UgaWQsIHZhbHVlLCBpbmRleCwgZXRjLiBBbmQgaXQgbXVzdCByZXR1cm4gYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGNvbG9yIChlLmcuICcjMDBmZjAwJykuXG4gICAgICogQG5hbWUgZGF0YeKApGNvbG9yXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUNvbG9yKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGF0YToge1xuICAgICAqICAgY29sb3I6IGZ1bmN0aW9uKGNvbG9yLCBkKSB7IC4uLiB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfY29sb3I6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFNldCBjb2xvciBmb3IgZWFjaCBkYXRhLlxuICAgICAqIEBuYW1lIGRhdGHigKRjb2xvcnNcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHQge31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgIGNvbG9yczoge1xuICAgICAqICAgICBkYXRhMTogXCIjZmYwMDAwXCIsXG4gICAgICogICAgIGRhdGEyOiBmdW5jdGlvbihkKSB7XG4gICAgICogICAgICAgIHJldHVybiBcIiMwMDBcIjtcbiAgICAgKiAgICAgfVxuICAgICAqICAgICAuLi5cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV9jb2xvcnM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBlYWNoIGRhdGEgd2hlbiB0aGUgY2hhcnQgYXBwZWFycy48YnI+PGJyPlxuICAgICAqIElmIHRydWUgc3BlY2lmaWVkLCBhbGwgb2YgZGF0YSB3aWxsIGJlIGhpZGRlbi4gSWYgbXVsdGlwbGUgaWRzIHNwZWNpZmllZCBhcyBhbiBhcnJheSwgdGhvc2Ugd2lsbCBiZSBoaWRkZW4uXG4gICAgICogQG5hbWUgZGF0YeKApGhpZGVcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtCb29sZWFufEFycmF5fVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICogICAvLyBhbGwgb2YgZGF0YSB3aWxsIGJlIGhpZGRlblxuICAgICAqICAgaGlkZTogdHJ1ZVxuICAgICAqXG4gICAgICogICAvLyBzcGVjaWZpZWQgZGF0YSB3aWxsIGJlIGhpZGRlblxuICAgICAqICAgaGlkZTogW1wiZGF0YTFcIiwgLi4uXVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX2hpZGU6ICExLFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHZhbHVlcyB0byBiZSBzaG93blxuICAgICAqIFRoZSBkYXRhIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSByZXR1cm5lZCBieSBgLmRhdGEoKWAuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXJcbiAgICAgKiBAbmFtZSBkYXRh4oCkZmlsdGVyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICogICAvLyBmaWx0ZXIgZm9yIGlkIHZhbHVlXG4gICAgICogICBmaWx0ZXI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgIC8vIHY6IFt7aWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogW1xuICAgICAqICAgICAgLy8gICAgICB7eDogMCwgdmFsdWU6IDEzMCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDB9LCAuLi5dXG4gICAgICogICAgICAvLyAgICB9LCAuLi5dXG4gICAgICogICAgICByZXR1cm4gdi5pZCAhPT0gXCJkYXRhMVwiO1xuICAgICAqICAgfVxuICAgICAqL1xuICAgIGRhdGFfZmlsdGVyOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0YWNraW5nIHRvIGJlIG5vcm1hbGl6ZWRcbiAgICAgKiAtICoqTk9URToqKlxuICAgICAqICAgLSBGb3Igc3RhY2tpbmcsICdbZGF0YS5ncm91cHNdKCMuZGF0YSUyNUUyJTI1ODAlMjVBNGdyb3VwcyknIG9wdGlvbiBzaG91bGQgYmUgc2V0XG4gICAgICogICAtIHkgQXhpcyB3aWxsIGJlIHNldCBpbiBwZXJjZW50YWdlIHZhbHVlICgwIH4gMTAwJSlcbiAgICAgKiAgIC0gTXVzdCBoYXZlIHBvc3RpdmUgdmFsdWVzXG4gICAgICogQG5hbWUgZGF0YeKApHN0YWNr4oCkbm9ybWFsaXplXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFTdGFja05vcm1hbGl6ZWQpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICAgICogICBzdGFjazoge1xuICAgICAgICAqICAgICAgbm9ybWFsaXplOiB0cnVlXG4gICAgICAgICogICB9XG4gICAgICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfc3RhY2tfbm9ybWFsaXplOiAhMSxcblxuICAgIC8qKlxuICAgICAqIFNldCBkYXRhIHNlbGVjdGlvbiBlbmFibGVkPGJyPjxicj5cbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQgdHJ1ZSwgd2UgY2FuIHNlbGVjdCB0aGUgZGF0YSBwb2ludHMgYW5kIGdldC9zZXQgaXRzIHN0YXRlIG9mIHNlbGVjdGlvbiBieSBBUEkgKGUuZy4gc2VsZWN0LCB1bnNlbGVjdCwgc2VsZWN0ZWQpLlxuICAgICAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRlbmFibGVkXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFTZWxlY3Rpb24pXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICogICAgc2VsZWN0aW9uOiB7XG4gICAgICogICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAqICAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV9zZWxlY3Rpb25fZW5hYmxlZDogITEsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZ3JvdXBlZCBzZWxlY3Rpb24gZW5hYmxlZC48YnI+PGJyPlxuICAgICAqIElmIHRoaXMgb3B0aW9uIHNldCB0cnVlLCBtdWx0aXBsZSBkYXRhIHBvaW50cyB0aGF0IGhhdmUgc2FtZSB4IHZhbHVlIHdpbGwgYmUgc2VsZWN0ZWQgYnkgb25lIHNlbGVjdGlvbi5cbiAgICAgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZ3JvdXBlZFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgICBzZWxlY3Rpb246IHtcbiAgICAgKiAgICAgICBncm91cGVkOiB0cnVlXG4gICAgICogICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX3NlbGVjdGlvbl9ncm91cGVkOiAhMSxcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGNhbGxiYWNrIGZvciBlYWNoIGRhdGEgcG9pbnQgdG8gZGV0ZXJtaW5lIGlmIGl0J3Mgc2VsZWN0YWJsZSBvciBub3QuPGJyPjxicj5cbiAgICAgKiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIGQgYXMgYW4gYXJndW1lbnQgYW5kIGl0IGhhcyBzb21lIHBhcmFtZXRlcnMgbGlrZSBpZCwgdmFsdWUsIGluZGV4LiBUaGlzIGNhbGxiYWNrIHNob3VsZCByZXR1cm4gYm9vbGVhbi5cbiAgICAgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkaXNzZWxlY3RhYmxlXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICogICAgc2VsZWN0aW9uOiB7XG4gICAgICogICAgICAgaXNzZWxlY3RhYmxlOiBmdW5jdGlvbihkKSB7IC4uLiB9XG4gICAgICogICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGU6IGZ1bmN0aW9uIGRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZSgpIHtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IG11bHRpcGxlIGRhdGEgcG9pbnRzIHNlbGVjdGlvbiBlbmFibGVkLjxicj48YnI+XG4gICAgICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIG11bHRpbGUgZGF0YSBwb2ludHMgY2FuIGhhdmUgdGhlIHNlbGVjdGVkIHN0YXRlIGF0IHRoZSBzYW1lIHRpbWUuIElmIGZhbHNlIHNldCwgb25seSBvbmUgZGF0YSBwb2ludCBjYW4gaGF2ZSB0aGUgc2VsZWN0ZWQgc3RhdGUgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSB1bnNlbGVjdGVkIHdoZW4gdGhlIG5ldyBkYXRhIHBvaW50IGlzIHNlbGVjdGVkLlxuICAgICAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRtdWx0aXBsZVxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGF0YToge1xuICAgICAqICAgIHNlbGVjdGlvbjoge1xuICAgICAqICAgICAgIG11bHRpcGxlOiBmYWxzZVxuICAgICAqICAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGU6ICEwLFxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRvIHNlbGVjdCBkYXRhIHBvaW50cyBieSBkcmFnZ2luZy5cbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgZGF0YSBwb2ludHMgY2FuIGJlIHNlbGVjdGVkIGJ5IGRyYWdnaW5nLlxuICAgICAqIC0gKipOT1RFOioqIElmIHRoaXMgb3B0aW9uIHNldCB0cnVlLCBzY3JvbGxpbmcgb24gdGhlIGNoYXJ0IHdpbGwgYmUgZGlzYWJsZWQgYmVjYXVzZSBkcmFnZ2luZyBldmVudCB3aWxsIGhhbmRsZSB0aGUgZXZlbnQuXG4gICAgICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApGRyYWdnYWJsZVxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgICBzZWxlY3Rpb246IHtcbiAgICAgKiAgICAgICBkcmFnZ2FibGU6IHRydWVcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV9zZWxlY3Rpb25fZHJhZ2dhYmxlOiAhMSxcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGNhbGxiYWNrIGZvciBjbGljayBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cbiAgICAgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gZWFjaCBkYXRhIHBvaW50IGNsaWNrZWQgYW5kIHdpbGwgcmVjZWl2ZSBgZGAgYW5kIGVsZW1lbnQgYXMgdGhlIGFyZ3VtZW50cy5cbiAgICAgKiAtIGBkYCBpcyB0aGUgZGF0YSBjbGlja2VkIGFuZCBlbGVtZW50IGlzIHRoZSBlbGVtZW50IGNsaWNrZWQuXG4gICAgICogLSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpbmcgc3ZnIGVsZW1lbnQuXG4gICAgICogLSBJbiB0aGlzIGNhbGxiYWNrLCBgdGhpc2Agd2lsbCBiZSB0aGUgQ2hhcnQgb2JqZWN0LlxuICAgICAqIEBuYW1lIGRhdGHigKRvbmNsaWNrXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGF0YToge1xuICAgICAqICAgICBvbmNsaWNrOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XG4gICAgICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGExXCJ9XG4gICAgICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxuICAgICAqICAgICAgICAuLi5cbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX29uY2xpY2s6IGZ1bmN0aW9uIGRhdGFfb25jbGljaygpIHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG1vdXNlL3RvdWNoIG92ZXIgZXZlbnQgb24gZWFjaCBkYXRhIHBvaW50Ljxicj48YnI+XG4gICAgICogVGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIG1vdXNlIGN1cnNvciBvciB2aWEgdG91Y2ggbW92ZXMgb250byBlYWNoIGRhdGEgcG9pbnQgYW5kIHdpbGwgcmVjZWl2ZSBgZGAgYW5kIGBlbGVtZW50YCBhcyB0aGUgYXJndW1lbnQuXG4gICAgICogLSBgZGAgaXMgdGhlIGRhdGEgd2hlcmUgbW91c2UgY3Vyc29yIG1vdmVzIG9udG8uXG4gICAgICogLSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpbmcgc3ZnIGVsZW1lbnQuXG4gICAgICogLSBJbiB0aGlzIGNhbGxiYWNrLCBgdGhpc2Agd2lsbCBiZSB0aGUgQ2hhcnQgb2JqZWN0LlxuICAgICAqIEBuYW1lIGRhdGHigKRvbm92ZXJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICogICAgIG9ub3ZlcjogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xuICAgICAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNH1cbiAgICAgKiAgICAgICAgLy8gZWxlbWVudCAtIDxjaXJjbGU+XG4gICAgICogICAgICAgIC4uLlxuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfb25vdmVyOiBmdW5jdGlvbiBkYXRhX29ub3ZlcigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG1vdXNlL3RvdWNoIG91dCBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cbiAgICAgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gbW91c2UgY3Vyc29yIG9yIHZpYSB0b3VjaCBtb3ZlcyBvdXQgZWFjaCBkYXRhIHBvaW50IGFuZCB3aWxsIHJlY2VpdmUgYGRgIGFzIHRoZSBhcmd1bWVudC5cbiAgICAgKiAtIGBkYCBpcyB0aGUgZGF0YSB3aGVyZSBtb3VzZSBjdXJzb3IgbW92ZXMgb3V0LlxuICAgICAqIC0gYGVsZW1lbnRgIGlzIHRoZSBjdXJyZW50IGludGVyYWN0aW5nIHN2ZyBlbGVtZW50LlxuICAgICAqIC0gSW4gdGhpcyBjYWxsYmFjaywgYHRoaXNgIHdpbGwgYmUgdGhlIENoYXJ0IG9iamVjdC5cbiAgICAgKiBAbmFtZSBkYXRh4oCkb25vdXRcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICogICAgIG9ub3V0OiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XG4gICAgICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0fVxuICAgICAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cbiAgICAgKiAgICAgICAgLi4uXG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV9vbm91dDogZnVuY3Rpb24gZGF0YV9vbm91dCgpIHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG9uIGRhdGEgc2VsZWN0aW9uLlxuICAgICAqIEBuYW1lIGRhdGHigKRvbnNlbGVjdGVkXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGF0YToge1xuICAgICAqICAgICBvbnNlbGVjdGVkOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XG4gICAgICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGExXCJ9XG4gICAgICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxuICAgICAqICAgICAgICAuLi5cbiAgICAgKiAgICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfb25zZWxlY3RlZDogZnVuY3Rpb24gZGF0YV9vbnNlbGVjdGVkKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBjYWxsYmFjayBmb3Igb24gZGF0YSB1bi1zZWxlY3Rpb24uXG4gICAgICogQG5hbWUgZGF0YeKApG9udW5zZWxlY3RlZFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgICAgb251bnNlbGVjdGVkOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XG4gICAgICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGExXCJ9XG4gICAgICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxuICAgICAqICAgICAgICAuLi5cbiAgICAgKiAgICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfb251bnNlbGVjdGVkOiBmdW5jdGlvbiBkYXRhX29udW5zZWxlY3RlZCgpIHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG1pbmltdW0gZGF0YVxuICAgICAqIC0gKipOT1RFOioqIEZvciAnYXJlYS1saW5lLXJhbmdlJyBhbmQgJ2FyZWEtc3BsaW5lLXJhbmdlJywgYG1pZGAgZGF0YSB3aWxsIGJlIHRha2VuIGZvciB0aGUgY29tcGFyaXNvblxuICAgICAqIEBuYW1lIGRhdGHigKRvbm1pblxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLk9uTWluTWF4Q2FsbGJhY2spXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgb25taW46IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAgICAvLyBkYXRhIC0gZXgpIFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi4gXVxuICAgICAgICAqICAgIC4uLlxuICAgICAqICB9XG4gICAgICovXG4gICAgZGF0YV9vbm1pbjogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG1heGltdW0gZGF0YVxuICAgICAqIC0gKipOT1RFOioqIEZvciAnYXJlYS1saW5lLXJhbmdlJyBhbmQgJ2FyZWEtc3BsaW5lLXJhbmdlJywgYG1pZGAgZGF0YSB3aWxsIGJlIHRha2VuIGZvciB0aGUgY29tcGFyaXNvblxuICAgICAqIEBuYW1lIGRhdGHigKRvbm1heFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLk9uTWluTWF4Q2FsbGJhY2spXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgb25tYXg6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAgICAvLyBkYXRhIC0gZXgpIFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi4gXVxuICAgICAgICAqICAgIC4uLlxuICAgICAqICB9XG4gICAgICovXG4gICAgZGF0YV9vbm1heDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIENTViBvciBKU09OIGZpbGUgZnJvbSBhIFVSTC4gTk9URSB0aGF0IHRoaXMgd2lsbCBub3Qgd29yayBpZiBsb2FkaW5nIHZpYSB0aGUgXCJmaWxlOi8vXCIgcHJvdG9jb2wgYXMgdGhlIG1vc3QgYnJvd3NlcnMgd2lsbCBibG9jayBYTUxIVFRQUmVxdWVzdHMuXG4gICAgICogQG5hbWUgZGF0YeKApHVybFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5Mb2FkRGF0YSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgICAgdXJsOiBcIi9kYXRhL3Rlc3QuY3N2XCJcbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV91cmw6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFhIUiBoZWFkZXIgdmFsdWVcbiAgICAgKiAtICoqTk9URToqKiBTaG91bGQgYmUgdXNlZCB3aXRoIGBkYXRhLnVybGAgb3B0aW9uXG4gICAgICogQG5hbWUgZGF0YeKApGhlYWRlcnNcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3Qvc2V0UmVxdWVzdEhlYWRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGF0YToge1xuICAgICAqICAgICB1cmw6IFwiL2RhdGEvdGVzdC5jc3ZcIixcbiAgICAgKiAgICAgaGVhZGVyczoge1xuICAgICAqICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQveG1sXCIsXG4gICAgICogICAgICAgIC4uLlxuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfaGVhZGVyczogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBKU09OIG9iamVjdCBmb3IgZGF0YS4gU2VlIGFsc28gZGF0YS5rZXlzLlxuICAgICAqIEBuYW1lIGRhdGHigKRqc29uXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBzZWUgW2RhdGHigKRrZXlzXSgjLmRhdGElMjVFMiUyNTgwJTI1QTRrZXlzKVxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkpTT05EYXRhKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGF0YToge1xuICAgICAqICAgICBqc29uOiBbXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGUxLmNvbVwiLCB1cGxvYWQ6IDIwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDQwMH0sXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGUyLmNvbVwiLCB1cGxvYWQ6IDEwMCwgZG93bmxvYWQ6IDMwMCwgdG90YWw6IDQwMH0sXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGUzLmNvbVwiLCB1cGxvYWQ6IDMwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDUwMH0sXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGU0LmNvbVwiLCB1cGxvYWQ6IDQwMCwgZG93bmxvYWQ6IDEwMCwgdG90YWw6IDUwMH1cbiAgICAgKiAgICAgXSxcbiAgICAgKiAgICAga2V5czoge1xuICAgICAqICAgICAgIC8vIHg6IFwibmFtZVwiLCAvLyBpdCdzIHBvc3NpYmxlIHRvIHNwZWNpZnkgJ3gnIHdoZW4gY2F0ZWdvcnkgYXhpc1xuICAgICAqICAgICAgIHZhbHVlOiBbXCJ1cGxvYWRcIiwgXCJkb3dubG9hZFwiXVxuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfanNvbjogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogTG9hZCBkYXRhIGZyb20gYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5LCB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGRhdGEgbmFtZXMsIHRoZSBmb2xsb3dpbmcgY29udGFpbmluZyByZWxhdGVkIGRhdGEgaW4gdGhhdCBvcmRlci5cbiAgICAgKiBAbmFtZSBkYXRh4oCkcm93c1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLlJvd09yaWVudGVkRGF0YSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgIHJvd3M6IFtcbiAgICAgKiAgICAgW1wiQVwiLCBcIkJcIiwgXCJDXCJdLFxuICAgICAqICAgICBbOTAsIDEyMCwgMzAwXSxcbiAgICAgKiAgICAgWzQwLCAxNjAsIDI0MF0sXG4gICAgICogICAgIFs1MCwgMjAwLCAyOTBdLFxuICAgICAqICAgICBbMTIwLCAxNjAsIDIzMF0sXG4gICAgICogICAgIFs4MCwgMTMwLCAzMDBdLFxuICAgICAqICAgICBbOTAsIDIyMCwgMzIwXVxuICAgICAqICAgXVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIGZvciAncmFuZ2UnIHR5cGVzKCdhcmVhLWxpbmUtcmFuZ2UnIG9yICdhcmVhLXNwbGluZS1yYW5nZScpLCBkYXRhIHNob3VsZCBjb250YWluOlxuICAgICAqIC8vIC0gYW4gYXJyYXkgb2YgW2hpZ2gsIG1pZCwgbG93XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcbiAgICAgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICdoaWdoJywgJ21pZCcgYW5kICdsb3cnIGtleSB2YWx1ZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgIHJvd3M6IFtcbiAgICAgKiAgICAgIFtcImRhdGExXCIsIFwiZGF0YTJcIl0sXG4gICAgICogICAgICBbXG4gICAgICogICAgICAgIC8vIG9yIHtoaWdoOjE1MCwgbWlkOiAxNDAsIGxvdzogMTEwfSwgMTIwXG4gICAgICogICAgICAgIFsxNTAsIDE0MCwgMTEwXSwgMTIwXG4gICAgICogICAgICBdLFxuICAgICAqICAgICAgW1sxNTUsIDEzMCwgMTE1XSwgNTVdLFxuICAgICAqICAgICAgW1sxNjAsIDEzNSwgMTIwXSwgNjBdXG4gICAgICogICBdLFxuICAgICAqICAgdHlwZXM6IHtcbiAgICAgKiAgICAgICBkYXRhMTogXCJhcmVhLWxpbmUtcmFuZ2VcIixcbiAgICAgKiAgICAgICBkYXRhMjogXCJsaW5lXCJcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyBmb3IgJ2J1YmJsZScgdHlwZSwgZGF0YSBjYW4gY29udGFpbiBkaW1lbnNpb24gdmFsdWU6XG4gICAgICogLy8gLSBhbiBhcnJheSBvZiBbeSwgel0gZGF0YSBmb2xsb3dpbmcgdGhlIG9yZGVyXG4gICAgICogLy8gLSBvciBhbiBvYmplY3Qgd2l0aCAneScgYW5kICd6JyBrZXkgdmFsdWVcbiAgICAgKiAvLyAneScgaXMgZm9yIHkgYXhpcyBjb29yZGluYXRpb24gYW5kICd6JyBpcyB0aGUgYnViYmxlIHJhZGl1cyB2YWx1ZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgIHJvd3M6IFtcbiAgICAgKiAgICAgIFtcImRhdGExXCIsIFwiZGF0YTJcIl0sXG4gICAgICogICAgICBbXG4gICAgICogICAgICAgIC8vIG9yIHt5OjEwLCB6OiAxNDB9LCAxMjBcbiAgICAgKiAgICAgICAgWzEwLCAxNDBdLCAxMjBcbiAgICAgKiAgICAgIF0sXG4gICAgICogICAgICBbWzEwMCwgMzBdLCA1NV0sXG4gICAgICogICAgICBbWzUwLCAxMDBdLCA2MF1cbiAgICAgKiAgIF0sXG4gICAgICogICB0eXBlczoge1xuICAgICAqICAgICAgIGRhdGExOiBcImJ1YmJsZVwiLFxuICAgICAqICAgICAgIGRhdGEyOiBcImxpbmVcIlxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX3Jvd3M6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIExvYWQgZGF0YSBmcm9tIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSwgd2l0aCBlYWNoIGVsZW1lbnQgY29udGFpbmluZyBhbiBhcnJheSBjb25zaXN0aW5nIG9mIGEgZGF0dW0gbmFtZSBhbmQgYXNzb2NpYXRlZCBkYXRhIHZhbHVlcy5cbiAgICAgKiBAbmFtZSBkYXRh4oCkY29sdW1uc1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkNvbHVtbk9yaWVudGVkRGF0YSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgIGNvbHVtbnM6IFtcbiAgICAgKiAgICAgIFtcImRhdGExXCIsIDMwLCAyMCwgNTAsIDQwLCA2MCwgNTBdLFxuICAgICAqICAgICAgW1wiZGF0YTJcIiwgMjAwLCAxMzAsIDkwLCAyNDAsIDEzMCwgMjIwXSxcbiAgICAgKiAgICAgIFtcImRhdGEzXCIsIDMwMCwgMjAwLCAxNjAsIDQwMCwgMjUwLCAyNTBdXG4gICAgICogICBdXG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gZm9yICdyYW5nZScgdHlwZXMoJ2FyZWEtbGluZS1yYW5nZScgb3IgJ2FyZWEtc3BsaW5lLXJhbmdlJyksIGRhdGEgc2hvdWxkIGNvbnRhaW46XG4gICAgICogLy8gLSBhbiBhcnJheSBvZiBbaGlnaCwgbWlkLCBsb3ddIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxuICAgICAqIC8vIC0gb3IgYW4gb2JqZWN0IHdpdGggJ2hpZ2gnLCAnbWlkJyBhbmQgJ2xvdycga2V5IHZhbHVlXG4gICAgICogZGF0YToge1xuICAgICAqICAgY29sdW1uczogW1xuICAgICAqICAgICAgW1wiZGF0YTFcIixcbiAgICAgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF0sICAvLyBvciB7aGlnaDoxNTAsIG1pZDogMTQwLCBsb3c6IDExMH1cbiAgICAgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF0sXG4gICAgICogICAgICAgICAgWzE1MCwgMTQwLCAxMTBdXG4gICAgICogICAgICBdXG4gICAgICogICBdLFxuICAgICAqICAgdHlwZTogXCJhcmVhLWxpbmUtcmFuZ2VcIlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIGZvciAnYnViYmxlJyB0eXBlLCBkYXRhIGNhbiBjb250YWluIGRpbWVuc2lvbiB2YWx1ZTpcbiAgICAgKiAvLyAtIGFuIGFycmF5IG9mIFt5LCB6XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcbiAgICAgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICd5JyBhbmQgJ3onIGtleSB2YWx1ZVxuICAgICAqIC8vICd5JyBpcyBmb3IgeSBheGlzIGNvb3JkaW5hdGlvbiBhbmQgJ3onIGlzIHRoZSBidWJibGUgcmFkaXVzIHZhbHVlXG4gICAgICogZGF0YToge1xuICAgICAqICAgY29sdW1uczogW1xuICAgICAqICAgICAgW1wiZGF0YTFcIixcbiAgICAgKiAgICAgICAgICBbMTAsIDE0MF0sICAvLyBvciB7eToxMCwgejogMTQwfVxuICAgICAqICAgICAgICAgIFsxMDAsIDMwXSxcbiAgICAgKiAgICAgICAgICBbNTAsIDEwMF1cbiAgICAgKiAgICAgIF1cbiAgICAgKiAgIF0sXG4gICAgICogICB0eXBlOiBcImJ1YmJsZVwiXG4gICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfY29sdW1uczogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogVXNlZCBpZiBsb2FkaW5nIEpTT04gdmlhIGRhdGEudXJsLlxuICAgICAqIC0gKipBdmFpbGFibGUgVmFsdWVzOioqXG4gICAgICogICAtIGpzb25cbiAgICAgKiAgIC0gY3N2XG4gICAgICogICAtIHRzdlxuICAgICAqIEBuYW1lIGRhdGHigKRtaW1lVHlwZVxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjc3ZcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgICAgbWltZVR5cGU6IFwianNvblwiXG4gICAgICogfVxuICAgICAqL1xuICAgIGRhdGFfbWltZVR5cGU6IFwiY3N2XCIsXG5cbiAgICAvKipcbiAgICAgKiBDaG9vc2Ugd2hpY2ggSlNPTiBvYmplY3Qga2V5cyBjb3JyZXNwb25kIHRvIGRlc2lyZWQgZGF0YS5cbiAgICAgKiAtICoqTk9URToqKiBPbmx5IGZvciBKU09OIG9iamVjdCBnaXZlbiBhcyBhcnJheS5cbiAgICAgKiBAbmFtZSBkYXRh4oCka2V5c1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgICAganNvbjogW1xuICAgICAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMS5jb21cIiwgdXBsb2FkOiAyMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA0MDB9LFxuICAgICAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMi5jb21cIiwgdXBsb2FkOiAxMDAsIGRvd25sb2FkOiAzMDAsIHRvdGFsOiA0MDB9LFxuICAgICAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMy5jb21cIiwgdXBsb2FkOiAzMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA1MDB9LFxuICAgICAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlNC5jb21cIiwgdXBsb2FkOiA0MDAsIGRvd25sb2FkOiAxMDAsIHRvdGFsOiA1MDB9XG4gICAgICogICAgIF0sXG4gICAgICogICAgIGtleXM6IHtcbiAgICAgKiAgICAgICAvLyB4OiBcIm5hbWVcIiwgLy8gaXQncyBwb3NzaWJsZSB0byBzcGVjaWZ5ICd4JyB3aGVuIGNhdGVnb3J5IGF4aXNcbiAgICAgKiAgICAgICB2YWx1ZTogW1widXBsb2FkXCIsIFwiZG93bmxvYWRcIl1cbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkYXRhX2tleXM6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFNldCB0ZXh0IGxhYmVsIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZXJlJ3Mgbm8gZGF0YSB0byBzaG93LlxuICAgICAqIC0gZXguIFRvZ2dsaW5nIGFsbCB2aXNpYmxlIGRhdGEgdG8gbm90IGJlIHNob3duLCB1bmxvYWRpbmcgYWxsIGN1cnJlbnQgZGF0YSwgZXRjLlxuICAgICAqIEBuYW1lIGRhdGHigKRlbXB0eeKApGxhYmVs4oCkdGV4dFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcIlwiXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhOiB7XG4gICAgICogICBlbXB0eToge1xuICAgICAqICAgICBsYWJlbDoge1xuICAgICAqICAgICAgIHRleHQ6IFwiTm8gRGF0YVwiXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZGF0YV9lbXB0eV9sYWJlbF90ZXh0OiBcIlwiLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHN1YmNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAbmFtZSBzdWJjaGFydFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzdWJjaGFydC5zaG93PWZhbHNlXSBTaG93IHN1YiBjaGFydCBvbiB0aGUgYm90dG9tIG9mIHRoZSBjaGFydC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzdWJjaGFydC5heGlzLnguc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgeCBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3N1YmNoYXJ0LmF4aXMueC50aWNrLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIGxpbmUuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbc3ViY2hhcnQuYXhpcy54LnRpY2sudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayB0ZXh0LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc3ViY2hhcnQuc2l6ZS5oZWlnaHRdIENoYW5nZSB0aGUgaGVpZ2h0IG9mIHRoZSBzdWJjaGFydC5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbc3ViY2hhcnQub25icnVzaF0gU2V0IGNhbGxiYWNrIGZvciBicnVzaCBldmVudC48YnI+XG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgY3VycmVudCB6b29tZWQgeCBkb21haW4uXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLlN1YkNoYXJ0KVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHN1YmNoYXJ0OiB7XG4gICAgICogICAgICBheGlzOiB7XG4gICAgICogICAgICBcdHg6IHtcbiAgICAgKiAgICAgIFx0ICBzaG93OiB0cnVlLFxuICAgICAqICAgICAgXHQgICAgdGljazoge1xuICAgICAqICAgICAgXHQgICAgICBzaG93OiB0cnVlLFxuICAgICAqICAgICAgXHQgICAgICB0ZXh0OiB7XG4gICAgICogICAgICBcdCAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgKiAgICAgIFx0ICAgICAgfVxuICAgICAqICAgICAgXHQgICAgfVxuICAgICAqICAgICAgXHR9XG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgKiAgICAgIHNpemU6IHtcbiAgICAgKiAgICAgICAgICBoZWlnaHQ6IDIwXG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgb25icnVzaDogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9XG4gICAgICogIH1cbiAgICAgKi9cbiAgICBzdWJjaGFydF9zaG93OiAhMSxcbiAgICBzdWJjaGFydF9zaXplX2hlaWdodDogNjAsXG4gICAgc3ViY2hhcnRfYXhpc194X3Nob3c6ICEwLFxuICAgIHN1YmNoYXJ0X2F4aXNfeF90aWNrX3Nob3c6ICEwLFxuICAgIHN1YmNoYXJ0X2F4aXNfeF90aWNrX3RleHRfc2hvdzogITAsXG4gICAgc3ViY2hhcnRfb25icnVzaDogZnVuY3Rpb24gc3ViY2hhcnRfb25icnVzaCgpIHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGNvbG9yIG9mIHRoZSBkYXRhIHZhbHVlc1xuICAgICAqIEBuYW1lIGNvbG9yXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gW2NvbG9yLm9ub3Zlcl0gU2V0IHRoZSBjb2xvciB2YWx1ZSBmb3IgZWFjaCBkYXRhIHBvaW50IHdoZW4gbW91c2UvdG91Y2ggb25vdmVyIGV2ZW50IG9jY3Vycy5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fG51bGx9IFtjb2xvci5wYXR0ZXJuPVtdXSBTZXQgY3VzdG9tIGNvbG9yIHBhdHRlcm4uIFBhc3NpbmcgYG51bGxgIHdpbGwgbm90IHNldCBhIGNvbG9yIGZvciB0aGVzZSBlbGVtZW50cywgd2hpY2ggcmVxdWlyZXMgdGhlIHVzYWdlIG9mIGN1c3RvbSBDU1MtYmFzZWQgdGhlbWluZyB0byB3b3JrLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjb2xvci50aWxlc10gaWYgZGVmaW5lZCwgYWxsb3dzIHVzZSBzdmcncyBwYXR0ZXJucyB0byBmaWxsIGRhdGEgYXJlYS4gSXQgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBbU1ZHUGF0dGVybkVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdQYXR0ZXJuRWxlbWVudCkuXG4gICAgICogIC0gKipOT1RFOioqIFRoZSBwYXR0ZXJuIGVsZW1lbnQncyBpZCB3aWxsIGJlIGRlZmluZWQgYXMgYGJiLWNvbG9yaXplLXBhdHRlcm4tJENPTE9SLVZBTFVFYC48YnI+XG4gICAgICogICAgZXguIFdoZW4gY29sb3IgcGF0dGVybiB2YWx1ZSBpcyBgWydyZWQnLCAnI2ZmZiddYCBhbmQgZGVmaW5lZCAyIHBhdHRlcm5zLHRoZW4gaWRzIGZvciBwYXR0ZXJuIGVsZW1lbnRzIGFyZTo8YnI+XG4gICAgICogICAgLSBgYmItY29sb3JpemUtcGF0dGVybi1yZWRgXG4gICAgICogICAgLSBgYmItY29sb3JpemUtcGF0dGVybi1mZmZgXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IFtjb2xvci50aHJlc2hvbGRdIGNvbG9yIHRocmVzaG9sZCBmb3IgZ2F1Z2UgYW5kIHRvb2x0aXAgY29sb3JcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NvbG9yLnRocmVzaG9sZC51bml0XSBJZiBzZXQgdG8gYHZhbHVlYCwgdGhlIHRocmVzaG9sZCB3aWxsIGJlIGJhc2VkIG9uIHRoZSBkYXRhIHZhbHVlLiBPdGhlcndpc2UgaXQnbGwgYmUgYmFzZWQgb24gZXF1YXRpb24gb2YgdGhlIGB0aHJlc2hvbGQubWF4YCBvcHRpb24gdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gW2NvbG9yLnRocmVzaG9sZC52YWx1ZXNdIFRocmVzaG9sZCB2YWx1ZXMgZm9yIGVhY2ggc3RlcHNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2NvbG9yLnRocmVzaG9sZC5tYXg9MTAwXSBUaGUgYmFzZSB2YWx1ZSB0byBkZXRlcm1pbmUgdGhyZXNob2xkIHN0ZXAgdmFsdWUgY29uZGl0aW9uLiBXaGVuIHRoZSBnaXZlbiB2YWx1ZSBpcyAxNSBhbmQgbWF4IDEwLCB0aGVuIHRoZSB2YWx1ZSBmb3IgdGhyZXNob2xkIGlzIGAxNSoxMDAvMTBgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIGNvbG9yOiB7XG4gICAgICogICAgICBwYXR0ZXJuOiBbXCIjMWY3N2I0XCIsIFwiI2FlYzdlOFwiLCAuLi5dLFxuICAgICAqXG4gICAgICogICAgICAvLyBTZXQgY29sb3JzJyBwYXR0ZXJuc1xuICAgICAqICAgICAgLy8gaXQgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBTVkdQYXR0ZXJuRWxlbWVudFxuICAgICAqICAgICAgdGlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgdmFyIHBhdHRlcm4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdHRlcm5cIik7XG4gICAgICogICAgICAgICB2YXIgZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgICAgKiAgICAgICAgIHZhciBjaXJjbGUxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJjaXJjbGVcIik7XG4gICAgICpcbiAgICAgKiAgICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKFwicGF0dGVyblVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIik7XG4gICAgICogICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMzJcIik7XG4gICAgICogICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjMyXCIpO1xuICAgICAqXG4gICAgICogICAgICAgICBnLnN0eWxlLmZpbGwgPSBcIiMwMDBcIjtcbiAgICAgKiAgICAgICAgIGcuc3R5bGUub3BhY2l0eSA9IFwiMC4yXCI7XG4gICAgICAgICAgICAgICpcbiAgICAgKiAgICAgICAgIGNpcmNsZTEuc2V0QXR0cmlidXRlKFwiY3hcIiwgXCIzXCIpO1xuICAgICAqICAgICAgICAgY2lyY2xlMS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBcIjNcIik7XG4gICAgICogICAgICAgICBjaXJjbGUxLnNldEF0dHJpYnV0ZShcInJcIiwgXCIzXCIpO1xuICAgICAgICAgICAgICAqXG4gICAgICogICAgICAgICBnLmFwcGVuZENoaWxkKGNpcmNsZTEpO1xuICAgICAqICAgICAgICAgcGF0dGVybi5hcHBlbmRDaGlsZChnKTtcbiAgICAgKlxuICAgICAqICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuXTtcbiAgICAgKiAgICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgIC8vIGZvciB0aHJlc2hvbGQgdXNhZ2UsIHBhdHRlcm4gdmFsdWVzIHNob3VsZCBiZSBzZXQgZm9yIGVhY2ggc3RlcHNcbiAgICAgKiAgICAgIHBhdHRlcm46IFtcImdyZXlcIiwgXCJncmVlblwiLCBcInllbGxvd1wiLCBcIm9yYW5nZVwiLCBcInJlZFwiXSxcbiAgICAgKiAgICAgIHRocmVzaG9sZDoge1xuICAgICAqICAgICAgICAgIHVuaXQ6IFwidmFsdWVcIixcbiAgICAgKlxuICAgICAqICAgICAgICAgIC8vIHdoZW4gdmFsdWUgaXMgMjAgPT4gJ2dyZWVuJywgdmFsdWUgaXMgNDAgPT4gJ29yYW5nZScgd2lsbCBiZSBzZXQuXG4gICAgICogICAgICAgICAgdmFsdWVzOiBbMTAsIDIwLCAzMCwgNDAsIDUwXSxcbiAgICAgKlxuICAgICAqICAgICAgICAgIC8vIHRoZSBlcXVhdGlvbiBmb3IgbWF4OlxuICAgICAqICAgICAgICAgIC8vIC0gdW5pdCA9PSAndmFsdWUnOiBtYXggPT4gMzBcbiAgICAgKiAgICAgICAgICAvLyAtIHVuaXQgIT0gJ3ZhbHVlJzogbWF4ID0+IHZhbHVlKjEwMC8zMFxuICAgICAqICAgICAgICAgIG1heDogMzBcbiAgICAgKiAgICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgIC8vIHNldCBhbGwgZGF0YSB0byAncmVkJ1xuICAgICAqICAgICAgb25vdmVyOiBcInJlZFwiLFxuICAgICAqXG4gICAgICogICAgICAvLyBzZXQgZGlmZmVyZW50IGNvbG9yIGZvciBkYXRhXG4gICAgICogICAgICBvbm92ZXI6IHtcbiAgICAgKiAgICAgICAgICBkYXRhMTogXCJyZWRcIixcbiAgICAgKiAgICAgICAgICBkYXRhMjogXCJ5ZWxsb3dcIlxuICAgICAqICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAgLy8gd2lsbCBwYXNzIGRhdGEgb2JqZWN0IHRvIHRoZSBjYWxsYmFja1xuICAgICAqICAgICAgb25vdmVyOiBmdW5jdGlvbihkKSB7XG4gICAgICogICAgICAgICAgcmV0dXJuIGQuaWQgPT09IFwiZGF0YTFcIiA/IFwicmVkXCIgOiBcImdyZWVuXCI7XG4gICAgICogICAgICB9XG4gICAgICogIH1cbiAgICAgKi9cbiAgICBjb2xvcl9wYXR0ZXJuOiBbXSxcbiAgICBjb2xvcl90aWxlczogdW5kZWZpbmVkLFxuICAgIGNvbG9yX3RocmVzaG9sZDoge30sXG4gICAgY29sb3Jfb25vdmVyOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBMZWdlbmQgb3B0aW9uc1xuICAgICAqIEBuYW1lIGxlZ2VuZFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGVnZW5kLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xlZ2VuZC5oaWRlPWZhbHNlXSBIaWRlIGxlZ2VuZFxuICAgICAqICBJZiB0cnVlIGdpdmVuLCBhbGwgbGVnZW5kIHdpbGwgYmUgaGlkZGVuLiBJZiBzdHJpbmcgb3IgYXJyYXkgZ2l2ZW4sIG9ubHkgdGhlIGxlZ2VuZCB0aGF0IGhhcyB0aGUgaWQgd2lsbCBiZSBoaWRkZW4uXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR9IFtsZWdlbmQuY29udGVudHMuYmluZHRvPXVuZGVmaW5lZF0gU2V0IENTUyBzZWxlY3RvciBvciBlbGVtZW50IHJlZmVyZW5jZSB0byBiaW5kIGxlZ2VuZCBpdGVtcy5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xGdW5jdGlvbn0gW2xlZ2VuZC5jb250ZW50cy50ZW1wbGF0ZT11bmRlZmluZWRdIFNldCBpdGVtJ3MgdGVtcGxhdGUuPGJyPlxuICAgICAqICAtIElmIHNldCBgc3RyaW5nYCB2YWx1ZSwgd2l0aGluIHRlbXBsYXRlIHRoZSAnY29sb3InIGFuZCAndGl0bGUnIGNhbiBiZSByZXBsYWNlZCB1c2luZyB0ZW1wbGF0ZS1saWtlIHN5bnRheCBzdHJpbmc6XG4gICAgICogICAgLSB7PUNPTE9SfTogZGF0YSBjb2xvciB2YWx1ZVxuICAgICAqICAgIC0gez1USVRMRX06IGRhdGEgdGl0bGUgdmFsdWVcbiAgICAgKiAgLSBJZiBzZXQgYGZ1bmN0aW9uYCB2YWx1ZSwgd2lsbCBwYXNzIGZvbGxvd2luZyBhcmd1bWVudHMgdG8gdGhlIGdpdmVuIGZ1bmN0aW9uOlxuICAgICAqICAgLSB0aXRsZSB7U3RyaW5nfTogZGF0YSdzIGlkIHZhbHVlXG4gICAgICogICAtIGNvbG9yIHtTdHJpbmd9OiBjb2xvciBzdHJpbmdcbiAgICAgKiAgIC0gZGF0YSB7QXJyYXl9OiBkYXRhIGFycmF5XG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtsZWdlbmQucG9zaXRpb249Ym90dG9tXSBDaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIGxlZ2VuZC48YnI+XG4gICAgICogIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOiBgYm90dG9tYCwgYHJpZ2h0YCBhbmQgYGluc2V0YCBhcmUgc3VwcG9ydGVkLlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbbGVnZW5kLmluc2V0PXthbmNob3I6ICd0b3AtbGVmdCcseDogMTAseTogMCxzdGVwOiB1bmRlZmluZWR9XSBDaGFuZ2UgaW5zZXQgbGVnZW5kIGF0dHJpYnV0ZXMuPGJyPlxuICAgICAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIG9iamVjdCB0aGF0IGhhcyB0aGUga2V5cyBgYW5jaG9yYCwgYHhgLCBgeWAgYW5kIGBzdGVwYC5cbiAgICAgKiAgLSAqKmFuY2hvcioqIGRlY2lkZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQ6XG4gICAgICogICAtIHRvcC1sZWZ0XG4gICAgICogICAtIHRvcC1yaWdodFxuICAgICAqICAgLSBib3R0b20tbGVmdFxuICAgICAqICAgLSBib3R0b20tcmlnaHRcbiAgICAgKiAgLSAqKngqKiBhbmQgKip5Kio6XG4gICAgICogICAtIHNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZCBiYXNlZCBvbiB0aGUgYW5jaG9yLlxuICAgICAqICAtICoqc3RlcCoqOlxuICAgICAqICAgLSBkZWZpbmVzIHRoZSBtYXggc3RlcCB0aGUgbGVnZW5kIGhhcyAoZS5nLiBJZiAyIHNldCBhbmQgbGVnZW5kIGhhcyAzIGxlZ2VuZCBpdGVtLCB0aGUgbGVnZW5kIDIgY29sdW1ucykuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLmVxdWFsbHk9ZmFsc2VdIFNldCB0byBhbGwgaXRlbXMgaGF2ZSBzYW1lIHdpZHRoIHNpemUuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLnBhZGRpbmc9MF0gU2V0IHBhZGRpbmcgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25jbGljaz11bmRlZmluZWRdIFNldCBjbGljayBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25vdmVyPXVuZGVmaW5lZF0gU2V0IG1vdXNlL3RvdWNoIG92ZXIgZXZlbnQgaGFuZGxlciB0byB0aGUgbGVnZW5kIGl0ZW0uXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2xlZ2VuZC5pdGVtLm9ub3V0PXVuZGVmaW5lZF0gU2V0IG1vdXNlL3RvdWNoIG91dCBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2xlZ2VuZC5pdGVtLnRpbGUud2lkdGg9MTBdIFNldCB3aWR0aCBvZiBpdGVtIHRpbGUgZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbGVnZW5kLml0ZW0udGlsZS5oZWlnaHQ9MTBdIFNldCBoZWlnaHQgb2YgaXRlbSB0aWxlIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQudXNlUG9pbnQ9ZmFsc2VdIFdoZXRoZXIgdG8gdXNlIGN1c3RvbSBwb2ludHMgaW4gbGVnZW5kLlxuICAgICAqIEBzZWUgW0RlbW86IHBvc2l0aW9uXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLkxlZ2VuZFBvc2l0aW9uKVxuICAgICAqIEBzZWUgW0RlbW86IGNvbnRlbnRzLnRlbXBsYXRlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLkxlZ2VuZFRlbXBsYXRlMSlcbiAgICAgKiBAc2VlIFtEZW1vOiB1c2VQb2ludF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0xlZ2VuZC51c2VQb2ludClcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBsZWdlbmQ6IHtcbiAgICAgKiAgICAgIHNob3c6IHRydWUsXG4gICAgICogICAgICBoaWRlOiB0cnVlLFxuICAgICAqICAgICAgLy9vciBoaWRlOiBcImRhdGExXCJcbiAgICAgICAgICAgICAgKiAgICAgIC8vb3IgaGlkZTogW1wiZGF0YTFcIiwgXCJkYXRhMlwiXVxuICAgICAqICAgICAgY29udGVudHM6IHtcbiAgICAgKiAgICAgICAgICBiaW5kdG86IFwiI2xlZ2VuZFwiLCAgIC8vIDx1bCBpZD0nbGVnZW5kJz48L3VsPlxuICAgICAqXG4gICAgICogICAgICAgICAgLy8gd2lsbCBiZSBhczogPGxpIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOiMxZjc3YjQnPmRhdGExPC9saT5cbiAgICAgKiAgICAgICAgICB0ZW1wbGF0ZTogXCI8bGkgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6ez1DT0xPUn0nPns9VElUTEV9PC9saT5cIlxuICAgICAqXG4gICAgICogICAgICAgICAgLy8gb3IgdXNpbmcgZnVuY3Rpb25cbiAgICAgKiAgICAgICAgICB0ZW1wbGF0ZTogZnVuY3Rpb24oaWQsIGNvbG9yLCBkYXRhKSB7XG4gICAgICogICAgICAgICAgICAgICAvLyBpZiB5b3Ugd2FudCBvbWl0IHNvbWUgbGVnZW5kLCByZXR1cm4gZmFsc3kgdmFsdWVcbiAgICAgKiAgICAgICAgICAgICAgIGlmICh0aXRsZSAhPT0gXCJkYXRhMVwiKSB7XG4gICAgICogICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxsaSBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjpcIisgY29sb3IgK1wiPlwiKyB0aXRsZSArXCI8L2xpPlwiO1xuICAgICAqICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgIH0sXG4gICAgICAgICAgICAgICogICAgICBwb3NpdGlvbjogXCJib3R0b21cIiwgIC8vIGJvdHRvbSwgcmlnaHQsIGluc2V0XG4gICAgICogICAgICBpbnNldDoge1xuICAgICAqICAgICAgICAgIGFuY2hvcjogXCJ0b3AtcmlnaHRcIiAgLy8gdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLWxlZnQsIGJvdHRvbS1yaWdodFxuICAgICAqICAgICAgICAgIHg6IDIwLFxuICAgICAqICAgICAgICAgIHk6IDEwLFxuICAgICAqICAgICAgICAgIHN0ZXA6IDJcbiAgICAgKiAgICAgIH0sXG4gICAgICAgICAgICAgICogICAgICBlcXVhbGx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgKiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgICAgICAgICAqICAgICAgaXRlbToge1xuICAgICAqICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKGlkKSB7IC4uLiB9LFxuICAgICAqICAgICAgICAgIG9ub3ZlcjogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXG4gICAgICogICAgICAgICAgb25vdXQ6IGZ1bmN0aW9uKGlkKSB7IC4uLiB9LFxuICAgICAqXG4gICAgICogICAgICAgICAgLy8gc2V0IHRpbGUncyBzaXplXG4gICAgICogICAgICAgICAgdGlsZToge1xuICAgICAqICAgICAgICAgICAgICB3aWR0aDogMjAsXG4gICAgICogICAgICAgICAgICAgIGhlaWdodDogMTVcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgdXNlUG9pbnQ6IHRydWVcbiAgICAgKiAgfVxuICAgICAqL1xuICAgIGxlZ2VuZF9zaG93OiAhMCxcbiAgICBsZWdlbmRfaGlkZTogITEsXG4gICAgbGVnZW5kX2NvbnRlbnRzX2JpbmR0bzogdW5kZWZpbmVkLFxuICAgIGxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZTogdW5kZWZpbmVkLFxuICAgIGxlZ2VuZF9wb3NpdGlvbjogXCJib3R0b21cIixcbiAgICBsZWdlbmRfaW5zZXRfYW5jaG9yOiBcInRvcC1sZWZ0XCIsXG4gICAgbGVnZW5kX2luc2V0X3g6IDEwLFxuICAgIGxlZ2VuZF9pbnNldF95OiAwLFxuICAgIGxlZ2VuZF9pbnNldF9zdGVwOiB1bmRlZmluZWQsXG4gICAgbGVnZW5kX2l0ZW1fb25jbGljazogdW5kZWZpbmVkLFxuICAgIGxlZ2VuZF9pdGVtX29ub3ZlcjogdW5kZWZpbmVkLFxuICAgIGxlZ2VuZF9pdGVtX29ub3V0OiB1bmRlZmluZWQsXG4gICAgbGVnZW5kX2VxdWFsbHk6ICExLFxuICAgIGxlZ2VuZF9wYWRkaW5nOiAwLFxuICAgIGxlZ2VuZF9pdGVtX3RpbGVfd2lkdGg6IDEwLFxuICAgIGxlZ2VuZF9pdGVtX3RpbGVfaGVpZ2h0OiAxMCxcbiAgICBsZWdlbmRfdXNlUG9pbnQ6ICExLFxuXG4gICAgLyoqXG4gICAgICogU3dpdGNoIHggYW5kIHkgYXhpcyBwb3NpdGlvbi5cbiAgICAgKiBAbmFtZSBheGlz4oCkcm90YXRlZFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHJvdGF0ZWQ6IHRydWVcbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc19yb3RhdGVkOiAhMSxcblxuICAgIC8qKlxuICAgICAqIFNldCBjbGlwLXBhdGggYXR0cmlidXRlIGZvciB4IGF4aXMgZWxlbWVudFxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkY2xpcFBhdGhcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAc2VlIFtEZW1vXSgpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBkb24ndCBzZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlXG4gICAgICogY2xpcFBhdGg6IGZhbHNlXG4gICAgICovXG4gICAgYXhpc194X2NsaXBQYXRoOiAhMCxcblxuICAgIC8qKlxuICAgICAqIFNob3cgb3IgaGlkZSB4IGF4aXMuXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRzaG93XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB4OiB7XG4gICAgICogICAgIHNob3c6IGZhbHNlXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeF9zaG93OiAhMCxcblxuICAgIC8qKlxuICAgICAqIFNldCB0eXBlIG9mIHggYXhpcy48YnI+PGJyPlxuICAgICAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxuICAgICAqIC0gdGltZXNlcmllc1xuICAgICAqIC0gY2F0ZWdvcnlcbiAgICAgKiAtIGluZGV4ZWRcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHR5cGVcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgaW5kZXhlZFxuICAgICAqIEBzZWUgW0RlbW86IGluZGV4ZWRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5BcmVhQ2hhcnQpXG4gICAgICogQHNlZSBbRGVtbzogdGltZXNlcmllc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LlRpbWVzZXJpZXNDaGFydClcbiAgICAgKiBAc2VlIFtEZW1vOiBjYXRlZ29yeV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuQ2F0ZWdvcnlEYXRhKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeDoge1xuICAgICAqICAgICB0eXBlOiBcInRpbWVzZXJpZXNcIlxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3hfdHlwZTogXCJpbmRleGVkXCIsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgaG93IHRvIHRyZWF0IHRoZSB0aW1lem9uZSBvZiB4IHZhbHVlcy48YnI+XG4gICAgICogSWYgdHJ1ZSwgdHJlYXQgeCB2YWx1ZSBhcyBsb2NhbHRpbWUuIElmIGZhbHNlLCBjb252ZXJ0IHRvIFVUQyBpbnRlcm5hbGx5LlxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkbG9jYWx0aW1lXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB4OiB7XG4gICAgICogICAgIGxvY2FsdGltZTogZmFsc2VcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc194X2xvY2FsdGltZTogITAsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgY2F0ZWdvcnkgbmFtZXMgb24gY2F0ZWdvcnkgYXhpcy5cbiAgICAgKiBUaGlzIG11c3QgYmUgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBjYXRlZ29yeSBuYW1lcyBpbiBzdHJpbmcuIElmIGNhdGVnb3J5IG5hbWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZGF0ZSBieSBkYXRhLnggb3B0aW9uLCB0aGlzIGlzIG5vdCByZXF1aXJlZC5cbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGNhdGVnb3JpZXNcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeDoge1xuICAgICAqICAgICBjYXRlZ29yaWVzOiBbXCJDYXRlZ29yeSAxXCIsIFwiQ2F0ZWdvcnkgMlwiLCAuLi5dXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeF9jYXRlZ29yaWVzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIGNlbnRlcml6ZSB0aWNrcyBvbiBjYXRlZ29yeSBheGlzLlxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGNlbnRlcmVkXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeDoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgY2VudGVyZWQ6IHRydWVcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3hfdGlja19jZW50ZXJlZDogITEsXG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGZvcm1hdCB0aWNrIHZhbHVlLiBGb3JtYXQgc3RyaW5nIGlzIGFsc28gYXZhaWxhYmxlIGZvciB0aW1lc2VyaWVzIGRhdGEuXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkZm9ybWF0XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb258U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBzZWUgW0QzJ3MgdGltZSBzcGVjaWZpZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lLWZvcm1hdCNsb2NhbGVfZm9ybWF0KVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeDoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgIC8vIGZvciB0aW1lc2VyaWVzLCBhICdkYXRldGltZScgb2JqZWN0IGlzIGdpdmVuIGFzIHBhcmFtZXRlclxuICAgICAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xuICAgICAqICAgICAgICAgICByZXR1cm4geC5nZXRGdWxsWWVhcigpO1xuICAgICAqICAgICAgIH1cbiAgICAgKlxuICAgICAqICAgICAgIC8vIGZvciBjYXRlZ29yeSwgaW5kZXgoTnVtYmVyKSBhbmQgY2F0ZWdvcnlOYW1lKFN0cmluZykgYXJlIGdpdmVuIGFzIHBhcmFtZXRlclxuICAgICAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oaW5kZXgsIGNhdGVnb3J5TmFtZSkge1xuICAgICAqICAgICAgICAgICByZXR1cm4gY2F0ZWdvcnlOYW1lLnN1YnN0cigwLCAxMCk7XG4gICAgICogICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAgICAvLyBmb3IgdGltZXNlcmllcyBmb3JtYXQgc3BlY2lmaWVyXG4gICAgICogICAgICAgIGZvcm1hdDogXCIlWS0lbS0lZCAlSDolTTolU1wiXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc194X3RpY2tfZm9ybWF0OiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XG4gICAgICogSWYgdHJ1ZSBpcyBzZXQsIHRoZSB0aWNrcyB3aWxsIGJlIGN1bGxlZCwgdGhlbiBvbmx5IGxpbWl0dGVkIHRpY2sgdGV4dCB3aWxsIGJlIHNob3duLiBUaGlzIG9wdGlvbiBkb2VzIG5vdCBoaWRlIHRoZSB0aWNrIGxpbmVzLiBJZiBmYWxzZSBpcyBzZXQsIGFsbCBvZiB0aWNrcyB3aWxsIGJlIHNob3duLjxicj48YnI+XG4gICAgICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueC50aWNrLmN1bGxpbmcubWF4LlxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGN1bGxpbmdcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogLSB0cnVlIGZvciBpbmRleGVkIGF4aXMgYW5kIHRpbWVzZXJpZXMgYXhpc1xuICAgICAqIC0gZmFsc2UgZm9yIGNhdGVnb3J5IGF4aXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHg6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIGN1bGxpbmc6IGZhbHNlXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc194X3RpY2tfY3VsbGluZzoge30sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpY2sgdGV4dHMgd2lsbCBiZSBhZGp1c3RlZCB0byBsZXNzIHRoYW4gdGhpcyB2YWx1ZS5cbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjdWxsaW5n4oCkbWF4XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB4OiB7XG4gICAgICogICAgIHRpY2s6IHtcbiAgICAgKiAgICAgICBjdWxsaW5nOiB7XG4gICAgICogICAgICAgICAgIG1heDogNVxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3hfdGlja19jdWxsaW5nX21heDogMTAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHggYXhpcyB0aWNrcyB0byBzaG93Ljxicj48YnI+XG4gICAgICogVGhpcyBvcHRpb24gaGlkZXMgdGljayBsaW5lcyB0b2dldGhlciB3aXRoIHRpY2sgdGV4dC4gSWYgdGhpcyBvcHRpb24gaXMgdXNlZCBvbiB0aW1lc2VyaWVzIGF4aXMsIHRoZSB0aWNrcyBwb3NpdGlvbiB3aWxsIGJlIGRldGVybWluZWQgcHJlY2lzZWx5IGFuZCBub3QgbmljZWx5IHBvc2l0aW9uZWQgKGUuZy4gaXQgd2lsbCBoYXZlIHJvdWdoIHNlY29uZCB2YWx1ZSkuXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkY291bnRcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB4OiB7XG4gICAgICogICAgIHRpY2s6IHtcbiAgICAgKiAgICAgICBjb3VudDogNVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeF90aWNrX2NvdW50OiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgbGluZS5cbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRzaG93XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHg6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIHNob3c6IGZhbHNlXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc194X3RpY2tfc2hvdzogITAsXG5cbiAgICAvKipcbiAgICAgKiBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgdGV4dC5cbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR0ZXh04oCkc2hvd1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB4OiB7XG4gICAgICogICAgIHRpY2s6IHtcbiAgICAgKiAgICAgICB0ZXh0OiB7XG4gICAgICogICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeF90aWNrX3RleHRfc2hvdzogITAsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHggQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRleHTigKRwb3NpdGlvblxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeDoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgdGV4dDoge1xuICAgICAqICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgKiAgICAgICAgICAgeDogMTAsXG4gICAgICogICAgICAgICAgIHk6IDEwXG4gICAgICogICAgICAgICB9XG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeF90aWNrX3RleHRfcG9zaXRpb246IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpdCB4IGF4aXMgdGlja3MuXG4gICAgICogLSAqKnRydWUqKjogdGlja3Mgd2lsbCBiZSBwb3NpdGlvbmVkIG5pY2VseSB0byBoYXZlIHNhbWUgaW50ZXJ2YWxzLlxuICAgICAqIC0gKipmYWxzZSoqOiB0aWNrcyB3aWxsIGJlIHBvc2l0aW9uZWQgYWNjb3JkaW5nIHRvIHggdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnRzLlxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGZpdFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlhBeGlzVGlja0ZpdHRpbmcpXG4gICAgICogQHNlZSBbRGVtbzogZm9yIHRpbWVzZXJpZXMgem9vbV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrVGltZXNlcmllcylcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHg6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIGZpdDogZmFsc2VcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3hfdGlja19maXQ6ICEwLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB4IHZhbHVlcyBvZiB0aWNrcyBtYW51YWxseS48YnI+PGJyPlxuICAgICAqIElmIHRoaXMgb3B0aW9uIGlzIHByb3ZpZGVkLCB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgZGV0ZXJtaW5lZCBiYXNlZCBvbiB0aG9zZSB2YWx1ZXMuPGJyPlxuICAgICAqIFRoaXMgb3B0aW9uIHdvcmtzIHdpdGggYHRpbWVzZXJpZXNgIGRhdGEgYW5kIHRoZSB4IHZhbHVlcyB3aWxsIGJlIHBhcnNlZCBhY2NvZGluZyB0byB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYW5kIGRhdGEueEZvcm1hdCBvcHRpb24uXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdmFsdWVzXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeDoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgdmFsdWVzOiBbMSwgMiwgNCwgOCwgMTYsIDMyLCAuLi5dLFxuICAgICAqXG4gICAgICogICAgICAgLy8gYW4gQXJyYXkgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkXG4gICAgICogICAgICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICBcdHJldHVybiBbIC4uLiBdO1xuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3hfdGlja192YWx1ZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgeCBheGlzIHRpY2sgdGV4dCBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGZvciAnY2F0ZWdvcnknIGFuZCAndGltZXNlcmllcycgdHlwZSBheGlzLlxuICAgICAqIC0gKipOT1RFOioqIFRoZSBjb25kaXRpb25zIHdoZXJlIGBhdXRvcm90YXRlYCBpcyBlbmFibGVkIGFyZTpcbiAgICAgKiAgIC0gYXhpcy54LnR5cGU9J2NhdGVnb3J5JyBvciAndGltZXNlcmllc1xuICAgICAqICAgLSBheGlzLngudGljay5tdWx0aWxpbmU9ZmFsc2VcbiAgICAgKiAgIC0gYXhpcy54LnRpY2suY3VsbGluZz1mYWxzZVxuICAgICAqICAgLSBheGlzLngudGljay5maXQ9dHJ1ZVxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGF1dG9yb3RhdGVcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrQXV0b3JvdGF0ZSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHg6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIHJvdGF0ZTogMTUsXG4gICAgICogICAgICAgYXV0b3JvdGF0ZTogdHJ1ZSxcbiAgICAgKiAgICAgICBtdWx0aWxpbmU6IGZhbHNlLFxuICAgICAqICAgICAgIGN1bGxpbmc6IGZhbHNlLFxuICAgICAqICAgICAgIGZpdDogdHJ1ZVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeF90aWNrX2F1dG9yb3RhdGU6ICExLFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlIHggYXhpcyB0aWNrIHRleHQuXG4gICAgICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgICogLSBBcHBsaWVkIHdoZW4gW2BheGlzLnJvdGF0ZWRgXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTRyb3RhdGVkKSBvcHRpb24gaXMgYGZhbHNlYC5cbiAgICAgKiAtIEFzIGxvbmcgYXMgYGF4aXNfeF90aWNrX2ZpdGAgaXMgc2V0IHRvIGB0cnVlYCBpdCB3aWxsIGNhbGN1bGF0ZSBhbiBvdmVyZmxvdyBmb3IgdGhlIHkyIGF4aXMgYW5kIGFkZCB0aGlzIHZhbHVlIHRvIHRoZSByaWdodCBwYWRkaW5nLlxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHJvdGF0ZVxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuUm90YXRlWEF4aXNUaWNrVGV4dClcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHg6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIHJvdGF0ZTogNjBcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3hfdGlja19yb3RhdGU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHggYXhpcyBvdXRlciB0aWNrLlxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApG91dGVyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB4OiB7XG4gICAgICogICAgIHRpY2s6IHtcbiAgICAgKiAgICAgICBvdXRlcjogZmFsc2VcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3hfdGlja19vdXRlcjogITAsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGljayB0ZXh0IHRvIGJlIG11bHRpbGluZVxuICAgICAqIC0gKipOT1RFOioqXG4gICAgICogID4gV2hlbiB4IHRpY2sgdGV4dCBjb250YWlucyBgXFxuYCwgaXQncyB1c2VkIGFzIGxpbmUgYnJlYWsgYW5kICdheGlzLngudGljay53aWR0aCcgb3B0aW9uIGlzIGlnbm9yZWQuXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkbXVsdGlsaW5lXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrTXVsdGlsaW5lKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeDoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgbXVsdGlsaW5lOiBmYWxzZVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZXhhbXBsZSBvZiBsaW5lIGJyZWFrIHdpdGggJ1xcbidcbiAgICAgKiAvLyBJbiB0aGlzIGNhc2UsICdheGlzLngudGljay53aWR0aCcgaXMgaWdub3JlZFxuICAgICAqIGRhdGE6IHtcbiAgICAgKiAgICB4OiBcInhcIixcbiAgICAgKiAgICBjb2x1bW5zOiBbXG4gICAgICogICAgICAgIFtcInhcIiwgXCJsb25nXFxudGV4dFwiLCBcIkFub3RoZXJcXG5Mb25nXFxuVGV4dFwiXSxcbiAgICAgKiAgICAgICAgLi4uXG4gICAgICogICAgXSxcbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc194X3RpY2tfbXVsdGlsaW5lOiAhMCxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aWNrIHdpZHRoXG4gICAgICogLSAqKk5PVEU6KipcbiAgICAgKiAgPiBXaGVuIHggdGljayB0ZXh0IGNvbnRhaW5zIGBcXG5gLCB0aGlzIG9wdGlvbiBpcyBpZ25vcmVkLlxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHdpZHRoXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHg6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIHdpZHRoOiA1MFxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeF90aWNrX3dpZHRoOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIGRpc3BsYXkgc3lzdGVtIHRvb2x0aXAodmlhICd0aXRsZScgYXR0cmlidXRlKSBmb3IgdGljayB0ZXh0XG4gICAgICogLSAqKk5PVEU6KiogT25seSBhdmFpbGFibGUgZm9yIGNhdGVnb3J5IGF4aXMgdHlwZSAoYGF4aXMueC50eXBlPSdjYXRlZ29yeSdgKVxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRvb2x0aXBcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB4OiB7XG4gICAgICogICAgIHRpY2s6IHtcbiAgICAgKiAgICAgICB0b29sdGlwOiB0cnVlXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc194X3RpY2tfdG9vbHRpcDogITEsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgbWF4IHZhbHVlIG9mIHggYXhpcyByYW5nZS5cbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApG1heFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1heCBTZXQgdGhlIG1heCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW21heC5maXQ9ZmFsc2VdIFdoZW4gc3BlY2lmaWVkIGBtYXgudmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYm91bmQgZGF0YSB2YWx1ZSwgc2V0dGluZyBgdHJ1ZWAgd2lsbCBtYWtlIHggYXhpcyBtYXggdG8gYmUgZml0dGVkIHRvIHRoZSBib3VuZCBkYXRhIG1heCB2YWx1ZS5cbiAgICAgKiAtICoqTk9URToqKiBJZiB0aGUgYm91bmQgZGF0YSBtYXggdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBgbWF4LnZhbHVlYCwgdGhlIHggYXhpcyBtYXggd2lsbCBiZSBsaW1pdGVkIGFzIHRoZSBnaXZlbiBgbWF4LnZhbHVlYC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW21heC52YWx1ZV0gU2V0IHRoZSBtYXggdmFsdWVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHg6IHtcbiAgICAgKiAgICAgbWF4OiAxMDAsXG4gICAgICpcbiAgICAgKiAgICAgbWF4OiB7XG4gICAgICogICAgICAgLy8gJ2ZpdD10cnVlJyB3aWxsIG1ha2UgeCBheGlzIG1heCB0byBiZSBsaW1pdGVkIGFzIHRoZSBib3VuZCBkYXRhIHZhbHVlIG1heCB3aGVuICdtYXgudmFsdWUnIGlzIGdyZWF0ZXIuXG4gICAgICogICAgICAgLy8gLSB3aGVuIGJvdW5kIGRhdGEgbWF4IGlzICcxMCcgYW5kIG1heC52YWx1ZTogJzEwMCcgPT0+ICB4IGF4aXMgbWF4IHdpbGwgYmUgJzEwJ1xuICAgICAqICAgICAgIC8vIC0gd2hlbiBib3VuZCBkYXRhIG1heCBpcyAnMTAwMCcgYW5kIG1heC52YWx1ZTogJzEwMCcgPT0+IHggYXhpcyBtYXggd2lsbCBiZSAnMTAwJ1xuICAgICAqICAgICAgIGZpdDogdHJ1ZSxcbiAgICAgKiAgICAgICB2YWx1ZTogMTAwXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc194X21heDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU2V0IG1pbiB2YWx1ZSBvZiB4IGF4aXMgcmFuZ2UuXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRtaW5cbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW4gU2V0IHRoZSBtaW4gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFttaW4uZml0PWZhbHNlXSBXaGVuIHNwZWNpZmllZCBgbWluLnZhbHVlYCBpcyBsb3dlciB0aGFuIHRoZSBib3VuZCBkYXRhIHZhbHVlLCBzZXR0aW5nIGB0cnVlYCB3aWxsIG1ha2UgeCBheGlzIG1pbiB0byBiZSBmaXR0ZWQgdG8gdGhlIGJvdW5kIGRhdGEgbWluIHZhbHVlLlxuICAgICAqIC0gKipOT1RFOioqIElmIHRoZSBib3VuZCBkYXRhIG1pbiB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBgbWluLnZhbHVlYCwgdGhlIHggYXhpcyBtaW4gd2lsbCBiZSBsaW1pdGVkIGFzIHRoZSBnaXZlbiBgbWluLnZhbHVlYC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW21pbi52YWx1ZV0gU2V0IHRoZSBtaW4gdmFsdWVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHg6IHtcbiAgICAgKiAgICAgbWluOiAtMTAwLFxuICAgICAqXG4gICAgICogICAgIG1pbjoge1xuICAgICAqICAgICAgIC8vICdmaXQ9dHJ1ZScgd2lsbCBtYWtlIHggYXhpcyBtaW4gdG8gYmUgbGltaXRlZCBhcyB0aGUgYm91bmQgZGF0YSB2YWx1ZSBtaW4gd2hlbiAnbWluLnZhbHVlJyBpcyBsb3dlci5cbiAgICAgKiAgICAgICAvLyAtIHdoZW4gYm91bmQgZGF0YSBtaW4gaXMgJy0xMCcgYW5kIG1pbi52YWx1ZTogJy0xMDAnID09PiAgeCBheGlzIG1pbiB3aWxsIGJlICctMTAnXG4gICAgICogICAgICAgLy8gLSB3aGVuIGJvdW5kIGRhdGEgbWluIGlzICctMTAwMCcgYW5kIG1pbi52YWx1ZTogJy0xMDAnID09PiB4IGF4aXMgbWluIHdpbGwgYmUgJy0xMDAnXG4gICAgICogICAgICAgZml0OiB0cnVlLFxuICAgICAqICAgICAgIHZhbHVlOiAtMTAwXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc194X21pbjogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHBhZGRpbmcgZm9yIHggYXhpcy48YnI+PGJyPlxuICAgICAqIElmIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIHJhbmdlIG9mIHggYXhpcyB3aWxsIGluY3JlYXNlL2RlY3JlYXNlIGFjY29yZGluZyB0byB0aGUgdmFsdWVzLlxuICAgICAqIElmIG5vIHBhZGRpbmcgaXMgbmVlZGVkIGluIHRoZSByYWdlIG9mIHggYXhpcywgMCBzaG91bGQgYmUgc2V0LlxuICAgICAqIC0gKipOT1RFOioqXG4gICAgICogICBUaGUgcGFkZGluZyB2YWx1ZXMgYXJlbid0IGJhc2VkIG9uIHBpeGVscy4gSXQgZGlmZmVycyBhY2NvcmRpbmcgYXhpcyB0eXBlczxicj5cbiAgICAgKiAgIC0gKipjYXRlZ29yeToqKiBUaGUgdW5pdCBvZiB0aWNrIHZhbHVlXG4gICAgICogICAgIGV4LiB0aGUgZ2l2ZW4gdmFsdWUgYDFgLCBpcyBzYW1lIGFzIHRoZSB3aWR0aCBvZiAxIHRpY2sgd2lkdGhcbiAgICAgKiAgIC0gKip0aW1lc2VyaWVzOioqIE51bWVyaWMgdGltZSB2YWx1ZVxuICAgICAqICAgICBleC4gdGhlIGdpdmVuIHZhbHVlIGAxMDAwKjYwKjYwKjI0YCwgd2hpY2ggaXMgbnVtZXJpYyB0aW1lIGVxdWl2YWxlbnQgb2YgYSBkYXksIGlzIHNhbWUgYXMgdGhlIHdpZHRoIG9mIDEgdGljayB3aWR0aFxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkcGFkZGluZ1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdHxOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQge31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHg6IHtcbiAgICAgKiAgICAgcGFkZGluZzoge1xuICAgICAqICAgICAgIC8vIHdoZW4gYXhpcyB0eXBlIGlzICdjYXRlZ29yeSdcbiAgICAgKiAgICAgICBsZWZ0OiAxLCAgLy8gc2V0IGxlZnQgcGFkZGluZyB3aWR0aCBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIGEgdGljaydzIHdpZHRoXG4gICAgICogICAgICAgcmlnaHQ6IDAuNSAgLy8gc2V0IHJpZ2h0IHBhZGRpbmcgd2lkdGggYXMgaGFsZiBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIHRpY2sncyB3aWR0aFxuICAgICAqXG4gICAgICogICAgICAgLy8gd2hlbiBheGlzIHR5cGUgaXMgJ3RpbWVzZXJpZXMnXG4gICAgICogICAgICAgbGVmdDogMTAwMCo2MCo2MCoyNCwgIC8vIHNldCBsZWZ0IHBhZGRpbmcgd2lkdGggb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIGRheSB0aWNrJ3Mgd2lkdGhcbiAgICAgKiAgICAgICByaWdodDogMTAwMCo2MCo2MCoxMiAgIC8vIHNldCByaWdodCBwYWRkaW5nIHdpZHRoIGFzIGhhbGYgb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIGRheSB0aWNrJ3Mgd2lkdGhcbiAgICAgKiAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAvLyBvciBzZXQgYm90aCB2YWx1ZXMgYXQgb25jZS5cbiAgICAgKiAgICAgcGFkZGluZzogMTBcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc194X3BhZGRpbmc6IHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGhlaWdodCBvZiB4IGF4aXMuPGJyPjxicj5cbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHggYXhpcyBjYW4gYmUgc2V0IG1hbnVhbGx5IGJ5IHRoaXMgb3B0aW9uLiBJZiB5b3UgbmVlZCBtb3JlIHNwYWNlIGZvciB4IGF4aXMsIHBsZWFzZSB1c2UgdGhpcyBvcHRpb24gZm9yIHRoYXQuIFRoZSB1bml0IGlzIHBpeGVsLlxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkaGVpZ2h0XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeDoge1xuICAgICAqICAgICBoZWlnaHQ6IDIwXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeF9oZWlnaHQ6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IGV4dGVudCBmb3Igc3ViY2hhcnQgYW5kIHpvb20uIFRoaXMgY2FuIGJlIGFuIGFycmF5IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheS5cbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGV4dGVudFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0FycmF5fEZ1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeDoge1xuICAgICAqICAgICAvLyBleHRlbnQgcmFuZ2UgYXMgYSBwaXhlbCB2YWx1ZVxuICAgICAqICAgICBleHRlbnQ6IFswLCAyMDBdLFxuICAgICAqXG4gICAgICogICAgIC8vIHdoZW4gYXhpcyBpcyAndGltZXNlcmllcycsIHBhcnNhYmxlIGRhdGV0aW1lIHN0cmluZ1xuICAgICAqICAgICBleHRlbnQ6IFtcIjIwMTktMDMtMDFcIiwgXCIyMDE5LTAzLTA1XCJdLFxuICAgICAqXG4gICAgICogICAgIC8vIHJldHVybiBleHRlbnQgdmFsdWVcbiAgICAgKiAgICAgZXh0ZW50OiBmdW5jdGlvbihkb21haW4sIHNjYWxlKSB7XG4gICAgICogICAgXHQgdmFyIGV4dGVudCA9IGRvbWFpbi5tYXAoZnVuY3Rpb24odikge1xuICAgICAqICAgICBcdCAgICByZXR1cm4gc2NhbGUodik7XG4gICAgICogICAgIFx0IH0pO1xuICAgICAqXG4gICAgICogICBcdCAvLyBpdCBzaG91bGQgcmV0dXJuIGEgZm9ybWF0IG9mIGFycmF5XG4gICAgICogICBcdCAvLyBleCkgWzAsIDU4NF1cbiAgICAgKiAgICAgXHQgcmV0dXJuIGV4dGVudDtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3hfZXh0ZW50OiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgbGFiZWwgb24geCBheGlzLjxicj48YnI+XG4gICAgICogWW91IGNhbiBzZXQgeCBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLlxuICAgICAqIGBzdHJpbmdgIGFuZCBgb2JqZWN0YCBjYW4gYmUgcGFzc2VkIGFuZCB3ZSBjYW4gY2hhbmdlIHRoZSBwb2lzaXRvbiBieSBwYXNzaW5nIG9iamVjdCB0aGF0IGhhcyBwb3NpdGlvbiBrZXkuPGJyPlxuICAgICAqIEF2YWlsYWJsZSBwb3NpdGlvbiBkaWZmZXJzIGFjY29yZGluZyB0byB0aGUgYXhpcyBkaXJlY3Rpb24gKHZlcnRpY2FsIG9yIGhvcml6b250YWwpLlxuICAgICAqIElmIHN0cmluZyBzZXQsIHRoZSBwb3NpdGlvbiB3aWxsIGJlIHRoZSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogIC0gKipJZiBpdCdzIGhvcml6b250YWwgYXhpczoqKlxuICAgICAqICAgIC0gaW5uZXItcmlnaHQgW2RlZmF1bHRdXG4gICAgICogICAgLSBpbm5lci1jZW50ZXJcbiAgICAgKiAgICAtIGlubmVyLWxlZnRcbiAgICAgKiAgICAtIG91dGVyLXJpZ2h0XG4gICAgICogICAgLSBvdXRlci1jZW50ZXJcbiAgICAgKiAgICAtIG91dGVyLWxlZnRcbiAgICAgKiAgLSAqKklmIGl0J3MgdmVydGljYWwgYXhpczoqKlxuICAgICAqICAgIC0gaW5uZXItdG9wIFtkZWZhdWx0XVxuICAgICAqICAgIC0gaW5uZXItbWlkZGxlXG4gICAgICogICAgLSBpbm5lci1ib3R0b21cbiAgICAgKiAgICAtIG91dGVyLXRvcFxuICAgICAqICAgIC0gb3V0ZXItbWlkZGxlXG4gICAgICogICAgLSBvdXRlci1ib3R0b21cbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGxhYmVsXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHg6IHtcbiAgICAgKiAgICAgbGFiZWw6IFwiWW91ciBYIEF4aXNcIlxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHg6IHtcbiAgICAgKiAgICAgbGFiZWw6IHtcbiAgICAgKiAgICAgICAgdGV4dDogXCJZb3VyIFggQXhpc1wiLFxuICAgICAqICAgICAgICBwb3NpdGlvbjogXCJvdXRlci1jZW50ZXJcIlxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeF9sYWJlbDoge30sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB4IEF4aXMuXG4gICAgICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geCBBeGlzIHZhbHVlIGlmIGRvbWFpbiBvcHRpb24gaXNuJ3Qgc2V0LlxuICAgICAqXG4gICAgICogRWFjaCBheGlzIG9iamVjdCBzaG91bGQgY29uc2lzdCB3aXRoIGZvbGxvd2luZyBvcHRpb25zOlxuICAgICAqXG4gICAgICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XG4gICAgICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuICAgICAqIHwgZG9tYWluIHwgQXJyYXkgfCAtIHwgU2V0IHRoZSBkb21haW4gdmFsdWUgfFxuICAgICAqIHwgdGljay5vdXRlciB8IEJvb2xlYW4gfCB0cnVlIHwgU2hvdyBvdXRlciB0aWNrIHxcbiAgICAgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcbiAgICAgKiB8IHRpY2suY291bnQgfCBOdW1iZXIgfCAtIHwgU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzIHxcbiAgICAgKiB8IHRpY2sudmFsdWVzIHwgQXJyYXkgfCAtIHwgU2V0IHRpY2sgdmFsdWVzIG1hbnVhbGx5IHxcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGF4ZXNcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXG4gICAgICogQHNlZSBbRGVtbzogRG9tYWluXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXNEb21haW4pXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB4OiB7XG4gICAgICogICAgYXhlczogW1xuICAgICAqICAgICAge1xuICAgICAqICAgICAgICAvLyBpZiBzZXQsIHdpbGwgbm90IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGUgbWFpbiB4IEF4aXMgZG9tYWluIHZhbHVlXG4gICAgXHQgKiAgICAgICAgZG9tYWluOiBbMCwgMTAwMF0sXG4gICAgICogICAgICAgIHRpY2s6IHtcbiAgICAgKiAgICAgICAgICBvdXRlcjogZmFsc2UsXG4gICAgICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XG4gICAgICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcbiAgICAgKiAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgIGNvdW50OiAyLFxuICAgICAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgIH0sXG4gICAgICogICAgICAuLi5cbiAgICAgKiAgICBdXG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeF9heGVzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIFNldCBjbGlwLXBhdGggYXR0cmlidXRlIGZvciB5IGF4aXMgZWxlbWVudFxuICAgICAqIC0gKipOT1RFKio6IGBjbGlwLXBhdGhgIGF0dHJpYnV0ZSBmb3IgeSBBeGlzIGlzIHNldCBvbmx5IHdoZW4gYGF4aXMueS5pbm5lcmAgb3B0aW9uIGlzIHRydWUuXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRjbGlwUGF0aFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZG9uJ3Qgc2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZVxuICAgICAqIGNsaXBQYXRoOiBmYWxzZVxuICAgICAqL1xuICAgIGF4aXNfeV9jbGlwUGF0aDogITAsXG5cbiAgICAvKipcbiAgICAgKiBTaG93IG9yIGhpZGUgeSBheGlzLlxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkc2hvd1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeToge1xuICAgICAqICAgICBzaG93OiBmYWxzZVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3lfc2hvdzogITAsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdHlwZSBvZiB5IGF4aXMuPGJyPjxicj5cbiAgICAgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcbiAgICAgKiAgIC0gdGltZXNlcmllc1xuICAgICAqICAgLSBpbmRleGVkXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0eXBlXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaW5kZXhlZFwiXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5OiB7XG4gICAgICogICAgIHR5cGU6IFwidGltZXNlcmllc1wiXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeV90eXBlOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgbWF4IHZhbHVlIG9mIHkgYXhpcy5cbiAgICAgKiAtICoqTk9URToqKiBQYWRkaW5nIHdpbGwgYmUgYWRkZWQgYmFzZWQgb24gdGhpcyB2YWx1ZSwgc28gaWYgeW91IGRvbid0IG5lZWQgdGhlIHBhZGRpbmcsIHBsZWFzZSBzZXQgYXhpcy55LnBhZGRpbmcgdG8gZGlzYWJsZSBpdCAoZS5nLiBheGlzLnkucGFkZGluZyA9IDApLlxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkbWF4XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeToge1xuICAgICAqICAgICBtYXg6IDEwMDBcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195X21heDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU2V0IG1pbiB2YWx1ZSBvZiB5IGF4aXMuXG4gICAgICogLSAqKk5PVEU6KipcbiAgICAgKiAgIFBhZGRpbmcgd2lsbCBiZSBhZGRlZCBiYXNlZCBvbiB0aGlzIHZhbHVlLCBzbyBpZiB5b3UgZG9uJ3QgbmVlZCB0aGUgcGFkZGluZywgcGxlYXNlIHNldCBheGlzLnkucGFkZGluZyB0byBkaXNhYmxlIGl0IChlLmcuIGF4aXMueS5wYWRkaW5nID0gMCkuXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRtaW5cbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5OiB7XG4gICAgICogICAgIG1pbjogMTAwMFxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3lfbWluOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRpcmVjdGlvbiBvZiB5IGF4aXMuPGJyPjxicj5cbiAgICAgKiBJZiB0cnVlIHNldCwgdGhlIGRpcmVjdGlvbiB3aWxsIGJlIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tLlxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkaW52ZXJ0ZWRcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5OiB7XG4gICAgICogICAgIGludmVydGVkOiB0cnVlXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeV9pbnZlcnRlZDogITEsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgY2VudGVyIHZhbHVlIG9mIHkgYXhpcy5cbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApGNlbnRlclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHk6IHtcbiAgICAgKiAgICAgY2VudGVyOiAwXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeV9jZW50ZXI6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFNob3cgeSBheGlzIGluc2lkZSBvZiB0aGUgY2hhcnQuXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRpbm5lclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHk6IHtcbiAgICAgKiAgICAgaW5uZXI6IHRydWVcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195X2lubmVyOiAhMSxcblxuICAgIC8qKlxuICAgICAqIFNldCBsYWJlbCBvbiB5IGF4aXMuPGJyPjxicj5cbiAgICAgKiBZb3UgY2FuIHNldCB5IGF4aXMgbGFiZWwgYW5kIGNoYW5nZSBpdHMgcG9zaXRpb24gYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBbYXhpcy54LmxhYmVsXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTR4JTI1RTIlMjU4MCUyNUE0bGFiZWwpLlxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkbGFiZWxcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtTdHJpbmd8T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IHt9XG4gICAgICogQHNlZSBbYXhpcy54LmxhYmVsXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTR4JTI1RTIlMjU4MCUyNUE0bGFiZWwpIGZvciBwb3NpdGlvbiBzdHJpbmcgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5OiB7XG4gICAgICogICAgIGxhYmVsOiBcIllvdXIgWSBBeGlzXCJcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5OiB7XG4gICAgICogICAgIGxhYmVsOiB7XG4gICAgICogICAgICAgIHRleHQ6IFwiWW91ciBZIEF4aXNcIixcbiAgICAgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItbWlkZGxlXCJcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3lfbGFiZWw6IHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGZvcm1hdHRlciBmb3IgeSBheGlzIHRpY2sgdGV4dC48YnI+PGJyPlxuICAgICAqIFRoaXMgb3B0aW9uIGFjY2VwdHMgZDMuZm9ybWF0IG9iamVjdCBhcyB3ZWxsIGFzIGEgZnVuY3Rpb24geW91IGRlZmluZS5cbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRmb3JtYXRcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHk6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xuICAgICAqICAgICAgICAgICByZXR1cm4geC5nZXRGdWxsWWVhcigpO1xuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3lfdGlja19mb3JtYXQ6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFNldHRpbmcgZm9yIGN1bGxpbmcgdGlja3MuPGJyPjxicj5cbiAgICAgKiBJZiB0cnVlIGlzIHNldCwgdGhlIHRpY2tzIHdpbGwgYmUgY3VsbGVkLCB0aGVuIG9ubHkgbGltaXR0ZWQgdGljayB0ZXh0IHdpbGwgYmUgc2hvd24uIFRoaXMgb3B0aW9uIGRvZXMgbm90IGhpZGUgdGhlIHRpY2sgbGluZXMuIElmIGZhbHNlIGlzIHNldCwgYWxsIG9mIHRpY2tzIHdpbGwgYmUgc2hvd24uPGJyPjxicj5cbiAgICAgKiBXZSBjYW4gY2hhbmdlIHRoZSBudW1iZXIgb2YgdGlja3MgdG8gYmUgc2hvd24gYnkgYXhpcy55LnRpY2suY3VsbGluZy5tYXguXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkY3VsbGluZ1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHk6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIGN1bGxpbmc6IGZhbHNlXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195X3RpY2tfY3VsbGluZzogITEsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpY2sgdGV4dHMgd2lsbCBiZSBhZGp1c3RlZCB0byBsZXNzIHRoYW4gdGhpcyB2YWx1ZS5cbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRjdWxsaW5n4oCkbWF4XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHk6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIGN1bGxpbmc6IHtcbiAgICAgKiAgICAgICAgICAgbWF4OiA1XG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeV90aWNrX2N1bGxpbmdfbWF4OiA1LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB5IGF4aXMgb3V0ZXIgdGljay5cbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRvdXRlclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeToge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgb3V0ZXI6IGZhbHNlXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195X3RpY2tfb3V0ZXI6ICEwLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHkgYXhpcyB0aWNrIHZhbHVlcyBtYW51YWxseS5cbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKR2YWx1ZXNcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheXxGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5OiB7XG4gICAgICogICAgIHRpY2s6IHtcbiAgICAgKiAgICAgICB2YWx1ZXM6IFsxMDAsIDEwMDAsIDEwMDAwXSxcbiAgICAgKlxuICAgICAqICAgICAgIC8vIGFuIEFycmF5IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZFxuICAgICAqICAgICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgXHRyZXR1cm4gWyAuLi4gXTtcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195X3RpY2tfdmFsdWVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlIHkgYXhpcyB0aWNrIHRleHQuXG4gICAgICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgICogLSBBcHBsaWVkIHdoZW4gW2BheGlzLnJvdGF0ZWRgXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTRyb3RhdGVkKSBvcHRpb24gaXMgYHRydWVgLlxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHJvdGF0ZVxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5OiB7XG4gICAgICogICAgIHRpY2s6IHtcbiAgICAgKiAgICAgICByb3RhdGU6IDYwXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195X3RpY2tfcm90YXRlOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzLjxicj48YnI+XG4gICAgICogLSAqKk5PVEU6KiogVGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrcyB3aWxsIGJlIGNhbGN1bGF0ZWQgcHJlY2lzZWx5LCBzbyB0aGUgdmFsdWVzIG9uIHRoZSB0aWNrcyB3aWxsIG5vdCBiZSByb3VuZGVkIG5pY2VseS4gSW4gdGhlIGNhc2UsIGF4aXMueS50aWNrLmZvcm1hdCBvciBheGlzLnkudGljay52YWx1ZXMgd2lsbCBiZSBoZWxwZnVsLlxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGNvdW50XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeToge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgY291bnQ6IDVcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3lfdGlja19jb3VudDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBvciBoaWRlIHkgYXhpcyB0aWNrIGxpbmUuXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkc2hvd1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5OiB7XG4gICAgICogICAgIHRpY2s6IHtcbiAgICAgKiAgICAgICBzaG93OiBmYWxzZVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeV90aWNrX3Nob3c6ICEwLFxuXG4gICAgLyoqXG4gICAgICogU2V0IGF4aXMgdGljayBzdGVwKGludGVydmFsKSBzaXplLlxuICAgICAqIC0gKipOT1RFOioqIFdpbGwgYmUgaWdub3JlZCBpZiBgYXhpcy55LnRpY2suY291bnRgIG9yIGBheGlzLnkudGljay52YWx1ZXNgIG9wdGlvbnMgYXJlIHNldC5cbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRzdGVwU2l6ZVxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5TdGVwU2l6ZUZvcllBeGlzKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeToge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgLy8gdGljayB2YWx1ZSB3aWxsIHN0ZXAgYXMgaW5kaWNhdGVkIGludGVydmFsIHZhbHVlLlxuICAgICAqICAgICAgIC8vIGV4KSAnc3RlcFNpemU9MTUnID09PiBbMCwgMTUsIDMwLCA0NSwgNjBdXG4gICAgICogICAgICAgc3RlcFNpemU6IDE1XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195X3RpY2tfc3RlcFNpemU6IG51bGwsXG5cbiAgICAvKipcbiAgICAqIFNob3cgb3IgaGlkZSB5IGF4aXMgdGljayB0ZXh0LlxuICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGV4dOKApHNob3dcbiAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXG4gICAgKiBAZXhhbXBsZVxuICAgICogYXhpczoge1xuICAgICogICB5OiB7XG4gICAgKiAgICAgdGljazoge1xuICAgICogICAgICAgdGV4dDoge1xuICAgICogICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgKiAgICAgICB9XG4gICAgKiAgICAgfVxuICAgICogICB9XG4gICAgKiB9XG4gICAgKi9cbiAgICBheGlzX3lfdGlja190ZXh0X3Nob3c6ICEwLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB5IEF4aXMgdGljayB0ZXh0J3MgcG9zaXRpb24gcmVsYXRpdmVseSBpdHMgb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKR0ZXh04oCkcG9zaXRpb25cbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHQge3g6IDAsIHk6MH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHk6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIHRleHQ6IHtcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICogICAgICAgICAgIHg6IDEwLFxuICAgICAqICAgICAgICAgICB5OiAxMFxuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3lfdGlja190ZXh0X3Bvc2l0aW9uOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MuPGJyPjxicj5cbiAgICAgKiAtICoqTk9URToqKiBUaGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgY2FsY3VsYXRlZCBwcmVjaXNlbHksIHNvIHRoZSB2YWx1ZXMgb24gdGhlIHRpY2tzIHdpbGwgbm90IGJlIHJvdW5kZWQgbmljZWx5LiBJbiB0aGUgY2FzZSwgYXhpcy55LnRpY2suZm9ybWF0IG9yIGF4aXMueS50aWNrLnZhbHVlcyB3aWxsIGJlIGhlbHBmdWwuXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGltZVxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0aW1lLnZhbHVlXSBEMydzIHRpbWUgaW50ZXJ2YWwgZnVuY3Rpb24gKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lI2ludGVydmFscylcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHk6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIHRpbWU6IHtcbiAgICAgKiAgICAgICAgICAvLyB0aWNrcyBhdCAxNS1taW51dGUgaW50ZXJ2YWxzXG4gICAgICogICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCN0aW1lX3RpY2tzXG4gICAgICogICAgICAgICAgdmFsdWU6IGQzLnRpbWVNaW51dGUuZXZlcnkoMTUpXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIC8vIEBUT0RPOiBub3QgZnVsbHkgaW1wbGVtZW50ZWQgeWV0XG4gICAgYXhpc195X3RpY2tfdGltZV92YWx1ZTogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHBhZGRpbmcgZm9yIHkgYXhpcy48YnI+PGJyPlxuICAgICAqIFlvdSBjYW4gc2V0IHBhZGRpbmcgZm9yIHkgYXhpcyB0byBjcmVhdGUgbW9yZSBzcGFjZSBvbiB0aGUgZWRnZSBvZiB0aGUgYXhpcy5cbiAgICAgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIG9iamVjdCBhbmQgaXQgY2FuIGluY2x1ZGUgdG9wIGFuZCBib3R0b20uIHRvcCwgYm90dG9tIHdpbGwgYmUgdHJlYXRlZCBhcyBwaXhlbHMuXG4gICAgICpcbiAgICAgKiAtICoqTk9URToqKlxuICAgICAqICAgLSBHaXZlbiB2YWx1ZXMgYXJlIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIHkgQXhpcyBkb21haW4gdmFsdWUgZm9yIHBhZGRpbmdcbiAgICAgKiAgIC0gRm9yIGFyZWEgYW5kIGJhciB0eXBlIGNoYXJ0cywgW2FyZWEuemVyb2Jhc2VkXSgjLmFyZWEpIG9yIFtiYXIuemVyb2Jhc2VkXSgjLmJhcikgb3B0aW9ucyBzaG91bGQgYmUgc2V0IHRvICdmYWxzZWAgdG8gZ2V0IHBhZGRlZCBib3R0b20uXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRwYWRkaW5nXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fE51bWJlcn1cbiAgICAgKiBAZGVmYXVsdCB7fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeToge1xuICAgICAqICAgICBwYWRkaW5nOiB7XG4gICAgICogICAgICAgdG9wOiAwLFxuICAgICAqICAgICAgIGJvdHRvbTogMFxuICAgICAqICAgICB9LFxuICAgICAqXG4gICAgICogICAgIC8vIG9yIHNldCBib3RoIHZhbHVlcyBhdCBvbmNlLlxuICAgICAqICAgICBwYWRkaW5nOiAxMFxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3lfcGFkZGluZzoge30sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGVmYXVsdCByYW5nZSBvZiB5IGF4aXMuPGJyPjxicj5cbiAgICAgKiBUaGlzIG9wdGlvbiBzZXQgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHkgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHk6IHtcbiAgICAgKiAgICAgZGVmYXVsdDogWzAsIDEwMDBdXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeV9kZWZhdWx0OiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB5IEF4aXMuXG4gICAgICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geSBBeGlzIHZhbHVlIGlmIGRvbWFpbiBvcHRpb24gaXNuJ3Qgc2V0LlxuICAgICAqXG4gICAgICogRWFjaCBheGlzIG9iamVjdCBzaG91bGQgY29uc2lzdCB3aXRoIGZvbGxvd2luZyBvcHRpb25zOlxuICAgICAqXG4gICAgICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XG4gICAgICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuICAgICAqIHwgZG9tYWluIHwgQXJyYXkgfCAtIHwgU2V0IHRoZSBkb21haW4gdmFsdWUgfFxuICAgICAqIHwgdGljay5vdXRlciB8IEJvb2xlYW4gfCB0cnVlIHwgU2hvdyBvdXRlciB0aWNrIHxcbiAgICAgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcbiAgICAgKiB8IHRpY2suY291bnQgfCBOdW1iZXIgfCAtIHwgU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzIHxcbiAgICAgKiB8IHRpY2sudmFsdWVzIHwgQXJyYXkgfCAtIHwgU2V0IHRpY2sgdmFsdWVzIG1hbnVhbGx5IHxcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApGF4ZXNcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXG4gICAgICogQHNlZSBbRGVtbzogRG9tYWluXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXNEb21haW4pXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB5OiB7XG4gICAgICogICAgYXhlczogW1xuICAgICAqICAgICAge1xuICAgICAqICAgICAgICAvLyBpZiBzZXQsIHdpbGwgbm90IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGUgbWFpbiB5IEF4aXMgZG9tYWluIHZhbHVlXG4gICAgICogICAgICAgIGRvbWFpbjogWzAsIDEwMDBdLFxuICAgICAqICAgICAgICB0aWNrOiB7XG4gICAgICogICAgICAgICAgb3V0ZXI6IGZhbHNlLFxuICAgICAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xuICAgICAqICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XG4gICAgICogICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICBjb3VudDogMixcbiAgICAgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwXVxuICAgICAqICAgICAgICB9XG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgLi4uXG4gICAgICogICAgXVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3lfYXhlczogW10sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IG9yIGhpZGUgeTIgYXhpcy5cbiAgICAgKiAtICoqTk9URSoqOlxuICAgICAqICAgLSBXaGVuIHNldCB0byBgZmFsc2VgIHdpbGwgbm90IGdlbmVyYXRlIHkyIGF4aXMgbm9kZS4gSW4gdGhpcyBjYXNlLCBhbGwgJ3kyJyBheGlzIHJlbGF0ZWQgZnVuY3Rpb25hbGl0eSB3b24ndCB3b3JrIHByb3Blcmx5LlxuICAgICAqICAgLSBJZiBuZWVkIHRvIHVzZSAneTInIHJlbGF0ZWQgb3B0aW9ucyB3aGlsZSB5MiBpc24ndCB2aXNpYmxlLCBzZXQgdGhlIHZhbHVlIGB0cnVlYCBhbmQgY29udHJvbCB2aXNpYmlsaXR5IGJ5IGNzcyBkaXNwbGF5IHByb3BlcnR5LlxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHNob3dcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICBzaG93OiB0cnVlXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeTJfc2hvdzogITEsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgbWF4IHZhbHVlIG9mIHkyIGF4aXMuXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkbWF4XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeTI6IHtcbiAgICAgKiAgICAgbWF4OiAxMDAwXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeTJfbWF4OiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgbWluIHZhbHVlIG9mIHkyIGF4aXMuXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkbWluXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeTI6IHtcbiAgICAgKiAgICAgbWluOiAtMTAwMFxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3kyX21pbjogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBkaXJlY3Rpb24gb2YgeTIgYXhpcy48YnI+PGJyPlxuICAgICAqIElmIHRydWUgc2V0LCB0aGUgZGlyZWN0aW9uIHdpbGwgYmUgZnJvbSB0aGUgdG9wIHRvIHRoZSBib3R0b20uXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkaW52ZXJ0ZWRcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICBpbnZlcnRlZDogdHJ1ZVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3kyX2ludmVydGVkOiAhMSxcblxuICAgIC8qKlxuICAgICAqIFNldCBjZW50ZXIgdmFsdWUgb2YgeTIgYXhpcy5cbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRjZW50ZXJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICBjZW50ZXI6IDBcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195Ml9jZW50ZXI6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFNob3cgeTIgYXhpcyBpbnNpZGUgb2YgdGhlIGNoYXJ0LlxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApGlubmVyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeTI6IHtcbiAgICAgKiAgICAgaW5uZXI6IHRydWVcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195Ml9pbm5lcjogITEsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgbGFiZWwgb24geTIgYXhpcy48YnI+PGJyPlxuICAgICAqIFlvdSBjYW4gc2V0IHkyIGF4aXMgbGFiZWwgYW5kIGNoYW5nZSBpdHMgcG9zaXRpb24gYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBbYXhpcy54LmxhYmVsXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTR4JTI1RTIlMjU4MCUyNUE0bGFiZWwpLlxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApGxhYmVsXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cbiAgICAgKiBAZGVmYXVsdCB7fVxuICAgICAqIEBzZWUgW2F4aXMueC5sYWJlbF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0eCUyNUUyJTI1ODAlMjVBNGxhYmVsKSBmb3IgcG9zaXRpb24gc3RyaW5nIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeTI6IHtcbiAgICAgKiAgICAgbGFiZWw6IFwiWW91ciBZMiBBeGlzXCJcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICBsYWJlbDoge1xuICAgICAqICAgICAgICB0ZXh0OiBcIllvdXIgWTIgQXhpc1wiLFxuICAgICAqICAgICAgICBwb3NpdGlvbjogXCJvdXRlci1taWRkbGVcIlxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeTJfbGFiZWw6IHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGZvcm1hdHRlciBmb3IgeTIgYXhpcyB0aWNrIHRleHQuPGJyPjxicj5cbiAgICAgKiBUaGlzIG9wdGlvbiB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgYXhpcy55LmZvcm1hdC5cbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkZm9ybWF0XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgZm9ybWF0OiBkMy5mb3JtYXQoXCIkLFwiKVxuICAgICAqICAgICAgIC8vb3IgZm9ybWF0OiBmdW5jdGlvbihkKSB7IHJldHVybiBcIiRcIiArIGQ7IH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3kyX3RpY2tfZm9ybWF0OiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XG4gICAgICogSWYgdHJ1ZSBpcyBzZXQsIHRoZSB0aWNrcyB3aWxsIGJlIGN1bGxlZCwgdGhlbiBvbmx5IGxpbWl0dGVkIHRpY2sgdGV4dCB3aWxsIGJlIHNob3duLiBUaGlzIG9wdGlvbiBkb2VzIG5vdCBoaWRlIHRoZSB0aWNrIGxpbmVzLiBJZiBmYWxzZSBpcyBzZXQsIGFsbCBvZiB0aWNrcyB3aWxsIGJlIHNob3duLjxicj48YnI+XG4gICAgICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueS50aWNrLmN1bGxpbmcubWF4LlxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRjdWxsaW5nXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeTI6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIGN1bGxpbmc6IGZhbHNlXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195Ml90aWNrX2N1bGxpbmc6ICExLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB0aWNrIHRleHRzIHdpbGwgYmUgYWRqdXN0ZWQgdG8gbGVzcyB0aGFuIHRoaXMgdmFsdWUuXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApGN1bGxpbmfigKRtYXhcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgNVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeTI6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIGN1bGxpbmc6IHtcbiAgICAgKiAgICAgICAgICAgbWF4OiA1XG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeTJfdGlja19jdWxsaW5nX21heDogNSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgb3IgaGlkZSB5MiBheGlzIG91dGVyIHRpY2suXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApG91dGVyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgb3V0ZXI6IGZhbHNlXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195Ml90aWNrX291dGVyOiAhMCxcblxuICAgIC8qKlxuICAgICAqIFNldCB5MiBheGlzIHRpY2sgdmFsdWVzIG1hbnVhbGx5LlxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKR2YWx1ZXNcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheXxGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgdmFsdWVzOiBbMTAwLCAxMDAwLCAxMDAwMF0sXG4gICAgICpcbiAgICAgKiAgICAgICAvLyBhbiBBcnJheSB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWRcbiAgICAgKiAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgIFx0cmV0dXJuIFsgLi4uIF07XG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeTJfdGlja192YWx1ZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgeTIgYXhpcyB0aWNrIHRleHQuXG4gICAgICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgICogLSBBcHBsaWVkIHdoZW4gW2BheGlzLnJvdGF0ZWRgXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTRyb3RhdGVkKSBvcHRpb24gaXMgYHRydWVgLlxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRyb3RhdGVcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXhpczoge1xuICAgICAqICAgeTI6IHtcbiAgICAgKiAgICAgdGljazoge1xuICAgICAqICAgICAgIHJvdGF0ZTogNjBcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3kyX3RpY2tfcm90YXRlOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBudW1iZXIgb2YgeTIgYXhpcyB0aWNrcy5cbiAgICAgKiAtICoqTk9URToqKiBUaGlzIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBheGlzLnkudGljay5jb3VudC5cbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkY291bnRcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgY291bnQ6IDVcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3kyX3RpY2tfY291bnQ6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFNob3cgb3IgaGlkZSB5MiBheGlzIHRpY2sgbGluZS5cbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkc2hvd1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgc2hvdzogZmFsc2VcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3kyX3RpY2tfc2hvdzogITAsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYXhpcyB0aWNrIHN0ZXAoaW50ZXJ2YWwpIHNpemUuXG4gICAgICogLSAqKk5PVEU6KiogV2lsbCBiZSBpZ25vcmVkIGlmIGBheGlzLnkyLnRpY2suY291bnRgIG9yIGBheGlzLnkyLnRpY2sudmFsdWVzYCBvcHRpb25zIGFyZSBzZXQuXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHN0ZXBTaXplXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlN0ZXBTaXplRm9yWUF4aXMpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgLy8gdGljayB2YWx1ZSB3aWxsIHN0ZXAgYXMgaW5kaWNhdGVkIGludGVydmFsIHZhbHVlLlxuICAgICAqICAgICAgIC8vIGV4KSAnc3RlcFNpemU9MTUnID09PiBbMCwgMTUsIDMwLCA0NSwgNjBdXG4gICAgICogICAgICAgc3RlcFNpemU6IDE1XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195Ml90aWNrX3N0ZXBTaXplOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBvciBoaWRlIHkyIGF4aXMgdGljayB0ZXh0LlxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKR0ZXh04oCkc2hvd1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICB0aWNrOiB7XG4gICAgICogICAgICAgdGV4dDoge1xuICAgICAqICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3kyX3RpY2tfdGV4dF9zaG93OiAhMCxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgeTIgQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKR0ZXh04oCkcG9zaXRpb25cbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHQge3g6IDAsIHk6MH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF4aXM6IHtcbiAgICAgKiAgIHkyOiB7XG4gICAgICogICAgIHRpY2s6IHtcbiAgICAgKiAgICAgICB0ZXh0OiB7XG4gICAgICogICAgICAgICBwb3NpdGlvbjoge1xuICAgICAqICAgICAgICAgICB4OiAxMCxcbiAgICAgKiAgICAgICAgICAgeTogMTBcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195Ml90aWNrX3RleHRfcG9zaXRpb246IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBwYWRkaW5nIGZvciB5MiBheGlzLjxicj48YnI+XG4gICAgICogWW91IGNhbiBzZXQgcGFkZGluZyBmb3IgeTIgYXhpcyB0byBjcmVhdGUgbW9yZSBzcGFjZSBvbiB0aGUgZWRnZSBvZiB0aGUgYXhpcy5cbiAgICAgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIG9iamVjdCBhbmQgaXQgY2FuIGluY2x1ZGUgdG9wIGFuZCBib3R0b20uIHRvcCwgYm90dG9tIHdpbGwgYmUgdHJlYXRlZCBhcyBwaXhlbHMuXG4gICAgICpcbiAgICAgKiAtICoqTk9URToqKlxuICAgICAqICAgLSBHaXZlbiB2YWx1ZXMgYXJlIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIHkyIEF4aXMgZG9tYWluIHZhbHVlIGZvciBwYWRkaW5nXG4gICAgICogICAtIEZvciBhcmVhIGFuZCBiYXIgdHlwZSBjaGFydHMsIFthcmVhLnplcm9iYXNlZF0oIy5hcmVhKSBvciBbYmFyLnplcm9iYXNlZF0oIy5iYXIpIG9wdGlvbnMgc2hvdWxkIGJlIHNldCB0byAnZmFsc2VgIHRvIGdldCBwYWRkZWQgYm90dG9tLlxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHBhZGRpbmdcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R8TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IHt9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICBwYWRkaW5nOiB7XG4gICAgICogICAgICAgdG9wOiAxMDAsXG4gICAgICogICAgICAgYm90dG9tOiAxMDBcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogICAgIC8vIG9yIHNldCBib3RoIHZhbHVlcyBhdCBvbmNlLlxuICAgICAqICAgICBwYWRkaW5nOiAxMFxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGlzX3kyX3BhZGRpbmc6IHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlZmF1bHQgcmFuZ2Ugb2YgeTIgYXhpcy48YnI+PGJyPlxuICAgICAqIFRoaXMgb3B0aW9uIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgeTIgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRkZWZhdWx0XG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBheGlzOiB7XG4gICAgICogICB5Mjoge1xuICAgICAqICAgICBkZWZhdWx0OiBbMCwgMTAwMF1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhpc195Ml9kZWZhdWx0OiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB5MiBBeGlzLlxuICAgICAqIC0gKipOT1RFOioqIEF4aXMnIHNjYWxlIGlzIGJhc2VkIG9uIHkyIEF4aXMgdmFsdWUgaWYgZG9tYWluIG9wdGlvbiBpc24ndCBzZXQuXG4gICAgICpcbiAgICAgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XG4gICAgICpcbiAgICAgKiB8IE5hbWUgfCBUeXBlIHwgRGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcbiAgICAgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XG4gICAgICogfCBkb21haW4gfCBBcnJheSB8IC0gfCBTZXQgdGhlIGRvbWFpbiB2YWx1ZSB8XG4gICAgICogfCB0aWNrLm91dGVyIHwgQm9vbGVhbiB8IHRydWUgfCBTaG93IG91dGVyIHRpY2sgfFxuICAgICAqIHwgdGljay5mb3JtYXQgfCBGdW5jdGlvbiB8IC0gfCBTZXQgZm9ybWF0dGVyIGZvciB0aWNrIHRleHQgfFxuICAgICAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxuICAgICAqIHwgdGljay52YWx1ZXMgfCBBcnJheSB8IC0gfCBTZXQgdGljayB2YWx1ZXMgbWFudWFsbHkgfFxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApGF4ZXNcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXG4gICAgICogQHNlZSBbRGVtbzogRG9tYWluXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXNEb21haW4pXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB5Mjoge1xuICAgICAqICAgIGF4ZXM6IFtcbiAgICAgKiAgICAgIHtcbiAgICAgKiAgICAgICAgLy8gaWYgc2V0LCB3aWxsIG5vdCBiZSBjb3JyZWxhdGVkIHdpdGggdGhlIG1haW4geTIgQXhpcyBkb21haW4gdmFsdWVcbiAgICAgKiAgICAgICAgZG9tYWluOiBbMCwgMTAwMF0sXG4gICAgICogICAgICAgIHRpY2s6IHtcbiAgICAgKiAgICAgICAgICBvdXRlcjogZmFsc2UsXG4gICAgICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XG4gICAgICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcbiAgICAgKiAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgIGNvdW50OiAyLFxuICAgICAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgIH0sXG4gICAgICogICAgICAuLi5cbiAgICAgKiAgICBdXG4gICAgICogfVxuICAgICAqL1xuICAgIGF4aXNfeTJfYXhlczogW10sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgcmVsYXRlZCBvcHRpb25zXG4gICAgICogQG5hbWUgZ3JpZFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtmcm9udD1mYWxzZV0gU2V0ICdncmlkICYgZm9jdXMgbGluZXMnIHRvIGJlIHBvc2l0aW9uZWQgb3ZlciBncmlkIGxpbmVzIGFuZCBjaGFydCBlbGVtZW50cy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt4LnNob3c9ZmFsc2VdIFNob3cgZ3JpZHMgYWxvbmcgeCBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt4LmxpbmVzPVtdXSBTaG93IGFkZGl0aW9uYWwgZ3JpZCBsaW5lcyBhbG9uZyB4IGF4aXMuPGJyPlxuICAgICAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgdmFsdWUsIHRleHQsIHBvc2l0aW9uIGFuZCBjbGFzcy4gdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzIGFyZSBvcHRpb25hbC4gRm9yIHBvc2l0aW9uLCBzdGFydCwgbWlkZGxlIGFuZCBlbmQgKGRlZmF1bHQpIGFyZSBhdmFpbGFibGUuXG4gICAgICogIElmIHggYXhpcyBpcyBjYXRlZ29yeSBheGlzLCB2YWx1ZSBjYW4gYmUgY2F0ZWdvcnkgbmFtZS4gSWYgeCBheGlzIGlzIHRpbWVzZXJpZXMgYXhpcywgdmFsdWUgY2FuIGJlIGRhdGUgc3RyaW5nLCBEYXRlIG9iamVjdCBhbmQgdW5peHRpbWUgaW50ZWdlci5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt5LnNob3c9ZmFsc2VdIFNob3cgZ3JpZHMgYWxvbmcgeCBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt5LmxpbmVzPVtdXSBTaG93IGFkZGl0aW9uYWwgZ3JpZCBsaW5lcyBhbG9uZyB5IGF4aXMuPGJyPlxuICAgICAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgdmFsdWUsIHRleHQsIHBvc2l0aW9uIGFuZCBjbGFzcy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3kudGlja3M9MTBdIE51bWJlciBvZiB5IGdyaWRzIHRvIGJlIHNob3duLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ZvY3VzLmVkZ2U9ZmFsc2VdIFNob3cgZWRnZWQgZm9jdXMgZ3JpZCBsaW5lLjxicj4qKk5PVEU6KiogQXZhaWxhYmxlIHdoZW4gW2B0b29sdGlwLmdyb3VwZWQ9ZmFsc2VgXSgjLnRvb2x0aXApIG9wdGlvbiBpcyBzZXQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZm9jdXMuc2hvdz10cnVlXSBTaG93IGdyaWQgbGluZSB3aGVuIGZvY3VzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ZvY3VzLnk9ZmFsc2VdIFNob3cgeSBjb29yZGluYXRlIGZvY3VzIGdyaWQgbGluZS48YnI+KipOT1RFOioqIEF2YWlsYWJsZSB3aGVuIFtgdG9vbHRpcC5ncm91cGVkPWZhbHNlYF0oIy50b29sdGlwKSBvcHRpb24gaXMgc2V0LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xpbmVzLmZyb250PXRydWVdIFNldCBncmlkIGxpbmVzIHRvIGJlIHBvc2l0aW9uZWQgb3ZlciBjaGFydCBlbGVtZW50cy5cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5HcmlkTGluZXMpXG4gICAgICogQHNlZSBbRGVtbzogWCBHcmlkIExpbmVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5PcHRpb25hbFhHcmlkTGluZXMpXG4gICAgICogQHNlZSBbRGVtbzogWSBHcmlkIExpbmVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5PcHRpb25hbFlHcmlkTGluZXMpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBncmlkOiB7XG4gICAgICogICB4OiB7XG4gICAgICogICAgIHNob3c6IHRydWUsXG4gICAgICogICAgIGxpbmVzOiBbXG4gICAgICogICAgICAge3ZhbHVlOiAyLCB0ZXh0OiBcIkxhYmVsIG9uIDJcIn0sXG4gICAgICogICAgICAge3ZhbHVlOiA1LCB0ZXh0OiBcIkxhYmVsIG9uIDVcIiwgY2xhc3M6IFwibGFiZWwtNVwifSxcbiAgICAgKiAgICAgICB7dmFsdWU6IDYsIHRleHQ6IFwiTGFiZWwgb24gNlwiLCBwb3NpdGlvbjogXCJzdGFydFwifVxuICAgICAqICAgICBdXG4gICAgICogICB9LFxuICAgICAqICAgeToge1xuICAgICAqICAgICBzaG93OiB0cnVlLFxuICAgICAqICAgICBsaW5lczogW1xuICAgICAqICAgICAgIHt2YWx1ZTogMTAwLCB0ZXh0OiBcIkxhYmVsIG9uIDEwMFwifSxcbiAgICAgKiAgICAgICB7dmFsdWU6IDIwMCwgdGV4dDogXCJMYWJlbCBvbiAyMDBcIiwgY2xhc3M6IFwibGFiZWwtMjAwXCJ9LFxuICAgICAqICAgICAgIHt2YWx1ZTogMzAwLCB0ZXh0OiBcIkxhYmVsIG9uIDMwMFwiLCBwb3NpdGlvbjogJ21pZGRsZSd9XG4gICAgICogICAgIF0sXG4gICAgICogICAgIHRpY2tzOiA1XG4gICAgICogICB9LFxuICAgICAqICAgZnJvbnQ6IHRydWUsXG4gICAgICogICBmb2N1czoge1xuICAgICAqICAgICAgc2hvdzogZmFsc2UsXG4gICAgICpcbiAgICAgKiAgICAgIC8vIEJlbG93IG9wdGlvbnMgYXJlIGF2YWlsYWJsZSB3aGVuICd0b29sdGlwLmdyb3VwZWQ9ZmFsc2UnIG9wdGlvbiBpcyBzZXRcbiAgICAgKiAgICAgIGVkZ2U6IHRydWUsXG4gICAgICogICAgICB5OiB0cnVlXG4gICAgICogICB9LFxuICAgICAqICAgbGluZXM6IHtcbiAgICAgKiAgICAgIGZyb250OiBmYWxzZVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBncmlkX3hfc2hvdzogITEsXG4gICAgZ3JpZF94X3R5cGU6IFwidGlja1wiLFxuICAgIGdyaWRfeF9saW5lczogW10sXG4gICAgZ3JpZF95X3Nob3c6ICExLFxuICAgIGdyaWRfeV9saW5lczogW10sXG4gICAgZ3JpZF95X3RpY2tzOiAxMCxcbiAgICBncmlkX2ZvY3VzX2VkZ2U6ICExLFxuICAgIGdyaWRfZm9jdXNfc2hvdzogITAsXG4gICAgZ3JpZF9mb2N1c195OiAhMSxcbiAgICBncmlkX2Zyb250OiAhMSxcbiAgICBncmlkX2xpbmVzX2Zyb250OiAhMCxcblxuICAgIC8qKlxuICAgICAqIFNldCBwb2ludCBvcHRpb25zXG4gICAgICogQG5hbWUgcG9pbnRcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcG9pbnQuc2hvdz10cnVlXSBXaGV0aGVyIHRvIHNob3cgZWFjaCBwb2ludCBpbiBsaW5lLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfEZ1bmN0aW9ufSBbcG9pbnQucj0yLjVdIFRoZSByYWRpdXMgc2l6ZSBvZiBlYWNoIHBvaW50LlxuICAgICAqICAtICoqTk9URToqKiBEaXNhYmxlZCBmb3IgJ2J1YmJsZScgdHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3BvaW50LmZvY3VzLmV4cGFuZC5lbmFibGVkPXRydWVdIFdoZXRoZXIgdG8gZXhwYW5kIGVhY2ggcG9pbnQgb24gZm9jdXMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwb2ludC5mb2N1cy5leHBhbmQucj1wb2ludC5yKjEuNzVdIFRoZSByYWRpdXMgc2l6ZSBvZiBlYWNoIHBvaW50IG9uIGZvY3VzLlxuICAgICAqICAtICoqTk9URToqKiBGb3IgJ2J1YmJsZScgdHlwZSwgdGhlIGRlZmF1bHQgaXMgYGJ1YmJsZVNpemUqMS4xNWBcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BvaW50LnNlbnNpdGl2aXR5PTEwXSBUaGUgc2Vuc3Rpdml0eSB2YWx1ZSBmb3IgaW50ZXJhY3Rpb24gYm91bmRhcnkuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwb2ludC5zZWxlY3Qucj1wb2ludC5yKjRdIFRoZSByYWRpdXMgc2l6ZSBvZiBlYWNoIHBvaW50IG9uIHNlbGVjdGVkLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcG9pbnQudHlwZT1cImNpcmNsZVwiXSBUaGUgdHlwZSBvZiBwb2ludCB0byBiZSBkcmF3blxuICAgICAqIC0gKipOT1RFOioqXG4gICAgICogICAtIElmIGNoYXJ0IGhhcyAnYnViYmxlJyB0eXBlLCBvbmx5IGNpcmNsZSBjYW4gYmUgdXNlZC5cbiAgICAgKiAgIC0gRm9yIElFLCBub24gY2lyY2xlIHBvaW50IGV4cGFuc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZHVlIHRvIGxhY2sgb2YgdHJhbnNmb3JtIHN1cHBvcnQuXG4gICAgICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcbiAgICAgKiAgIC0gY2lyY2xlXG4gICAgICogICAtIHJlY3RhbmdsZVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtwb2ludC5wYXR0ZXJuPVtdXSBUaGUgdHlwZSBvZiBwb2ludCBvciBzdmcgc2hhcGUgYXMgc3RyaW5nLCB0byBiZSBkcmF3biBmb3IgZWFjaCBsaW5lXG4gICAgICogLSAqKk5PVEU6KipcbiAgICAgKiAgIC0gVGhpcyBpcyBhbiBgZXhwZXJpbWVudGFsYCBmZWF0dXJlIGFuZCBjYW4gaGF2ZSBzb21lIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLlxuICAgICAqICAgLSBJZiBjaGFydCBoYXMgJ2J1YmJsZScgdHlwZSwgb25seSBjaXJjbGUgY2FuIGJlIHVzZWQuXG4gICAgICogICAtIEZvciBJRSwgbm9uIGNpcmNsZSBwb2ludCBleHBhbnNpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGR1ZSB0byBsYWNrIG9mIHRyYW5zZm9ybSBzdXBwb3J0LlxuICAgICAqIC0gKipBdmFpbGFibGUgVmFsdWVzOioqXG4gICAgICogICAtIGNpcmNsZVxuICAgICAqICAgLSByZWN0YW5nbGVcbiAgICAgKiAgIC0gc3ZnIHNoYXBlIHRhZyBpbnRlcnByZXRlZCBhcyBzdHJpbmc8YnI+XG4gICAgICogICAgIChleC4gYDxwb2x5Z29uIHBvaW50cz0nMi41IDAgMCA1IDUgNSc+PC9wb2x5Z29uPmApXG4gICAgICogQHNlZSBbRGVtbzogcG9pbnQgdHlwZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1BvaW50LlJlY3RhbmdsZVBvaW50cylcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBwb2ludDoge1xuICAgICAqICAgICAgc2hvdzogZmFsc2UsXG4gICAgICogICAgICByOiA1LFxuICAgICAqXG4gICAgICogICAgICAvLyBvciBjdXN0b21pemUgdGhlIHJhZGl1c1xuICAgICAqICAgICAgcjogZnVuY3Rpb24oZCkge1xuICAgICAqICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgIHJldHVybiByO1xuICAgICAqICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAgZm9jdXM6IHtcbiAgICAgKiAgICAgICAgICBleHBhbmQ6IHtcbiAgICAgKiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgKiAgICAgICAgICAgICAgcjogMVxuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgIH0sXG4gICAgICogICAgICBzZWxlY3Q6IHtcbiAgICAgKiAgICAgICAgICByOiAzXG4gICAgICogICAgICB9LFxuICAgICAqXG4gICAgICogICAgICAvLyBoYXZpbmcgbG93ZXIgdmFsdWUsIG1lYW5zIGhvdyBjbG9zZXIgdG8gYmUgZm9yIGludGVyYWN0aW9uXG4gICAgICogICAgICBzZW5zaXRpdml0eTogMyxcbiAgICAgKlxuICAgICAqICAgICAgLy8gdmFsaWQgdmFsdWVzIGFyZSBcImNpcmNsZVwiIG9yIFwicmVjdGFuZ2xlXCJcbiAgICAgKiAgICAgIHR5cGU6IFwicmVjdGFuZ2xlXCIsXG4gICAgICpcbiAgICAgKiAgICAgIC8vIG9yIGluZGljYXRlIGFzIHBhdHRlcm5cbiAgICBcdCAqICAgICAgcGF0dGVybjogW1xuICAgIFx0ICogICAgICAgIFwiY2lyY2xlXCIsXG4gICAgXHQgKiAgICAgICAgXCJyZWN0YW5nbGVcIixcbiAgICBcdCAqICAgICAgICBcIjxwb2x5Z29uIHBvaW50cz0nMCA2IDQgMCAtNCAwJz48L3BvbHlnb24+XCJcbiAgICBcdCAqICAgICBdLFxuICAgICAqICB9XG4gICAgICovXG4gICAgcG9pbnRfc2hvdzogITAsXG4gICAgcG9pbnRfcjogMi41LFxuICAgIHBvaW50X3NlbnNpdGl2aXR5OiAxMCxcbiAgICBwb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZDogITAsXG4gICAgcG9pbnRfZm9jdXNfZXhwYW5kX3I6IHVuZGVmaW5lZCxcbiAgICBwb2ludF9wYXR0ZXJuOiBbXSxcbiAgICBwb2ludF9zZWxlY3RfcjogdW5kZWZpbmVkLFxuICAgIHBvaW50X3R5cGU6IFwiY2lyY2xlXCIsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgbGluZSBvcHRpb25zXG4gICAgICogQG5hbWUgbGluZVxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsaW5lLmNvbm5lY3ROdWxsPWZhbHNlXSBTZXQgaWYgbnVsbCBkYXRhIHBvaW50IHdpbGwgYmUgY29ubmVjdGVkIG9yIG5vdC48YnI+XG4gICAgICogIElmIHRydWUgc2V0LCB0aGUgcmVnaW9uIG9mIG51bGwgZGF0YSB3aWxsIGJlIGNvbm5lY3RlZCB3aXRob3V0IGFueSBkYXRhIHBvaW50LiBJZiBmYWxzZSBzZXQsIHRoZSByZWdpb24gb2YgbnVsbCBkYXRhIHdpbGwgbm90IGJlIGNvbm5lY3RlZCBhbmQgZ2V0IGVtcHR5LlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9ICAgW2xpbmUuY2xhc3Nlcz11bmRlZmluZWRdIElmIHNldCwgdXNlZCB0byBzZXQgYSBjc3MgY2xhc3Mgb24gZWFjaCBsaW5lLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xpbmUuc3RlcC50eXBlPXN0ZXBdIENoYW5nZSBzdGVwIHR5cGUgZm9yIHN0ZXAgY2hhcnQuPGJyPlxuICAgICAqICoqQXZhaWxhYmxlIHZhbHVlczoqKlxuICAgICAqIC0gc3RlcFxuICAgICAqIC0gc3RlcC1iZWZvcmVcbiAgICAgKiAtIHN0ZXAtYWZ0ZXJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW58QXJyYXl9IFtsaW5lLnBvaW50PXRydWVdIFNldCB0byBmYWxzZSB0byBub3QgZHJhdyBwb2ludHMgb24gbGluZWNoYXJ0cy4gT3IgcGFzcyBhbiBhcnJheSBvZiBsaW5lIGlkcyB0byBkcmF3IHBvaW50cyBmb3IuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGluZS56ZXJvYmFzZWQ9ZmFsc2VdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBsaW5lIGNoYXJ0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIGxpbmU6IHtcbiAgICAgKiAgICAgIGNvbm5lY3ROdWxsOiB0cnVlLFxuICAgICAqICAgICAgY2xhc3NlczogW1xuICAgICAqICAgICAgICAgIFwibGluZS1jbGFzczFcIixcbiAgICAgKiAgICAgICAgICBcImxpbmUtY2xhc3MyXCJcbiAgICAgKiAgICAgIF0sXG4gICAgICogICAgICBzdGVwOiB7XG4gICAgICogICAgICAgICAgdHlwZTogXCJzdGVwLWFmdGVyXCJcbiAgICAgKiAgICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgIC8vIGhpZGUgYWxsIGRhdGEgcG9pbnRzICgncG9pbnQuc2hvdz1mYWxzZScgYWxzbyBoYXMgc2ltaWxhciBlZmZlY3QpXG4gICAgICogICAgICBwb2ludDogZmFsc2UsXG4gICAgICpcbiAgICAgKiAgICAgIC8vIHNob3cgZGF0YSBwb2ludHMgZm9yIG9ubHkgaW5kaWNhdGVkIGRhdGFzXG4gICAgICogICAgICBwb2ludDogW1xuICAgICAqICAgICAgICAgIFwiZGF0YTFcIiwgXCJkYXRhM1wiXG4gICAgICogICAgICBdLFxuICAgICAqXG4gICAgICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXG4gICAgICogIH1cbiAgICAgKi9cbiAgICBsaW5lX2Nvbm5lY3ROdWxsOiAhMSxcbiAgICBsaW5lX3N0ZXBfdHlwZTogXCJzdGVwXCIsXG4gICAgbGluZV96ZXJvYmFzZWQ6ICExLFxuICAgIGxpbmVfY2xhc3NlczogdW5kZWZpbmVkLFxuICAgIGxpbmVfcG9pbnQ6ICEwLFxuXG4gICAgLyoqXG4gICAgXHQqIFNldCBzY2F0dGVyIG9wdGlvbnNcbiAgICBcdCogQG5hbWUgc2NhdHRlclxuICAgIFx0KiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgIFx0KiBAdHlwZSB7T2JqZWN0fVxuICAgIFx0KiBAcHJvcGVydHkge0Jvb2xlYW59IFtzY2F0dGVyLnplcm9iYXNlZD1mYWxzZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIHNjYXR0ZXIgY2hhcnQuXG4gICAgXHQqIEBleGFtcGxlXG4gICAgXHQqICBzY2F0dGVyOiB7XG4gICAgXHQqICAgICAgY29ubmVjdE51bGw6IHRydWUsXG4gICAgXHQqICAgICAgc3RlcDoge1xuICAgIFx0KiAgICAgICAgICB0eXBlOiBcInN0ZXAtYWZ0ZXJcIlxuICAgIFx0KiAgICAgIH0sXG4gICAgXHQqXG4gICAgXHQqICAgICAgLy8gaGlkZSBhbGwgZGF0YSBwb2ludHMgKCdwb2ludC5zaG93PWZhbHNlJyBhbHNvIGhhcyBzaW1pbGFyIGVmZmVjdClcbiAgICBcdCogICAgICBwb2ludDogZmFsc2UsXG4gICAgXHQqXG4gICAgXHQqICAgICAgLy8gc2hvdyBkYXRhIHBvaW50cyBmb3Igb25seSBpbmRpY2F0ZWQgZGF0YXNcbiAgICBcdCogICAgICBwb2ludDogW1xuICAgIFx0KiAgICAgICAgICBcImRhdGExXCIsIFwiZGF0YTNcIlxuICAgIFx0KiAgICAgIF0sXG4gICAgXHQqXG4gICAgXHQqICAgICAgemVyb2Jhc2VkOiBmYWxzZVxuICAgIFx0KiAgfVxuICAgIFx0Ki9cbiAgICBzY2F0dGVyX3plcm9iYXNlZDogITEsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYmFyIG9wdGlvbnNcbiAgICAgKiBAbmFtZSBiYXJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIucGFkZGluZz0wXSBUaGUgcGFkZGluZyBwaXhlbCB2YWx1ZSBiZXR3ZWVuIGVhY2ggYmFyLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLnJhZGl1c10gU2V0IHRoZSByYWRpdXMgb2YgYmFyIGVkZ2UgaW4gcGl4ZWwuXG4gICAgICogLSAqKk5PVEU6KiogV29ya3Mgb25seSBmb3Igbm9uLXN0YWNrZWQgYmFyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIucmFkaXVzLnJhdGlvXSBTZXQgdGhlIHJhZGl1cyByYXRpbyBvZiBiYXIgZWRnZSBpbiByZWxhdGl2ZSB0aGUgYmFyJ3Mgd2lkdGguXG4gICAgXHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci5zZW5zaXRpdml0eT0yXSBUaGUgc2Vuc3Rpdml0eSBvZmZzZXQgdmFsdWUgZm9yIGludGVyYWN0aW9uIGJvdW5kYXJ5LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoXSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBjaGFydC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci53aWR0aC5yYXRpbz0wLjZdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGNoYXJ0IGJ5IHJhdGlvLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLm1heF0gVGhlIG1heGltdW0gd2lkdGggdmFsdWUgZm9yIHJhdGlvLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLmRhdGFuYW1lXSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBmb3IgaW5kaWNhdGVkIGRhdGFzZXQgb25seS5cbiAgICAgKiAtICoqTk9URToqKlxuICAgICAqICAgLSBXb3JrcyBvbmx5IGZvciBub24tc3RhY2tlZCBiYXJcbiAgICAgKiAgIC0gQmFycyBhcmUgY2VudGVyZWQgYWNjb2RpbmcgaXRzIHRvdGFsIHdpZHRoIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGguZGF0YW5hbWUucmF0aW89MC42XSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBjaGFydCBieSByYXRpby5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci53aWR0aC5kYXRhbmFtZS5tYXhdIFRoZSBtYXhpbXVtIHdpZHRoIHZhbHVlIGZvciByYXRpby5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtiYXIuemVyb2Jhc2VkPXRydWVdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBiYXIgY2hhcnQuXG4gICAgICogQHNlZSBbRGVtbzogYmFyIHBhZGRpbmddKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNCYXJDaGFydE9wdGlvbnMuQmFyUGFkZGluZylcbiAgICAgKiBAc2VlIFtEZW1vOiBiYXIgcmFkaXVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhclJhZGl1cylcbiAgICAgKiBAc2VlIFtEZW1vOiBiYXIgd2lkdGhdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNCYXJDaGFydE9wdGlvbnMuQmFyV2lkdGgpXG4gICAgICogQHNlZSBbRGVtbzogYmFyIHdpZHRoIHZhcmlhbnRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNCYXJDaGFydE9wdGlvbnMuQmFyV2lkdGhWYXJpYW50KVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIGJhcjoge1xuICAgICAqICAgICAgcGFkZGluZzogMSxcbiAgICAgKlxuICAgICAqICAgICAgLy8gdGhlICdyYWRpdXMnIG9wdGlvbiBjYW4gYmUgdXNlZCBvbmx5IGZvciBub24tc3RhY2tpbmcgYmFyc1xuICAgICAqICAgICAgcmFkaXVzOiAxMCxcbiAgICAgKiAgICAgIC8vIG9yXG4gICAgICogICAgICByYWRpdXM6IHtcbiAgICAgKiAgICAgICAgICByYXRpbzogMC41XG4gICAgICogICAgICB9XG4gICAgICpcbiAgICAgKiAgICAgIC8vIHdpbGwgbm90IGhhdmUgb2Zmc2V0IGJldHdlZW4gZWFjaCBiYXIgZWxlbWVudHMgZm9yIGludGVyYWN0aW9uXG4gICAgICogICAgICBzZW5zaXRpdml0eTogMCxcbiAgICAgKlxuICAgICAqICAgICAgd2lkdGg6IDEwLFxuICAgICAqXG4gICAgICogICAgICAvLyBvclxuICAgICAqICAgICAgd2lkdGg6IHtcbiAgICAgKiAgICAgICAgICByYXRpbzogMC4yLFxuICAgICAqICAgICAgICAgIG1heDogMjBcbiAgICAgKiAgICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgIC8vIG9yIHNwZWNpZnkgd2lkdGggcGVyIGRhdGFzZXRcbiAgICAgKiAgICAgIHdpZHRoOiB7XG4gICAgICogICAgICAgICAgZGF0YTE6IDIwLFxuICAgICAqICAgICAgICAgIGRhdGEyOiB7XG4gICAgICogICAgICAgICAgICAgIHJhdGlvOiAwLjIsXG4gICAgICogICAgICAgICAgICAgIG1heDogMjBcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9LFxuICAgICAqXG4gICAgICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXG4gICAgICogIH1cbiAgICAgKi9cbiAgICBiYXJfcGFkZGluZzogMCxcbiAgICBiYXJfcmFkaXVzOiB1bmRlZmluZWQsXG4gICAgYmFyX3JhZGl1c19yYXRpbzogdW5kZWZpbmVkLFxuICAgIGJhcl9zZW5zaXRpdml0eTogMixcbiAgICBiYXJfd2lkdGg6IHVuZGVmaW5lZCxcbiAgICBiYXJfd2lkdGhfcmF0aW86IC42LFxuICAgIGJhcl93aWR0aF9tYXg6IHVuZGVmaW5lZCxcbiAgICBiYXJfemVyb2Jhc2VkOiAhMCxcblxuICAgIC8qKlxuICAgICAqIFNldCBidWJibGUgb3B0aW9uc1xuICAgICAqIEBuYW1lIGJ1YmJsZVxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxGdW5jdGlvbn0gW2J1YmJsZS5tYXhSPTM1XSBTZXQgdGhlIG1heCBidWJibGUgcmFkaXVzIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbYnViYmxlLnplcm9iYXNlZD1mYWxzZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGJ1YmJsZSBjaGFydC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBidWJibGU6IHtcbiAgICAgKiAgICAgIC8vIGV4KSBJZiAxMDAgaXMgdGhlIGhpZ2hlc3QgdmFsdWUgYW1vbmcgZGF0YSBib3VuZCwgdGhlIHJlcHJlc2VudGF0aW9uIGJ1YmJsZSBvZiAxMDAgd2lsbCBoYXZlIHJhZGl1cyBvZiA1MC5cbiAgICAgKiAgICAgIC8vIEFuZCB0aGUgbGVzc2VyIHdpbGwgaGF2ZSByYWRpdXMgcmVsYXRpdmVseSBmcm9tIHRoYSBtYXggdmFsdWUuXG4gICAgICogICAgICBtYXhSOiA1MCxcbiAgICAgKlxuICAgICAqICAgICAgLy8gb3Igc2V0IHJhZGl1cyBjYWxsYmFja1xuICAgICAqICAgICAgbWF4UjogZnVuY3Rpb24oZCkge1xuICAgICAqICAgICAgICAgIC8vIGV4LiBvZiBkIHBhcmFtIC0ge3g6IEZyaSBPY3QgMDYgMjAxNyAwMDowMDowMCBHTVQrMDkwMCwgdmFsdWU6IDgwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogNX1cbiAgICAgKiAgICAgICAgICAuLi5cbiAgICAgKiAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGQudmFsdWUgKiAyKTtcbiAgICAgKiAgICAgIH0sXG4gICAgICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXG4gICAgICogIH1cbiAgICAgKi9cbiAgICBidWJibGVfbWF4UjogMzUsXG4gICAgYnViYmxlX3plcm9iYXNlZDogITEsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYXJlYSBvcHRpb25zXG4gICAgICogQG5hbWUgYXJlYVxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFthcmVhLnplcm9iYXNlZD10cnVlXSBTZXQgaWYgbWluIG9yIG1heCB2YWx1ZSB3aWxsIGJlIDAgb24gYXJlYSBjaGFydC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFthcmVhLmFib3ZlPWZhbHNlXSBTZXQgYmFja2dyb3VuZCBhcmVhIGFib3ZlIHRoZSBkYXRhIGNoYXJ0IGxpbmUuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gW2FyZWEubGluZWFyR3JhZGllbnQ9ZmFsc2VdIFNldCB0aGUgbGluZWFyIGdyYWRpZW50IG9uIGFyZWEuPGJyPjxicj5cbiAgICAgKiBPciBjdXN0b21pemUgYnkgZ2l2aW5nIGJlbG93IG9iamVjdCB2YWx1ZTpcbiAgICAgKiAgLSB4IHtBcnJheX06IGB4MWAsIGB4MmAgdmFsdWVcbiAgICAgKiAgLSB5IHtBcnJheX06IGB5MWAsIGB5MmAgdmFsdWVcbiAgICAgKiAgLSBzdG9wcyB7QXJyYXl9OiBFYWNoIGl0ZW0gc2hvdWxkIGJlIGhhdmluZyBgW29mZnNldCwgc3RvcC1jb2xvciwgc3RvcC1vcGFjaXR5XWAgdmFsdWVzLlxuICAgICAqIEBzZWUgW01ETidzICZsdDtsaW5lYXJHcmFkaWVudD5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50L2xpbmVhckdyYWRpZW50KSwgWyZsdDtzdG9wPl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvc3RvcClcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuQXJlYUNoYXJ0KVxuICAgICAqIEBzZWUgW0RlbW86IGFib3ZlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXJlYUNoYXJ0T3B0aW9ucy5BYm92ZSlcbiAgICAgKiBAc2VlIFtEZW1vOiBsaW5lYXJHcmFkaWVudF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0FyZWFDaGFydE9wdGlvbnMuTGluZWFyR3JhZGllbnQpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgYXJlYToge1xuICAgICAqICAgICAgemVyb2Jhc2VkOiBmYWxzZSxcbiAgICAgKiAgICAgIGFib3ZlOiB0cnVlLFxuICAgICAqXG4gICAgICogICAgICAvLyB3aWxsIGdlbmVyYXRlIGZvbGx3aW5nIGxpbmVhckdyYWRpZW50OlxuICAgICAqICAgICAgLy8gPGxpbmVhckdyYWRpZW50IHgxPVwiMFwiIHgyPVwiMFwiIHkxPVwiMFwiIHkyPVwiMVwiPlxuICAgICAqICAgICAgLy8gICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0b3AtY29sb3I9XCIkREFUQV9DT0xPUlwiIHN0b3Atb3BhY2l0eT1cIjFcIj48L3N0b3A+XG4gICAgICogICAgICAvLyAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3RvcC1jb2xvcj1cIiREQVRBX0NPTE9SXCIgc3RvcC1vcGFjaXR5PVwiMFwiPjwvc3RvcD5cbiAgICAgKiAgICAgIC8vIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICogICAgICBsaW5lYXJHcmFkaWVudDogdHJ1ZSxcbiAgICAgKlxuICAgICAqICAgICAgLy8gT3IgY3VzdG9taXplZCBncmFkaWVudFxuICAgICAqICAgICAgbGluZWFyR3JhZGllbnQ6IHtcbiAgICAgKiAgICAgIFx0eDogWzAsIDBdLCAgLy8geDEsIHgyIGF0dHJpYnV0ZXNcbiAgICAgKiAgICAgIFx0eTogWzAsIDBdLCAgLy8geTEsIHkyIGF0dHJpYnV0ZXNcbiAgICAgKiAgICAgIFx0c3RvcHM6IFtcbiAgICAgKiAgICAgIFx0ICAvLyBvZmZzZXQsIHN0b3AtY29sb3IsIHN0b3Atb3BhY2l0eVxuICAgICAqICAgICAgXHQgIFswLCBcIiM3Y2I1ZWNcIiwgMV0sXG4gICAgICpcbiAgICAgKiAgICAgIFx0ICAvLyBzZXR0aW5nICdudWxsJyBmb3Igc3RvcC1jb2xvciwgd2lsbCBzZXQgaXRzIG9yaWdpbmFsIGRhdGEgY29sb3JcbiAgICAgKiAgICAgIFx0ICBbMC41LCBudWxsLCAwXSxcbiAgICAgKlxuICAgICAqICAgICAgXHQgIC8vIHNldHRpbmcgJ2Z1bmN0aW9uJyBmb3Igc3RvcC1jb2xvciwgd2lsbCBwYXNzIGRhdGEgaWQgYXMgYXJndW1lbnQuXG4gICAgICogICAgICBcdCAgLy8gSXQgc2hvdWxkIHJldHVybiBjb2xvciBzdHJpbmcgb3IgbnVsbCB2YWx1ZVxuICAgICAqICAgICAgXHQgIFsxLCBmdW5jdGlvbihpZCkgeyByZXR1cm4gaWQgPT09IFwiZGF0YTFcIiA/IFwicmVkXCIgOiBcImJsdWVcIjsgfSwgMF0sXG4gICAgICogICAgICBcdF1cbiAgICAgKiAgICAgIH1cbiAgICAgKiAgfVxuICAgICAqL1xuICAgIGFyZWFfemVyb2Jhc2VkOiAhMCxcbiAgICBhcmVhX2Fib3ZlOiAhMSxcbiAgICBhcmVhX2xpbmVhckdyYWRpZW50OiAhMSxcblxuICAgIC8qKlxuICAgICAqIFNldCBwaWUgb3B0aW9uc1xuICAgICAqIEBuYW1lIHBpZVxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtwaWUubGFiZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGFiZWwgb24gZWFjaCBwaWUgcGllY2UuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3BpZS5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBlYWNoIHBpZSBwaWVjZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5sYWJlbC50aHJlc2hvbGQ9MC4wNV0gU2V0IHRocmVzaG9sZCB0byBzaG93L2hpZGUgbGFiZWxzLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfEZ1bmN0aW9ufSBbcGllLmxhYmVsLnJhdGlvPXVuZGVmaW5lZF0gU2V0IHJhdGlvIG9mIGxhYmVscyBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW58T2JqZWN0fSBbcGllLmV4cGFuZD10cnVlXSBFbmFibGUgb3IgZGlzYWJsZSBleHBhbmRpbmcgcGllIHBpZWNlcy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5leHBhbmQucmF0ZT0wLjk4XSBTZXQgZXhwYW5kIHJhdGUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwaWUuZXhwYW5kLmR1cmF0aW9uPTUwXSBTZXQgZXhwYW5kIHRyYW5zaXRpb24gdGltZSBpbiBtcy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxPYmplY3R9IFtwaWUuaW5uZXJSYWRpdXM9MF0gU2V0cyB0aGUgaW5uZXIgcmFkaXVzIG9mIHBpZSBhcmMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwaWUucGFkQW5nbGU9MF0gU2V0IHBhZGRpbmcgYmV0d2VlbiBkYXRhLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGllLnBhZGRpbmc9MF0gU2V0cyB0aGUgZ2FwIGJldHdlZW4gcGllIGFyY3MuXG4gICAgXHQgKiBAcHJvcGVydHkge051bWJlcn0gW2RvbnV0LnN0YXJ0aW5nQW5nbGU9MF0gU2V0IHN0YXJ0aW5nIGFuZ2xlIHdoZXJlIGRhdGEgZHJhd3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgcGllOiB7XG4gICAgICogICAgICBsYWJlbDoge1xuICAgICAqICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvLCBpZCkge1xuICAgICAqICAgICAgICAgICAgICByZXR1cm4gZDMuZm9ybWF0KFwiJFwiKSh2YWx1ZSk7XG4gICAgICpcbiAgICAgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcbiAgICAgKiAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlICtcIiVcXG5MaW5lMVxcbjJMaW5lMlwiO1xuICAgICAqICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgdGhyZXNob2xkOiAwLjEsXG4gICAgICpcbiAgICAgKiAgICAgICAgICAvLyBzZXQgcmF0aW8gY2FsbGJhY2suIFNob3VsZCByZXR1cm4gcmF0aW8gdmFsdWVcbiAgICAgKiAgICAgICAgICByYXRpbzogZnVuY3Rpb24oZCwgcmFkaXVzLCBoKSB7XG4gICAgICogICAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgICAgICByZXR1cm4gcmF0aW87XG4gICAgICogICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAvLyBvciBzZXQgcmF0aW8gbnVtYmVyXG4gICAgICogICAgICAgICAgcmF0aW86IDAuNVxuICAgICAqICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAgLy8gZGlzYWJsZSBleHBhbmQgdHJhbnNpdGlvbiBmb3IgaW50ZXJhY3Rpb25cbiAgICAgKiAgICAgIGV4cGFuZDogZmFsc2UsXG4gICAgICpcbiAgICAgKiAgICAgIGV4cGFuZDoge1xuICAgICAqICAgICAgXHQvLyBzZXQgZHVyYXRpb24gb2YgZXhwYW5kIHRyYW5zaXRpb24gdG8gNTAwbXMuXG4gICAgICogICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgKlxuICAgICAqICAgICAgXHQvLyBzZXQgZXhwYW5kIGFyZWEgcmF0ZVxuICAgICAqICAgICAgICAgIHJhdGU6IDFcbiAgICAgKiAgICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAqXG4gICAgICogICAgICAvLyBzZXQgZGlmZmVyZW50IGlubmVyUmFkaXVzIGZvciBlYWNoIGRhdGFcbiAgICAgKiAgICAgIGlubmVyUmFkaXVzOiB7XG4gICAgICogICAgICBcdGRhdGExOiAxMCxcbiAgICAgKiAgICAgIFx0ZGF0YTI6IDBcbiAgICAgKiAgICAgIH1cbiAgICAgKlxuICAgICAqICAgICAgcGFkQW5nbGU6IDAuMSxcbiAgICAgKiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICogICAgICBzdGFydGluZ0FuZ2xlOiAxXG4gICAgICogIH1cbiAgICAgKi9cbiAgICBwaWVfbGFiZWxfc2hvdzogITAsXG4gICAgcGllX2xhYmVsX2Zvcm1hdDogdW5kZWZpbmVkLFxuICAgIHBpZV9sYWJlbF90aHJlc2hvbGQ6IC4wNSxcbiAgICBwaWVfbGFiZWxfcmF0aW86IHVuZGVmaW5lZCxcbiAgICBwaWVfZXhwYW5kOiB7fSxcbiAgICBwaWVfZXhwYW5kX3JhdGU6IC45OCxcbiAgICBwaWVfZXhwYW5kX2R1cmF0aW9uOiA1MCxcbiAgICBwaWVfaW5uZXJSYWRpdXM6IDAsXG4gICAgcGllX3BhZEFuZ2xlOiAwLFxuICAgIHBpZV9wYWRkaW5nOiAwLFxuICAgIHBpZV9zdGFydGluZ0FuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHBsdWdpbnNcbiAgICAgKiBAbmFtZSBwbHVnaW5zXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgcGx1Z2luczogW1xuICAgICAqICAgIG5ldyBiYi5wbHVnaW4uc3RhbmZvcmQoeyAuLi4gfSksXG4gICAgICogICAgbmV3IFBsdWdpbkEoKSxcbiAgICAgKiAgICAuLi5cbiAgICAgKiBdXG4gICAgICovXG4gICAgcGx1Z2luczogW10sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZ2F1Z2Ugb3B0aW9uc1xuICAgICAqIEBuYW1lIGdhdWdlXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dhdWdlLmZ1bGxDaXJjbGU9ZmFsc2VdIFNob3cgZnVsbCBjaXJjbGUgYXMgZG9udXQuIFdoZW4gc2V0IHRvICd0cnVlJywgdGhlIG1heCBsYWJlbCB3aWxsIG5vdCBiZSBzaG93ZWQgZHVlIHRvIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFyZSBzYW1lIGxvY2F0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dhdWdlLmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGdhdWdlLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtnYXVnZS5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBnYXVnZS4gTGFiZWwgdGV4dCBjYW4gYmUgbXVsdGlsaW5lZCB3aXRoIGBcXG5gIGNoYXJhY3Rlci5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZ2F1Z2UubGFiZWwuZXh0ZW50c10gU2V0IGN1c3RvbWl6ZWQgbWluL21heCBsYWJlbCB0ZXh0LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dhdWdlLmV4cGFuZD10cnVlXSBFbmFibGUgb3IgZGlzYWJsZSBleHBhbmRpbmcgZ2F1Z2UuXG4gICAgXHQgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLmV4cGFuZC5yYXRlPTAuOThdIFNldCBleHBhbmQgcmF0ZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLmV4cGFuZC5kdXJhdGlvbj01MF0gU2V0IHRoZSBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLm1pbj0wXSBTZXQgbWluIHZhbHVlIG9mIHRoZSBnYXVnZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLm1heD0xMDBdIFNldCBtYXggdmFsdWUgb2YgdGhlIGdhdWdlLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2Uuc3RhcnRpbmdBbmdsZT0tMSAqIE1hdGguUEkgLyAyXSBTZXQgc3RhcnRpbmcgYW5nbGUgd2hlcmUgZGF0YSBkcmF3cy5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2dhdWdlLnRpdGxlPVwiXCJdIFNldCB0aXRsZSBvZiBnYXVnZSBjaGFydC4gVXNlIGBcXG5gIGNoYXJhY3RlciB0byBlbnRlciBsaW5lIGJyZWFrLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZ2F1Z2UudW5pdHNdIFNldCB1bml0cyBvZiB0aGUgZ2F1Z2UuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnYXVnZS53aWR0aF0gU2V0IHdpZHRoIG9mIGdhdWdlIGNoYXJ0LlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZ2F1Z2UudHlwZT1cInNpbmdsZVwiXSBTZXQgdHlwZSBvZiBnYXVnZSB0byBiZSBkaXNwbGF5ZWQuPGJyPjxicj5cbiAgICAgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcbiAgICAgKiAtIHNpbmdsZVxuICAgICAqIC0gbXVsdGlcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2dhdWdlLmFyY3MubWluV2lkdGg9NV0gU2V0IG1pbmltYWwgd2lkdGggb2YgZ2F1Z2UgYXJjcyB1bnRpbCB0aGUgaW5uZXJSYWRpdXMgZGlzYXBwZWFycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBnYXVnZToge1xuICAgICAqICAgICAgZnVsbENpcmNsZTogZmFsc2UsXG4gICAgICogICAgICBsYWJlbDoge1xuICAgICAqICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvKSB7XG4gICAgICogICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgKlxuICAgICAqICAgICAgICAgICAgICAvLyB0byBtdWx0aWxpbmUsIHJldHVybiB3aXRoICdcXG4nIGNoYXJhY3RlclxuICAgICAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XG4gICAgICogICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICBleHRlbnRzOiBmdW5jdGlvbih2YWx1ZSwgaXNNYXgpIHtcbiAgICBcdCAqICAgICAgICAgICAgICByZXR1cm4gKGlzTWF4ID8gXCJNYXg6XCIgOiBcIk1pbjpcIikgKyB2YWx1ZTtcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9LFxuICAgICAqXG4gICAgICogICAgICAvLyBkaXNhYmxlIGV4cGFuZCB0cmFuc2l0aW9uIGZvciBpbnRlcmFjdGlvblxuICAgICAqICAgICAgZXhwYW5kOiBmYWxzZSxcbiAgICAgKlxuICAgICAqICAgICAgZXhwYW5kOiB7XG4gICAgICogICAgICBcdC8vIHNldCBkdXJhdGlvbiBvZiBleHBhbmQgdHJhbnNpdGlvbiB0byA1MDBtcy5cbiAgICAgKiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAqXG4gICAgICogICAgICBcdC8vIHNldCBleHBhbmQgYXJlYSByYXRlXG4gICAgICogICAgICAgICAgcmF0ZTogMVxuICAgICAqICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAgbWluOiAtMTAwLFxuICAgICAqICAgICAgbWF4OiAyMDAsXG4gICAgICogICAgICB0eXBlOiBcInNpbmdsZVwiICAvLyBvciAnbXVsdGknXG4gICAgICogICAgICB0aXRsZTogXCJUaXRsZSBUZXh0XCIsXG4gICAgICogICAgICB1bml0czogXCIlXCIsXG4gICAgICogICAgICB3aWR0aDogMTAsXG4gICAgICogICAgICBhcmNzOiB7XG4gICAgICogICAgICAgICAgbWluV2lkdGg6IDVcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgfVxuICAgICAqL1xuICAgIGdhdWdlX2Z1bGxDaXJjbGU6ICExLFxuICAgIGdhdWdlX2xhYmVsX3Nob3c6ICEwLFxuICAgIGdhdWdlX2xhYmVsX2Zvcm1hdDogdW5kZWZpbmVkLFxuICAgIGdhdWdlX21pbjogMCxcbiAgICBnYXVnZV9tYXg6IDEwMCxcbiAgICBnYXVnZV90eXBlOiBcInNpbmdsZVwiLFxuICAgIGdhdWdlX3N0YXJ0aW5nQW5nbGU6IC0xICogTWF0aC5QSSAvIDIsXG4gICAgZ2F1Z2VfbGFiZWxfZXh0ZW50czogdW5kZWZpbmVkLFxuICAgIGdhdWdlX3RpdGxlOiBcIlwiLFxuICAgIGdhdWdlX3VuaXRzOiB1bmRlZmluZWQsXG4gICAgZ2F1Z2Vfd2lkdGg6IHVuZGVmaW5lZCxcbiAgICBnYXVnZV9hcmNzX21pbldpZHRoOiA1LFxuICAgIGdhdWdlX2V4cGFuZDoge30sXG4gICAgZ2F1Z2VfZXhwYW5kX3JhdGU6IC45OCxcbiAgICBnYXVnZV9leHBhbmRfZHVyYXRpb246IDUwLFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRvbnV0IG9wdGlvbnNcbiAgICAgKiBAbmFtZSBkb251dFxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtkb251dC5sYWJlbC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsYWJlbCBvbiBlYWNoIGRvbnV0IHBpZWNlLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtkb251dC5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBlYWNoIGRvbnV0IHBpZWNlLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQubGFiZWwudGhyZXNob2xkPTAuMDVdIFNldCB0aHJlc2hvbGQgdG8gc2hvdy9oaWRlIGxhYmVscy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxGdW5jdGlvbn0gW2RvbnV0LmxhYmVsLnJhdGlvPXVuZGVmaW5lZF0gU2V0IHJhdGlvIG9mIGxhYmVscyBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtkb251dC5leHBhbmQ9dHJ1ZV0gRW5hYmxlIG9yIGRpc2FibGUgZXhwYW5kaW5nIGRvbnV0IHBpZWNlcy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2RvbnV0LmV4cGFuZC5yYXRlPTAuOThdIFNldCBleHBhbmQgcmF0ZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2RvbnV0LmV4cGFuZC5kdXJhdGlvbj01MF0gU2V0IGV4cGFuZCB0cmFuc2l0aW9uIHRpbWUgaW4gbXMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC53aWR0aF0gU2V0IHdpZHRoIG9mIGRvbnV0IGNoYXJ0LlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZG9udXQudGl0bGU9XCJcIl0gU2V0IHRpdGxlIG9mIGRvbnV0IGNoYXJ0LiBVc2UgYFxcbmAgY2hhcmFjdGVyIHRvIGVudGVyIGxpbmUgYnJlYWsuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5wYWRBbmdsZT0wXSBTZXQgcGFkZGluZyBiZXR3ZWVuIGRhdGEuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5zdGFydGluZ0FuZ2xlPTBdIFNldCBzdGFydGluZyBhbmdsZSB3aGVyZSBkYXRhIGRyYXdzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIGRvbnV0OiB7XG4gICAgICogICAgICBsYWJlbDoge1xuICAgICAqICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvLCBpZCkge1xuICAgICAqICAgICAgICAgICAgICByZXR1cm4gZDMuZm9ybWF0KFwiJFwiKSh2YWx1ZSk7XG4gICAgICpcbiAgICAgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcbiAgICAgKiAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlICtcIiVcXG5MaW5lMVxcbjJMaW5lMlwiO1xuICAgICAqICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgdGhyZXNob2xkOiAwLjEsXG4gICAgICpcbiAgICAgKiAgICAgICAgICAvLyBzZXQgcmF0aW8gY2FsbGJhY2suIFNob3VsZCByZXR1cm4gcmF0aW8gdmFsdWVcbiAgICAgKiAgICAgICAgICByYXRpbzogZnVuY3Rpb24oZCwgcmFkaXVzLCBoKSB7XG4gICAgICogICAgICAgICAgXHQuLi5cbiAgICAgKiAgICAgICAgICBcdHJldHVybiByYXRpbztcbiAgICAgKiAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgIC8vIG9yIHNldCByYXRpbyBudW1iZXJcbiAgICAgKiAgICAgICAgICByYXRpbzogMC41XG4gICAgICogICAgICB9LFxuICAgICAqXG4gICAgICogICAgICAvLyBkaXNhYmxlIGV4cGFuZCB0cmFuc2l0aW9uIGZvciBpbnRlcmFjdGlvblxuICAgICAqICAgICAgZXhwYW5kOiBmYWxzZSxcbiAgICAgKlxuICAgICAqICAgICAgZXhwYW5kOiB7XG4gICAgICogICAgICBcdC8vIHNldCBkdXJhdGlvbiBvZiBleHBhbmQgdHJhbnNpdGlvbiB0byA1MDBtcy5cbiAgICAgKiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAqXG4gICAgICogICAgICBcdC8vIHNldCBleHBhbmQgYXJlYSByYXRlXG4gICAgICogICAgICAgICAgcmF0ZTogMVxuICAgICAqICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAgd2lkdGg6IDEwLFxuICAgICAqICAgICAgcGFkQW5nbGU6IDAuMixcbiAgICAgKiAgICAgIHN0YXJ0aW5nQW5nbGU6IDEsXG4gICAgICogICAgICB0aXRsZTogXCJEb251dCBUaXRsZVwiXG4gICAgICpcbiAgICAgKiAgICAgIC8vIHRpdGxlIHdpdGggbGluZSBicmVha1xuICAgICAqICAgICAgdGl0bGU6IFwiVGl0bGUxXFxuVGl0bGUyXCJcbiAgICAgKiAgfVxuICAgICAqL1xuICAgIGRvbnV0X2xhYmVsX3Nob3c6ICEwLFxuICAgIGRvbnV0X2xhYmVsX2Zvcm1hdDogdW5kZWZpbmVkLFxuICAgIGRvbnV0X2xhYmVsX3RocmVzaG9sZDogLjA1LFxuICAgIGRvbnV0X2xhYmVsX3JhdGlvOiB1bmRlZmluZWQsXG4gICAgZG9udXRfd2lkdGg6IHVuZGVmaW5lZCxcbiAgICBkb251dF90aXRsZTogXCJcIixcbiAgICBkb251dF9leHBhbmQ6IHt9LFxuICAgIGRvbnV0X2V4cGFuZF9yYXRlOiAuOTgsXG4gICAgZG9udXRfZXhwYW5kX2R1cmF0aW9uOiA1MCxcbiAgICBkb251dF9wYWRBbmdsZTogMCxcbiAgICBkb251dF9zdGFydGluZ0FuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHNwbGluZSBvcHRpb25zXG4gICAgICogLSAqKkF2YWlsYWJsZSBpbnRlcnBvbGF0aW9uIHR5cGUgdmFsdWVzOioqXG4gICAgICogIC0gYmFzaXMgKGQzLmN1cnZlQmFzaXMpXG4gICAgICogIC0gYmFzaXMtY2xvc2VkIChkMy5jdXJ2ZUJhc2lzQ2xvc2VkKVxuICAgICAqICAtIGJhc2lzLW9wZW4gKGQzLmN1cnZlQmFzaXNPcGVuKVxuICAgICAqICAtIGJ1bmRsZSAoZDMuY3VydmVCdW5kbGUpXG4gICAgICogIC0gY2FyZGluYWwgKGQzLmN1cnZlQ2FyZGluYWwpXG4gICAgICogIC0gY2FyZGluYWwtY2xvc2VkIChkMy5jdXJ2ZUNhcmRpbmFsQ2xvc2VkKVxuICAgICAqICAtIGNhcmRpbmFsLW9wZW4gKGQzLmN1cnZlQ2FyZGluYWxPcGVuKVxuICAgICAqICAtIGNhdG11bGwtcm9tIChkMy5jdXJ2ZUNhdG11bGxSb20pXG4gICAgICogIC0gY2F0bXVsbC1yb20tY2xvc2VkIChkMy5jdXJ2ZUNhdG11bGxSb21DbG9zZWQpXG4gICAgICogIC0gY2F0bXVsbC1yb20tb3BlbiAoZDMuY3VydmVDYXRtdWxsUm9tT3BlbilcbiAgICAgKiAgLSBtb25vdG9uZS14IChkMy5jdXJ2ZU1vbm90b25lWClcbiAgICAgKiAgLSBtb25vdG9uZS15IChkMy5jdXJ2ZU1vbm90b25lWSlcbiAgICAgKiAgLSBuYXR1cmFsIChkMy5jdXJ2ZU5hdHVyYWwpXG4gICAgICogIC0gbGluZWFyLWNsb3NlZCAoZDMuY3VydmVMaW5lYXJDbG9zZWQpXG4gICAgICogIC0gbGluZWFyIChkMy5jdXJ2ZUxpbmVhcilcbiAgICAgKiAgLSBzdGVwIChkMy5jdXJ2ZVN0ZXApXG4gICAgICogIC0gc3RlcC1hZnRlciAoZDMuY3VydmVTdGVwQWZ0ZXIpXG4gICAgICogIC0gc3RlcC1iZWZvcmUgKGQzLmN1cnZlU3RlcEJlZm9yZSlcbiAgICAgKiBAbmFtZSBzcGxpbmVcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzcGxpbmUuaW50ZXJwb2xhdGlvbi50eXBlPVwiY2FyZGluYWxcIl1cbiAgICAgKiBAc2VlIFtJbnRlcnBvbGF0aW9uIChkMyB2NCldKGh0dHA6Ly9ibC5vY2tzLm9yZy9lbW1hc2F1bmRlcnMvYzI1YTE0Nzk3MGRlZjJiMDJkOGM3YzI3MTlkYzc1MDIpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgc3BsaW5lOiB7XG4gICAgICogICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICogICAgICAgICAgdHlwZTogXCJjYXJkaW5hbFwiXG4gICAgICogICAgICB9XG4gICAgICogIH1cbiAgICAgKi9cbiAgICBzcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlOiBcImNhcmRpbmFsXCIsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgcmFkYXIgb3B0aW9uc1xuICAgICAqIC0gKipOT1RFOioqXG4gICAgICogID4gV2hlbiB4IHRpY2sgdGV4dCBjb250YWlucyBgXFxuYCwgaXQncyB1c2VkIGFzIGxpbmUgYnJlYWsuXG4gICAgICogQG5hbWUgcmFkYXJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyYWRhci5heGlzLm1heD11bmRlZmluZWRdIFRoZSBtYXggdmFsdWUgb2YgYXhpcy4gSWYgbm90IGdpdmVuLCBpdCdsbCB0YWtlIHRoZSBtYXggdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gZGF0YS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyYWRhci5heGlzLmxpbmUuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgYXhpcyBsaW5lLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmFkYXIuYXhpcy50ZXh0LnBvc2l0aW9uLng9MF0geCBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXG4gICAgICogQHByb3BlcnR5IHtOVW1iZXJ9IFtyYWRhci5heGlzLnRleHQucG9zaXRpb24ueT0wXSB5IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyYWRhci5heGlzLnRleHQuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgYXhpcyB0ZXh0LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmRpcmVjdGlvbi5jbG9ja3dpc2U9ZmFsc2VdIFNldCB0aGUgZGlyZWN0aW9uIHRvIGJlIGRyYXduLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmFkYXIubGV2ZWwuZGVwdGg9M10gU2V0IHRoZSBsZXZlbCBkZXB0aC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyYWRhci5sZXZlbC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsZXZlbC5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbcmFkYXIubGV2ZWwudGV4dC5mb3JtYXQ9KHgpID0+ICh4ICUgMSA9PT0gMCA/IHggOiB4LnRvRml4ZWQoMikpXSBTZXQgZm9ybWF0IGZ1bmN0aW9uIGZvciB0aGUgbGV2ZWwgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIubGV2ZWwudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsZXZlbCB0ZXh0LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmFkYXIuc2l6ZS5yYXRpbz0wLjg3XSBTZXQgc2l6ZSByYXRpby5cbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuUmFkYXJDaGFydClcbiAgICAgKiBAc2VlIFtEZW1vOiByYWRhciBheGlzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJBeGlzKVxuICAgICAqIEBzZWUgW0RlbW86IHJhZGFyIGxldmVsXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJMZXZlbClcbiAgICAgKiBAc2VlIFtEZW1vOiByYWRhciBzaXplXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJTaXplKVxuICAgICAqIEBzZWUgW0RlbW86IHJhZGFyIGF4aXMgbXVsdGlsaW5lXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJBeGlzTXVsdGlsaW5lKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHJhZGFyOiB7XG4gICAgICogICAgICBheGlzOiB7XG4gICAgICogICAgICAgICAgbWF4OiA1MCxcbiAgICAgKiAgICAgICAgICBsaW5lOiB7XG4gICAgICogICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICogICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICB0ZXh0OiB7XG4gICAgICogICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICogICAgICAgICAgICAgIFx0eDogMCxcbiAgICAgKiAgICAgICAgICAgICAgXHR5OiAwXG4gICAgICogICAgICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICogICAgICAgICAgfVxuICAgICAqICAgICAgfSxcbiAgICAgKiAgICAgIGRpcmVjdGlvbjoge1xuICAgICAqICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICAgICAqICAgICAgfSxcbiAgICAgKiAgICAgIGxldmVsOiB7XG4gICAgICogICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICogICAgICAgICAgdGV4dDoge1xuICAgICAqICAgICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XG4gICAgICogICAgICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAgIHNob3c6IHRydWVcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgc2l6ZToge1xuICAgICAqICAgICAgICAgIHJhdGlvOiAwLjdcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgfVxuICAgICAqL1xuICAgIHJhZGFyX2F4aXNfbWF4OiB1bmRlZmluZWQsXG4gICAgcmFkYXJfYXhpc19saW5lX3Nob3c6ICEwLFxuICAgIHJhZGFyX2F4aXNfdGV4dF9zaG93OiAhMCxcbiAgICByYWRhcl9heGlzX3RleHRfcG9zaXRpb246IHt9LFxuICAgIHJhZGFyX2xldmVsX2RlcHRoOiAzLFxuICAgIHJhZGFyX2xldmVsX3Nob3c6ICEwLFxuICAgIHJhZGFyX2xldmVsX3RleHRfZm9ybWF0OiBmdW5jdGlvbiByYWRhcl9sZXZlbF90ZXh0X2Zvcm1hdCh4KSB7XG4gICAgICByZXR1cm4geCAlIDEgPT09IDAgPyB4IDogeC50b0ZpeGVkKDIpO1xuICAgIH0sXG4gICAgcmFkYXJfbGV2ZWxfdGV4dF9zaG93OiAhMCxcbiAgICByYWRhcl9zaXplX3JhdGlvOiAuODcsXG4gICAgcmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZTogITEsXG5cbiAgICAvKipcbiAgICAgKiBDb250cm9sIHRoZSByZW5kZXIgdGltaW5nXG4gICAgICogQG5hbWUgcmVuZGVyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JlbmRlci5sYXp5PXRydWVdIE1ha2UgdG8gbm90IHJlbmRlciBhdCBpbml0aWFsaXphdGlvbiAoZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gYmluZCBlbGVtZW50J3MgdmlzaWJpbGl0eSBpcyBoaWRkZW4pLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JlbmRlci5vYnNlcnZlPXRydWVdIE9ic2VydmUgYmluZCBlbGVtZW50J3MgdmlzaWJpbGl0eShgZGlzcGxheWAgb3IgYHZpc2libGl0eWAgaW5saW5lIGNzcyBwcm9wZXJ0eSBvciBjbGFzcyB2YWx1ZSkgJiByZW5kZXIgd2hlbiBpcyB2aXNpYmxlIGF1dG9tYXRpY2FsbHkgKGZvciBJRXMsIG9ubHkgd29ya3MgSUUxMSspLiBXaGVuIHNldCB0byAqKmZhbHNlKiosIGNhbGwgW2AuZmx1c2goKWBdKC4vQ2hhcnQuaHRtbCNmbHVzaCkgdG8gcmVuZGVyLlxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuTGF6eVJlbmRlcilcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICByZW5kZXI6IHtcbiAgICAgKiAgICBsYXp5OiB0cnVlLFxuICAgICAqICAgIG9ic2VydmU6IHRydWVcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXHQvLyA8IS0tIHJlbmRlci5sYXp5IHdpbGwgZGV0ZWN0IHZpc2liaWxpdHkgZGVmaW5lZCAtLT5cbiAgICAgKiAgLy8gKGEpIDxkaXYgaWQ9J2NoYXJ0JyBjbGFzcz0naGlkZSc+PC9kaXY+XG4gICAgICogIC8vIChiKSA8ZGl2IGlkPSdjaGFydCcgc3R5bGU9J2Rpc3BsYXk6bm9uZSc+PC9kaXY+XG4gICAgICpcbiAgICAgKiAgLy8gcmVuZGVyLmxhenkgZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gZWxlbWVudCBpcyBoaWRkZW5cbiAgICAgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoeyAuLi4gfSk7XG4gICAgICpcbiAgICAgKiAgLy8gY2hhcnQgd2lsbCBiZSByZW5kZXJlZCBhdXRvbWF0aWNhbGx5IHdoZW4gZWxlbWVudCdzIHZpc2liaWxpdHkgY2hhbmdlc1xuICAgICAqICAvLyBOb3RlOiB3b3JrcyBvbmx5IGZvciBpbmxpbmVkIGNzcyBwcm9wZXJ0eSBvciBjbGFzcyBhdHRyaWJ1dGUgY2hhbmdlc1xuICAgICAqICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhcnQnKS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJykgIC8vIChhKVxuICAgICAqICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhcnQnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsgIC8vIChiKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlx0Ly8gY2hhcnQgd29uJ3QgYmUgcmVuZGVyZWQgYW5kIG5vdCBvYnNlcnZpbmcgYmluZCBlbGVtZW50J3MgdmlzaWJsaXR5IGNoYW5nZXNcbiAgICAgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xuICAgICAqICAgICByZW5kZXI6IHtcbiAgICAgKiAgICAgICAgICBsYXp5OiB0cnVlLFxuICAgICAqICAgICAgICAgIG9ic2VydmU6IGZhbHNlXG4gICAgICogICAgIH1cbiAgICAgKiAgfSk7XG4gICAgICpcbiAgICAgKiAgLy8gY2FsbCBhdCBhbnkgcG9pbnQgd2hlbiB5b3Ugd2FudCB0byByZW5kZXJcbiAgICAgKiAgY2hhcnQuZmx1c2goKTtcbiAgICAgKi9cbiAgICByZW5kZXI6IHt9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyByZWN0YW5nbGVzIGluc2lkZSB0aGUgY2hhcnQuPGJyPjxicj5cbiAgICAgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgYXhpcywgc3RhcnQsIGVuZCBhbmQgY2xhc3MuXG4gICAgICogVGhlIGtleXMgc3RhcnQsIGVuZCBhbmQgY2xhc3MgYXJlIG9wdGlvbmFsLlxuICAgICAqIGF4aXMgbXVzdCBiZSB4LCB5IG9yIHkyLiBzdGFydCBhbmQgZW5kIHNob3VsZCBiZSB0aGUgdmFsdWUgd2hlcmUgcmVnaW9ucyBzdGFydCBhbmQgZW5kLlxuICAgICAqIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBlZGdlIHZhbHVlcyB3aWxsIGJlIHVzZWQuXG4gICAgICogSWYgdGltZXNlcmllcyB4IGF4aXMsIGRhdGUgc3RyaW5nLCBEYXRlIG9iamVjdCBhbmQgdW5peHRpbWUgaW50ZWdlciBjYW4gYmUgdXNlZC5cbiAgICAgKiBJZiBjbGFzcyBpcyBzZXQsIHRoZSByZWdpb24gZWxlbWVudCB3aWxsIGhhdmUgaXQgYXMgY2xhc3MuXG4gICAgICogQG5hbWUgcmVnaW9uc1xuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgcmVnaW9uczogW1xuICAgICAqICAgIHtcbiAgICAgKiAgICAgIGF4aXM6IFwieFwiLFxuICAgICAqICAgICAgc3RhcnQ6IDEsXG4gICAgICogICAgICBlbmQ6IDQsXG4gICAgICogICAgICBjbGFzczogXCJyZWdpb24tMS00XCJcbiAgICAgKiAgICB9XG4gICAgICogIF1cbiAgICAgKi9cbiAgICByZWdpb25zOiBbXSxcblxuICAgIC8qKlxuICAgICAqIFRvb2x0aXAgb3B0aW9uc1xuICAgICAqIEBuYW1lIHRvb2x0aXBcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB0b29sdGlwLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Rvb2x0aXAuZG9Ob3RIaWRlPWZhbHNlXSBNYWtlIHRvb2x0aXAga2VlcCBzaG93aW5nIG5vdCBoaWRpbmcgb24gaW50ZXJhY3Rpb24uXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5ncm91cGVkPXRydWVdIFNldCBpZiB0b29sdGlwIGlzIGdyb3VwZWQgb3Igbm90IGZvciB0aGUgZGF0YSBwb2ludHMuXG4gICAgICogICAtICoqTk9URToqKiBUaGUgb3ZlcmxhcHBlZCBkYXRhIHBvaW50cyB3aWxsIGJlIGRpc3BsYXllZCBhcyBncm91cGVkIGV2ZW4gaWYgc2V0IGZhbHNlLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Rvb2x0aXAubGlua2VkPWZhbHNlXSBTZXQgaWYgdG9vbHRpcHMgb24gYWxsIHZpc2libGUgY2hhcnRzIHdpdGggbGlrZSB4IHBvaW50cyBhcmUgc2hvd24gdG9nZXRoZXIgd2hlbiBvbmUgaXMgc2hvd24uXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0b29sdGlwLmxpbmtlZC5uYW1lPVwiXCJdIEdyb3BpbmcgbmFtZSBmb3IgbGlua2VkIHRvb2x0aXAuPGJyPklmIHNwZWNpZmllZCwgbGlua2VkIHRvb2x0aXAgd2lsbCBiZSBncm9wZWQgaW50ZXJhY3RpbmcgdG8gYmUgd29ya2VkIG9ubHkgd2l0aCB0aGUgc2FtZSBuYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC50aXRsZV0gU2V0IGZvcm1hdCBmb3IgdGhlIHRpdGxlIG9mIHRvb2x0aXAuPGJyPlxuICAgICAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgeCBvZiB0aGUgZGF0YSBwb2ludCB0byBzaG93LlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC5uYW1lXSBTZXQgZm9ybWF0IGZvciB0aGUgbmFtZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBuYW1lLCByYXRpbywgaWQgYW5kIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuIHJhdGlvIHdpbGwgYmUgdW5kZWZpbmVkIGlmIHRoZSBjaGFydCBpcyBub3QgZG9udXQvcGllL2dhdWdlLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC52YWx1ZV0gU2V0IGZvcm1hdCBmb3IgdGhlIHZhbHVlIG9mIGVhY2ggZGF0YSBpbiB0b29sdGlwLjxicj5cbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIG5hbWUsIHJhdGlvLCBpZCBhbmQgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gcmF0aW8gd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIGNoYXJ0IGlzIG5vdCBkb251dC9waWUvZ2F1Z2UuXG4gICAgICogIElmIHVuZGVmaW5lZCByZXR1cm5lZCwgdGhlIHJvdyBvZiB0aGF0IHZhbHVlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5wb3NpdGlvbl0gU2V0IGN1c3RvbSBwb3NpdGlvbiBmdW5jdGlvbiBmb3IgdGhlIHRvb2x0aXAuPGJyPlxuICAgICAqICBUaGlzIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgcG9zaXRpb24gYnkgcmV0dXJuaW5nIG9iamVjdCB0aGF0IGhhcyB0b3AgYW5kIGxlZnQuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbnxPYmplY3R9IFt0b29sdGlwLmNvbnRlbnRzXSBTZXQgY3VzdG9tIEhUTUwgZm9yIHRoZSB0b29sdGlwLjxicj5cbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIGRhdGEsIGRlZmF1bHRUaXRsZUZvcm1hdCwgZGVmYXVsdFZhbHVlRm9ybWF0IGFuZCBjb2xvciBvZiB0aGUgZGF0YSBwb2ludCB0byBzaG93LiBJZiB0b29sdGlwLmdyb3VwZWQgaXMgdHJ1ZSwgZGF0YSBpbmNsdWRlcyBtdWx0aXBsZSBkYXRhIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudH0gW3Rvb2x0aXAuY29udGVudHMuYmluZHRvPXVuZGVmaW5lZF0gU2V0IENTUyBzZWxlY3RvciBvciBlbGVtZW50IHJlZmVyZW5jZSB0byBiaW5kIHRvb2x0aXAuXG4gICAgICogIC0gKipOT1RFOioqIFdoZW4gaXMgc3BlY2lmaWVkLCB3aWxsIG5vdCBiZSB1cGRhdGluZyB0b29sdGlwJ3MgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0b29sdGlwLmNvbnRlbnRzLnRlbXBsYXRlPXVuZGVmaW5lZF0gU2V0IHRvb2x0aXAncyB0ZW1wbGF0ZS48YnI+PGJyPlxuICAgICAqICBXaXRoaW4gdGVtcGxhdGUsIGJlbG93IHN5bnRheCB3aWxsIGJlIHJlcGxhY2VkIHVzaW5nIHRlbXBsYXRlLWxpa2Ugc3ludGF4IHN0cmluZzpcbiAgICAgKiAgICAtICoqe3sgLi4uIH19Kio6IHRoZSBkb3VibHkgY3VybHkgYnJhY2tldHMgaW5kaWNhdGUgbG9vcCBibG9jayBmb3IgZGF0YSByb3dzLlxuICAgICAqICAgIC0gKip7PUNMQVNTX1RPT0xUSVB9Kio6IGRlZmF1bHQgdG9vbHRpcCBjbGFzcyBuYW1lIGBiYi10b29sdGlwYC5cbiAgICAgKiAgICAtICoqez1DTEFTU19UT09MVElQX05BTUV9Kio6IGRlZmF1bHQgdG9vbHRpcCBkYXRhIGNsYXNzIG5hbWUgKGV4LiBgYmItdG9vbHRpcC1uYW1lLWRhdGExYClcbiAgICAgKiAgICAtICoqez1USVRMRX0qKjogdGl0bGUgdmFsdWUuXG4gICAgICogICAgLSAqKns9Q09MT1J9Kio6IGRhdGEgY29sb3IuXG4gICAgICogICAgLSAqKns9VkFMVUV9Kio6IGRhdGEgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IFt0b29sdGlwLmNvbnRlbnRzLnRleHQ9dW5kZWZpbmVkXSBTZXQgYWRkaXRpb25hbCB0ZXh0IGNvbnRlbnQgd2l0aGluIGRhdGEgbG9vcCwgdXNpbmcgdGVtcGxhdGUgc3ludGF4LlxuICAgICAqICAtICoqTk9URToqKiBJdCBzaG91bGQgY29udGFpbiBgeyBrZXk6IEFycmF5LCAuLi4gfWAgdmFsdWVcbiAgICAgKiAgICAtICdrZXknIG5hbWUgaXMgdXNlZCBhcyBzdWJzdGl0dXRpb24gd2l0aGluIHRlbXBsYXRlIGFzICd7PUtFWX0nXG4gICAgICogICAgLSBUaGUgdmFsdWUgYXJyYXkgbGVuZ3RoIHNob3VsZCBtYXRjaCB3aXRoIHRoZSBkYXRhIGxlbmd0aFxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Rvb2x0aXAuaW5pdC5zaG93PWZhbHNlXSBTaG93IHRvb2x0aXAgYXQgdGhlIGluaXRpYWxpemF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdG9vbHRpcC5pbml0Lng9MF0gU2V0IHggQXhpcyBpbmRleCB0byBiZSBzaG93biBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IFt0b29sdGlwLmluaXQucG9zaXRpb249e3RvcDogXCIwcHhcIixsZWZ0OiBcIjUwcHhcIn1dIFNldCB0aGUgcG9zaXRpb24gb2YgdG9vbHRpcCBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25zaG93XSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgc2hvd24uXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25oaWRlXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgaGlkZGVuLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uc2hvd25dIFNldCBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIGFmdGVyIHRoZSB0b29sdGlwIGlzIHNob3duXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25oaWRkZW5dIFNldCBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIGFmdGVyIHRoZSB0b29sdGlwIGlzIGhpZGRlbi5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xGdW5jdGlvbnxudWxsfSBbdG9vbHRpcC5vcmRlcj1udWxsXSBTZXQgdG9vbHRpcCBkYXRhIGRpc3BsYXkgb3JkZXIuPGJyPjxicj5cbiAgICAgKiAgKipBdmFpbGFibGUgVmFsdWVzOioqXG4gICAgICogIC0gYGRlc2NgOiBJbiBkZXNjZW5kaW5nIGRhdGEgdmFsdWUgb3JkZXJcbiAgICAgKiAgLSBgYXNjYDogSW4gYXNjZW5kaW5nIGRhdGEgdmFsdWUgb3JkZXJcbiAgICAgKiAgLSBgbnVsbGA6IEl0IGtlZXBzIHRoZSBkYXRhIGRpc3BsYXkgb3JkZXI8YnI+XG4gICAgICogICAgICoqTk9URToqKiBXaGVuIGBkYXRhLmdyb3Vwc2AgaXMgc2V0LCB0aGUgb3JkZXIgd2lsbCBmb2xsb3cgYXMgdGhlIHN0YWNrZWQgZ3JhcGggb3JkZXIuPGJyPlxuICAgICAqICAgICAgSWYgd2FudCB0byBvcmRlciBhcyBkYXRhIGJvdW5kLCBzZXQgYW55IHZhbHVlIHJhdGhlciB0aGFuIGFzYywgZGVzYyBvciBudWxsLiAoZXguIGVtcHR5IHN0cmluZyBcIlwiKVxuICAgICAqICAtIGBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgLi4uIH1gOiBbQXJyYXkuc29ydCBjb21wYXJlRnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQjUGFyYW1ldGVycylcbiAgICAgKiBAc2VlIFtEZW1vOiBIaWRlIFRvb2x0aXBdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLkhpZGVUb29sdGlwKVxuICAgICAqIEBzZWUgW0RlbW86IFRvb2x0aXAgR3JvdXBpbmddKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLlRvb2x0aXBHcm91cGluZylcbiAgICAgKiBAc2VlIFtEZW1vOiBUb29sdGlwIEZvcm1hdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcEZvcm1hdClcbiAgICAgKiBAc2VlIFtEZW1vOiBMaW5rZWQgVG9vbHRpcF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuTGlua2VkVG9vbHRpcHMpXG4gICAgICogQHNlZSBbRGVtbzogVG9vbHRpcCBUZW1wbGF0ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcFRlbXBsYXRlKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHRvb2x0aXA6IHtcbiAgICAgKiAgICAgIHNob3c6IHRydWUsXG4gICAgICogICAgICBkb05vdEhpZGU6IHRydWUsXG4gICAgICogICAgICBncm91cGVkOiBmYWxzZSxcbiAgICAgKiAgICAgIGZvcm1hdDoge1xuICAgICAqICAgICAgICAgIHRpdGxlOiBmdW5jdGlvbih4KSB7IHJldHVybiBcIkRhdGEgXCIgKyB4OyB9LFxuICAgICAqICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uKG5hbWUsIHJhdGlvLCBpZCwgaW5kZXgpIHsgcmV0dXJuIG5hbWU7IH0sXG4gICAgICogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiByYXRpbzsgfVxuICAgICAqICAgICAgfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbihkYXRhLCB3aWR0aCwgaGVpZ2h0LCBlbGVtZW50KSB7XG4gICAgICogICAgICBcdC8vIHJldHVybiB3aXRoIHVuaXQgb3Igd2l0aG91dC4gSWYgdGhlIHZhbHVlIGlzIG51bWJlciwgaXMgdHJlYXRlZCBhcyAncHgnLlxuICAgICAqICAgICAgXHRyZXR1cm4ge3RvcDogXCIxMCVcIiwgbGVmdDogMjB9ICAvLyB0b3A6MTAlOyBsZWZ0OiAyMHB4O1xuICAgIFx0XHQgKiAgICAgIH0sXG4gICAgXHRcdCAqICAgICAgY29udGVudHM6IGZ1bmN0aW9uKGQsIGRlZmF1bHRUaXRsZUZvcm1hdCwgZGVmYXVsdFZhbHVlRm9ybWF0LCBjb2xvcikge1xuICAgIFx0XHQgKiAgICAgICAgICByZXR1cm4gLi4uIC8vIGZvcm1hdHRlZCBodG1sIGFzIHlvdSB3YW50XG4gICAgIFx0XHQgKiAgICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgICAvLyBzcGVjaWZ5IHRvb2x0aXAgY29udGVudHMgdXNpbmcgdGVtcGxhdGVcbiAgICAgKiAgICAgICAvLyAtIGV4YW1wbGUgb2YgSFRNTCByZXR1cm5lZDpcbiAgICAgKiAgICAgICAvLyA8dWwgY2xhc3M9XCJiYi10b29sdGlwXCI+XG4gICAgICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTFcIj48c3Bhbj4yNTA8L3NwYW4+PGJyPjxzcGFuIHN0eWxlPVwiY29sb3I6IzAwYzczY1wiPmRhdGExPC9zcGFuPjwvbGk+XG4gICAgICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTJcIj48c3Bhbj41MDwvc3Bhbj48YnI+PHNwYW4gc3R5bGU9XCJjb2xvcjojZmE3MTcxXCI+ZGF0YTI8L3NwYW4+PC9saT5cbiAgICAgKiAgICAgICAvLyA8L3VsPlxuICAgICAqICAgICAgIGNvbnRlbnRzOiB7XG4gICAgICogICAgICBcdGJpbmR0bzogXCIjdG9vbHRpcFwiLFxuICAgICAqICAgICAgXHR0ZW1wbGF0ZTogJzx1bCBjbGFzcz17PUNMQVNTX1RPT0xUSVB9Pnt7JyArXG4gICAgICogICAgICBcdFx0XHQnPGxpIGNsYXNzPVwiez1DTEFTU19UT09MVElQX05BTUV9XCI+PHNwYW4+ez1WQUxVRX08L3NwYW4+PGJyPicgK1xuICAgICAqICAgICAgXHRcdFx0JzxzcGFuIHN0eWxlPWNvbG9yOns9Q09MT1J9Pns9TkFNRX08L3NwYW4+PC9saT4nICtcbiAgICAgKiAgICAgIFx0XHQnfX08L3VsPidcbiAgICAgKiAgICAgIH1cbiAgICAgKlxuICAgICAqICAgICAgIC8vIHdpdGggYWRkaXRpb25hbCB0ZXh0IHZhbHVlXG4gICAgICogICAgICAgLy8gLSBleGFtcGxlIG9mIEhUTUwgcmV0dXJuZWQ6XG4gICAgICogICAgICAgLy8gPHVsIGNsYXNzPVwiYmItdG9vbHRpcFwiPlxuICAgICAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGExXCI+PHNwYW4+MjUwPC9zcGFuPjxicj5jb21tZW50MTxzcGFuIHN0eWxlPVwiY29sb3I6IzAwYzczY1wiPmRhdGExPC9zcGFuPnRleHQxPC9saT5cbiAgICAgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMlwiPjxzcGFuPjUwPC9zcGFuPjxicj5jb21tZW50MjxzcGFuIHN0eWxlPVwiY29sb3I6I2ZhNzE3MVwiPmRhdGEyPC9zcGFuPnRleHQyPC9saT5cbiAgICAgKiAgICAgICAvLyA8L3VsPlxuICAgICAqICAgICAgIGNvbnRlbnRzOiB7XG4gICAgICogICAgICBcdGJpbmR0bzogXCIjdG9vbHRpcFwiLFxuICAgICAqICAgICAgXHR0ZXh0OiB7XG4gICAgICogICAgICBcdFx0Ly8gYSkgJ2tleScgbmFtZSBpcyB1c2VkIGFzIHN1YnN0aXR1dGlvbiB3aXRoaW4gdGVtcGxhdGUgYXMgJ3s9S0VZfSdcbiAgICAgKiAgICAgIFx0XHQvLyBiKSB0aGUgbGVuZ3RoIHNob3VsZCBtYXRjaCB3aXRoIHRoZSBkYXRhIGxlbmd0aFxuICAgICAqICAgICAgXHRcdFZBUjE6IFtcInRleHQxXCIsIFwidGV4dDJcIl0sXG4gICAgICogICAgICBcdFx0VkFSMjogW1wiY29tbWVudDFcIiwgXCJjb21tZW50MlwiXSxcbiAgICAgKiAgICAgIFx0fSxcbiAgICAgKiAgICAgIFx0dGVtcGxhdGU6ICc8dWwgY2xhc3M9ez1DTEFTU19UT09MVElQfT57eycgK1xuICAgICAqICAgICAgXHRcdFx0JzxsaSBjbGFzcz1cIns9Q0xBU1NfVE9PTFRJUF9OQU1FfVwiPjxzcGFuPns9VkFMVUV9PC9zcGFuPns9VkFSMn08YnI+JyArXG4gICAgICogICAgICBcdFx0XHQnPHNwYW4gc3R5bGU9Y29sb3I6ez1DT0xPUn0+ez1OQU1FfTwvc3Bhbj57PVZBUjF9PC9saT4nICtcbiAgICAgKiAgICAgIFx0XHQnfX08L3VsPidcbiAgICAgKiAgICAgIH1cbiAgICAgXHRcdCAqXG4gICAgIFx0XHQgKiAgICAgIC8vIHNvcnQgdG9vbHRpcCBkYXRhIHZhbHVlIGRpc3BsYXkgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgIFx0XHQgKiAgICAgIG9yZGVyOiBcImFzY1wiLFxuICAgICBcdFx0ICpcbiAgICAgKiAgICAgIC8vIHNwZWNpZnlpbmcgc29ydCBmdW5jdGlvblxuICAgICAqICAgICAgb3JkZXI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgICAgICAgIC8vIHBhcmFtIGRhdGEgcGFzc2VkIGZvcm1hdFxuICAgICAqICAgICAgICAge3g6IDUsIHZhbHVlOiAyNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA1LCBuYW1lOiBcImRhdGExXCJ9XG4gICAgICogICAgICAgICAgIC4uLlxuICAgICAqICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAgLy8gc2hvdyBhdCB0aGUgaW5pdGlhbGl6YXRpb25cbiAgICAgKiAgICAgIGluaXQ6IHtcbiAgICAgKiAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAqICAgICAgICAgIHg6IDIsXG4gICAgICogICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgKiAgICAgICAgICAgICAgdG9wOiBcIjE1MHB4XCIsXG4gICAgICogICAgICAgICAgICAgIGxlZnQ6IFwiMjUwcHhcIlxuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgIC8vIGZpcmVzIHByaW9yIHRvb2x0aXAgaXMgc2hvd25cbiAgICAgKiAgICAgIG9uc2hvdzogZnVuY3Rpb24oY3R4LCBzZWxlY3RlZERhdGEpIHtcbiAgICAgKiAgICAgIFx0Y3R4OyAvLyBjdXJyZW50IGNoYXJ0IGluc3RhbmNlXG4gICAgICpcbiAgICAgKiAgICAgIFx0Ly8gY3VycmVudCBkYXRhc2V0IHNlbGVjdGVkXG4gICAgICogICAgICBcdC8vID09PiBbe3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGEyXCJ9LCAuLi5dXG4gICAgICogICAgICBcdHNlbGVjdGVkRGF0YTtcbiAgICAgKiAgICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgIC8vIGZpcmVzIHByaW9yIHRvb2x0aXAgaXMgaGlkZGVuXG4gICAgICogICAgICBvbmhpZGU6IGZ1bmN0aW9uKGN0eCwgc2VsZWN0ZWREYXRhKSB7XG4gICAgICogICAgICBcdGN0eDsgLy8gY3VycmVudCBjaGFydCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogICAgICBcdC8vIGN1cnJlbnQgZGF0YXNldCBzZWxlY3RlZFxuICAgICAqICAgICAgXHQvLyA9PT4gW3t4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMlwifSwgLi4uXVxuICAgICAqICAgICAgXHRzZWxlY3RlZERhdGE7XG4gICAgICogICAgICB9LFxuICAgICAqXG4gICAgICogICAgICAvLyBmaXJlcyBhZnRlciB0b29sdGlwIGlzIHNob3duXG4gICAgICogICAgICBvbnNob3duOiBmdW5jdGlvbihjdHgsIHNlbGVjdGVkRGF0YSkge1xuICAgICAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqICAgICAgXHQvLyBjdXJyZW50IGRhdGFzZXQgc2VsZWN0ZWRcbiAgICAgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cbiAgICAgKiAgICAgIFx0c2VsZWN0ZWREYXRhO1xuICAgICAqICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAgLy8gZmlyZXMgYWZ0ZXIgdG9vbHRpcCBpcyBoaWRkZW5cbiAgICAgKiAgICAgIG9uaGlkZGVuOiBmdW5jdGlvbihjdHgsIHNlbGVjdGVkRGF0YSkge1xuICAgICAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqICAgICAgXHQvLyBjdXJyZW50IGRhdGFzZXQgc2VsZWN0ZWRcbiAgICAgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cbiAgICAgKiAgICAgIFx0c2VsZWN0ZWREYXRhO1xuICAgICAqICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAgLy8gTGluayBhbnkgdG9vbHRpcHMgd2hlbiBtdWx0aXBsZSBjaGFydHMgYXJlIG9uIHRoZSBzY3JlZW4gd2hlcmUgc2FtZSB4IGNvb3JkaW5hdGVzIGFyZSBhdmFpbGFibGVcbiAgICAgKiAgICAgIC8vIFVzZWZ1bCBmb3IgdGltZXNlcmllcyBjb3JyZWxhdGlvblxuICAgICAqICAgICAgbGlua2VkOiB0cnVlLFxuICAgICAqXG4gICAgICogICAgICAvLyBTcGVjaWZ5IG5hbWUgdG8gaW50ZXJhY3QgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIG9ubHkuXG4gICAgICogICAgICBsaW5rZWQ6IHtcbiAgICAgKiAgICAgICAgICBuYW1lOiBcInNvbWUtZ3JvdXBcIlxuICAgICAqICAgICAgfVxuICAgICAqICB9XG4gICAgICovXG4gICAgdG9vbHRpcF9zaG93OiAhMCxcbiAgICB0b29sdGlwX2RvTm90SGlkZTogITEsXG4gICAgdG9vbHRpcF9ncm91cGVkOiAhMCxcbiAgICB0b29sdGlwX2Zvcm1hdF90aXRsZTogdW5kZWZpbmVkLFxuICAgIHRvb2x0aXBfZm9ybWF0X25hbWU6IHVuZGVmaW5lZCxcbiAgICB0b29sdGlwX2Zvcm1hdF92YWx1ZTogdW5kZWZpbmVkLFxuICAgIHRvb2x0aXBfcG9zaXRpb246IHVuZGVmaW5lZCxcbiAgICB0b29sdGlwX2NvbnRlbnRzOiB7fSxcbiAgICB0b29sdGlwX2luaXRfc2hvdzogITEsXG4gICAgdG9vbHRpcF9pbml0X3g6IDAsXG4gICAgdG9vbHRpcF9pbml0X3Bvc2l0aW9uOiB7XG4gICAgICB0b3A6IFwiMHB4XCIsXG4gICAgICBsZWZ0OiBcIjUwcHhcIlxuICAgIH0sXG4gICAgdG9vbHRpcF9saW5rZWQ6ICExLFxuICAgIHRvb2x0aXBfbGlua2VkX25hbWU6IFwiXCIsXG4gICAgdG9vbHRpcF9vbnNob3c6IGZ1bmN0aW9uIHRvb2x0aXBfb25zaG93KCkge30sXG4gICAgdG9vbHRpcF9vbmhpZGU6IGZ1bmN0aW9uIHRvb2x0aXBfb25oaWRlKCkge30sXG4gICAgdG9vbHRpcF9vbnNob3duOiBmdW5jdGlvbiB0b29sdGlwX29uc2hvd24oKSB7fSxcbiAgICB0b29sdGlwX29uaGlkZGVuOiBmdW5jdGlvbiB0b29sdGlwX29uaGlkZGVuKCkge30sXG4gICAgdG9vbHRpcF9vcmRlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aXRsZSBvcHRpb25zXG4gICAgICogQG5hbWUgdGl0bGVcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0aXRsZS50ZXh0XSBUaXRsZSB0ZXh0LiBJZiBjb250YWlucyBgXFxuYCwgaXQncyB1c2VkIGFzIGxpbmUgYnJlYWsgYWxsb3dpbmcgbXVsdGlsaW5lIHRpdGxlLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGl0bGUucGFkZGluZy50b3A9MF0gVG9wIHBhZGRpbmcgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aXRsZS5wYWRkaW5nLnJpZ2h0PTBdIFJpZ2h0IHBhZGRpbmcgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aXRsZS5wYWRkaW5nLmJvdHRvbT0wXSBCb3R0b20gcGFkZGluZyB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcubGVmdD0wXSBMZWZ0IHBhZGRpbmcgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0aXRsZS5wb3NpdGlvbj1jZW50ZXJdIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOiAnY2VudGVyJywgJ3JpZ2h0JyBhbmQgJ2xlZnQnLlxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUaXRsZS5NdWx0aWxpbmVkVGl0bGUpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdGl0bGU6IHtcbiAgICAgKiAgICAgIHRleHQ6IFwiVGl0bGUgVGV4dFwiLFxuICAgICAqXG4gICAgICogICAgICAvLyBvciBNdWx0aWxpbmUgdGl0bGUgdGV4dFxuICAgICAqICAgICAgdGV4dDogXCJNYWluIHRpdGxlIHRleHRcXG5TdWIgdGl0bGUgdGV4dFwiLFxuICAgICAqXG4gICAgICogICAgICBwYWRkaW5nOiB7XG4gICAgICogICAgICAgICAgdG9wOiAxMCxcbiAgICAgKiAgICAgICAgICByaWdodDogMTAsXG4gICAgICogICAgICAgICAgYm90dG9tOiAxMCxcbiAgICAgKiAgICAgICAgICBsZWZ0OiAxMFxuICAgICAqICAgICAgfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiBcImNlbnRlclwiXG4gICAgICogIH1cbiAgICAgKi9cbiAgICB0aXRsZV90ZXh0OiB1bmRlZmluZWQsXG4gICAgdGl0bGVfcGFkZGluZzoge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfSxcbiAgICB0aXRsZV9wb3NpdGlvbjogXCJjZW50ZXJcIlxuICB9O1xufTtcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb25maWcvY29uZmlnLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICBnZXRPcHRpb25zOiBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiBuZXcgT3B0aW9uc19PcHRpb25zKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvYWQgY29uZmlndXJhdGlvbiBvcHRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBVc2VyJ3MgZ2VuZXJhdGlvbiBjb25maWcgdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGxvYWRDb25maWc6IGZ1bmN0aW9uIGxvYWRDb25maWcoY29uZmlnKSB7XG4gICAgdmFyIHRhcmdldCxcbiAgICAgICAga2V5cyxcbiAgICAgICAgcmVhZCxcbiAgICAgICAgdGhpc0NvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBmaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGtleSA9IGtleXMuc2hpZnQoKTtcbiAgICAgIHJldHVybiBrZXkgJiYgdGFyZ2V0ICYmIGlzT2JqZWN0VHlwZSh0YXJnZXQpICYmIGtleSBpbiB0YXJnZXQgPyAodGFyZ2V0ID0gdGFyZ2V0W2tleV0sIGZpbmQoKSkgOiBrZXkgPyB1bmRlZmluZWQgOiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXNDb25maWcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdGFyZ2V0ID0gY29uZmlnLCBrZXlzID0ga2V5LnNwbGl0KFwiX1wiKSwgcmVhZCA9IGZpbmQoKSwgaXNEZWZpbmVkKHJlYWQpICYmICh0aGlzQ29uZmlnW2tleV0gPSByZWFkKTtcbiAgICB9KTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbnRlcm5hbHMvc2NhbGUuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIGdldFNjYWxlOiBmdW5jdGlvbiBnZXRTY2FsZShtaW4sIG1heCwgZm9yVGltZXNlcmllcykge1xuICAgIHJldHVybiAoZm9yVGltZXNlcmllcyA/IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zY2FsZV9jb21tb25qczJfZDNfc2NhbGVfYW1kX2QzX3NjYWxlX3Jvb3RfZDNfW1wic2NhbGVUaW1lXCJdKSgpIDogT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NjYWxlX2NvbW1vbmpzMl9kM19zY2FsZV9hbWRfZDNfc2NhbGVfcm9vdF9kM19bXCJzY2FsZUxpbmVhclwiXSkoKSkucmFuZ2UoW21pbiwgbWF4XSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB4IEF4aXMgc2NhbGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkb21haW5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2Zmc2V0IFRoZSBvZmZzZXQgZ2V0dGVyIHRvIGJlIHN1bVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gc2NhbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFg6IGZ1bmN0aW9uIGdldFgobWluLCBtYXgsIGRvbWFpbiwgb2Zmc2V0KSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgc2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQuZ2V0U2NhbGUobWluLCBtYXgsICQkLmlzVGltZVNlcmllcygpKTtcbiAgICByZXR1cm4gJCQuZ2V0Q3VzdG9taXplZFNjYWxlKGRvbWFpbiA/IHNjYWxlLmRvbWFpbihkb21haW4pIDogc2NhbGUsIG9mZnNldCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB5IEF4aXMgc2NhbGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkb21haW5cbiAgICogQHJldHVybiB7RnVuY3Rpb259IHNjYWxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRZOiBmdW5jdGlvbiBnZXRZKG1pbiwgbWF4LCBkb21haW4pIHtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLmdldFNjYWxlKG1pbiwgbWF4LCB0aGlzLmlzVGltZVNlcmllc1koKSk7XG4gICAgcmV0dXJuIGRvbWFpbiAmJiBzY2FsZS5kb21haW4oZG9tYWluKSwgc2NhbGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjdXN0b21pemVkIHNjYWxlXG4gICAqIEBwYXJhbSB7ZDMuc2NhbGVMaW5lYXJ8ZDMuc2NhbGVUaW1lfSBzY2FsZVZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9mZnNldFZhbHVlIE9mZnNldCBnZXR0ZXIgdG8gYmUgc3VtXG4gICAqIEByZXR1cm4ge30gc2NhbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEN1c3RvbWl6ZWRTY2FsZTogZnVuY3Rpb24gZ2V0Q3VzdG9taXplZFNjYWxlKHNjYWxlVmFsdWUsIG9mZnNldFZhbHVlKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICQkLnhBeGlzLnRpY2tPZmZzZXQoKTtcbiAgICB9LFxuICAgICAgICBzY2FsZSA9IGZ1bmN0aW9uIChkLCByYXcpIHtcbiAgICAgIHZhciB2ID0gc2NhbGVWYWx1ZShkKSArIG9mZnNldCgpO1xuICAgICAgcmV0dXJuIHJhdyA/IHYgOiBNYXRoLmNlaWwodik7XG4gICAgfTtcblxuICAgIC8vIGNvcHkgb3JpZ2luYWwgc2NhbGUgbWV0aG9kc1xuICAgIGZvciAodmFyIGtleSBpbiBzY2FsZVZhbHVlKSBzY2FsZVtrZXldID0gc2NhbGVWYWx1ZVtrZXldO1xuXG4gICAgcmV0dXJuIHNjYWxlLm9yZ0RvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzY2FsZVZhbHVlLmRvbWFpbigpO1xuICAgIH0sIHNjYWxlLm9yZ1NjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNjYWxlVmFsdWU7XG4gICAgfSwgJCQuaXNDYXRlZ29yaXplZCgpICYmIChzY2FsZS5kb21haW4gPSBmdW5jdGlvbiAoZG9tYWluVmFsdWUpIHtcbiAgICAgIHZhciBkb21haW4gPSBkb21haW5WYWx1ZTtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlVmFsdWUuZG9tYWluKGRvbWFpbiksIHNjYWxlKSA6IChkb21haW4gPSB0aGlzLm9yZ0RvbWFpbigpLCBbZG9tYWluWzBdLCBkb21haW5bMV0gKyAxXSk7XG4gICAgfSksIHNjYWxlO1xuICB9LFxuICBnZXRZU2NhbGU6IGZ1bmN0aW9uIGdldFlTY2FsZShpZCkge1xuICAgIHJldHVybiB0aGlzLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgPyB0aGlzLnkyIDogdGhpcy55O1xuICB9LFxuICBnZXRTdWJZU2NhbGU6IGZ1bmN0aW9uIGdldFN1YllTY2FsZShpZCkge1xuICAgIHJldHVybiB0aGlzLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgPyB0aGlzLnN1YlkyIDogdGhpcy5zdWJZO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc2NhbGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0luaXQgLSBwYXJhbSBpcyBnaXZlbiBhdCB0aGUgaW5pdCByZW5kZXJpbmdcbiAgICovXG4gIHVwZGF0ZVNjYWxlczogZnVuY3Rpb24gdXBkYXRlU2NhbGVzKGlzSW5pdCkge1xuICAgIHZhciB1cGRhdGVYRG9tYWluID0gIShhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCkgfHwgYXJndW1lbnRzWzFdLFxuICAgICAgICAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcbiAgICAkJC54TWluID0gaXNSb3RhdGVkID8gMSA6IDAsICQkLnhNYXggPSBpc1JvdGF0ZWQgPyAkJC5oZWlnaHQgOiAkJC53aWR0aCwgJCQueU1pbiA9IGlzUm90YXRlZCA/IDAgOiAkJC5oZWlnaHQsICQkLnlNYXggPSBpc1JvdGF0ZWQgPyAkJC53aWR0aCA6IDEsICQkLnN1YlhNaW4gPSAkJC54TWluLCAkJC5zdWJYTWF4ID0gJCQueE1heCwgJCQuc3ViWU1pbiA9IGlzUm90YXRlZCA/IDAgOiAkJC5oZWlnaHQyLCAkJC5zdWJZTWF4ID0gaXNSb3RhdGVkID8gJCQud2lkdGgyIDogMTtcbiAgICAvLyB1cGRhdGUgc2NhbGVzXG4gICAgLy8geCBBeGlzXG4gICAgdmFyIHhEb21haW4gPSB1cGRhdGVYRG9tYWluICYmICQkLnggJiYgJCQueC5vcmdEb21haW4oKSxcbiAgICAgICAgeFN1YkRvbWFpbiA9IHVwZGF0ZVhEb21haW4gJiYgJCQub3JnWERvbWFpbjtcbiAgICAvLyB5IEF4aXNcbiAgICAvLyB1cGRhdGUgZm9yIGFyY1xuICAgICQkLnggPSAkJC5nZXRYKCQkLnhNaW4sICQkLnhNYXgsIHhEb21haW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAkJC54QXhpcy50aWNrT2Zmc2V0KCk7XG4gICAgfSksICQkLnN1YlggPSAkJC5nZXRYKCQkLnhNaW4sICQkLnhNYXgsIHhTdWJEb21haW4sIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZCAlIDEgPyAwIDogJCQuc3ViWEF4aXMudGlja09mZnNldCgpO1xuICAgIH0pLCAkJC54QXhpc1RpY2tGb3JtYXQgPSAkJC5heGlzLmdldFhBeGlzVGlja0Zvcm1hdCgpLCAkJC54QXhpc1RpY2tWYWx1ZXMgPSAkJC5heGlzLmdldFRpY2tWYWx1ZXMoXCJ4XCIpLCAkJC54QXhpcyA9ICQkLmF4aXMuZ2V0QXhpcyhcInhcIiwgJCQueCwgY29uZmlnLmF4aXNfeF90aWNrX291dGVyLCBpc0luaXQpLCAkJC5zdWJYQXhpcyA9ICQkLmF4aXMuZ2V0QXhpcyhcInN1YlhcIiwgJCQuc3ViWCwgY29uZmlnLmF4aXNfeF90aWNrX291dGVyLCBpc0luaXQpLCAkJC55ID0gJCQuZ2V0WSgkJC55TWluLCAkJC55TWF4LCAkJC55ID8gJCQueS5kb21haW4oKSA6IGNvbmZpZy5heGlzX3lfZGVmYXVsdCksICQkLnN1YlkgPSAkJC5nZXRZKCQkLnN1YllNaW4sICQkLnN1YllNYXgsICQkLnN1YlkgPyAkJC5zdWJZLmRvbWFpbigpIDogY29uZmlnLmF4aXNfeV9kZWZhdWx0KSwgJCQueUF4aXNUaWNrVmFsdWVzID0gJCQuYXhpcy5nZXRUaWNrVmFsdWVzKFwieVwiKSwgJCQueUF4aXMgPSAkJC5heGlzLmdldEF4aXMoXCJ5XCIsICQkLnksIGNvbmZpZy5heGlzX3lfdGlja19vdXRlciwgaXNJbml0KSwgY29uZmlnLmF4aXNfeTJfc2hvdyAmJiAoJCQueTIgPSAkJC5nZXRZKCQkLnlNaW4sICQkLnlNYXgsICQkLnkyID8gJCQueTIuZG9tYWluKCkgOiBjb25maWcuYXhpc195Ml9kZWZhdWx0KSwgJCQuc3ViWTIgPSAkJC5nZXRZKCQkLnN1YllNaW4sICQkLnN1YllNYXgsICQkLnN1YlkyID8gJCQuc3ViWTIuZG9tYWluKCkgOiBjb25maWcuYXhpc195Ml9kZWZhdWx0KSwgJCQueTJBeGlzVGlja1ZhbHVlcyA9ICQkLmF4aXMuZ2V0VGlja1ZhbHVlcyhcInkyXCIpLCAkJC55MkF4aXMgPSAkJC5heGlzLmdldEF4aXMoXCJ5MlwiLCAkJC55MiwgY29uZmlnLmF4aXNfeTJfdGlja19vdXRlciwgaXNJbml0KSksICQkLnVwZGF0ZUFyYyAmJiAkJC51cGRhdGVBcmMoKTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbnRlcm5hbHMvZG9tYWluLmpzXG5cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIGdldFlEb21haW5NaW5NYXg6IGZ1bmN0aW9uIGdldFlEb21haW5NaW5NYXgodGFyZ2V0cywgdHlwZSkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgaXNNaW4gPSB0eXBlID09PSBcIm1pblwiLFxuICAgICAgICBkYXRhR3JvdXBzID0gY29uZmlnLmRhdGFfZ3JvdXBzLFxuICAgICAgICBpZHMgPSAkJC5tYXBUb0lkcyh0YXJnZXRzKSxcbiAgICAgICAgeXMgPSAkJC5nZXRWYWx1ZXNBc0lkS2V5ZWQodGFyZ2V0cyk7XG4gICAgcmV0dXJuIGRhdGFHcm91cHMubGVuZ3RoID4gMCAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpZHNJbkdyb3VwLCBfcmV0LCBoYXNWYWx1ZSA9ICQkW1wiaGFzXCIuY29uY2F0KGlzTWluID8gXCJOZWdhdGl2ZVwiIDogXCJQb3NpdGl2ZVwiLCBcIlZhbHVlSW5UYXJnZXRzXCIpXSh0YXJnZXRzKSwgX2xvb3AgPSBmdW5jdGlvbiAoaiwgX2lkc0luR3JvdXApIHtcbiAgICAgICAgaWYgKF9pZHNJbkdyb3VwID0gX2lkc0luR3JvdXAuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIGlkcy5pbmRleE9mKHYpID49IDA7XG4gICAgICAgIH0pLCBfaWRzSW5Hcm91cC5sZW5ndGggPT09IDApIHJldHVybiBpZHNJbkdyb3VwID0gX2lkc0luR3JvdXAsIFwiY29udGludWVcIjtcbiAgICAgICAgdmFyIGJhc2VJZCA9IF9pZHNJbkdyb3VwWzBdLFxuICAgICAgICAgICAgYmFzZUF4aXNJZCA9ICQkLmF4aXMuZ2V0SWQoYmFzZUlkKTtcbiAgICAgICAgaGFzVmFsdWUgJiYgeXNbYmFzZUlkXSAmJiAoeXNbYmFzZUlkXSA9IHlzW2Jhc2VJZF0ubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIChpc01pbiA/IHYgPCAwIDogdiA+IDApID8gdiA6IDA7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmb3IgKHZhciBpZCwgX3JldDIsIF9sb29wMiA9IGZ1bmN0aW9uIChrLCBpZCkge1xuICAgICAgICAgIGlmICgheXNbaWRdKSByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgIHZhciBheGlzSWQgPSAkJC5heGlzLmdldElkKGlkKTtcbiAgICAgICAgICB5c1tpZF0uZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9ICt2LFxuICAgICAgICAgICAgICAgIG1lZXRDb25kaXRpb24gPSBpc01pbiA/IHZhbCA+IDAgOiB2YWwgPCAwO1xuICAgICAgICAgICAgYXhpc0lkICE9PSBiYXNlQXhpc0lkIHx8IGhhc1ZhbHVlICYmIG1lZXRDb25kaXRpb24gfHwgKHlzW2Jhc2VJZF1baV0gKz0gdmFsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgayA9IDE7IGlkID0gX2lkc0luR3JvdXBba107IGsrKykgX3JldDIgPSBfbG9vcDIoaywgaWQpLCBfcmV0MiA9PT0gXCJjb250aW51ZVwiO1xuXG4gICAgICAgIGlkc0luR3JvdXAgPSBfaWRzSW5Hcm91cDtcbiAgICAgIH0sIGogPSAwOyBpZHNJbkdyb3VwID0gZGF0YUdyb3Vwc1tqXTsgaisrKSBfcmV0ID0gX2xvb3AoaiwgaWRzSW5Hcm91cCksIF9yZXQgPT09IFwiY29udGludWVcIjtcbiAgICB9KCksIGdldE1pbk1heCh0eXBlLCBPYmplY3Qua2V5cyh5cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNaW5NYXgodHlwZSwgeXNba2V5XSk7XG4gICAgfSkpO1xuICB9LFxuICBnZXRZRG9tYWluTWluOiBmdW5jdGlvbiBnZXRZRG9tYWluTWluKHRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRZRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWluXCIpO1xuICB9LFxuICBnZXRZRG9tYWluTWF4OiBmdW5jdGlvbiBnZXRZRG9tYWluTWF4KHRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRZRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWF4XCIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBoaWRkZW4gdGFyZ2V0cyBib3VuZCB0byB0aGUgZ2l2ZW4gYXhpcyBpZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNIaWRkZW5UYXJnZXRXaXRoWURvbWFpbjogZnVuY3Rpb24gaXNIaWRkZW5UYXJnZXRXaXRoWURvbWFpbihpZCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgcmV0dXJuICQkLmhpZGRlblRhcmdldElkcy5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gJCQuYXhpcy5nZXRJZCh2KSA9PT0gaWQ7XG4gICAgfSk7XG4gIH0sXG4gIGdldFlEb21haW46IGZ1bmN0aW9uIGdldFlEb21haW4odGFyZ2V0cywgYXhpc0lkLCB4RG9tYWluKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBwZnggPSBcImF4aXNfXCIuY29uY2F0KGF4aXNJZCk7XG4gICAgaWYgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkpIHJldHVybiBbMCwgMTAwXTtcbiAgICB2YXIgdGFyZ2V0c0J5QXhpc0lkID0gdGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAkJC5heGlzLmdldElkKHQuaWQpID09PSBheGlzSWQ7XG4gICAgfSksXG4gICAgICAgIHlUYXJnZXRzID0geERvbWFpbiA/ICQkLmZpbHRlckJ5WERvbWFpbih0YXJnZXRzQnlBeGlzSWQsIHhEb21haW4pIDogdGFyZ2V0c0J5QXhpc0lkO1xuICAgIGlmICh5VGFyZ2V0cy5sZW5ndGggPT09IDApIHJldHVybiAkJC5pc0hpZGRlblRhcmdldFdpdGhZRG9tYWluKGF4aXNJZCkgPyAkJFtheGlzSWRdLmRvbWFpbigpIDogYXhpc0lkID09PSBcInkyXCIgPyAkJC55LmRvbWFpbigpIDogLy8gV2hlbiBhbGwgZGF0YSBib3VuZHMgdG8geTIsIHkgQXhpcyBkb21haW4gaXMgY2FsbGVkIHByaW9yIHkyLlxuICAgIC8vIFNvLCBpdCBuZWVkcyB0byBjYWxsIHRvIGdldCB5MiBkb21haW4gaGVyZVxuICAgICQkLmdldFlEb21haW4odGFyZ2V0cywgXCJ5MlwiLCB4RG9tYWluKTtcbiAgICB2YXIgeU1pbiA9IGNvbmZpZ1tcIlwiLmNvbmNhdChwZngsIFwiX21pblwiKV0sXG4gICAgICAgIHlNYXggPSBjb25maWdbXCJcIi5jb25jYXQocGZ4LCBcIl9tYXhcIildLFxuICAgICAgICB5RG9tYWluTWluID0gJCQuZ2V0WURvbWFpbk1pbih5VGFyZ2V0cyksXG4gICAgICAgIHlEb21haW5NYXggPSAkJC5nZXRZRG9tYWluTWF4KHlUYXJnZXRzKSxcbiAgICAgICAgY2VudGVyID0gY29uZmlnW1wiXCIuY29uY2F0KHBmeCwgXCJfY2VudGVyXCIpXSxcbiAgICAgICAgaXNaZXJvQmFzZWQgPSBbXCJhcmVhXCIsIFwiYmFyXCIsIFwiYnViYmxlXCIsIFwibGluZVwiLCBcInNjYXR0ZXJcIl0uc29tZShmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuICQkLmhhc1R5cGUodiwgeVRhcmdldHMpICYmIGNvbmZpZ1tcIlwiLmNvbmNhdCh2LCBcIl96ZXJvYmFzZWRcIildO1xuICAgIH0pLFxuICAgICAgICBpc0ludmVydGVkID0gY29uZmlnW1wiXCIuY29uY2F0KHBmeCwgXCJfaW52ZXJ0ZWRcIildLFxuICAgICAgICBzaG93SG9yaXpvbnRhbERhdGFMYWJlbCA9ICQkLmhhc0RhdGFMYWJlbCgpICYmIGNvbmZpZy5heGlzX3JvdGF0ZWQsXG4gICAgICAgIHNob3dWZXJ0aWNhbERhdGFMYWJlbCA9ICQkLmhhc0RhdGFMYWJlbCgpICYmICFjb25maWcuYXhpc19yb3RhdGVkO1xuICAgIHlEb21haW5NaW4gPSBpc1ZhbHVlKHlNaW4pID8geU1pbiA6IGlzVmFsdWUoeU1heCkgPyB5RG9tYWluTWluIDwgeU1heCA/IHlEb21haW5NaW4gOiB5TWF4IC0gMTAgOiB5RG9tYWluTWluLCB5RG9tYWluTWF4ID0gaXNWYWx1ZSh5TWF4KSA/IHlNYXggOiBpc1ZhbHVlKHlNaW4pID8geU1pbiA8IHlEb21haW5NYXggPyB5RG9tYWluTWF4IDogeU1pbiArIDEwIDogeURvbWFpbk1heCwgaXNOYU4oeURvbWFpbk1pbikgJiYgKHlEb21haW5NaW4gPSAwKSwgaXNOYU4oeURvbWFpbk1heCkgJiYgKHlEb21haW5NYXggPSB5RG9tYWluTWluKSwgeURvbWFpbk1pbiA9PT0geURvbWFpbk1heCAmJiAoeURvbWFpbk1pbiA8IDAgPyB5RG9tYWluTWF4ID0gMCA6IHlEb21haW5NaW4gPSAwKTtcbiAgICB2YXIgaXNBbGxQb3NpdGl2ZSA9IHlEb21haW5NaW4gPj0gMCAmJiB5RG9tYWluTWF4ID49IDAsXG4gICAgICAgIGlzQWxsTmVnYXRpdmUgPSB5RG9tYWluTWluIDw9IDAgJiYgeURvbWFpbk1heCA8PSAwO1xuICAgIChpc1ZhbHVlKHlNaW4pICYmIGlzQWxsUG9zaXRpdmUgfHwgaXNWYWx1ZSh5TWF4KSAmJiBpc0FsbE5lZ2F0aXZlKSAmJiAoaXNaZXJvQmFzZWQgPSAhMSksIGlzWmVyb0Jhc2VkICYmIChpc0FsbFBvc2l0aXZlICYmICh5RG9tYWluTWluID0gMCksIGlzQWxsTmVnYXRpdmUgJiYgKHlEb21haW5NYXggPSAwKSk7XG4gICAgdmFyIGRvbWFpbkxlbmd0aCA9IE1hdGguYWJzKHlEb21haW5NYXggLSB5RG9tYWluTWluKSxcbiAgICAgICAgcGFkZGluZyA9IHtcbiAgICAgIHRvcDogZG9tYWluTGVuZ3RoICogLjEsXG4gICAgICBib3R0b206IGRvbWFpbkxlbmd0aCAqIC4xXG4gICAgfTtcblxuICAgIGlmIChpc0RlZmluZWQoY2VudGVyKSkge1xuICAgICAgdmFyIHlEb21haW5BYnMgPSBNYXRoLm1heChNYXRoLmFicyh5RG9tYWluTWluKSwgTWF0aC5hYnMoeURvbWFpbk1heCkpO1xuICAgICAgeURvbWFpbk1heCA9IGNlbnRlciArIHlEb21haW5BYnMsIHlEb21haW5NaW4gPSBjZW50ZXIgLSB5RG9tYWluQWJzO1xuICAgIH0gLy8gYWRkIHBhZGRpbmcgZm9yIGRhdGEgbGFiZWxcblxuXG4gICAgaWYgKHNob3dIb3Jpem9udGFsRGF0YUxhYmVsKSB7XG4gICAgICB2YXIgZGlmZiA9IGRpZmZEb21haW4oJCQueS5yYW5nZSgpKSxcbiAgICAgICAgICByYXRpbyA9ICQkLmdldERhdGFMYWJlbExlbmd0aCh5RG9tYWluTWluLCB5RG9tYWluTWF4LCBcIndpZHRoXCIpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdiAvIGRpZmY7XG4gICAgICB9KTtcbiAgICAgIFtcImJvdHRvbVwiLCBcInRvcFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgIHBhZGRpbmdbdl0gKz0gZG9tYWluTGVuZ3RoICogKHJhdGlvW2ldIC8gKDEgLSByYXRpb1swXSAtIHJhdGlvWzFdKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNob3dWZXJ0aWNhbERhdGFMYWJlbCkge1xuICAgICAgdmFyIGxlbmd0aHMgPSAkJC5nZXREYXRhTGFiZWxMZW5ndGgoeURvbWFpbk1pbiwgeURvbWFpbk1heCwgXCJoZWlnaHRcIik7XG4gICAgICBbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICBwYWRkaW5nW3ZdICs9ICQkLmF4aXMuY29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmcobGVuZ3Roc1tpXSwgZG9tYWluTGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0gLy8gaWYgcGFkZGluZyBpcyBzZXQsIHRoZSBkb21haW4gd2lsbCBiZSB1cGRhdGVkIHJlbGF0aXZlIHRoZSBjdXJyZW50IGRvbWFpbiB2YWx1ZVxuICAgIC8vIGV4KSAkJC5oZWlnaHQ9MzAwLCBwYWRkaW5nLnRvcD0xNTAsIGRvbWFpbkxlbmd0aD00ICAtLT4gZG9tYWluPTZcblxuXG4gICAgdmFyIHAgPSBjb25maWdbXCJcIi5jb25jYXQocGZ4LCBcIl9wYWRkaW5nXCIpXTtcbiAgICBub3RFbXB0eShwKSAmJiBbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgcGFkZGluZ1t2XSA9ICQkLmF4aXMuZ2V0UGFkZGluZyhwLCB2LCBwYWRkaW5nW3ZdLCBkb21haW5MZW5ndGgpO1xuICAgIH0pLCBpc1plcm9CYXNlZCAmJiAoaXNBbGxQb3NpdGl2ZSAmJiAocGFkZGluZy5ib3R0b20gPSB5RG9tYWluTWluKSwgaXNBbGxOZWdhdGl2ZSAmJiAocGFkZGluZy50b3AgPSAteURvbWFpbk1heCkpO1xuICAgIHZhciBkb21haW4gPSBbeURvbWFpbk1pbiAtIHBhZGRpbmcuYm90dG9tLCB5RG9tYWluTWF4ICsgcGFkZGluZy50b3BdO1xuICAgIHJldHVybiBpc0ludmVydGVkID8gZG9tYWluLnJldmVyc2UoKSA6IGRvbWFpbjtcbiAgfSxcbiAgZ2V0WERvbWFpbk1pbk1heDogZnVuY3Rpb24gZ2V0WERvbWFpbk1pbk1heCh0YXJnZXRzLCB0eXBlKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnVmFsdWUgPSAkJC5jb25maWdbXCJheGlzX3hfXCIuY29uY2F0KHR5cGUpXSxcbiAgICAgICAgZGF0YVZhbHVlID0gZ2V0TWluTWF4KHR5cGUsIHRhcmdldHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gZ2V0TWluTWF4KHR5cGUsIHQudmFsdWVzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi54O1xuICAgICAgfSkpO1xuICAgIH0pKSxcbiAgICAgICAgdmFsdWUgPSBpc09iamVjdChjb25maWdWYWx1ZSkgPyBjb25maWdWYWx1ZS52YWx1ZSA6IGNvbmZpZ1ZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSA9IGlzRGVmaW5lZCh2YWx1ZSkgJiYgJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5wYXJzZURhdGUodmFsdWUpIDogdmFsdWUsIGlzT2JqZWN0KGNvbmZpZ1ZhbHVlKSAmJiBjb25maWdWYWx1ZS5maXQgJiYgKHR5cGUgPT09IFwibWluXCIgJiYgdmFsdWUgPCBkYXRhVmFsdWUgfHwgdHlwZSA9PT0gXCJtYXhcIiAmJiB2YWx1ZSA+IGRhdGFWYWx1ZSkgJiYgKHZhbHVlID0gdW5kZWZpbmVkKSwgaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogZGF0YVZhbHVlO1xuICB9LFxuICBnZXRYRG9tYWluTWluOiBmdW5jdGlvbiBnZXRYRG9tYWluTWluKHRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRYRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWluXCIpO1xuICB9LFxuICBnZXRYRG9tYWluTWF4OiBmdW5jdGlvbiBnZXRYRG9tYWluTWF4KHRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRYRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWF4XCIpO1xuICB9LFxuICBnZXRYRG9tYWluUGFkZGluZzogZnVuY3Rpb24gZ2V0WERvbWFpblBhZGRpbmcoZG9tYWluKSB7XG4gICAgdmFyIG1heERhdGFDb3VudCxcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGRpZmYgPSBkb21haW5bMV0gLSBkb21haW5bMF0sXG4gICAgICAgIHhQYWRkaW5nID0gY29uZmlnLmF4aXNfeF9wYWRkaW5nO1xuICAgICQkLmlzQ2F0ZWdvcml6ZWQoKSA/IHBhZGRpbmcgPSAwIDogJCQuaGFzVHlwZShcImJhclwiKSA/IChtYXhEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKSwgcGFkZGluZyA9IG1heERhdGFDb3VudCA+IDEgPyBkaWZmIC8gKG1heERhdGFDb3VudCAtIDEpIC8gMiA6IC41KSA6IHBhZGRpbmcgPSBkaWZmICogLjAxO1xuICAgIHZhciBsZWZ0ID0gcGFkZGluZyxcbiAgICAgICAgcmlnaHQgPSBwYWRkaW5nO1xuICAgIHJldHVybiBpc09iamVjdCh4UGFkZGluZykgJiYgbm90RW1wdHkoeFBhZGRpbmcpID8gKGxlZnQgPSBpc1ZhbHVlKHhQYWRkaW5nLmxlZnQpID8geFBhZGRpbmcubGVmdCA6IHBhZGRpbmcsIHJpZ2h0ID0gaXNWYWx1ZSh4UGFkZGluZy5yaWdodCkgPyB4UGFkZGluZy5yaWdodCA6IHBhZGRpbmcpIDogaXNOdW1iZXIoY29uZmlnLmF4aXNfeF9wYWRkaW5nKSAmJiAobGVmdCA9IHhQYWRkaW5nLCByaWdodCA9IHhQYWRkaW5nKSwge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHJpZ2h0OiByaWdodFxuICAgIH07XG4gIH0sXG4gIGdldFhEb21haW46IGZ1bmN0aW9uIGdldFhEb21haW4odGFyZ2V0cykge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHhEb21haW4gPSBbJCQuZ2V0WERvbWFpbk1pbih0YXJnZXRzKSwgJCQuZ2V0WERvbWFpbk1heCh0YXJnZXRzKV0sXG4gICAgICAgIF94RG9tYWluMiA9IF9zbGljZWRUb0FycmF5KHhEb21haW4sIDIpLFxuICAgICAgICBmaXJzdFggPSBfeERvbWFpbjJbMF0sXG4gICAgICAgIGxhc3RYID0gX3hEb21haW4yWzFdLFxuICAgICAgICBwYWRkaW5nID0gJCQuZ2V0WERvbWFpblBhZGRpbmcoeERvbWFpbiksXG4gICAgICAgIG1pbiA9IDAsXG4gICAgICAgIG1heCA9IDA7XG5cbiAgICByZXR1cm4gZmlyc3RYIC0gbGFzdFggIT09IDAgfHwgJCQuaXNDYXRlZ29yaXplZCgpIHx8ICgkJC5pc1RpbWVTZXJpZXMoKSA/IChmaXJzdFggPSBuZXcgRGF0ZShmaXJzdFguZ2V0VGltZSgpICogLjUpLCBsYXN0WCA9IG5ldyBEYXRlKGxhc3RYLmdldFRpbWUoKSAqIDEuNSkpIDogKGZpcnN0WCA9IGZpcnN0WCA9PT0gMCA/IDEgOiBmaXJzdFggKiAuNSwgbGFzdFggPSBsYXN0WCA9PT0gMCA/IC0xIDogbGFzdFggKiAxLjUpKSwgKGZpcnN0WCB8fCBmaXJzdFggPT09IDApICYmIChtaW4gPSAkJC5pc1RpbWVTZXJpZXMoKSA/IG5ldyBEYXRlKGZpcnN0WC5nZXRUaW1lKCkgLSBwYWRkaW5nLmxlZnQpIDogZmlyc3RYIC0gcGFkZGluZy5sZWZ0KSwgKGxhc3RYIHx8IGxhc3RYID09PSAwKSAmJiAobWF4ID0gJCQuaXNUaW1lU2VyaWVzKCkgPyBuZXcgRGF0ZShsYXN0WC5nZXRUaW1lKCkgKyBwYWRkaW5nLnJpZ2h0KSA6IGxhc3RYICsgcGFkZGluZy5yaWdodCksIFttaW4sIG1heF07XG4gIH0sXG4gIHVwZGF0ZVhEb21haW46IGZ1bmN0aW9uIHVwZGF0ZVhEb21haW4odGFyZ2V0cywgd2l0aFVwZGF0ZVhEb21haW4sIHdpdGhVcGRhdGVPcmdYRG9tYWluLCB3aXRoVHJpbSwgZG9tYWluKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICB6b29tRW5hYmxlZCA9IGNvbmZpZy56b29tX2VuYWJsZWQ7XG5cbiAgICBpZiAod2l0aFVwZGF0ZU9yZ1hEb21haW4gJiYgKCQkLnguZG9tYWluKGRvbWFpbiB8fCBzb3J0VmFsdWUoJCQuZ2V0WERvbWFpbih0YXJnZXRzKSkpLCAkJC5vcmdYRG9tYWluID0gJCQueC5kb21haW4oKSwgem9vbUVuYWJsZWQgJiYgJCQuem9vbS51cGRhdGVTY2FsZUV4dGVudCgpLCAkJC5zdWJYLmRvbWFpbigkJC54LmRvbWFpbigpKSwgJCQuYnJ1c2ggJiYgJCQuYnJ1c2guc2NhbGUoJCQuc3ViWCkpLCB3aXRoVXBkYXRlWERvbWFpbikge1xuICAgICAgdmFyIGRvbWFpblZhbHVlID0gZG9tYWluIHx8ICEkJC5icnVzaCB8fCBicnVzaEVtcHR5KCQkKSA/ICQkLm9yZ1hEb21haW4gOiBnZXRCcnVzaFNlbGVjdGlvbigkJCkubWFwKCQkLnN1YlguaW52ZXJ0KTtcbiAgICAgICQkLnguZG9tYWluKGRvbWFpblZhbHVlKSwgem9vbUVuYWJsZWQgJiYgJCQuem9vbS51cGRhdGVTY2FsZUV4dGVudCgpO1xuICAgIH0gLy8gVHJpbSBkb21haW4gd2hlbiB0b28gYmlnIGJ5IHpvb20gbW91c2Vtb3ZlIGV2ZW50XG5cblxuICAgIHJldHVybiB3aXRoVHJpbSAmJiAkJC54LmRvbWFpbigkJC50cmltWERvbWFpbigkJC54Lm9yZ0RvbWFpbigpKSksICQkLnguZG9tYWluKCk7XG4gIH0sXG4gIHRyaW1YRG9tYWluOiBmdW5jdGlvbiB0cmltWERvbWFpbihkb21haW4pIHtcbiAgICB2YXIgem9vbURvbWFpbiA9IHRoaXMuZ2V0Wm9vbURvbWFpbigpLFxuICAgICAgICBfem9vbURvbWFpbiA9IF9zbGljZWRUb0FycmF5KHpvb21Eb21haW4sIDIpLFxuICAgICAgICBtaW4gPSBfem9vbURvbWFpblswXSxcbiAgICAgICAgbWF4ID0gX3pvb21Eb21haW5bMV07XG5cbiAgICByZXR1cm4gZG9tYWluWzBdIDw9IG1pbiAmJiAoZG9tYWluWzFdID0gK2RvbWFpblsxXSArIChtaW4gLSBkb21haW5bMF0pLCBkb21haW5bMF0gPSBtaW4pLCBtYXggPD0gZG9tYWluWzFdICYmIChkb21haW5bMF0gPSArZG9tYWluWzBdIC0gKGRvbWFpblsxXSAtIG1heCksIGRvbWFpblsxXSA9IG1heCksIGRvbWFpbjtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kYXRhL2RhdGEuanNcblxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICBpc1g6IGZ1bmN0aW9uIGlzWChrZXkpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGRhdGFLZXkgPSBjb25maWcuZGF0YV94ICYmIGtleSA9PT0gY29uZmlnLmRhdGFfeCxcbiAgICAgICAgZXhpc3RWYWx1ZSA9IG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSAmJiB1dGlsX2hhc1ZhbHVlKGNvbmZpZy5kYXRhX3hzLCBrZXkpO1xuICAgIHJldHVybiBkYXRhS2V5IHx8IGV4aXN0VmFsdWU7XG4gIH0sXG4gIGlzTm90WDogZnVuY3Rpb24gaXNOb3RYKGtleSkge1xuICAgIHJldHVybiAhdGhpcy5pc1goa2V5KTtcbiAgfSxcbiAgaXNTdGFja05vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGlzU3RhY2tOb3JtYWxpemVkKCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICByZXR1cm4gY29uZmlnLmRhdGFfc3RhY2tfbm9ybWFsaXplICYmIHRoaXMuaXNHcm91cGVkKCk7XG4gIH0sXG4gIGlzR3JvdXBlZDogZnVuY3Rpb24gaXNHcm91cGVkKGlkKSB7XG4gICAgdmFyIGdyb3VwcyA9IHRoaXMuY29uZmlnLmRhdGFfZ3JvdXBzO1xuICAgIHJldHVybiBpZCA/IGdyb3Vwcy5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdi5pbmRleE9mKGlkKSA+PSAwICYmIHYubGVuZ3RoID4gMTtcbiAgICB9KSA6IGdyb3Vwcy5sZW5ndGggPiAwO1xuICB9LFxuICBnZXRYS2V5OiBmdW5jdGlvbiBnZXRYS2V5KGlkKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgIHJldHVybiBjb25maWcuZGF0YV94ID8gY29uZmlnLmRhdGFfeCA6IG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSA/IGNvbmZpZy5kYXRhX3hzW2lkXSA6IG51bGw7XG4gIH0sXG4gIGdldFhWYWx1ZXNPZlhLZXk6IGZ1bmN0aW9uIGdldFhWYWx1ZXNPZlhLZXkoa2V5LCB0YXJnZXRzKSB7XG4gICAgdmFyIHhWYWx1ZXMsXG4gICAgICAgICQkID0gdGhpcyxcbiAgICAgICAgaWRzID0gdGFyZ2V0cyAmJiBub3RFbXB0eSh0YXJnZXRzKSA/ICQkLm1hcFRvSWRzKHRhcmdldHMpIDogW107XG4gICAgcmV0dXJuIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgJCQuZ2V0WEtleShpZCkgPT09IGtleSAmJiAoeFZhbHVlcyA9ICQkLmRhdGEueHNbaWRdKTtcbiAgICB9KSwgeFZhbHVlcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGluZGV4IG51bWJlciBiYXNlZCBvbiBnaXZlbiB4IEF4aXMgdmFsdWVcbiAgICogQHBhcmFtIHtEYXRlfE51bWJlcnxTdHJpbmd9IHggeCBBeGlzIHRvIGJlIGNvbXBhcmVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJhc2VkWCB4IEF4aXMgbGlzdCB0byBiZSBiYXNlZCBvblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGluZGV4IG51bWJlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SW5kZXhCeVg6IGZ1bmN0aW9uIGdldEluZGV4QnlYKHgsIGJhc2VkWCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgcmV0dXJuIGJhc2VkWCA/IGJhc2VkWC5pbmRleE9mKGlzU3RyaW5nKHgpID8geCA6ICt4KSA6ICgkJC5maWx0ZXJCeVgoJCQuZGF0YS50YXJnZXRzLCB4KVswXSB8fCB7XG4gICAgICBpbmRleDogbnVsbFxuICAgIH0pLmluZGV4O1xuICB9LFxuICBnZXRYVmFsdWU6IGZ1bmN0aW9uIGdldFhWYWx1ZShpZCwgaSkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgcmV0dXJuIGlkIGluICQkLmRhdGEueHMgJiYgJCQuZGF0YS54c1tpZF0gJiYgaXNWYWx1ZSgkJC5kYXRhLnhzW2lkXVtpXSkgPyAkJC5kYXRhLnhzW2lkXVtpXSA6IGk7XG4gIH0sXG4gIGdldE90aGVyVGFyZ2V0WHM6IGZ1bmN0aW9uIGdldE90aGVyVGFyZ2V0WHMoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgaWRzRm9yWCA9IE9iamVjdC5rZXlzKCQkLmRhdGEueHMpO1xuICAgIHJldHVybiBpZHNGb3JYLmxlbmd0aCA/ICQkLmRhdGEueHNbaWRzRm9yWFswXV0gOiBudWxsO1xuICB9LFxuICBnZXRPdGhlclRhcmdldFg6IGZ1bmN0aW9uIGdldE90aGVyVGFyZ2V0WChpbmRleCkge1xuICAgIHZhciB4cyA9IHRoaXMuZ2V0T3RoZXJUYXJnZXRYcygpO1xuICAgIHJldHVybiB4cyAmJiBpbmRleCA8IHhzLmxlbmd0aCA/IHhzW2luZGV4XSA6IG51bGw7XG4gIH0sXG4gIGFkZFhzOiBmdW5jdGlvbiBhZGRYcyh4cykge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoeHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAkJC5jb25maWcuZGF0YV94c1tpZF0gPSB4c1tpZF07XG4gICAgfSk7XG4gIH0sXG4gIGlzTXVsdGlwbGVYOiBmdW5jdGlvbiBpc011bHRpcGxlWCgpIHtcbiAgICByZXR1cm4gbm90RW1wdHkodGhpcy5jb25maWcuZGF0YV94cykgfHwgIXRoaXMuY29uZmlnLmRhdGFfeFNvcnQgfHwgdGhpcy5oYXNUeXBlKFwiYnViYmxlXCIpIHx8IHRoaXMuaGFzVHlwZShcInNjYXR0ZXJcIik7XG4gIH0sXG4gIGFkZE5hbWU6IGZ1bmN0aW9uIGFkZE5hbWUoZGF0YSkge1xuICAgIHZhciBuYW1lLFxuICAgICAgICAkJCA9IHRoaXM7XG4gICAgcmV0dXJuIGRhdGEgJiYgKG5hbWUgPSAkJC5jb25maWcuZGF0YV9uYW1lc1tkYXRhLmlkXSwgZGF0YS5uYW1lID0gbmFtZSA9PT0gdW5kZWZpbmVkID8gZGF0YS5pZCA6IG5hbWUpLCBkYXRhO1xuICB9LFxuICBnZXRBbGxWYWx1ZXNPbkluZGV4OiBmdW5jdGlvbiBnZXRBbGxWYWx1ZXNPbkluZGV4KGluZGV4KSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICByZXR1cm4gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICQkLmFkZE5hbWUoJCQuZ2V0VmFsdWVPbkluZGV4KHQudmFsdWVzLCBpbmRleCkpO1xuICAgIH0pO1xuICB9LFxuICBnZXRWYWx1ZU9uSW5kZXg6IGZ1bmN0aW9uIGdldFZhbHVlT25JbmRleCh2YWx1ZXMsIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlT25JbmRleCA9IHZhbHVlcy5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2LmluZGV4ID09PSBpbmRleDtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVPbkluZGV4Lmxlbmd0aCA/IHZhbHVlT25JbmRleFswXSA6IG51bGw7XG4gIH0sXG4gIHVwZGF0ZVRhcmdldFg6IGZ1bmN0aW9uIHVwZGF0ZVRhcmdldFgodGFyZ2V0cywgeCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgIHYueCA9ICQkLmdlbmVyYXRlVGFyZ2V0WCh4W2ldLCB0LmlkLCBpKTtcbiAgICAgIH0pLCAkJC5kYXRhLnhzW3QuaWRdID0geDtcbiAgICB9KTtcbiAgfSxcbiAgdXBkYXRlVGFyZ2V0WHM6IGZ1bmN0aW9uIHVwZGF0ZVRhcmdldFhzKHRhcmdldHMsIHhzKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHhzW3QuaWRdICYmICQkLnVwZGF0ZVRhcmdldFgoW3RdLCB4c1t0LmlkXSk7XG4gICAgfSk7XG4gIH0sXG4gIGdlbmVyYXRlVGFyZ2V0WDogZnVuY3Rpb24gZ2VuZXJhdGVUYXJnZXRYKHJhd1gsIGlkLCBpbmRleCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHggPSAkJC5pc0NhdGVnb3JpemVkKCkgPyBpbmRleCA6IHJhd1ggfHwgaW5kZXg7XG4gICAgcmV0dXJuICQkLmlzVGltZVNlcmllcygpID8geCA9IHJhd1ggPyAkJC5wYXJzZURhdGUocmF3WCkgOiAkJC5wYXJzZURhdGUoJCQuZ2V0WFZhbHVlKGlkLCBpbmRleCkpIDogJCQuaXNDdXN0b21YKCkgJiYgISQkLmlzQ2F0ZWdvcml6ZWQoKSAmJiAoeCA9IGlzVmFsdWUocmF3WCkgPyArcmF3WCA6ICQkLmdldFhWYWx1ZShpZCwgaW5kZXgpKSwgeDtcbiAgfSxcbiAgY2xvbmVUYXJnZXQ6IGZ1bmN0aW9uIGNsb25lVGFyZ2V0KHRhcmdldCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGFyZ2V0LmlkLFxuICAgICAgaWRfb3JnOiB0YXJnZXQuaWRfb3JnLFxuICAgICAgdmFsdWVzOiB0YXJnZXQudmFsdWVzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGQueCxcbiAgICAgICAgICB2YWx1ZTogZC52YWx1ZSxcbiAgICAgICAgICBpZDogZC5pZFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICB9LFxuICB1cGRhdGVYczogZnVuY3Rpb24gdXBkYXRlWHModmFsdWVzKSB7XG4gICAgdmFsdWVzLmxlbmd0aCAmJiAodGhpcy54cyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2Lng7XG4gICAgfSkpO1xuICB9LFxuICBnZXRQcmV2WDogZnVuY3Rpb24gZ2V0UHJldlgoaSkge1xuICAgIHZhciB4ID0gdGhpcy54c1tpIC0gMV07XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh4KSA/IHggOiBudWxsO1xuICB9LFxuICBnZXROZXh0WDogZnVuY3Rpb24gZ2V0TmV4dFgoaSkge1xuICAgIHZhciB4ID0gdGhpcy54c1tpICsgMV07XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh4KSA/IHggOiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYmFzZSB2YWx1ZSBpc0FyZWFSYW5nZVR5cGVcbiAgICogQHBhcmFtIGRhdGEgRGF0YSBvYmplY3RcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0QmFzZVZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlVmFsdWUoZGF0YSkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgJiYgKCQkLmlzQXJlYVJhbmdlVHlwZShkYXRhKSA/IHZhbHVlID0gJCQuZ2V0QXJlYVJhbmdlRGF0YShkYXRhLCBcIm1pZFwiKSA6ICQkLmlzQnViYmxlWlR5cGUoZGF0YSkgJiYgKHZhbHVlID0gJCQuZ2V0QnViYmxlWkRhdGEodmFsdWUsIFwieVwiKSkpLCB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IG1pbi9tYXggdmFsdWUgZnJvbSB0aGUgZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIGFycmF5IGRhdGEgdG8gYmUgZXZhbHVhdGVkXG4gICAqIEByZXR1cm4ge3ttaW46IHtOdW1iZXJ9LCBtYXg6IHtOdW1iZXJ9fX1cbiAgICovXG4gIGdldE1pbk1heFZhbHVlOiBmdW5jdGlvbiBnZXRNaW5NYXhWYWx1ZShkYXRhKSB7XG4gICAgdmFyIG1pbixcbiAgICAgICAgbWF4LFxuICAgICAgICBnZXRCYXNlVmFsdWUgPSB0aGlzLmdldEJhc2VWYWx1ZS5iaW5kKHRoaXMpO1xuICAgIHJldHVybiAoZGF0YSB8fCB0aGlzLmRhdGEudGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0LnZhbHVlcztcbiAgICB9KSkuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgdmFyIHZhbHVlID0gdi5tYXAoZ2V0QmFzZVZhbHVlKS5maWx0ZXIoaXNOdW1iZXIpO1xuICAgICAgbWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgW2kgPyBtaW4gOiBJbmZpbml0eV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh2YWx1ZSkpKSwgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgW2kgPyBtYXggOiAtSW5maW5pdHldLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmFsdWUpKSk7XG4gICAgfSksIHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXhcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbi9tYXggZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHt7bWluOiBBcnJheSwgbWF4OiBBcnJheX19XG4gICAqL1xuICBnZXRNaW5NYXhEYXRhOiBmdW5jdGlvbiBnZXRNaW5NYXhEYXRhKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNhY2hlS2V5ID0gXCIkbWluTWF4RGF0YVwiLFxuICAgICAgICBtaW5NYXhEYXRhID0gJCQuZ2V0Q2FjaGUoY2FjaGVLZXkpO1xuXG4gICAgaWYgKCFtaW5NYXhEYXRhKSB7XG4gICAgICB2YXIgZGF0YSA9ICQkLmRhdGEudGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWVzO1xuICAgICAgfSksXG4gICAgICAgICAgbWluTWF4ID0gJCQuZ2V0TWluTWF4VmFsdWUoZGF0YSksXG4gICAgICAgICAgbWluID0gW10sXG4gICAgICAgICAgbWF4ID0gW107XG4gICAgICAvLyB1cGRhdGUgdGhlIGNhY2hlZCBkYXRhXG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG1pbkRhdGEgPSAkJC5nZXRGaWx0ZXJlZERhdGFCeVZhbHVlKHYsIG1pbk1heC5taW4pLFxuICAgICAgICAgICAgbWF4RGF0YSA9ICQkLmdldEZpbHRlcmVkRGF0YUJ5VmFsdWUodiwgbWluTWF4Lm1heCk7XG4gICAgICAgIG1pbkRhdGEubGVuZ3RoICYmIChtaW4gPSBtaW4uY29uY2F0KG1pbkRhdGEpKSwgbWF4RGF0YS5sZW5ndGggJiYgKG1heCA9IG1heC5jb25jYXQobWF4RGF0YSkpO1xuICAgICAgfSksICQkLmFkZENhY2hlKGNhY2hlS2V5LCBtaW5NYXhEYXRhID0ge1xuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXhcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtaW5NYXhEYXRhO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgc3VtIG9mIGRhdGEgcGVyIGluZGV4XG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZ2V0VG90YWxQZXJJbmRleDogZnVuY3Rpb24gZ2V0VG90YWxQZXJJbmRleCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBzdW0gPSAkJC5nZXRDYWNoZShcIiR0b3RhbFBlckluZGV4XCIpO1xuICAgIHJldHVybiAkJC5pc1N0YWNrTm9ybWFsaXplZCgpICYmICFzdW0gJiYgKHN1bSA9IFtdLCAkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICByb3cudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgc3VtW2ldIHx8IChzdW1baV0gPSAwKSwgc3VtW2ldICs9IGlzTnVtYmVyKHYudmFsdWUpID8gdi52YWx1ZSA6IDA7XG4gICAgICB9KTtcbiAgICB9KSksIHN1bTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRvdGFsIGRhdGEgc3VtXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3VidHJhY3RIaWRkZW4gU3VidHJhY3QgaGlkZGVuIGRhdGEgZnJvbSB0b3RhbFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gIFx0ICogQHByaXZhdGVcbiAgICovXG4gIGdldFRvdGFsRGF0YVN1bTogZnVuY3Rpb24gZ2V0VG90YWxEYXRhU3VtKHN1YnRyYWN0SGlkZGVuKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY2FjaGVLZXkgPSBcIiR0b3RhbERhdGFTdW1cIixcbiAgICAgICAgdG90YWwgPSAkJC5nZXRDYWNoZShjYWNoZUtleSk7XG5cbiAgICBpZiAoIWlzTnVtYmVyKHRvdGFsKSkge1xuICAgICAgdmFyIHN1bSA9IG1lcmdlQXJyYXkoJCQuZGF0YS50YXJnZXRzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC52YWx1ZXM7XG4gICAgICB9KSkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2LnZhbHVlO1xuICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgICAgIHJldHVybiBwICsgYztcbiAgICAgIH0pO1xuICAgICAgJCQuYWRkQ2FjaGUoY2FjaGVLZXksIHRvdGFsID0gc3VtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VidHJhY3RIaWRkZW4gJiYgKHRvdGFsIC09ICQkLmdldEhpZGRlblRvdGFsRGF0YVN1bSgpKSwgdG90YWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0b3RhbCBoaWRkZW4gZGF0YSBzdW1cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICBcdCAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRIaWRkZW5Ub3RhbERhdGFTdW06IGZ1bmN0aW9uIGdldEhpZGRlblRvdGFsRGF0YVN1bSgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBhcGkgPSAkJC5hcGksXG4gICAgICAgIGhpZGRlblRhcmdldElkcyA9ICQkLmhpZGRlblRhcmdldElkcyxcbiAgICAgICAgdG90YWwgPSAwO1xuICAgIHJldHVybiBoaWRkZW5UYXJnZXRJZHMubGVuZ3RoICYmICh0b3RhbCA9IGFwaS5kYXRhLnZhbHVlcy5iaW5kKGFwaSkoaGlkZGVuVGFyZ2V0SWRzKS5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHtcbiAgICAgIHJldHVybiBwICsgYztcbiAgICB9KSksIHRvdGFsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgZmlsdGVyZWQgZGF0YSBieSB2YWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybiB7QXJyYXl9IGZpbHRlcmVkIGFycmF5IGRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEZpbHRlcmVkRGF0YUJ5VmFsdWU6IGZ1bmN0aW9uIGdldEZpbHRlcmVkRGF0YUJ5VmFsdWUoZGF0YSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGRhdGEuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0QmFzZVZhbHVlKHQpID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtYXggbGVuZ3RoIG9mIHRoZSBkYXRhXG4gICAqIEByZXR1cm4ge051bWJlcn0gbWF4IGRhdGEgbGVuZ3RoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXhEYXRhQ291bnQ6IGZ1bmN0aW9uIGdldE1heERhdGFDb3VudCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuZGF0YS50YXJnZXRzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQudmFsdWVzLmxlbmd0aDtcbiAgICB9KSkpO1xuICB9LFxuICBnZXRNYXhEYXRhQ291bnRUYXJnZXQ6IGZ1bmN0aW9uIGdldE1heERhdGFDb3VudFRhcmdldCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5maWx0ZXJUYXJnZXRzVG9TaG93KCkgfHwgW10sXG4gICAgICAgIGxlbmd0aCA9IHRhcmdldC5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA+IDEgPyAodGFyZ2V0ID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQudmFsdWVzO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgIH0pLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYueDtcbiAgICB9KSwgdGFyZ2V0ID0gc29ydFZhbHVlKGdldFVuaXF1ZSh0YXJnZXQpKS5tYXAoZnVuY3Rpb24gKHgsIGluZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgIH07XG4gICAgfSkpIDogbGVuZ3RoICYmICh0YXJnZXQgPSB0YXJnZXRbMF0udmFsdWVzKSwgdGFyZ2V0O1xuICB9LFxuICBtYXBUb0lkczogZnVuY3Rpb24gbWFwVG9JZHModGFyZ2V0cykge1xuICAgIHJldHVybiB0YXJnZXRzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuaWQ7XG4gICAgfSk7XG4gIH0sXG4gIG1hcFRvVGFyZ2V0SWRzOiBmdW5jdGlvbiBtYXBUb1RhcmdldElkcyhpZHMpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgIHJldHVybiBpZHMgPyBpc0FycmF5KGlkcykgPyBpZHMuY29uY2F0KCkgOiBbaWRzXSA6ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyk7XG4gIH0sXG4gIGhhc1RhcmdldDogZnVuY3Rpb24gaGFzVGFyZ2V0KHRhcmdldHMsIGlkKSB7XG4gICAgdmFyIGlkcyA9IHRoaXMubWFwVG9JZHModGFyZ2V0cyk7XG5cbiAgICBmb3IgKHZhciB2YWwsIGkgPSAwOyB2YWwgPSBpZHNbaV07IGkrKykgaWYgKHZhbCA9PT0gaWQpIHJldHVybiAhMDtcblxuICAgIHJldHVybiAhMTtcbiAgfSxcbiAgaXNUYXJnZXRUb1Nob3c6IGZ1bmN0aW9uIGlzVGFyZ2V0VG9TaG93KHRhcmdldElkKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlkZGVuVGFyZ2V0SWRzLmluZGV4T2YodGFyZ2V0SWQpIDwgMDtcbiAgfSxcbiAgaXNMZWdlbmRUb1Nob3c6IGZ1bmN0aW9uIGlzTGVnZW5kVG9TaG93KHRhcmdldElkKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlkZGVuTGVnZW5kSWRzLmluZGV4T2YodGFyZ2V0SWQpIDwgMDtcbiAgfSxcbiAgZmlsdGVyVGFyZ2V0c1RvU2hvdzogZnVuY3Rpb24gZmlsdGVyVGFyZ2V0c1RvU2hvdyh0YXJnZXRzKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICByZXR1cm4gKHRhcmdldHMgfHwgJCQuZGF0YS50YXJnZXRzKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAkJC5pc1RhcmdldFRvU2hvdyh0LmlkKTtcbiAgICB9KTtcbiAgfSxcbiAgbWFwVGFyZ2V0c1RvVW5pcXVlWHM6IGZ1bmN0aW9uIG1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICB4cyA9IFtdO1xuICAgIHJldHVybiB0YXJnZXRzICYmIHRhcmdldHMubGVuZ3RoICYmICh4cyA9IGdldFVuaXF1ZShtZXJnZUFycmF5KHRhcmdldHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC52YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiArdi54O1xuICAgICAgfSk7XG4gICAgfSkpKSwgeHMgPSAkJC5pc1RpbWVTZXJpZXMoKSA/IHhzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCt4KTtcbiAgICB9KSA6IHhzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuICt4O1xuICAgIH0pKSwgc29ydFZhbHVlKHhzKTtcbiAgfSxcbiAgYWRkSGlkZGVuVGFyZ2V0SWRzOiBmdW5jdGlvbiBhZGRIaWRkZW5UYXJnZXRJZHModGFyZ2V0SWRzKSB7XG4gICAgdGhpcy5oaWRkZW5UYXJnZXRJZHMgPSB0aGlzLmhpZGRlblRhcmdldElkcy5jb25jYXQodGFyZ2V0SWRzKTtcbiAgfSxcbiAgcmVtb3ZlSGlkZGVuVGFyZ2V0SWRzOiBmdW5jdGlvbiByZW1vdmVIaWRkZW5UYXJnZXRJZHModGFyZ2V0SWRzKSB7XG4gICAgdGhpcy5oaWRkZW5UYXJnZXRJZHMgPSB0aGlzLmhpZGRlblRhcmdldElkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMDtcbiAgICB9KTtcbiAgfSxcbiAgYWRkSGlkZGVuTGVnZW5kSWRzOiBmdW5jdGlvbiBhZGRIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKSB7XG4gICAgdGhpcy5oaWRkZW5MZWdlbmRJZHMgPSB0aGlzLmhpZGRlbkxlZ2VuZElkcy5jb25jYXQodGFyZ2V0SWRzKTtcbiAgfSxcbiAgcmVtb3ZlSGlkZGVuTGVnZW5kSWRzOiBmdW5jdGlvbiByZW1vdmVIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKSB7XG4gICAgdGhpcy5oaWRkZW5MZWdlbmRJZHMgPSB0aGlzLmhpZGRlbkxlZ2VuZElkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMDtcbiAgICB9KTtcbiAgfSxcbiAgZ2V0VmFsdWVzQXNJZEtleWVkOiBmdW5jdGlvbiBnZXRWYWx1ZXNBc0lkS2V5ZWQodGFyZ2V0cykge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHlzID0ge30sXG4gICAgICAgIGlzTXVsdGlwbGVYID0gJCQuaXNNdWx0aXBsZVgoKSxcbiAgICAgICAgeHMgPSBpc011bHRpcGxlWCA/ICQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIGlzU3RyaW5nKHYpID8gdiA6ICt2O1xuICAgIH0pIDogbnVsbDtcbiAgICByZXR1cm4gdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgdC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgdmFsdWUgPSB2LnZhbHVlO1xuICAgICAgICBpc0FycmF5KHZhbHVlKSA/IGRhdGEucHVzaC5hcHBseShkYXRhLCBfdG9Db25zdW1hYmxlQXJyYXkodmFsdWUpKSA6IGlzT2JqZWN0KHZhbHVlKSAmJiBcImhpZ2hcIiBpbiB2YWx1ZSA/IGRhdGEucHVzaC5hcHBseShkYXRhLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LnZhbHVlcyh2YWx1ZSkpKSA6ICQkLmlzQnViYmxlWlR5cGUodikgPyBkYXRhLnB1c2goJCQuZ2V0QnViYmxlWkRhdGEodmFsdWUsIFwieVwiKSkgOiBpc011bHRpcGxlWCA/IGRhdGFbJCQuZ2V0SW5kZXhCeVgodi54LCB4cyldID0gdmFsdWUgOiBkYXRhLnB1c2godmFsdWUpO1xuICAgICAgfSksIHlzW3QuaWRdID0gZGF0YTtcbiAgICB9KSwgeXM7XG4gIH0sXG4gIGNoZWNrVmFsdWVJblRhcmdldHM6IGZ1bmN0aW9uIGNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgY2hlY2tlcikge1xuICAgIHZhciB2YWx1ZXMsXG4gICAgICAgIGlkcyA9IE9iamVjdC5rZXlzKHRhcmdldHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlcyA9IHRhcmdldHNbaWRzW2ldXS52YWx1ZXM7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSBpZiAoY2hlY2tlcih2YWx1ZXNbal0udmFsdWUpKSByZXR1cm4gITA7XG4gICAgfVxuXG4gICAgcmV0dXJuICExO1xuICB9LFxuICBoYXNNdWx0aVRhcmdldHM6IGZ1bmN0aW9uIGhhc011bHRpVGFyZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJUYXJnZXRzVG9TaG93KCkubGVuZ3RoID4gMTtcbiAgfSxcbiAgaGFzTmVnYXRpdmVWYWx1ZUluVGFyZ2V0czogZnVuY3Rpb24gaGFzTmVnYXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzLCBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYgPCAwO1xuICAgIH0pO1xuICB9LFxuICBoYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzOiBmdW5jdGlvbiBoYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja1ZhbHVlSW5UYXJnZXRzKHRhcmdldHMsIGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdiA+IDA7XG4gICAgfSk7XG4gIH0sXG4gIF9jaGVja09yZGVyOiBmdW5jdGlvbiBfY2hlY2tPcmRlcih0eXBlKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBvcmRlciA9IGNvbmZpZy5kYXRhX29yZGVyO1xuICAgIHJldHVybiBpc1N0cmluZyhvcmRlcikgJiYgb3JkZXIudG9Mb3dlckNhc2UoKSA9PT0gdHlwZTtcbiAgfSxcbiAgaXNPcmRlckRlc2M6IGZ1bmN0aW9uIGlzT3JkZXJEZXNjKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGVja09yZGVyKFwiZGVzY1wiKTtcbiAgfSxcbiAgaXNPcmRlckFzYzogZnVuY3Rpb24gaXNPcmRlckFzYygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tPcmRlcihcImFzY1wiKTtcbiAgfSxcblxuICAvKipcbiAgICogU29ydCB0YXJnZXRzIGRhdGFcbiAgICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0c1ZhbHVlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb3JkZXJUYXJnZXRzOiBmdW5jdGlvbiBvcmRlclRhcmdldHModGFyZ2V0c1ZhbHVlKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICB0YXJnZXRzID0gX3RvQ29uc3VtYWJsZUFycmF5KHRhcmdldHNWYWx1ZSksXG4gICAgICAgIG9yZGVyQXNjID0gJCQuaXNPcmRlckFzYygpLFxuICAgICAgICBvcmRlckRlc2MgPSAkJC5pc09yZGVyRGVzYygpO1xuXG4gICAgLy8gVE9ETzogYWNjZXB0IG5hbWUgYXJyYXkgZm9yIG9yZGVyXG4gICAgcmV0dXJuIG9yZGVyQXNjIHx8IG9yZGVyRGVzYyA/IHRhcmdldHMuc29ydChmdW5jdGlvbiAodDEsIHQyKSB7XG4gICAgICB2YXIgcmVkdWNlciA9IGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgICAgIHJldHVybiBwICsgTWF0aC5hYnMoYy52YWx1ZSk7XG4gICAgICB9LFxuICAgICAgICAgIHQxU3VtID0gdDEudmFsdWVzLnJlZHVjZShyZWR1Y2VyLCAwKSxcbiAgICAgICAgICB0MlN1bSA9IHQyLnZhbHVlcy5yZWR1Y2UocmVkdWNlciwgMCk7XG5cbiAgICAgIHJldHVybiBvcmRlckFzYyA/IHQyU3VtIC0gdDFTdW0gOiB0MVN1bSAtIHQyU3VtO1xuICAgIH0pIDogaXNGdW5jdGlvbihjb25maWcuZGF0YV9vcmRlcikgJiYgdGFyZ2V0cy5zb3J0KGNvbmZpZy5kYXRhX29yZGVyKSwgdGFyZ2V0cztcbiAgfSxcbiAgZmlsdGVyQnlYOiBmdW5jdGlvbiBmaWx0ZXJCeVgodGFyZ2V0cywgeCkge1xuICAgIHJldHVybiBtZXJnZUFycmF5KHRhcmdldHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC52YWx1ZXM7XG4gICAgfSkpLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYueCAtIHggPT09IDA7XG4gICAgfSk7XG4gIH0sXG4gIGZpbHRlclJlbW92ZU51bGw6IGZ1bmN0aW9uIGZpbHRlclJlbW92ZU51bGwoZGF0YSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gaXNWYWx1ZShfdGhpczIuZ2V0QmFzZVZhbHVlKGQpKTtcbiAgICB9KTtcbiAgfSxcbiAgZmlsdGVyQnlYRG9tYWluOiBmdW5jdGlvbiBmaWx0ZXJCeVhEb21haW4odGFyZ2V0cywgeERvbWFpbikge1xuICAgIHJldHVybiB0YXJnZXRzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHQuaWQsXG4gICAgICAgIGlkX29yZzogdC5pZF9vcmcsXG4gICAgICAgIHZhbHVlczogdC52YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIHhEb21haW5bMF0gPD0gdi54ICYmIHYueCA8PSB4RG9tYWluWzFdO1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSxcbiAgaGFzRGF0YUxhYmVsOiBmdW5jdGlvbiBoYXNEYXRhTGFiZWwoKSB7XG4gICAgdmFyIGRhdGFMYWJlbHMgPSB0aGlzLmNvbmZpZy5kYXRhX2xhYmVscztcbiAgICByZXR1cm4gaXNCb29sZWFuKGRhdGFMYWJlbHMpICYmIGRhdGFMYWJlbHMgfHwgaXNPYmplY3RUeXBlKGRhdGFMYWJlbHMpICYmIG5vdEVtcHR5KGRhdGFMYWJlbHMpO1xuICB9LFxuICBnZXREYXRhTGFiZWxMZW5ndGg6IGZ1bmN0aW9uIGdldERhdGFMYWJlbExlbmd0aChtaW4sIG1heCwga2V5KSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgbGVuZ3RocyA9IFswLCAwXTtcbiAgICByZXR1cm4gJCQuc2VsZWN0Q2hhcnQuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdEFsbChcIi5kdW1teVwiKS5kYXRhKFttaW4sIG1heF0pLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKS50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gJCQuZGF0YUxhYmVsRm9ybWF0KGQuaWQpKGQpO1xuICAgIH0pLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIGxlbmd0aHNbaV0gPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2tleV0gKiAxLjM7XG4gICAgfSkucmVtb3ZlKCksIGxlbmd0aHM7XG4gIH0sXG4gIGlzTm9uZUFyYzogZnVuY3Rpb24gaXNOb25lQXJjKGQpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNUYXJnZXQodGhpcy5kYXRhLnRhcmdldHMsIGQuaWQpO1xuICB9LFxuICBpc0FyYzogZnVuY3Rpb24gaXNBcmMoZCkge1xuICAgIHJldHVybiBcImRhdGFcIiBpbiBkICYmIHRoaXMuaGFzVGFyZ2V0KHRoaXMuZGF0YS50YXJnZXRzLCBkLmRhdGEuaWQpO1xuICB9LFxuICBmaW5kU2FtZVhPZlZhbHVlczogZnVuY3Rpb24gZmluZFNhbWVYT2ZWYWx1ZXModmFsdWVzLCBpbmRleCkge1xuICAgIHZhciBpLFxuICAgICAgICB0YXJnZXRYID0gdmFsdWVzW2luZGV4XS54LFxuICAgICAgICBzYW1lcyA9IFtdO1xuXG4gICAgZm9yIChpID0gaW5kZXggLSAxOyBpID49IDAgJiYgISh0YXJnZXRYICE9PSB2YWx1ZXNbaV0ueCk7IGktLSkgc2FtZXMucHVzaCh2YWx1ZXNbaV0pO1xuXG4gICAgZm9yIChpID0gaW5kZXg7IGkgPCB2YWx1ZXMubGVuZ3RoICYmICEodGFyZ2V0WCAhPT0gdmFsdWVzW2ldLngpOyBpKyspIHNhbWVzLnB1c2godmFsdWVzW2ldKTtcblxuICAgIHJldHVybiBzYW1lcztcbiAgfSxcbiAgZmluZENsb3Nlc3RGcm9tVGFyZ2V0czogZnVuY3Rpb24gZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzLCBwb3MpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjYW5kaWRhdGVzID0gdGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgcmV0dXJuICQkLmZpbmRDbG9zZXN0KHRhcmdldC52YWx1ZXMsIHBvcyk7XG4gICAgfSk7XG4gICAgLy8gbWFwIHRvIGFycmF5IG9mIGNsb3Nlc3QgcG9pbnRzIG9mIGVhY2ggdGFyZ2V0XG4gICAgLy8gZGVjaWRlIGNsb3Nlc3QgcG9pbnQgYW5kIHJldHVyblxuICAgIHJldHVybiAkJC5maW5kQ2xvc2VzdChjYW5kaWRhdGVzLCBwb3MpO1xuICB9LFxuICBmaW5kQ2xvc2VzdDogZnVuY3Rpb24gZmluZENsb3Nlc3QodmFsdWVzLCBwb3MpIHtcbiAgICB2YXIgY2xvc2VzdCxcbiAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICBkYXRhID0gdmFsdWVzLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYgJiYgaXNWYWx1ZSh2LnZhbHVlKTtcbiAgICB9KSxcbiAgICAgICAgbWluRGlzdCA9ICQkLmNvbmZpZy5wb2ludF9zZW5zaXRpdml0eTtcbiAgICByZXR1cm4gZGF0YS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiAkJC5pc0JhclR5cGUodi5pZCk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgdmFyIHNoYXBlID0gJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmJhcnMpLmNvbmNhdCgkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh2LmlkKSwgXCIgLlwiKS5jb25jYXQoY29uZmlnX2NsYXNzZXMuYmFyLCBcIi1cIikuY29uY2F0KHYuaW5kZXgpKS5ub2RlKCk7XG4gICAgICAhY2xvc2VzdCAmJiAkJC5pc1dpdGhpbkJhcihzaGFwZSkgJiYgKGNsb3Nlc3QgPSB2KTtcbiAgICB9KSwgZGF0YS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiAhJCQuaXNCYXJUeXBlKHYuaWQpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIHZhciBkID0gJCQuZGlzdCh2LCBwb3MpO1xuICAgICAgZCA8IG1pbkRpc3QgJiYgKG1pbkRpc3QgPSBkLCBjbG9zZXN0ID0gdik7XG4gICAgfSksIGNsb3Nlc3Q7XG4gIH0sXG4gIGRpc3Q6IGZ1bmN0aW9uIGRpc3QoZGF0YSwgcG9zKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZCxcbiAgICAgICAgeEluZGV4ID0gaXNSb3RhdGVkID8gMSA6IDAsXG4gICAgICAgIHlJbmRleCA9IGlzUm90YXRlZCA/IDAgOiAxLFxuICAgICAgICB5ID0gJCQuY2lyY2xlWShkYXRhLCBkYXRhLmluZGV4KSxcbiAgICAgICAgeCA9ICgkJC56b29tU2NhbGUgfHwgJCQueCkoZGF0YS54KTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHggLSBwb3NbeEluZGV4XSwgMikgKyBNYXRoLnBvdyh5IC0gcG9zW3lJbmRleF0sIDIpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBkYXRhIGZvciBzdGVwIHR5cGVcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIE9iamVjdCBkYXRhIHZhbHVlc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnZlcnRWYWx1ZXNUb1N0ZXA6IGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkLFxuICAgICAgICBzdGVwVHlwZSA9IGNvbmZpZy5saW5lX3N0ZXBfdHlwZSxcbiAgICAgICAgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ2F0ZWdvcml6ZWQoKSxcbiAgICAgICAgY29udmVydGVkID0gaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzLmNvbmNhdCgpIDogW3ZhbHVlc107XG4gICAgaWYgKCFpc1JvdGF0ZWQgJiYgIWlzQ2F0ZWdvcml6ZWQpIHJldHVybiB2YWx1ZXM7IC8vIGluc2VydCAmIGFwcGVuZCBjbG9uaW5nIGZpcnN0L2xhc3QgdmFsdWUgdG8gYmUgZnVsbHkgcmVuZGVyZWQgY292ZXJpbmcgb24gZWFjaCBnYXAgc2lkZXNcblxuICAgIHZhciBpZCA9IGNvbnZlcnRlZFswXS5pZCxcbiAgICAgICAgeCA9IGNvbnZlcnRlZFswXS54IC0gMSxcbiAgICAgICAgdmFsdWUgPSBjb252ZXJ0ZWRbMF0udmFsdWU7IC8vIGluc2VydFxuXG4gICAgcmV0dXJuIGlzQ2F0ZWdvcml6ZWQgJiYgY29udmVydGVkLnVuc2hpZnQoe1xuICAgICAgeDogeCxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGlkOiBpZFxuICAgIH0pLCBzdGVwVHlwZSA9PT0gXCJzdGVwLWFmdGVyXCIgJiYgY29udmVydGVkLnVuc2hpZnQoe1xuICAgICAgeDogeCAtIDEsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBpZDogaWRcbiAgICB9KSwgeCA9IGNvbnZlcnRlZC5sZW5ndGggLSAxLCB2YWx1ZSA9IGNvbnZlcnRlZFt4XS52YWx1ZSwgaXNDYXRlZ29yaXplZCAmJiBjb252ZXJ0ZWQucHVzaCh7XG4gICAgICB4OiB4LFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgaWQ6IGlkXG4gICAgfSksIHN0ZXBUeXBlID09PSBcInN0ZXAtYmVmb3JlXCIgJiYgY29udmVydGVkLnB1c2goe1xuICAgICAgeDogeCArIDEsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBpZDogaWRcbiAgICB9KSwgY29udmVydGVkO1xuICB9LFxuICBjb252ZXJ0VmFsdWVzVG9SYW5nZTogZnVuY3Rpb24gY29udmVydFZhbHVlc1RvUmFuZ2UodmFsdWVzKSB7XG4gICAgdmFyIGNvbnZlcnRlZCA9IGlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcy5jb25jYXQoKSA6IFt2YWx1ZXNdLFxuICAgICAgICByYW5nZXMgPSBbXTtcbiAgICByZXR1cm4gY29udmVydGVkLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgeCA9IHJhbmdlLngsXG4gICAgICAgICAgaWQgPSByYW5nZS5pZDtcbiAgICAgIHJhbmdlcy5wdXNoKHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB2YWx1ZTogcmFuZ2UudmFsdWVbMF1cbiAgICAgIH0pLCByYW5nZXMucHVzaCh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgdmFsdWU6IHJhbmdlLnZhbHVlWzJdXG4gICAgICB9KTtcbiAgICB9KSwgcmFuZ2VzO1xuICB9LFxuICB1cGRhdGVEYXRhQXR0cmlidXRlczogZnVuY3Rpb24gdXBkYXRlRGF0YUF0dHJpYnV0ZXMobmFtZSwgYXR0cnMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGN1cnJlbnQgPSBjb25maWdbXCJkYXRhX1wiLmNvbmNhdChuYW1lKV07XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKGF0dHJzKSA/IGN1cnJlbnQgOiAoT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBjdXJyZW50W2lkXSA9IGF0dHJzW2lkXTtcbiAgICB9KSwgJCQucmVkcmF3KHtcbiAgICAgIHdpdGhMZWdlbmQ6ICEwXG4gICAgfSksIGN1cnJlbnQpO1xuICB9LFxuICBnZXRBcmVhUmFuZ2VEYXRhOiBmdW5jdGlvbiBnZXRBcmVhUmFuZ2VEYXRhKGQsIHR5cGUpIHtcbiAgICB2YXIgdmFsdWUgPSBkLnZhbHVlO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YXIgaW5kZXggPSBbXCJoaWdoXCIsIFwibWlkXCIsIFwibG93XCJdLmluZGV4T2YodHlwZSk7XG4gICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbnVsbCA6IHZhbHVlW2luZGV4XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVbdHlwZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCByYXRpbyB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBSYXRpbyBmb3IgZ2l2ZW4gdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIHZhbHVlIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFzUGVyY2VudCBDb252ZXJ0IHRoZSByZXR1cm4gYXMgcGVyY2VudCBvciBub3RcbiAgICogQHJldHVybiB7TnVtYmVyfSBSYXRpbyB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UmF0aW86IGZ1bmN0aW9uIGdldFJhdGlvKHR5cGUsIGQsIGFzUGVyY2VudCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgYXBpID0gJCQuYXBpLFxuICAgICAgICByYXRpbyA9IDA7XG4gICAgaWYgKGQgJiYgYXBpLmRhdGEuc2hvd24uY2FsbChhcGkpLmxlbmd0aCkgaWYgKHJhdGlvID0gZC5yYXRpbyB8fCBkLnZhbHVlLCB0eXBlID09PSBcImFyY1wiKSByYXRpbyA9ICQkLnBpZS5wYWRBbmdsZSgpKCkgPyBkLnZhbHVlIC8gJCQuZ2V0VG90YWxEYXRhU3VtKCEwKSA6IChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIChNYXRoLlBJICogKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAxIDogMikpO2Vsc2UgaWYgKHR5cGUgPT09IFwiaW5kZXhcIikge1xuICAgICAgdmFyIGRhdGFWYWx1ZXMgPSBhcGkuZGF0YS52YWx1ZXMuYmluZChhcGkpLFxuICAgICAgICAgIHRvdGFsID0gdGhpcy5nZXRUb3RhbFBlckluZGV4KCk7XG5cbiAgICAgIGlmICgkJC5oaWRkZW5UYXJnZXRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBoaWRkZW5TdW0gPSBkYXRhVmFsdWVzKCQkLmhpZGRlblRhcmdldElkcywgITEpO1xuICAgICAgICBoaWRkZW5TdW0ubGVuZ3RoICYmIChoaWRkZW5TdW0gPSBoaWRkZW5TdW0ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnIpIHtcbiAgICAgICAgICByZXR1cm4gYWNjLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc051bWJlcih2KSA/IHYgOiAwKSArIGN1cnJbaV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLCB0b3RhbCA9IHRvdGFsLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgIHJldHVybiB2IC0gaGlkZGVuU3VtW2ldO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGQucmF0aW8gPSBpc051bWJlcihkLnZhbHVlKSAmJiB0b3RhbCAmJiB0b3RhbFtkLmluZGV4XSA+IDAgPyBkLnZhbHVlIC8gdG90YWxbZC5pbmRleF0gOiAwLCByYXRpbyA9IGQucmF0aW87XG4gICAgfSBlbHNlIHR5cGUgPT09IFwicmFkYXJcIiAmJiAocmF0aW8gPSBwYXJzZUZsb2F0KE1hdGgubWF4KGQudmFsdWUsIDApKSAvICQkLm1heFZhbHVlICogY29uZmlnLnJhZGFyX3NpemVfcmF0aW8pO1xuICAgIHJldHVybiBhc1BlcmNlbnQgJiYgcmF0aW8gPyByYXRpbyAqIDEwMCA6IHJhdGlvO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTb3J0IGRhdGEgaW5kZXggdG8gYmUgYWxpZ25lZCB3aXRoIHggYXhpcy5cbiAgICogQHBhcmFtIHtBcnJheX0gdGlja1ZhbHVlcyBUaWNrIGFycmF5IHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlRGF0YUluZGV4QnlYOiBmdW5jdGlvbiB1cGRhdGVEYXRhSW5kZXhCeVgodGlja1ZhbHVlcykge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHRpY2tWYWx1ZU1hcCA9IHRpY2tWYWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChvdXQsIHRpY2ssIGluZGV4KSB7XG4gICAgICByZXR1cm4gb3V0Wyt0aWNrLnhdID0gaW5kZXgsIG91dDtcbiAgICB9LCB7fSk7XG4gICAgJCQuZGF0YS50YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCB2YWx1ZUluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRpY2tWYWx1ZU1hcFsrdmFsdWUueF07XG4gICAgICAgIGluZGV4ID09PSB1bmRlZmluZWQgJiYgKGluZGV4ID0gdmFsdWVJbmRleCksIHZhbHVlLmluZGV4ID0gaW5kZXg7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1kc3ZcIixcImNvbW1vbmpzMlwiOlwiZDMtZHN2XCIsXCJhbWRcIjpcImQzLWRzdlwiLFwicm9vdFwiOlwiZDNcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc19kM19kc3ZfY29tbW9uanMyX2QzX2Rzdl9hbWRfZDNfZHN2X3Jvb3RfZDNfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZGF0YS9kYXRhLmNvbnZlcnQuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5cbi8qKlxuICogQ29udmVydCBDU1YvVFNWIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZXIgUGFyc2VyIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IHhzdiBEYXRhXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbnZhciBjb252ZXJ0Q3N2VHN2VG9EYXRhID0gZnVuY3Rpb24gKHBhcnNlciwgeHN2KSB7XG4gIHZhciBkLFxuICAgICAgcm93cyA9IHBhcnNlci5yb3dzKHhzdik7XG4gIHJldHVybiByb3dzLmxlbmd0aCA9PT0gMSA/IChkID0gW3t9XSwgcm93c1swXS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIGRbMF1baWRdID0gbnVsbDtcbiAgfSkpIDogZCA9IHBhcnNlci5wYXJzZSh4c3YpLCBkO1xufTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWxfQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIENvbnZlcnQgZGF0YSBhY2NvcmRpbmcgaXRzIHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgZGF0YSBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmb3IgdXJsKFhIUikgdHlwZSBsb2FkaW5nXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnZlcnREYXRhOiBmdW5jdGlvbiBjb252ZXJ0RGF0YShhcmdzLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhLFxuICAgICAgICAkJCA9IHRoaXM7XG4gICAgaWYgKGFyZ3MuYmluZHRvID8gKGRhdGEgPSB7fSwgW1widXJsXCIsIFwibWltZVR5cGVcIiwgXCJoZWFkZXJzXCIsIFwia2V5c1wiLCBcImpzb25cIiwgXCJrZXlzXCIsIFwicm93c1wiLCBcImNvbHVtbnNcIl0uZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgdmFyIGtleSA9IFwiZGF0YV9cIi5jb25jYXQodik7XG4gICAgICBrZXkgaW4gYXJncyAmJiAoZGF0YVt2XSA9IGFyZ3Nba2V5XSk7XG4gICAgfSkpIDogZGF0YSA9IGFyZ3MsIGRhdGEudXJsICYmIGNhbGxiYWNrKSAkJC5jb252ZXJ0VXJsVG9EYXRhKGRhdGEudXJsLCBkYXRhLm1pbWVUeXBlLCBkYXRhLmhlYWRlcnMsIGRhdGEua2V5cywgY2FsbGJhY2spO2Vsc2UgaWYgKGRhdGEuanNvbikgZGF0YSA9ICQkLmNvbnZlcnRKc29uVG9EYXRhKGRhdGEuanNvbiwgZGF0YS5rZXlzKTtlbHNlIGlmIChkYXRhLnJvd3MpIGRhdGEgPSAkJC5jb252ZXJ0Um93c1RvRGF0YShkYXRhLnJvd3MpO2Vsc2UgaWYgKGRhdGEuY29sdW1ucykgZGF0YSA9ICQkLmNvbnZlcnRDb2x1bW5zVG9EYXRhKGRhdGEuY29sdW1ucyk7ZWxzZSBpZiAoYXJncy5iaW5kdG8pIHRocm93IEVycm9yKFwidXJsIG9yIGpzb24gb3Igcm93cyBvciBjb2x1bW5zIGlzIHJlcXVpcmVkLlwiKTtcbiAgICByZXR1cm4gaXNBcnJheShkYXRhKSAmJiBkYXRhO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IFVSTCBkYXRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgUmVtb3RlIFVSTFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgTUlNRSB0eXBlIHN0cmluZzoganNvbiB8IGNzdiB8IHRzdlxuICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVycyBIZWFkZXIgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBrZXlzIEtleSBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSBDYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udmVydFVybFRvRGF0YTogZnVuY3Rpb24gY29udmVydFVybFRvRGF0YSh1cmwpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBtaW1lVHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJjc3ZcIixcbiAgICAgICAgaGVhZGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLFxuICAgICAgICBrZXlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICByZXEub3BlbihcIkdFVFwiLCB1cmwpLCBoZWFkZXJzICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xuICAgIH0pLCByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSBpZiAocmVxLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IHJlcS5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc3BvbnNlICYmIGRvbmUuY2FsbChfdGhpcywgX3RoaXNbXCJjb252ZXJ0XCIuY29uY2F0KGNhcGl0YWxpemUobWltZVR5cGUpLCBcIlRvRGF0YVwiKV0obWltZVR5cGUgPT09IFwianNvblwiID8gSlNPTi5wYXJzZShyZXNwb25zZSkgOiByZXNwb25zZSwga2V5cykpO1xuICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdCh1cmwsIFwiOiBTb21ldGhpbmcgd2VudCB3cm9uZyBsb2FkaW5nIVwiKSk7XG4gICAgfSwgcmVxLnNlbmQoKTtcbiAgfSxcbiAgY29udmVydENzdlRvRGF0YTogZnVuY3Rpb24gY29udmVydENzdlRvRGF0YSh4c3YpIHtcbiAgICByZXR1cm4gY29udmVydENzdlRzdlRvRGF0YSh7XG4gICAgICByb3dzOiBleHRlcm5hbF9jb21tb25qc19kM19kc3ZfY29tbW9uanMyX2QzX2Rzdl9hbWRfZDNfZHN2X3Jvb3RfZDNfW1wiY3N2UGFyc2VSb3dzXCJdLFxuICAgICAgcGFyc2U6IGV4dGVybmFsX2NvbW1vbmpzX2QzX2Rzdl9jb21tb25qczJfZDNfZHN2X2FtZF9kM19kc3Zfcm9vdF9kM19bXCJjc3ZQYXJzZVwiXVxuICAgIH0sIHhzdik7XG4gIH0sXG4gIGNvbnZlcnRUc3ZUb0RhdGE6IGZ1bmN0aW9uIGNvbnZlcnRUc3ZUb0RhdGEodHN2KSB7XG4gICAgcmV0dXJuIGNvbnZlcnRDc3ZUc3ZUb0RhdGEoe1xuICAgICAgcm93czogZXh0ZXJuYWxfY29tbW9uanNfZDNfZHN2X2NvbW1vbmpzMl9kM19kc3ZfYW1kX2QzX2Rzdl9yb290X2QzX1tcInRzdlBhcnNlUm93c1wiXSxcbiAgICAgIHBhcnNlOiBleHRlcm5hbF9jb21tb25qc19kM19kc3ZfY29tbW9uanMyX2QzX2Rzdl9hbWRfZDNfZHN2X3Jvb3RfZDNfW1widHN2UGFyc2VcIl1cbiAgICB9LCB0c3YpO1xuICB9LFxuICBjb252ZXJ0SnNvblRvRGF0YTogZnVuY3Rpb24gY29udmVydEpzb25Ub0RhdGEoanNvbiwga2V5c1BhcmFtKSB7XG4gICAgdmFyIHRhcmdldEtleXMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIF90aGlzMiA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBuZXdSb3dzID0gW107XG5cbiAgICBpZiAoaXNBcnJheShqc29uKSkge1xuICAgICAgdmFyIGtleXMgPSBrZXlzUGFyYW0gfHwgY29uZmlnLmRhdGFfa2V5cztcbiAgICAgIGtleXMueCA/ICh0YXJnZXRLZXlzID0ga2V5cy52YWx1ZS5jb25jYXQoa2V5cy54KSwgY29uZmlnLmRhdGFfeCA9IGtleXMueCkgOiB0YXJnZXRLZXlzID0ga2V5cy52YWx1ZSwgbmV3Um93cy5wdXNoKHRhcmdldEtleXMpLCBqc29uLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIG5ld1JvdyA9IHRhcmdldEtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAvLyBjb252ZXJ0IHVuZGVmaW5lZCB0byBudWxsIGJlY2F1c2UgdW5kZWZpbmVkIGRhdGEgd2lsbCBiZSByZW1vdmVkIGluIGNvbnZlcnREYXRhVG9UYXJnZXRzKClcbiAgICAgICAgICB2YXIgdiA9IF90aGlzMi5maW5kVmFsdWVJbkpzb24obywga2V5KTtcblxuICAgICAgICAgIHJldHVybiBpc1VuZGVmaW5lZCh2KSAmJiAodiA9IG51bGwpLCB2O1xuICAgICAgICB9KTtcbiAgICAgICAgbmV3Um93cy5wdXNoKG5ld1Jvdyk7XG4gICAgICB9KSwgZGF0YSA9IHRoaXMuY29udmVydFJvd3NUb0RhdGEobmV3Um93cyk7XG4gICAgfSBlbHNlIE9iamVjdC5rZXlzKGpzb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHRtcCA9IGpzb25ba2V5XS5jb25jYXQoKTtcbiAgICAgIHRtcC51bnNoaWZ0KGtleSksIG5ld1Jvd3MucHVzaCh0bXApO1xuICAgIH0pLCBkYXRhID0gdGhpcy5jb252ZXJ0Q29sdW1uc1RvRGF0YShuZXdSb3dzKTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuICBmaW5kVmFsdWVJbkpzb246IGZ1bmN0aW9uIGZpbmRWYWx1ZUluSnNvbihvYmplY3QsIHBhdGgpIHtcbiAgICBpZiAob2JqZWN0W3BhdGhdICE9PSB1bmRlZmluZWQpIHJldHVybiBvYmplY3RbcGF0aF07XG4gICAgdmFyIGNvbnZlcnRlZFBhdGggPSBwYXRoLnJlcGxhY2UoL1xcWyhcXHcrKVxcXS9nLCBcIi4kMVwiKSxcbiAgICAgICAgcGF0aEFycmF5ID0gY29udmVydGVkUGF0aC5yZXBsYWNlKC9eXFwuLywgXCJcIikuc3BsaXQoXCIuXCIpLFxuICAgICAgICB0YXJnZXQgPSBvYmplY3Q7IC8vIGNvbnZlcnQgaW5kZXhlcyB0byBwcm9wZXJ0aWVzIChyZXBsYWNlIFtdIHdpdGggLilcblxuICAgIHJldHVybiBwYXRoQXJyYXkuc29tZShmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuICEodGFyZ2V0ID0gdGFyZ2V0ICYmIGsgaW4gdGFyZ2V0ID8gdGFyZ2V0W2tdIDogdW5kZWZpbmVkKTtcbiAgICB9KSwgdGFyZ2V0O1xuICB9LFxuICBjb252ZXJ0Um93c1RvRGF0YTogZnVuY3Rpb24gY29udmVydFJvd3NUb0RhdGEocm93cykge1xuICAgIHZhciBrZXlzID0gcm93c1swXSxcbiAgICAgICAgbmV3Um93cyA9IFtdO1xuICAgIHJldHVybiByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdywgaSkge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHZhciBuZXdSb3cgPSB7fTtcbiAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24gKHYsIGopIHtcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodikpIHRocm93IG5ldyBFcnJvcihcIlNvdXJjZSBkYXRhIGlzIG1pc3NpbmcgYSBjb21wb25lbnQgYXQgKFwiLmNvbmNhdChpLCBcIiwgXCIpLmNvbmNhdChqLCBcIikhXCIpKTtcbiAgICAgICAgICBuZXdSb3dba2V5c1tqXV0gPSB2O1xuICAgICAgICB9KSwgbmV3Um93cy5wdXNoKG5ld1Jvdyk7XG4gICAgICB9XG4gICAgfSksIG5ld1Jvd3M7XG4gIH0sXG4gIGNvbnZlcnRDb2x1bW5zVG9EYXRhOiBmdW5jdGlvbiBjb252ZXJ0Q29sdW1uc1RvRGF0YShjb2x1bW5zKSB7XG4gICAgdmFyIG5ld1Jvd3MgPSBbXTtcbiAgICByZXR1cm4gY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2wsIGkpIHtcbiAgICAgIHZhciBrZXkgPSBjb2xbMF07XG4gICAgICBjb2wuZm9yRWFjaChmdW5jdGlvbiAodiwgaikge1xuICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQobmV3Um93c1tqIC0gMV0pICYmIChuZXdSb3dzW2ogLSAxXSA9IHt9KSwgaXNVbmRlZmluZWQodikpIHRocm93IG5ldyBFcnJvcihcIlNvdXJjZSBkYXRhIGlzIG1pc3NpbmcgYSBjb21wb25lbnQgYXQgKFwiLmNvbmNhdChpLCBcIiwgXCIpLmNvbmNhdChqLCBcIikhXCIpKTtcbiAgICAgICAgICBuZXdSb3dzW2ogLSAxXVtrZXldID0gdjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksIG5ld1Jvd3M7XG4gIH0sXG4gIGNvbnZlcnREYXRhVG9UYXJnZXRzOiBmdW5jdGlvbiBjb252ZXJ0RGF0YVRvVGFyZ2V0cyhkYXRhLCBhcHBlbmRYcykge1xuICAgIHZhciB4c0RhdGEsXG4gICAgICAgIF90aGlzMyA9IHRoaXMsXG4gICAgICAgICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBpc1RpbWVTZXJpZXMgPSAkJC5pc1RpbWVTZXJpZXMoKSxcbiAgICAgICAgZGF0YUtleXMgPSBPYmplY3Qua2V5cyhkYXRhWzBdIHx8IHt9KSxcbiAgICAgICAgaWRzID0gZGF0YUtleXMubGVuZ3RoID8gZGF0YUtleXMuZmlsdGVyKCQkLmlzTm90WCwgJCQpIDogW10sXG4gICAgICAgIHhzID0gZGF0YUtleXMubGVuZ3RoID8gZGF0YUtleXMuZmlsdGVyKCQkLmlzWCwgJCQpIDogW107XG5cbiAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHZhciB4S2V5ID0gX3RoaXMzLmdldFhLZXkoaWQpO1xuXG4gICAgICBfdGhpczMuaXNDdXN0b21YKCkgfHwgaXNUaW1lU2VyaWVzID8geHMuaW5kZXhPZih4S2V5KSA+PSAwID8geHNEYXRhID0gKGFwcGVuZFhzICYmICQkLmRhdGEueHNbaWRdIHx8IFtdKS5jb25jYXQoZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRbeEtleV07XG4gICAgICB9KS5maWx0ZXIoaXNWYWx1ZSkubWFwKGZ1bmN0aW9uIChyYXdYLCBpKSB7XG4gICAgICAgIHJldHVybiAkJC5nZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQsIGkpO1xuICAgICAgfSkpIDogY29uZmlnLmRhdGFfeCA/IHhzRGF0YSA9IF90aGlzMy5nZXRPdGhlclRhcmdldFhzKCkgOiBub3RFbXB0eShjb25maWcuZGF0YV94cykgJiYgKHhzRGF0YSA9ICQkLmdldFhWYWx1ZXNPZlhLZXkoeEtleSwgJCQuZGF0YS50YXJnZXRzKSkgOiB4c0RhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0pLCB4c0RhdGEgJiYgKF90aGlzMy5kYXRhLnhzW2lkXSA9IHhzRGF0YSk7XG4gICAgfSksIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgaWYgKCFfdGhpczMuZGF0YS54c1tpZF0pIHRocm93IG5ldyBFcnJvcihcInggaXMgbm90IGRlZmluZWQgZm9yIGlkID0gXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiLlwiKSk7XG4gICAgfSk7XG4gICAgLy8gY29udmVydCB0byB0YXJnZXRcbiAgICB2YXIgdGFyZ2V0cyA9IGlkcy5tYXAoZnVuY3Rpb24gKGlkLCBpbmRleCkge1xuICAgICAgdmFyIGNvbnZlcnRlZElkID0gY29uZmlnLmRhdGFfaWRDb252ZXJ0ZXIoaWQpLFxuICAgICAgICAgIHhLZXkgPSAkJC5nZXRYS2V5KGlkKSxcbiAgICAgICAgICBpc0NhdGVnb3JpemVkID0gJCQuaXNDdXN0b21YKCkgJiYgJCQuaXNDYXRlZ29yaXplZCgpLFxuICAgICAgICAgIGhhc0NhdGVnb3J5ID0gaXNDYXRlZ29yaXplZCAmJiBkYXRhLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi54O1xuICAgICAgfSkuZXZlcnkoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5pbmRleE9mKHYpID4gLTE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBjb252ZXJ0ZWRJZCxcbiAgICAgICAgaWRfb3JnOiBpZCxcbiAgICAgICAgdmFsdWVzOiBkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHZhciB4LFxuICAgICAgICAgICAgICByYXdYID0gZFt4S2V5XSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBkW2lkXTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPSB2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpID8gaXNBcnJheSh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBudWxsIDogK3ZhbHVlLCBpc0NhdGVnb3JpemVkICYmIGluZGV4ID09PSAwICYmICFpc1VuZGVmaW5lZChyYXdYKSA/ICghaGFzQ2F0ZWdvcnkgJiYgaW5kZXggPT09IDAgJiYgaSA9PT0gMCAmJiAoY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gW10pLCB4ID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YocmF3WCksIHggPT09IC0xICYmICh4ID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aCwgY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLnB1c2gocmF3WCkpKSA6IHggPSAkJC5nZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQsIGkpLCAoaXNVbmRlZmluZWQodmFsdWUpIHx8ICQkLmRhdGEueHNbaWRdLmxlbmd0aCA8PSBpKSAmJiAoeCA9IHVuZGVmaW5lZCksIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBpZDogY29udmVydGVkSWRcbiAgICAgICAgICB9O1xuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gaXNEZWZpbmVkKHYueCk7XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pOyAvLyBmaW5pc2ggdGFyZ2V0c1xuXG4gICAgcmV0dXJuIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgY29uZmlnLmRhdGFfeFNvcnQgJiYgKHQudmFsdWVzID0gdC52YWx1ZXMuc29ydChmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgIHZhciB4MSA9IHYxLnggfHwgdjEueCA9PT0gMCA/IHYxLnggOiBJbmZpbml0eSxcbiAgICAgICAgICAgIHgyID0gdjIueCB8fCB2Mi54ID09PSAwID8gdjIueCA6IEluZmluaXR5O1xuICAgICAgICByZXR1cm4geDEgLSB4MjtcbiAgICAgIH0pKSwgdC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICByZXR1cm4gdi5pbmRleCA9IGk7XG4gICAgICB9KSwgJCQuZGF0YS54c1t0LmlkXS5zb3J0KGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgcmV0dXJuIHYxIC0gdjI7XG4gICAgICB9KTtcbiAgICB9KSwgJCQuaGFzTmVnYXRpdmVWYWx1ZSA9ICQkLmhhc05lZ2F0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cyksICQkLmhhc1Bvc2l0aXZlVmFsdWUgPSAkJC5oYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpLCBjb25maWcuZGF0YV90eXBlICYmICQkLnNldFRhcmdldFR5cGUoJCQubWFwVG9JZHModGFyZ2V0cykuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuICEoaWQgaW4gY29uZmlnLmRhdGFfdHlwZXMpO1xuICAgIH0pLCBjb25maWcuZGF0YV90eXBlKSwgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gJCQuYWRkQ2FjaGUoZC5pZF9vcmcsIGQsICEwKTtcbiAgICB9KSwgdGFyZ2V0cztcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kYXRhL2RhdGEubG9hZC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWxfQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcbiAgbG9hZDogZnVuY3Rpb24gbG9hZChyYXdUYXJnZXRzLCBhcmdzKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgdGFyZ2V0cyA9IHJhd1RhcmdldHM7XG4gICAgLy8gU2V0IHRhcmdldHNcbiAgICAvLyBSZWRyYXcgd2l0aCBuZXcgdGFyZ2V0c1xuICAgIHRhcmdldHMgJiYgKGFyZ3MuZmlsdGVyICYmICh0YXJnZXRzID0gdGFyZ2V0cy5maWx0ZXIoYXJncy5maWx0ZXIpKSwgKGFyZ3MudHlwZSB8fCBhcmdzLnR5cGVzKSAmJiB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlcyAmJiBhcmdzLnR5cGVzW3QuaWRdIHx8IGFyZ3MudHlwZTtcbiAgICAgICQkLnNldFRhcmdldFR5cGUodC5pZCwgdHlwZSk7XG4gICAgfSksICQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIGlmIChkLmlkID09PSB0YXJnZXRzW2ldLmlkKSB7XG4gICAgICAgIGQudmFsdWVzID0gdGFyZ2V0c1tpXS52YWx1ZXMsIHRhcmdldHMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KSwgJCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmNvbmNhdCh0YXJnZXRzKSksICQkLnVwZGF0ZVRhcmdldHMoJCQuZGF0YS50YXJnZXRzKSwgJCQucmVkcmF3KHtcbiAgICAgIHdpdGhVcGRhdGVPcmdYRG9tYWluOiAhMCxcbiAgICAgIHdpdGhVcGRhdGVYRG9tYWluOiAhMCxcbiAgICAgIHdpdGhMZWdlbmQ6ICEwXG4gICAgfSksIGFyZ3MuZG9uZSAmJiBhcmdzLmRvbmUoKTtcbiAgfSxcbiAgbG9hZEZyb21BcmdzOiBmdW5jdGlvbiBsb2FkRnJvbUFyZ3MoYXJncykge1xuICAgIHZhciAkJCA9IHRoaXM7IC8vIHByZXZlbnQgbG9hZCB3aGVuIGNoYXJ0IGlzIGFscmVhZHkgZGVzdHJveWVkXG5cbiAgICBpZiAoJCQuY29uZmlnKSB7XG4gICAgICAkJC5yZXNldENhY2hlKCk7XG4gICAgICB2YXIgZGF0YSA9IGFyZ3MuZGF0YSB8fCAkJC5jb252ZXJ0RGF0YShhcmdzLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gJCQubG9hZCgkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cyhkKSwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIGRhdGEgJiYgJCQubG9hZCgkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cyhkYXRhKSwgYXJncyk7XG4gICAgfSAvLyByZXNldCBpbnRlcm5hbGx5IGNhY2hlZCBkYXRhXG5cbiAgfSxcbiAgdW5sb2FkOiBmdW5jdGlvbiB1bmxvYWQocmF3VGFyZ2V0SWRzLCBjdXN0b21Eb25lQ2IpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBkb25lID0gY3VzdG9tRG9uZUNiLFxuICAgICAgICB0YXJnZXRJZHMgPSByYXdUYXJnZXRJZHM7XG4gICAgLy8gSWYgbm8gdGFyZ2V0LCBjYWxsIGRvbmUgYW5kIHJldHVyblxuICAgIHJldHVybiAkJC5yZXNldENhY2hlKCksIGRvbmUgfHwgKGRvbmUgPSBmdW5jdGlvbiAoKSB7fSksIHRhcmdldElkcyA9IHRhcmdldElkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gJCQuaGFzVGFyZ2V0KCQkLmRhdGEudGFyZ2V0cywgaWQpO1xuICAgIH0pLCB0YXJnZXRJZHMgJiYgdGFyZ2V0SWRzLmxlbmd0aCAhPT0gMCA/IHZvaWQgKCQkLnN2Zy5zZWxlY3RBbGwodGFyZ2V0SWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiAkJC5zZWxlY3RvclRhcmdldChpZCk7XG4gICAgfSkpLnRyYW5zaXRpb24oKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLnJlbW92ZSgpLmNhbGwoJCQuZW5kYWxsLCBkb25lKSwgdGFyZ2V0SWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAkJC53aXRob3V0RmFkZUluW2lkXSA9ICExLCAkJC5sZWdlbmQgJiYgJCQubGVnZW5kLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMubGVnZW5kSXRlbSkuY29uY2F0KCQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKSkpLnJlbW92ZSgpLCAkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlkICE9PSBpZDtcbiAgICAgIH0pO1xuICAgIH0pKSA6IHZvaWQgZG9uZSgpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ludGVybmFscy9jYXRlZ29yeS5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBDYXRlZ29yeSBOYW1lXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBnYXRlZ29yeSBOYW1lXG4gICAqL1xuICBjYXRlZ29yeU5hbWU6IGZ1bmN0aW9uIGNhdGVnb3J5TmFtZShpKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIHJldHVybiBpIDwgY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aCA/IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllc1tpXSA6IGk7XG4gIH1cbn0pO1xuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZHJhZ1wiLFwiY29tbW9uanMyXCI6XCJkMy1kcmFnXCIsXCJhbWRcIjpcImQzLWRyYWdcIixcInJvb3RcIjpcImQzXCJ9XG52YXIgZXh0ZXJuYWxfY29tbW9uanNfZDNfZHJhZ19jb21tb25qczJfZDNfZHJhZ19hbWRfZDNfZHJhZ19yb290X2QzXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvbi5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuXG5cblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWxfQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGFyZWEgdGhhdCBkZXRlY3RzIHRoZSBldmVudC5cbiAgICogQWRkIGEgY29udGFpbmVyIGZvciB0aGUgem9uZSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdEV2ZW50UmVjdDogZnVuY3Rpb24gaW5pdEV2ZW50UmVjdCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgICQkLm1haW4uc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaGFydCkpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLmV2ZW50UmVjdHMpLnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVkcmF3cyB0aGUgYXJlYSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVkcmF3RXZlbnRSZWN0OiBmdW5jdGlvbiByZWRyYXdFdmVudFJlY3QoKSB7XG4gICAgdmFyIGV2ZW50UmVjdFVwZGF0ZSxcbiAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGlzTXVsdGlwbGVYID0gJCQuaXNNdWx0aXBsZVgoKSxcbiAgICAgICAgem9vbUVuYWJsZWQgPSBjb25maWcuem9vbV9lbmFibGVkLFxuICAgICAgICBldmVudFJlY3RzID0gJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmV2ZW50UmVjdHMpKS5zdHlsZShcImN1cnNvclwiLCB6b29tRW5hYmxlZCAmJiB6b29tRW5hYmxlZC50eXBlICE9PSBcImRyYWdcIiA/IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIm5zLXJlc2l6ZVwiIDogXCJldy1yZXNpemVcIiA6IG51bGwpLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuZXZlbnRSZWN0c011bHRpcGxlLCBpc011bHRpcGxlWCkuY2xhc3NlZChjb25maWdfY2xhc3Nlcy5ldmVudFJlY3RzU2luZ2xlLCAhaXNNdWx0aXBsZVgpO1xuICAgIGlmIChldmVudFJlY3RzLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuZXZlbnRSZWN0KSkucmVtb3ZlKCksICQkLmV2ZW50UmVjdCA9IGV2ZW50UmVjdHMuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5ldmVudFJlY3QpKSwgaXNNdWx0aXBsZVgpIGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmV2ZW50UmVjdC5kYXRhKFswXSksIGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmdlbmVyYXRlRXZlbnRSZWN0c0Zvck11bHRpcGxlWHMoZXZlbnRSZWN0VXBkYXRlLmVudGVyKCkpLm1lcmdlKGV2ZW50UmVjdFVwZGF0ZSk7ZWxzZSB7XG4gICAgICAvLyBTZXQgZGF0YSBhbmQgdXBkYXRlICQkLmV2ZW50UmVjdFxuICAgICAgdmFyIHhBeGlzVGlja1ZhbHVlcyA9ICQkLmdldE1heERhdGFDb3VudFRhcmdldCgpOyAvLyB1cGRhdGUgZGF0YSdzIGluZGV4IHZhbHVlIHRvIGJlIGFsaW5nZWQgd2l0aCB0aGUgeCBBeGlzXG5cbiAgICAgICQkLnVwZGF0ZURhdGFJbmRleEJ5WCh4QXhpc1RpY2tWYWx1ZXMpLCAkJC51cGRhdGVYcyh4QXhpc1RpY2tWYWx1ZXMpLCAkJC51cGRhdGVQb2ludENsYXNzKCEwKSwgZXZlbnRSZWN0cy5kYXR1bSh4QXhpc1RpY2tWYWx1ZXMpLCAkJC5ldmVudFJlY3QgPSBldmVudFJlY3RzLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuZXZlbnRSZWN0KSksIGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmV2ZW50UmVjdC5kYXRhKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfSksIGV2ZW50UmVjdFVwZGF0ZS5leGl0KCkucmVtb3ZlKCksIGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmdlbmVyYXRlRXZlbnRSZWN0c0ZvclNpbmdsZVgoZXZlbnRSZWN0VXBkYXRlLmVudGVyKCkpLm1lcmdlKGV2ZW50UmVjdFVwZGF0ZSk7XG4gICAgfVxuICAgICQkLmV2ZW50UmVjdCA9IGV2ZW50UmVjdFVwZGF0ZSwgJCQudXBkYXRlRXZlbnRSZWN0KGV2ZW50UmVjdFVwZGF0ZSksICQkLmlucHV0VHlwZSAhPT0gXCJ0b3VjaFwiIHx8ICQkLnN2Zy5vbihcInRvdWNoc3RhcnQuZXZlbnRSZWN0XCIpIHx8ICQkLmhhc0FyY1R5cGUoKSB8fCAkJC5iaW5kVG91Y2hPbkV2ZW50UmVjdChpc011bHRpcGxlWCk7XG4gIH0sXG4gIGJpbmRUb3VjaE9uRXZlbnRSZWN0OiBmdW5jdGlvbiBiaW5kVG91Y2hPbkV2ZW50UmVjdChpc011bHRpcGxlWCkge1xuICAgIHZhciBzdGFydFB4LFxuICAgICAgICAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgZ2V0RXZlbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRvdWNoID0gZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcImV2ZW50XCJdLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgcmV0dXJuIE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKShicm93c2VyX2RvYy5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpKTtcbiAgICB9LFxuICAgICAgICBnZXRJbmRleCA9IGZ1bmN0aW9uIChldmVudFJlY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IGV2ZW50UmVjdCAmJiBldmVudFJlY3QuYXR0cihcImNsYXNzXCIpICYmIGV2ZW50UmVjdC5hdHRyKFwiY2xhc3NcIikucmVwbGFjZShuZXcgUmVnRXhwKFwiKFwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5ldmVudFJlY3QsIFwiLT98cylcIiksIFwiZ1wiKSwgXCJcIikgKiAxO1xuICAgICAgcmV0dXJuIChpc05hTihpbmRleCkgfHwgaW5kZXggPT09IG51bGwpICYmIChpbmRleCA9IC0xKSwgaW5kZXg7XG4gICAgfSxcbiAgICAgICAgc2VsZWN0UmVjdCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBpZiAoaXNNdWx0aXBsZVgpICQkLnNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKGNvbnRleHQpO2Vsc2Uge1xuICAgICAgICB2YXIgZXZlbnRSZWN0ID0gZ2V0RXZlbnRSZWN0KCksXG4gICAgICAgICAgICBpbmRleCA9IGdldEluZGV4KGV2ZW50UmVjdCk7XG4gICAgICAgICQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goaW5kZXgpLCBpbmRleCA9PT0gLTEgPyAkJC51bnNlbGVjdFJlY3QoKSA6ICQkLnNlbGVjdFJlY3RGb3JTaW5nbGUoY29udGV4dCwgZXZlbnRSZWN0LCBpbmRleCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgcHJldmVudERlZmF1bHQgPSBjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoLnByZXZlbnREZWZhdWx0LFxuICAgICAgICBpc1ByZXZlbnRlZCA9IGlzQm9vbGVhbihwcmV2ZW50RGVmYXVsdCkgJiYgcHJldmVudERlZmF1bHQgfHwgITEsXG4gICAgICAgIHByZXZlbnRUaHJlc2hvbGQgPSAhaXNOYU4ocHJldmVudERlZmF1bHQpICYmIHByZXZlbnREZWZhdWx0IHx8IG51bGwsXG4gICAgICAgIHByZXZlbnRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IGV2ZW50LnR5cGUsXG4gICAgICAgICAgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSxcbiAgICAgICAgICBjdXJyZW50WFkgPSB0b3VjaFtcImNsaWVudFwiLmNvbmNhdChjb25maWcuYXhpc19yb3RhdGVkID8gXCJZXCIgOiBcIlhcIildO1xuICAgICAgZXZlbnRUeXBlID09PSBcInRvdWNoc3RhcnRcIiA/IGlzUHJldmVudGVkID8gZXZlbnQucHJldmVudERlZmF1bHQoKSA6IHByZXZlbnRUaHJlc2hvbGQgIT09IG51bGwgJiYgKHN0YXJ0UHggPSBjdXJyZW50WFkpIDogZXZlbnRUeXBlID09PSBcInRvdWNobW92ZVwiICYmIChpc1ByZXZlbnRlZCB8fCBzdGFydFB4ID09PSAhMCB8fCBwcmV2ZW50VGhyZXNob2xkICE9PSBudWxsICYmIE1hdGguYWJzKHN0YXJ0UHggLSBjdXJyZW50WFkpID49IHByZXZlbnRUaHJlc2hvbGQpICYmIChzdGFydFB4ID0gITAsIGV2ZW50LnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH07XG5cbiAgICAvLyBiaW5kIHRvdWNoIGV2ZW50c1xuICAgICQkLnN2Zy5vbihcInRvdWNoc3RhcnQuZXZlbnRSZWN0IHRvdWNobW92ZS5ldmVudFJlY3RcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV2ZW50UmVjdCA9IGdldEV2ZW50UmVjdCgpLFxuICAgICAgICAgIGV2ZW50ID0gZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcImV2ZW50XCJdO1xuXG4gICAgICBpZiAoIWV2ZW50UmVjdC5lbXB0eSgpICYmIGV2ZW50UmVjdC5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmV2ZW50UmVjdCkpIHtcbiAgICAgICAgLy8gaWYgdG91Y2ggcG9pbnRzIGFyZSA+IDEsIG1lYW5zIGRvaW5nIHpvb21pbmcgaW50ZXJhY3Rpb24uIEluIHRoaXMgY2FzZSBkbyBub3QgZXhlY3V0ZSB0b29sdGlwIGNvZGVzLlxuICAgICAgICBpZiAoJCQuZHJhZ2dpbmcgfHwgJCQuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkgfHwgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSByZXR1cm47XG4gICAgICAgIHByZXZlbnRFdmVudChldmVudCksIHNlbGVjdFJlY3QodGhpcyk7XG4gICAgICB9IGVsc2UgJCQudW5zZWxlY3RSZWN0KCksICQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goKTtcbiAgICB9LCAhMCkub24oXCJ0b3VjaGVuZC5ldmVudFJlY3RcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV2ZW50UmVjdCA9IGdldEV2ZW50UmVjdCgpO1xuICAgICAgIWV2ZW50UmVjdC5lbXB0eSgpICYmIGV2ZW50UmVjdC5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmV2ZW50UmVjdCkgJiYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhJCQudG9nZ2xlU2hhcGUgfHwgJCQuY2FuY2VsQ2xpY2spICYmICQkLmNhbmNlbENsaWNrICYmICgkJC5jYW5jZWxDbGljayA9ICExKTtcbiAgICB9LCAhMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGxvY2F0aW9uIGFuZCBzaXplIG9mIHRoZSBldmVudFJlY3QuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxuICAgKi9cbiAgdXBkYXRlRXZlbnRSZWN0OiBmdW5jdGlvbiB1cGRhdGVFdmVudFJlY3QoZXZlbnRSZWN0VXBkYXRlKSB7XG4gICAgdmFyIHgsXG4gICAgICAgIHksXG4gICAgICAgIHcsXG4gICAgICAgIGgsXG4gICAgICAgICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICB4U2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQueCxcbiAgICAgICAgZXZlbnRSZWN0RGF0YSA9IGV2ZW50UmVjdFVwZGF0ZSB8fCAkJC5ldmVudFJlY3QuZGF0YSgpLFxuICAgICAgICBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuICAgIGlmICgkJC5pc011bHRpcGxlWCgpKSAvLyBUT0RPOiByb3RhdGVkIG5vdCBzdXBwb3J0ZWQgeWV0XG4gICAgeCA9IDAsIHkgPSAwLCB3ID0gJCQud2lkdGgsIGggPSAkJC5oZWlnaHQ7ZWxzZSB7XG4gICAgICB2YXIgcmVjdFcsIHJlY3RYO1xuICAgICAgaWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSkgcmVjdFcgPSAkJC5nZXRFdmVudFJlY3RXaWR0aCgpLCByZWN0WCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB4U2NhbGUoZC54KSAtIHJlY3RXIC8gMjtcbiAgICAgIH07ZWxzZSB7XG4gICAgICAgIHZhciBnZXRQcmV2TmV4dFggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGQuaW5kZXg7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZXY6ICQkLmdldFByZXZYKGluZGV4KSxcbiAgICAgICAgICAgIG5leHQ6ICQkLmdldE5leHRYKGluZGV4KVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVjdFcgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHZhciB4ID0gZ2V0UHJldk5leHRYKGQpOyAvLyBpZiB0aGVyZSB0aGlzIGlzIGEgc2luZ2xlIGRhdGEgcG9pbnQgbWFrZSB0aGUgZXZlbnRSZWN0IGZ1bGwgd2lkdGggKG9yIGhlaWdodClcblxuICAgICAgICAgIHJldHVybiB4LnByZXYgPT09IG51bGwgJiYgeC5uZXh0ID09PSBudWxsID8gaXNSb3RhdGVkID8gJCQuaGVpZ2h0IDogJCQud2lkdGggOiAoeC5wcmV2ID09PSBudWxsICYmICh4LnByZXYgPSB4U2NhbGUuZG9tYWluKClbMF0pLCB4Lm5leHQgPT09IG51bGwgJiYgKHgubmV4dCA9IHhTY2FsZS5kb21haW4oKVsxXSksIE1hdGgubWF4KDAsICh4U2NhbGUoeC5uZXh0KSAtIHhTY2FsZSh4LnByZXYpKSAvIDIpKTtcbiAgICAgICAgfSwgcmVjdFggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHZhciB4ID0gZ2V0UHJldk5leHRYKGQpLFxuICAgICAgICAgICAgICB0aGlzWCA9IGQueDtcbiAgICAgICAgICAvLyBpZiB0aGVyZSB0aGlzIGlzIGEgc2luZ2xlIGRhdGEgcG9pbnQgcG9zaXRpb24gdGhlIGV2ZW50UmVjdCBhdCAwXG4gICAgICAgICAgcmV0dXJuIHgucHJldiA9PT0gbnVsbCAmJiB4Lm5leHQgPT09IG51bGwgPyAwIDogKHgucHJldiA9PT0gbnVsbCAmJiAoeC5wcmV2ID0geFNjYWxlLmRvbWFpbigpWzBdKSwgKHhTY2FsZSh0aGlzWCkgKyB4U2NhbGUoeC5wcmV2KSkgLyAyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHggPSBpc1JvdGF0ZWQgPyAwIDogcmVjdFgsIHkgPSBpc1JvdGF0ZWQgPyByZWN0WCA6IDAsIHcgPSBpc1JvdGF0ZWQgPyAkJC53aWR0aCA6IHJlY3RXLCBoID0gaXNSb3RhdGVkID8gcmVjdFcgOiAkJC5oZWlnaHQ7XG4gICAgfVxuICAgIGV2ZW50UmVjdERhdGEuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzRXZlbnQuYmluZCgkJCkpLmF0dHIoXCJ4XCIsIHgpLmF0dHIoXCJ5XCIsIHkpLmF0dHIoXCJ3aWR0aFwiLCB3KS5hdHRyKFwiaGVpZ2h0XCIsIGgpO1xuICB9LFxuICBzZWxlY3RSZWN0Rm9yU2luZ2xlOiBmdW5jdGlvbiBzZWxlY3RSZWN0Rm9yU2luZ2xlKGNvbnRleHQsIGV2ZW50UmVjdCwgaW5kZXgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGlzU2VsZWN0aW9uRW5hYmxlZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkLFxuICAgICAgICBpc1NlbGVjdGlvbkdyb3VwZWQgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCxcbiAgICAgICAgaXNUb29sdGlwR3JvdXBlZCA9IGNvbmZpZy50b29sdGlwX2dyb3VwZWQsXG4gICAgICAgIHNlbGVjdGVkRGF0YSA9ICQkLmdldEFsbFZhbHVlc09uSW5kZXgoaW5kZXgpO1xuICAgIGlzVG9vbHRpcEdyb3VwZWQgJiYgKCQkLnNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgY29udGV4dCksICQkLnNob3dHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKSwgIWlzU2VsZWN0aW9uRW5hYmxlZCB8fCBpc1NlbGVjdGlvbkdyb3VwZWQpIHx8ICQkLm1haW4uc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5zaGFwZSwgXCItXCIpLmNvbmNhdChpbmRleCkpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMpLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuRVhQQU5ERUQsICEwKSwgaXNTZWxlY3Rpb25FbmFibGVkICYmIGV2ZW50UmVjdC5zdHlsZShcImN1cnNvclwiLCBpc1NlbGVjdGlvbkdyb3VwZWQgPyBcInBvaW50ZXJcIiA6IG51bGwpLCBpc1Rvb2x0aXBHcm91cGVkIHx8ICgkJC5oaWRlR3JpZEZvY3VzKCksICQkLmhpZGVUb29sdGlwKCksICFpc1NlbGVjdGlvbkdyb3VwZWQgJiYgJCQuZXhwYW5kQ2lyY2xlc0JhcnMoaW5kZXgpKTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGQpO1xuICAgIH0pLmNhbGwoZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICB2YXIgZCA9IHNlbGVjdGVkLmRhdGEoKTtcbiAgICAgIGlzU2VsZWN0aW9uRW5hYmxlZCAmJiAoaXNTZWxlY3Rpb25Hcm91cGVkIHx8IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkpICYmIGV2ZW50UmVjdC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIiksIGlzVG9vbHRpcEdyb3VwZWQgfHwgKCQkLnNob3dUb29sdGlwKGQsIGNvbnRleHQpLCAkJC5zaG93R3JpZEZvY3VzKGQpLCAkJC51bmV4cGFuZENpcmNsZXMoKSwgc2VsZWN0ZWQuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gJCQuZXhwYW5kQ2lyY2xlc0JhcnMoaW5kZXgsIGQuaWQpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9LFxuICBleHBhbmRDaXJjbGVzQmFyczogZnVuY3Rpb24gZXhwYW5kQ2lyY2xlc0JhcnMoaW5kZXgsIGlkLCByZXNldCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICBjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQgJiYgJCQuZXhwYW5kQ2lyY2xlcyhpbmRleCwgaWQsIHJlc2V0KSwgJCQuZXhwYW5kQmFycyhpbmRleCwgaWQsIHJlc2V0KTtcbiAgfSxcbiAgc2VsZWN0UmVjdEZvck11bHRpcGxlWHM6IGZ1bmN0aW9uIHNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKGNvbnRleHQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XG5cbiAgICAvLyBkbyBub3RoaW5nIHdoZW4gZHJhZ2dpbmdcbiAgICBpZiAoISgkJC5kcmFnZ2luZyB8fCAkJC5oYXNBcmNUeXBlKHRhcmdldHNUb1Nob3cpKSkge1xuICAgICAgdmFyIG1vdXNlID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJtb3VzZVwiXSkoY29udGV4dCksXG4gICAgICAgICAgY2xvc2VzdCA9ICQkLmZpbmRDbG9zZXN0RnJvbVRhcmdldHModGFyZ2V0c1RvU2hvdywgbW91c2UpO1xuICAgICAgaWYgKCQkLm1vdXNlb3ZlciAmJiAoIWNsb3Nlc3QgfHwgY2xvc2VzdC5pZCAhPT0gJCQubW91c2VvdmVyLmlkKSAmJiAoY29uZmlnLmRhdGFfb25vdXQuY2FsbCgkJC5hcGksICQkLm1vdXNlb3ZlciksICQkLm1vdXNlb3ZlciA9IHVuZGVmaW5lZCksICFjbG9zZXN0KSByZXR1cm4gdm9pZCAkJC51bnNlbGVjdFJlY3QoKTtcbiAgICAgIHZhciBzYW1lWERhdGEgPSAkJC5pc0J1YmJsZVR5cGUoY2xvc2VzdCkgfHwgJCQuaXNTY2F0dGVyVHlwZShjbG9zZXN0KSB8fCAhY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCA/IFtjbG9zZXN0XSA6ICQkLmZpbHRlckJ5WCh0YXJnZXRzVG9TaG93LCBjbG9zZXN0LngpLFxuICAgICAgICAgIHNlbGVjdGVkRGF0YSA9IHNhbWVYRGF0YS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuICQkLmFkZE5hbWUoZCk7XG4gICAgICB9KTsgLy8gc2hvdyB0b29sdGlwIHdoZW4gY3Vyc29yIGlzIGNsb3NlIHRvIHNvbWUgcG9pbnRcblxuICAgICAgJCQuc2hvd1Rvb2x0aXAoc2VsZWN0ZWREYXRhLCBjb250ZXh0KSwgJCQuZXhwYW5kQ2lyY2xlc0JhcnMoY2xvc2VzdC5pbmRleCwgY2xvc2VzdC5pZCwgITApLCAkJC5zaG93R3JpZEZvY3VzKHNlbGVjdGVkRGF0YSksICgkJC5pc0JhclR5cGUoY2xvc2VzdC5pZCkgfHwgJCQuZGlzdChjbG9zZXN0LCBtb3VzZSkgPCBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkpICYmICgkJC5zdmcuc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5ldmVudFJlY3QpKS5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIiksICEkJC5tb3VzZW92ZXIgJiYgKGNvbmZpZy5kYXRhX29ub3Zlci5jYWxsKCQkLmFwaSwgY2xvc2VzdCksICQkLm1vdXNlb3ZlciA9IGNsb3Nlc3QpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuc2VsZWN0IEV2ZW50UmVjdC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVuc2VsZWN0UmVjdDogZnVuY3Rpb24gdW5zZWxlY3RSZWN0KCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgJCQuc3ZnLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuZXZlbnRSZWN0KSkuc3R5bGUoXCJjdXJzb3JcIiwgbnVsbCksICQkLmhpZGVHcmlkRm9jdXMoKSwgJCQuaGlkZVRvb2x0aXAoKSwgJCQuX2hhbmRsZUxpbmtlZENoYXJ0cyghMSksICQkLnVuZXhwYW5kQ2lyY2xlcygpLCAkJC51bmV4cGFuZEJhcnMoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlIGRhdGEub25vdmVyL291dCBjYWxsYmFjayBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0T3Zlck91dDogZnVuY3Rpb24gc2V0T3Zlck91dChpc092ZXIsIGQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGlzQXJjID0gaXNPYmplY3QoZCk7XG5cbiAgICAvLyBDYWxsIGV2ZW50IGhhbmRsZXJcbiAgICBpZiAoaXNBcmMgfHwgZCAhPT0gLTEpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGNvbmZpZ1tpc092ZXIgPyBcImRhdGFfb25vdmVyXCIgOiBcImRhdGFfb25vdXRcIl0uYmluZCgkJC5hcGkpO1xuICAgICAgaWYgKGNvbmZpZy5jb2xvcl9vbm92ZXIgJiYgJCQuc2V0T3ZlckNvbG9yKGlzT3ZlciwgZCwgaXNBcmMpLCBpc0FyYykgY2FsbGJhY2soZCwgJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmFyYykuY29uY2F0KCQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpKSkubm9kZSgpKTtlbHNlIGlmICghY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCkge1xuICAgICAgICB2YXIgY2FsbGVlID0gJCQuc2V0T3Zlck91dCxcbiAgICAgICAgICAgIGxhc3QgPSBjYWxsZWUubGFzdCB8fCBbXSxcbiAgICAgICAgICAgIHNoYXBlID0gJCQubWFpbi5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnNoYXBlLCBcIi1cIikuY29uY2F0KGQpKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNoYXBlLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgKGxhc3QubGVuZ3RoID09PSAwIHx8IGxhc3QuZXZlcnkoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2ICE9PSBfdGhpcztcbiAgICAgICAgICB9KSkgJiYgKGNhbGxiYWNrKGQsIHRoaXMpLCBsYXN0LnB1c2godGhpcykpO1xuICAgICAgICB9KSwgbGFzdC5sZW5ndGggPiAwICYmIHNoYXBlLmVtcHR5KCkgJiYgKGNhbGxiYWNrID0gY29uZmlnLmRhdGFfb25vdXQuYmluZCgkJC5hcGkpLCBsYXN0LmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHYpLmRhdHVtKCksIHYpO1xuICAgICAgICB9KSwgbGFzdCA9IFtdKSwgY2FsbGVlLmxhc3QgPSBsYXN0O1xuICAgICAgfSBlbHNlIGlzT3ZlciAmJiAkJC5leHBhbmRDaXJjbGVzQmFycyhkLCBudWxsLCAhMCksICQkLmlzTXVsdGlwbGVYKCkgfHwgJCQubWFpbi5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnNoYXBlLCBcIi1cIikuY29uY2F0KGQpKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGNhbGxiYWNrKGQsIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIGRhdGEub25vdmVyL291dCBjYWxsYmFjayBmb3IgdG91Y2ggZXZlbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBkIHRhcmdldCBpbmRleCBvciBkYXRhIG9iamVjdCBmb3IgQXJjIHR5cGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGxPdmVyT3V0Rm9yVG91Y2g6IGZ1bmN0aW9uIGNhbGxPdmVyT3V0Rm9yVG91Y2goZCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNhbGxlZSA9ICQkLmNhbGxPdmVyT3V0Rm9yVG91Y2gsXG4gICAgICAgIGxhc3QgPSBjYWxsZWUubGFzdDtcbiAgICAoaXNPYmplY3QoZCkgJiYgbGFzdCA/IGQuaWQgIT09IGxhc3QuaWQgOiBkICE9PSBsYXN0KSAmJiAoKGxhc3QgfHwgaXNOdW1iZXIobGFzdCkpICYmICQkLnNldE92ZXJPdXQoITEsIGxhc3QpLCAoZCB8fCBpc051bWJlcihkKSkgJiYgJCQuc2V0T3Zlck91dCghMCwgZCksIGNhbGxlZS5sYXN0ID0gZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBkcmFnZ2FibGUgc2VsZWN0aW9uIGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uOiBmdW5jdGlvbiBnZXREcmFnZ2FibGVTZWxlY3Rpb24oKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgIHJldHVybiBjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25fZHJhZ2dhYmxlICYmICQkLmRyYWcgPyBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfZHJhZ19jb21tb25qczJfZDNfZHJhZ19hbWRfZDNfZHJhZ19yb290X2QzX1tcImRyYWdcIl0pKCkub24oXCJkcmFnXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICQkLmRyYWcoT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJtb3VzZVwiXSkodGhpcykpO1xuICAgIH0pLm9uKFwic3RhcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgJCQuZHJhZ3N0YXJ0KE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wibW91c2VcIl0pKHRoaXMpKTtcbiAgICB9KS5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkJC5kcmFnZW5kKCk7XG4gICAgfSkgOiBmdW5jdGlvbiAoKSB7fTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGV2ZW50UmVjdCBmb3IgZWFjaCBkYXRhIG9uIHRoZSB4LWF4aXMuXG4gICAqIFJlZ2lzdGVyIHRvdWNoIGFuZCBkcmFnIGV2ZW50cy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXG4gICAqL1xuICBnZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYOiBmdW5jdGlvbiBnZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYKGV2ZW50UmVjdEVudGVyKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICByZWN0ID0gZXZlbnRSZWN0RW50ZXIuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NFdmVudC5iaW5kKCQkKSkuc3R5bGUoXCJjdXJzb3JcIiwgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgPyBcInBvaW50ZXJcIiA6IG51bGwpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICQkLmNsaWNrSGFuZGxlckZvclNpbmdsZVguYmluZCh0aGlzKShkLCAkJCk7XG4gICAgfSkuY2FsbCgkJC5nZXREcmFnZ2FibGVTZWxlY3Rpb24oKSk7XG4gICAgcmV0dXJuICQkLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiICYmIHJlY3Qub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICQkLmRyYWdnaW5nIHx8ICQkLmZsb3dpbmcgfHwgJCQuaGFzQXJjVHlwZSgpIHx8ICQkLmNvbmZpZy50b29sdGlwX2dyb3VwZWQgJiYgJCQuc2V0T3Zlck91dCghMCwgZC5pbmRleCk7XG4gICAgfSkub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgd2hpbGUgZHJhZ2dpbmcvZmxvd2luZ1xuICAgICAgaWYgKCEoJCQuZHJhZ2dpbmcgfHwgJCQuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGQuaW5kZXgsXG4gICAgICAgICAgICBldmVudFJlY3QgPSAkJC5zdmcuc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5ldmVudFJlY3QsIFwiLVwiKS5jb25jYXQoaW5kZXgpKTtcbiAgICAgICAgJCQuaXNTdGVwVHlwZShkKSAmJiAkJC5jb25maWcubGluZV9zdGVwX3R5cGUgPT09IFwic3RlcC1hZnRlclwiICYmIE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wibW91c2VcIl0pKHRoaXMpWzBdIDwgJCQueCgkJC5nZXRYVmFsdWUoZC5pZCwgaW5kZXgpKSAmJiAoaW5kZXggLT0gMSksIGluZGV4ID09PSAtMSA/ICQkLnVuc2VsZWN0UmVjdCgpIDogJCQuc2VsZWN0UmVjdEZvclNpbmdsZSh0aGlzLCBldmVudFJlY3QsIGluZGV4KSwgJCQuY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCB8fCAkJC5zZXRPdmVyT3V0KGluZGV4ICE9PSAtMSwgZC5pbmRleCk7XG4gICAgICB9XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgISQkLmNvbmZpZyB8fCAkJC5oYXNBcmNUeXBlKCkgfHwgKCQkLnVuc2VsZWN0UmVjdCgpLCAkJC5zZXRPdmVyT3V0KCExLCBkLmluZGV4KSk7XG4gICAgfSksIHJlY3Q7XG4gIH0sXG4gIGNsaWNrSGFuZGxlckZvclNpbmdsZVg6IGZ1bmN0aW9uIGNsaWNrSGFuZGxlckZvclNpbmdsZVgoZCwgY3R4KSB7XG4gICAgdmFyICQkID0gY3R4LFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgaWYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhJCQudG9nZ2xlU2hhcGUgfHwgJCQuY2FuY2VsQ2xpY2spIHJldHVybiB2b2lkICgkJC5jYW5jZWxDbGljayAmJiAoJCQuY2FuY2VsQ2xpY2sgPSAhMSkpO1xuICAgIHZhciBpbmRleCA9IGQuaW5kZXg7XG4gICAgJCQubWFpbi5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnNoYXBlLCBcIi1cIikuY29uY2F0KGluZGV4KSkuZWFjaChmdW5jdGlvbiAoZDIpIHtcbiAgICAgIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGQyKSkgJiYgKCQkLnRvZ2dsZVNoYXBlKHRoaXMsIGQyLCBpbmRleCksIGNvbmZpZy5kYXRhX29uY2xpY2suY2FsbCgkJC5hcGksIGQyLCB0aGlzKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBldmVudFJlY3QsXG4gICAqIFJlZ2lzdGVyIHRvdWNoIGFuZCBkcmFnIGV2ZW50cy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXG4gICAqL1xuICBnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzOiBmdW5jdGlvbiBnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzKGV2ZW50UmVjdEVudGVyKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgcmVjdCA9IGV2ZW50UmVjdEVudGVyLmFwcGVuZChcInJlY3RcIikuYXR0cihcInhcIiwgMCkuYXR0cihcInlcIiwgMCkuYXR0cihcIndpZHRoXCIsICQkLndpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsICQkLmhlaWdodCkuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLmV2ZW50UmVjdCkub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkJC5jbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTLmJpbmQodGhpcykoJCQpO1xuICAgIH0pLmNhbGwoJCQuZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uKCkpO1xuICAgIHJldHVybiAkJC5pbnB1dFR5cGUgPT09IFwibW91c2VcIiAmJiByZWN0Lm9uKFwibW91c2VvdmVyIG1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkJC5zZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyh0aGlzKTtcbiAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICEkJC5jb25maWcgfHwgJCQuaGFzQXJjVHlwZSgpIHx8ICQkLnVuc2VsZWN0UmVjdCgpO1xuICAgIH0pLCByZWN0O1xuICB9LFxuICBjbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTOiBmdW5jdGlvbiBjbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTKGN0eCkge1xuICAgIHZhciAkJCA9IGN0eCxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xuXG4gICAgaWYgKCEkJC5oYXNBcmNUeXBlKHRhcmdldHNUb1Nob3cpKSB7XG4gICAgICB2YXIgbW91c2UgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcIm1vdXNlXCJdKSh0aGlzKSxcbiAgICAgICAgICBjbG9zZXN0ID0gJCQuZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzVG9TaG93LCBtb3VzZSk7XG4gICAgICAhY2xvc2VzdCB8fCAoJCQuaXNCYXJUeXBlKGNsb3Nlc3QuaWQpIHx8ICQkLmRpc3QoY2xvc2VzdCwgbW91c2UpIDwgY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KSAmJiAkJC5tYWluLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuc2hhcGVzKS5jb25jYXQoJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoY2xvc2VzdC5pZCkpKS5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnNoYXBlLCBcIi1cIikuY29uY2F0KGNsb3Nlc3QuaW5kZXgpKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICQkLmlzV2l0aGluU2hhcGUodGhpcywgY2xvc2VzdCkpICYmICgkJC50b2dnbGVTaGFwZSh0aGlzLCBjbG9zZXN0LCBjbG9zZXN0LmluZGV4KSwgY29uZmlnLmRhdGFfb25jbGljay5jYWxsKCQkLmFwaSwgY2xvc2VzdCwgdGhpcykpO1xuICAgICAgfSk7XG4gICAgfSAvLyBzZWxlY3QgaWYgc2VsZWN0aW9uIGVuYWJsZWRcblxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIG1vdXNlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCBvZiBldmVudFJlY3RcbiAgICogQHBhcmFtIHtBcnJheX0gbW91c2UgeCBhbmQgeSBjb29yZGluYXRlIHZhbHVlXG4gICAqL1xuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHR5cGUsIGluZGV4LCBtb3VzZSkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGlzTXVsdGlwbGVYID0gJCQuaXNNdWx0aXBsZVgoKSxcbiAgICAgICAgc2VsZWN0b3IgPSBcIi5cIi5jb25jYXQoaXNNdWx0aXBsZVggPyBjb25maWdfY2xhc3Nlcy5ldmVudFJlY3QgOiBcIlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5ldmVudFJlY3QsIFwiLVwiKS5jb25jYXQoaW5kZXgpKSxcbiAgICAgICAgZXZlbnRSZWN0ID0gJCQubWFpbi5zZWxlY3Qoc2VsZWN0b3IpLm5vZGUoKSxcbiAgICAgICAgX2V2ZW50UmVjdCRnZXRCb3VuZGluID0gZXZlbnRSZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICB3aWR0aCA9IF9ldmVudFJlY3QkZ2V0Qm91bmRpbi53aWR0aCxcbiAgICAgICAgbGVmdCA9IF9ldmVudFJlY3QkZ2V0Qm91bmRpbi5sZWZ0LFxuICAgICAgICB0b3AgPSBfZXZlbnRSZWN0JGdldEJvdW5kaW4udG9wLFxuICAgICAgICB4ID0gbGVmdCArIChtb3VzZSA/IG1vdXNlWzBdIDogMCkgKyAoaXNNdWx0aXBsZVggfHwgJCQuY29uZmlnLmF4aXNfcm90YXRlZCA/IDAgOiB3aWR0aCAvIDIpLFxuICAgICAgICB5ID0gdG9wICsgKG1vdXNlID8gbW91c2VbMV0gOiAwKTtcblxuICAgIGVtdWxhdGVFdmVudFsvXihtb3VzZXxjbGljaykvLnRlc3QodHlwZSkgPyBcIm1vdXNlXCIgOiBcInRvdWNoXCJdKGV2ZW50UmVjdCwgdHlwZSwge1xuICAgICAgc2NyZWVuWDogeCxcbiAgICAgIHNjcmVlblk6IHksXG4gICAgICBjbGllbnRYOiB4LFxuICAgICAgY2xpZW50WTogeVxuICAgIH0pO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ludGVybmFscy9zaXplLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBVcGRhdGUgY29udGFpbmVyIHNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldENvbnRhaW5lclNpemU6IGZ1bmN0aW9uIHNldENvbnRhaW5lclNpemUoKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC5jdXJyZW50V2lkdGggPSAkJC5nZXRDdXJyZW50V2lkdGgoKSwgJCQuY3VycmVudEhlaWdodCA9ICQkLmdldEN1cnJlbnRIZWlnaHQoKTtcbiAgfSxcbiAgZ2V0Q3VycmVudFdpZHRoOiBmdW5jdGlvbiBnZXRDdXJyZW50V2lkdGgoKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICByZXR1cm4gJCQuY29uZmlnLnNpemVfd2lkdGggfHwgJCQuZ2V0UGFyZW50V2lkdGgoKTtcbiAgfSxcbiAgZ2V0Q3VycmVudEhlaWdodDogZnVuY3Rpb24gZ2V0Q3VycmVudEhlaWdodCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGggPSBjb25maWcuc2l6ZV9oZWlnaHQgfHwgJCQuZ2V0UGFyZW50SGVpZ2h0KCk7XG4gICAgcmV0dXJuIGggPiAwID8gaCA6IDMyMCAvICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMiA6IDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgQXhpcyBzaXplIGFjY29yZGluZyBpdHMgcG9zaXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIEF4aXMgaWQgdmFsdWUgLSB4LCB5IG9yIHkyXG4gICAqIEByZXR1cm4ge251bWJlcn0gc2l6ZSBBeGlzIHNpemUgdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEF4aXNTaXplOiBmdW5jdGlvbiBnZXRBeGlzU2l6ZShpZCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcbiAgICByZXR1cm4gaXNSb3RhdGVkICYmIGlkID09PSBcInhcIiB8fCAhaXNSb3RhdGVkICYmIC95Mj8vLnRlc3QoaWQpID8gJCQuZ2V0QXhpc1dpZHRoQnlBeGlzSWQoaWQsICEwKSA6ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KGlkKTtcbiAgfSxcbiAgZ2V0Q3VycmVudFBhZGRpbmdUb3A6IGZ1bmN0aW9uIGdldEN1cnJlbnRQYWRkaW5nVG9wKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgYXhlc0xlbiA9IGNvbmZpZy5heGlzX3kyX2F4ZXMubGVuZ3RoLFxuICAgICAgICBwYWRkaW5nID0gaXNWYWx1ZShjb25maWcucGFkZGluZ190b3ApID8gY29uZmlnLnBhZGRpbmdfdG9wIDogMDtcbiAgICByZXR1cm4gJCQudGl0bGUgJiYgJCQudGl0bGUubm9kZSgpICYmIChwYWRkaW5nICs9ICQkLmdldFRpdGxlUGFkZGluZygpKSwgYXhlc0xlbiAmJiBjb25maWcuYXhpc19yb3RhdGVkICYmIChwYWRkaW5nICs9ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieTJcIikgKiBheGVzTGVuKSwgcGFkZGluZztcbiAgfSxcbiAgZ2V0Q3VycmVudFBhZGRpbmdCb3R0b206IGZ1bmN0aW9uIGdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgYXhpc0lkID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IFwieVwiIDogXCJ4XCIsXG4gICAgICAgIGF4ZXNMZW4gPSBjb25maWdbXCJheGlzX1wiLmNvbmNhdChheGlzSWQsIFwiX2F4ZXNcIildLmxlbmd0aCxcbiAgICAgICAgcGFkZGluZyA9IGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfYm90dG9tKSA/IGNvbmZpZy5wYWRkaW5nX2JvdHRvbSA6IDA7XG4gICAgcmV0dXJuIHBhZGRpbmcgKyAoYXhlc0xlbiA/ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KGF4aXNJZCkgKiBheGVzTGVuIDogMCk7XG4gIH0sXG4gIGdldEN1cnJlbnRQYWRkaW5nTGVmdDogZnVuY3Rpb24gZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KHdpdGhvdXRSZWNvbXB1dGUpIHtcbiAgICB2YXIgcGFkZGluZyxcbiAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQsXG4gICAgICAgIGF4aXNJZCA9IGlzUm90YXRlZCA/IFwieFwiIDogXCJ5XCIsXG4gICAgICAgIGF4ZXNMZW4gPSBjb25maWdbXCJheGlzX1wiLmNvbmNhdChheGlzSWQsIFwiX2F4ZXNcIildLmxlbmd0aCxcbiAgICAgICAgYXhpc1dpZHRoID0gJCQuZ2V0QXhpc1dpZHRoQnlBeGlzSWQoYXhpc0lkLCB3aXRob3V0UmVjb21wdXRlKTtcbiAgICByZXR1cm4gcGFkZGluZyA9IGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfbGVmdCkgPyBjb25maWcucGFkZGluZ19sZWZ0IDogaXNSb3RhdGVkID8gY29uZmlnLmF4aXNfeF9zaG93ID8gTWF0aC5tYXgoY2VpbDEwKGF4aXNXaWR0aCksIDQwKSA6IDEgOiAhY29uZmlnLmF4aXNfeV9zaG93IHx8IGNvbmZpZy5heGlzX3lfaW5uZXIgPyAkJC5heGlzLmdldEF4aXNMYWJlbFBvc2l0aW9uKFwieVwiKS5pc091dGVyID8gMzAgOiAxIDogY2VpbDEwKGF4aXNXaWR0aCksIHBhZGRpbmcgKyBheGlzV2lkdGggKiBheGVzTGVuO1xuICB9LFxuICBnZXRDdXJyZW50UGFkZGluZ1JpZ2h0OiBmdW5jdGlvbiBnZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCkge1xuICAgIHZhciBwYWRkaW5nLFxuICAgICAgICB3aXRob3V0VGlja1RleHRPdmVyZmxvdyA9ICEhKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkKSAmJiBhcmd1bWVudHNbMF0sXG4gICAgICAgICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBkZWZhdWx0UGFkZGluZyA9IDEwLFxuICAgICAgICBsZWdlbmRXaWR0aE9uUmlnaHQgPSAkJC5pc0xlZ2VuZFJpZ2h0ID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSArIDIwIDogMCxcbiAgICAgICAgYXhlc0xlbiA9IGNvbmZpZy5heGlzX3kyX2F4ZXMubGVuZ3RoLFxuICAgICAgICBheGlzV2lkdGggPSAkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChcInkyXCIpLFxuICAgICAgICB4QXhpc1RpY2tUZXh0T3ZlcmZsb3cgPSB3aXRob3V0VGlja1RleHRPdmVyZmxvdyA/IDAgOiAkJC5heGlzLmdldFhBeGlzVGlja1RleHRZMk92ZXJmbG93KGRlZmF1bHRQYWRkaW5nKTtcbiAgICByZXR1cm4gcGFkZGluZyA9IGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfcmlnaHQpID8gY29uZmlnLnBhZGRpbmdfcmlnaHQgKyAxIDogY29uZmlnLmF4aXNfcm90YXRlZCA/IGRlZmF1bHRQYWRkaW5nICsgbGVnZW5kV2lkdGhPblJpZ2h0IDogIWNvbmZpZy5heGlzX3kyX3Nob3cgfHwgY29uZmlnLmF4aXNfeTJfaW5uZXIgPyBNYXRoLm1heCgyICsgbGVnZW5kV2lkdGhPblJpZ2h0ICsgKCQkLmF4aXMuZ2V0QXhpc0xhYmVsUG9zaXRpb24oXCJ5MlwiKS5pc091dGVyID8gMjAgOiAwKSwgeEF4aXNUaWNrVGV4dE92ZXJmbG93KSA6IE1hdGgubWF4KGNlaWwxMChheGlzV2lkdGgpICsgbGVnZW5kV2lkdGhPblJpZ2h0LCB4QXhpc1RpY2tUZXh0T3ZlcmZsb3cpLCBwYWRkaW5nICsgYXhpc1dpZHRoICogYXhlc0xlbjtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwYXJlbnQgcmVjdCBlbGVtZW50J3Mgc2l6ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHByb3BlcnR5L2F0dHJpYnV0ZSBuYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXJlbnRSZWN0VmFsdWU6IGZ1bmN0aW9uIGdldFBhcmVudFJlY3RWYWx1ZShrZXkpIHtcbiAgICBmb3IgKHZhciB2LCBvZmZzZXROYW1lID0gXCJvZmZzZXRcIi5jb25jYXQoY2FwaXRhbGl6ZShrZXkpKSwgcGFyZW50ID0gdGhpcy5zZWxlY3RDaGFydC5ub2RlKCk7ICF2ICYmIHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZSAhPT0gXCJCT0RZXCI7KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2tleV07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG9mZnNldE5hbWUgaW4gcGFyZW50ICYmICh2ID0gcGFyZW50W29mZnNldE5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gXCJ3aWR0aFwiKSB7XG4gICAgICAvLyBTb21ldGltZXMgZWxlbWVudCdzIHdpZHRoIHZhbHVlIGlzIGluY29ycmVjdChleC4gZmxleCBjb250YWluZXIpXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIHVzZSBib2R5J3Mgb2Zmc2V0V2lkdGggaW5zdGVhZC5cbiAgICAgIHZhciBib2R5V2lkdGggPSBicm93c2VyX2RvYy5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgdiA+IGJvZHlXaWR0aCAmJiAodiA9IGJvZHlXaWR0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG4gIH0sXG4gIGdldFBhcmVudFdpZHRoOiBmdW5jdGlvbiBnZXRQYXJlbnRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnRSZWN0VmFsdWUoXCJ3aWR0aFwiKTtcbiAgfSxcbiAgZ2V0UGFyZW50SGVpZ2h0OiBmdW5jdGlvbiBnZXRQYXJlbnRIZWlnaHQoKSB7XG4gICAgdmFyIGggPSB0aGlzLnNlbGVjdENoYXJ0LnN0eWxlKFwiaGVpZ2h0XCIpO1xuICAgIHJldHVybiBoLmluZGV4T2YoXCJweFwiKSA+IDAgPyBwYXJzZUludChoLCAxMCkgOiAwO1xuICB9LFxuICBnZXRTdmdMZWZ0OiBmdW5jdGlvbiBnZXRTdmdMZWZ0KHdpdGhvdXRSZWNvbXB1dGUpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGhhc0xlZnRBeGlzUmVjdCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgfHwgIWNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgIWNvbmZpZy5heGlzX3lfaW5uZXIsXG4gICAgICAgIGxlZnRBeGlzQ2xhc3MgPSBjb25maWcuYXhpc19yb3RhdGVkID8gY29uZmlnX2NsYXNzZXMuYXhpc1ggOiBjb25maWdfY2xhc3Nlcy5heGlzWSxcbiAgICAgICAgbGVmdEF4aXMgPSAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQobGVmdEF4aXNDbGFzcykpLm5vZGUoKSxcbiAgICAgICAgc3ZnUmVjdCA9IGxlZnRBeGlzICYmIGhhc0xlZnRBeGlzUmVjdCA/IGxlZnRBeGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge1xuICAgICAgcmlnaHQ6IDBcbiAgICB9LFxuICAgICAgICBjaGFydFJlY3QgPSAkJC5zZWxlY3RDaGFydC5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKSxcbiAgICAgICAgc3ZnTGVmdCA9IHN2Z1JlY3QucmlnaHQgLSBjaGFydFJlY3QubGVmdCAtIChoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KHdpdGhvdXRSZWNvbXB1dGUpKTtcbiAgICByZXR1cm4gc3ZnTGVmdCA+IDAgPyBzdmdMZWZ0IDogMDtcbiAgfSxcbiAgZ2V0QXhpc1dpZHRoQnlBeGlzSWQ6IGZ1bmN0aW9uIGdldEF4aXNXaWR0aEJ5QXhpc0lkKGlkLCB3aXRob3V0UmVjb21wdXRlKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgcG9zaXRpb24gPSAkJC5heGlzLmdldExhYmVsUG9zaXRpb25CeUlkKGlkKTtcbiAgICByZXR1cm4gJCQuYXhpcy5nZXRNYXhUaWNrV2lkdGgoaWQsIHdpdGhvdXRSZWNvbXB1dGUpICsgKHBvc2l0aW9uLmlzSW5uZXIgPyAyMCA6IDQwKTtcbiAgfSxcbiAgZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQ6IGZ1bmN0aW9uIGdldEhvcml6b250YWxBeGlzSGVpZ2h0KGlkKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkLFxuICAgICAgICBoID0gMzA7XG4gICAgaWYgKGlkID09PSBcInhcIiAmJiAhY29uZmlnLmF4aXNfeF9zaG93KSByZXR1cm4gODtcbiAgICBpZiAoaWQgPT09IFwieFwiICYmIGNvbmZpZy5heGlzX3hfaGVpZ2h0KSByZXR1cm4gY29uZmlnLmF4aXNfeF9oZWlnaHQ7XG4gICAgaWYgKGlkID09PSBcInlcIiAmJiAhY29uZmlnLmF4aXNfeV9zaG93KSByZXR1cm4gIWNvbmZpZy5sZWdlbmRfc2hvdyB8fCAkJC5pc0xlZ2VuZFJpZ2h0IHx8ICQkLmlzTGVnZW5kSW5zZXQgPyAxIDogMTA7XG4gICAgaWYgKGlkID09PSBcInkyXCIgJiYgIWNvbmZpZy5heGlzX3kyX3Nob3cpIHJldHVybiAkJC5yb3RhdGVkX3BhZGRpbmdfdG9wOyAvLyBjb25zdCByb3RhdGUgPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19yb3RhdGVgXTtcblxuICAgIHZhciByb3RhdGUgPSAkJC5nZXRBeGlzVGlja1JvdGF0ZShpZCk7IC8vIENhbGN1bGF0ZSB4L3kgYXhpcyBoZWlnaHQgd2hlbiB0aWNrIHJvdGF0ZWRcblxuICAgIHJldHVybiAoaWQgPT09IFwieFwiICYmICFpc1JvdGF0ZWQgfHwgL3kyPy8udGVzdChpZCkgJiYgaXNSb3RhdGVkKSAmJiByb3RhdGUgJiYgKGggPSAzMCArICQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKGlkKSAqIE1hdGguY29zKE1hdGguUEkgKiAoOTAgLSByb3RhdGUpIC8gMTgwKSwgIWNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUgJiYgJCQuY3VycmVudEhlaWdodCAmJiBoID4gJCQuY3VycmVudEhlaWdodCAvIDIgJiYgKGggPSAkJC5jdXJyZW50SGVpZ2h0IC8gMikpLCBoICsgKCQkLmF4aXMuZ2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpLmlzSW5uZXIgPyAwIDogMTApICsgKGlkICE9PSBcInkyXCIgfHwgaXNSb3RhdGVkID8gMCA6IC0xMCk7XG4gIH0sXG4gIGdldEV2ZW50UmVjdFdpZHRoOiBmdW5jdGlvbiBnZXRFdmVudFJlY3RXaWR0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy54QXhpcy50aWNrSW50ZXJ2YWwoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBheGlzIHRpY2sgdGVzdCByb3RhdGUgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAqIEByZXR1cm4ge051bWJlcn0gcm90YXRlIHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRBeGlzVGlja1JvdGF0ZTogZnVuY3Rpb24gZ2V0QXhpc1RpY2tSb3RhdGUoaWQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIHJvdGF0ZSA9IGNvbmZpZ1tcImF4aXNfXCIuY29uY2F0KGlkLCBcIl90aWNrX3JvdGF0ZVwiKV07XG5cbiAgICBpZiAoaWQgPT09IFwieFwiKSB7XG4gICAgICB2YXIgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ2F0ZWdvcml6ZWQoKSxcbiAgICAgICAgICBpc1RpbWVTZXJpZXMgPSAkJC5pc1RpbWVTZXJpZXMoKSxcbiAgICAgICAgICBhbGxvd2VkWEF4aXNUeXBlcyA9IGlzQ2F0ZWdvcml6ZWQgfHwgaXNUaW1lU2VyaWVzLFxuICAgICAgICAgIHRpY2tDb3VudCA9IDA7XG4gICAgICBjb25maWcuYXhpc194X3RpY2tfZml0ICYmIGFsbG93ZWRYQXhpc1R5cGVzICYmICgkJC5heGlzLnggPSB7XG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHJpZ2h0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tDb3VudDogMFxuICAgICAgfSwgdGlja0NvdW50ID0gJCQuY3VycmVudE1heFRpY2tXaWR0aHMueC50aWNrcy5sZW5ndGggKyAoaXNUaW1lU2VyaWVzID8gLTEgOiAxKSwgdGlja0NvdW50ICE9PSAkJC5heGlzLngudGlja0NvdW50ICYmICgkJC5heGlzLngucGFkZGluZyA9ICQkLmF4aXMuZ2V0WEF4aXNQYWRkaW5nKHRpY2tDb3VudCkpLCAkJC5heGlzLngudGlja0NvdW50ID0gdGlja0NvdW50KSwgJCQuc3ZnICYmIGNvbmZpZy5heGlzX3hfdGlja19maXQgJiYgIWNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUgJiYgIWNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nICYmIGNvbmZpZy5heGlzX3hfdGlja19hdXRvcm90YXRlICYmIGFsbG93ZWRYQXhpc1R5cGVzICYmIChyb3RhdGUgPSAkJC5uZWVkVG9Sb3RhdGVYQXhpc1RpY2tUZXh0cygpID8gY29uZmlnLmF4aXNfeF90aWNrX3JvdGF0ZSA6IDApO1xuICAgIH1cblxuICAgIHJldHVybiByb3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHdlYXRoZXIgYXhpcyB0aWNrIHRleHQgbmVlZHMgdG8gYmUgcm90YXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbmVlZFRvUm90YXRlWEF4aXNUaWNrVGV4dHM6IGZ1bmN0aW9uIG5lZWRUb1JvdGF0ZVhBeGlzVGlja1RleHRzKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHhBeGlzTGVuZ3RoID0gJCQuY3VycmVudFdpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCExKSAtICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoITApLFxuICAgICAgICB0aWNrQ291bnRXaXRoUGFkZGluZyA9ICQkLmF4aXMueC50aWNrQ291bnQgKyAkJC5heGlzLngucGFkZGluZy5sZWZ0ICsgJCQuYXhpcy54LnBhZGRpbmcucmlnaHQsXG4gICAgICAgIG1heFRpY2tXaWR0aCA9ICQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKFwieFwiKTtcbiAgICByZXR1cm4gbWF4VGlja1dpZHRoID4gKHhBeGlzTGVuZ3RoIC8gdGlja0NvdW50V2l0aFBhZGRpbmcgfHwgMCk7XG4gIH1cbn0pO1xuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2hhcGVcIixcImNvbW1vbmpzMlwiOlwiZDMtc2hhcGVcIixcImFtZFwiOlwiZDMtc2hhcGVcIixcInJvb3RcIjpcImQzXCJ9XG52YXIgZXh0ZXJuYWxfY29tbW9uanNfZDNfc2hhcGVfY29tbW9uanMyX2QzX3NoYXBlX2FtZF9kM19zaGFwZV9yb290X2QzXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zaGFwZS9zaGFwZS5qc1xuXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5cblxuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICBnZXRTaGFwZUluZGljZXM6IGZ1bmN0aW9uIGdldFNoYXBlSW5kaWNlcyh0eXBlRmlsdGVyKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICB4cyA9IGNvbmZpZy5kYXRhX3hzLFxuICAgICAgICBoYXNYcyA9IG5vdEVtcHR5KHhzKSxcbiAgICAgICAgaW5kaWNlcyA9IHt9LFxuICAgICAgICBpID0gaGFzWHMgPyB7fSA6IDA7XG4gICAgcmV0dXJuIGhhc1hzICYmIGdldFVuaXF1ZShPYmplY3Qua2V5cyh4cykubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4geHNbdl07XG4gICAgfSkpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlbdl0gPSAwLCBpbmRpY2VzW3ZdID0ge307XG4gICAgfSksICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzLmZpbHRlcih0eXBlRmlsdGVyLCAkJCkpLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIGZvciAodmFyIGdyb3VwcywgeEtleSA9IChkLmlkIGluIHhzKSA/IHhzW2QuaWRdIDogXCJcIiwgaW5kID0geEtleSA/IGluZGljZXNbeEtleV0gOiBpbmRpY2VzLCBqID0gMDsgZ3JvdXBzID0gY29uZmlnLmRhdGFfZ3JvdXBzW2pdOyBqKyspIGlmICghKGdyb3Vwcy5pbmRleE9mKGQuaWQpIDwgMCkpIGZvciAodmFyIF9yb3c0LCBfazQgPSAwOyBfcm93NCA9IGdyb3Vwc1tfazRdOyBfazQrKykgaWYgKF9yb3c0IGluIGluZCkge1xuICAgICAgICBpbmRbZC5pZF0gPSBpbmRbX3JvdzRdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaXNVbmRlZmluZWQoaW5kW2QuaWRdKSAmJiAoaW5kW2QuaWRdID0geEtleSA/IGlbeEtleV0rKyA6IGkrKywgaW5kLl9fbWF4X18gPSAoeEtleSA/IGlbeEtleV0gOiBpKSAtIDEpO1xuICAgIH0pLCBpbmRpY2VzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgaW5kaWNlcyB2YWx1ZSBiYXNlZCBvbiBkYXRhIElEIHZhbHVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmRpY2VzIEluZGljZXMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBEYXRhIGlkIHZhbHVlXG4gICAqIEByZXR1cm4ge09iamVjdH0gSW5kaWNlcyBvYmplY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEluZGljZXM6IGZ1bmN0aW9uIGdldEluZGljZXMoaW5kaWNlcywgaWQpIHtcbiAgICB2YXIgeHMgPSB0aGlzLmNvbmZpZy5kYXRhX3hzO1xuICAgIHJldHVybiBub3RFbXB0eSh4cykgPyBpbmRpY2VzW3hzW2lkXV0gOiBpbmRpY2VzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgaW5kaWNlcyBtYXggbnVtYmVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmRpY2VzIEluZGljZXMgb2JqZWN0XG4gICAqIEByZXR1cm4ge051bWJlcn0gTWF4IG51bWJlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SW5kaWNlc01heDogZnVuY3Rpb24gZ2V0SW5kaWNlc01heChpbmRpY2VzKSB7XG4gICAgcmV0dXJuIG5vdEVtcHR5KHRoaXMuY29uZmlnLmRhdGFfeHMpID8gLy8gaWYgaXMgbXVsdGlwbGUgeHMsIHJldHVybiB0b3RhbCBzdW0gb2YgeHMnIF9fbWF4X18gdmFsdWVcbiAgICBPYmplY3Qua2V5cyhpbmRpY2VzKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBpbmRpY2VzW3ZdLl9fbWF4X18gfHwgMDtcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3Vycikge1xuICAgICAgcmV0dXJuIGFjYyArIGN1cnI7XG4gICAgfSkgOiBpbmRpY2VzLl9fbWF4X187XG4gIH0sXG4gIGdldFNoYXBlWDogZnVuY3Rpb24gZ2V0U2hhcGVYKG9mZnNldCwgaW5kaWNlcywgaXNTdWIpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBzY2FsZSA9IGlzU3ViID8gJCQuc3ViWCA6ICQkLnpvb21TY2FsZSB8fCAkJC54LFxuICAgICAgICBiYXJQYWRkaW5nID0gJCQuY29uZmlnLmJhcl9wYWRkaW5nLFxuICAgICAgICBzdW0gPSBmdW5jdGlvbiAocCwgYykge1xuICAgICAgcmV0dXJuIHAgKyBjO1xuICAgIH0sXG4gICAgICAgIGhhbGZXaWR0aCA9IGlzT2JqZWN0VHlwZShvZmZzZXQpICYmIG9mZnNldC50b3RhbC5sZW5ndGggPyBvZmZzZXQudG90YWwucmVkdWNlKHN1bSkgLyAyIDogMDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIGluZCA9ICQkLmdldEluZGljZXMoaW5kaWNlcywgZC5pZCksXG4gICAgICAgICAgaW5kZXggPSBkLmlkIGluIGluZCA/IGluZFtkLmlkXSA6IDAsXG4gICAgICAgICAgdGFyZ2V0c051bSA9IChpbmQuX19tYXhfXyB8fCAwKSArIDEsXG4gICAgICAgICAgeCA9IDA7XG5cbiAgICAgIGlmIChub3RFbXB0eShkLngpKSB7XG4gICAgICAgIHZhciB4UG9zID0gc2NhbGUoZC54KTtcbiAgICAgICAgeCA9IGhhbGZXaWR0aCA/IHhQb3MgLSAob2Zmc2V0W2QuaWRdIHx8IG9mZnNldC53aWR0aCkgKyBvZmZzZXQudG90YWwuc2xpY2UoMCwgaW5kZXggKyAxKS5yZWR1Y2Uoc3VtKSAtIGhhbGZXaWR0aCA6IHhQb3MgLSAoaXNOdW1iZXIob2Zmc2V0KSA/IG9mZnNldCA6IG9mZnNldC53aWR0aCkgKiAodGFyZ2V0c051bSAvIDIgLSBpbmRleCk7XG4gICAgICB9IC8vIGFkanVzdCB4IHBvc2l0aW9uIGZvciBiYXIucGFkZGluZyBvcHRpb25xXG5cblxuICAgICAgcmV0dXJuIG9mZnNldCAmJiB4ICYmIHRhcmdldHNOdW0gPiAxICYmIGJhclBhZGRpbmcgJiYgKGluZGV4ICYmICh4ICs9IGJhclBhZGRpbmcgKiBpbmRleCksIHRhcmdldHNOdW0gPiAyID8geCAtPSAodGFyZ2V0c051bSAtIDEpICogYmFyUGFkZGluZyAvIDIgOiB0YXJnZXRzTnVtID09PSAyICYmICh4IC09IGJhclBhZGRpbmcgLyAyKSksIHg7XG4gICAgfTtcbiAgfSxcbiAgZ2V0U2hhcGVZOiBmdW5jdGlvbiBnZXRTaGFwZVkoaXNTdWIpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBpc1N0YWNrTm9ybWFsaXplZCA9ICQkLmlzU3RhY2tOb3JtYWxpemVkKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpc1N0YWNrTm9ybWFsaXplZCA/ICQkLmdldFJhdGlvKFwiaW5kZXhcIiwgZCwgITApIDogJCQuaXNCdWJibGVaVHlwZShkKSA/ICQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwieVwiKSA6IGQudmFsdWU7XG4gICAgICByZXR1cm4gKGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlKGQuaWQpIDogJCQuZ2V0WVNjYWxlKGQuaWQpKSh2YWx1ZSk7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHNoYXBlIGJhc2VkIHkgQXhpcyBtaW4gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIERhdGEgaWRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2hhcGVZTWluOiBmdW5jdGlvbiBnZXRTaGFwZVlNaW4oaWQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBfJCQkJCQkYXhpcyRnZXRJZCRkb20gPSAkJFskJC5heGlzLmdldElkKGlkKV0uZG9tYWluKCksXG4gICAgICAgIF8kJCQkJCRheGlzJGdldElkJGRvbTIgPSBfc2xpY2VkVG9BcnJheShfJCQkJCQkYXhpcyRnZXRJZCRkb20sIDEpLFxuICAgICAgICB5TWluID0gXyQkJCQkJGF4aXMkZ2V0SWQkZG9tMlswXTtcblxuICAgIHJldHVybiAhJCQuaXNHcm91cGVkKGlkKSAmJiB5TWluID4gMCA/IHlNaW4gOiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgU2hhcGUncyBvZmZzZXQgZGF0YVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCk6IGJvb2xlYW59IHR5cGVGaWx0ZXJcbiAgICogQHJldHVybiB7e3NoYXBlT2Zmc2V0VGFyZ2V0czogU2hhcGVPZmZzZXRUYXJnZXRbXSwgaW5kZXhNYXBCeVRhcmdldElkOiBvYmplY3R9fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2hhcGVPZmZzZXREYXRhOiBmdW5jdGlvbiBnZXRTaGFwZU9mZnNldERhdGEodHlwZUZpbHRlcikge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHRhcmdldHMgPSAkJC5vcmRlclRhcmdldHMoJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHR5cGVGaWx0ZXIsICQkKSkpLFxuICAgICAgICBpc1N0YWNrTm9ybWFsaXplZCA9ICQkLmlzU3RhY2tOb3JtYWxpemVkKCksXG4gICAgICAgIHNoYXBlT2Zmc2V0VGFyZ2V0cyA9IHRhcmdldHMubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHZhciByb3dWYWx1ZXMgPSB0YXJnZXQudmFsdWVzLFxuICAgICAgICAgIHZhbHVlcyA9IHt9O1xuICAgICAgJCQuaXNTdGVwVHlwZSh0YXJnZXQpICYmIChyb3dWYWx1ZXMgPSAkJC5jb252ZXJ0VmFsdWVzVG9TdGVwKHJvd1ZhbHVlcykpO1xuICAgICAgdmFyIHJvd1ZhbHVlTWFwQnlYVmFsdWUgPSByb3dWYWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChvdXQsIGQpIHtcbiAgICAgICAgdmFyIGtleSA9ICtkLng7XG4gICAgICAgIHJldHVybiBvdXRba2V5XSA9IGQsIHZhbHVlc1trZXldID0gaXNTdGFja05vcm1hbGl6ZWQgPyAkJC5nZXRSYXRpbyhcImluZGV4XCIsIGQsICEwKSA6IGQudmFsdWUsIG91dDtcbiAgICAgIH0sIHt9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiB0YXJnZXQuaWQsXG4gICAgICAgIHJvd1ZhbHVlczogcm93VmFsdWVzLFxuICAgICAgICByb3dWYWx1ZU1hcEJ5WFZhbHVlOiByb3dWYWx1ZU1hcEJ5WFZhbHVlLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlc1xuICAgICAgfTtcbiAgICB9KSxcbiAgICAgICAgaW5kZXhNYXBCeVRhcmdldElkID0gdGFyZ2V0cy5yZWR1Y2UoZnVuY3Rpb24gKG91dCwgX3JlZiwgaW5kZXgpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYuaWQ7XG4gICAgICByZXR1cm4gb3V0W2lkXSA9IGluZGV4LCBvdXQ7XG4gICAgfSwge30pO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleE1hcEJ5VGFyZ2V0SWQ6IGluZGV4TWFwQnlUYXJnZXRJZCxcbiAgICAgIHNoYXBlT2Zmc2V0VGFyZ2V0czogc2hhcGVPZmZzZXRUYXJnZXRzXG4gICAgfTtcbiAgfSxcbiAgZ2V0U2hhcGVPZmZzZXQ6IGZ1bmN0aW9uIGdldFNoYXBlT2Zmc2V0KHR5cGVGaWx0ZXIsIGluZGljZXMsIGlzU3ViKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgXyQkJGdldFNoYXBlT2Zmc2V0RGF0ID0gJCQuZ2V0U2hhcGVPZmZzZXREYXRhKHR5cGVGaWx0ZXIpLFxuICAgICAgICBzaGFwZU9mZnNldFRhcmdldHMgPSBfJCQkZ2V0U2hhcGVPZmZzZXREYXQuc2hhcGVPZmZzZXRUYXJnZXRzLFxuICAgICAgICBpbmRleE1hcEJ5VGFyZ2V0SWQgPSBfJCQkZ2V0U2hhcGVPZmZzZXREYXQuaW5kZXhNYXBCeVRhcmdldElkO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBpZHgpIHtcbiAgICAgIHZhciBpbmQgPSAkJC5nZXRJbmRpY2VzKGluZGljZXMsIGQuaWQpLFxuICAgICAgICAgIHNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUoZC5pZCkgOiAkJC5nZXRZU2NhbGUoZC5pZCksXG4gICAgICAgICAgeTAgPSBzY2FsZSgkJC5nZXRTaGFwZVlNaW4oZC5pZCkpLFxuICAgICAgICAgIGRhdGFYQXNOdW1iZXIgPSArZC54LFxuICAgICAgICAgIG9mZnNldCA9IHkwO1xuICAgICAgcmV0dXJuIHNoYXBlT2Zmc2V0VGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQgIT09IGQuaWQ7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmIChpbmRbdC5pZF0gPT09IGluZFtkLmlkXSAmJiBpbmRleE1hcEJ5VGFyZ2V0SWRbdC5pZF0gPCBpbmRleE1hcEJ5VGFyZ2V0SWRbZC5pZF0pIHtcbiAgICAgICAgICB2YXIgcm93ID0gdC5yb3dWYWx1ZXNbaWR4XTsgLy8gY2hlY2sgaWYgdGhlIHggdmFsdWVzIGxpbmUgdXBcblxuICAgICAgICAgIHJvdyAmJiArcm93LnggPT09IGRhdGFYQXNOdW1iZXIgfHwgKHJvdyA9IHQucm93VmFsdWVNYXBCeVhWYWx1ZVtkYXRhWEFzTnVtYmVyXSksIHJvdyAmJiByb3cudmFsdWUgKiBkLnZhbHVlID49IDAgJiYgKG9mZnNldCArPSBzY2FsZSh0LnZhbHVlc1tkYXRhWEFzTnVtYmVyXSkgLSB5MCk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBvZmZzZXQ7XG4gICAgfTtcbiAgfSxcbiAgaXNXaXRoaW5TaGFwZTogZnVuY3Rpb24gaXNXaXRoaW5TaGFwZSh0aGF0LCBkKSB7XG4gICAgdmFyIGlzV2l0aGluLFxuICAgICAgICAkJCA9IHRoaXMsXG4gICAgICAgIHNoYXBlID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoYXQpO1xuICAgIHJldHVybiAkJC5pc1RhcmdldFRvU2hvdyhkLmlkKSA/ICQkLmhhc1ZhbGlkUG9pbnRUeXBlKHRoYXQubm9kZU5hbWUpID8gaXNXaXRoaW4gPSAkJC5pc1N0ZXBUeXBlKGQpID8gJCQuaXNXaXRoaW5TdGVwKHRoYXQsICQkLmdldFlTY2FsZShkLmlkKShkLnZhbHVlKSkgOiAkJC5pc1dpdGhpbkNpcmNsZSh0aGF0LCAkJC5pc0J1YmJsZVR5cGUoZCkgPyAkJC5wb2ludFNlbGVjdFIoZCkgKiAxLjUgOiAwKSA6IHRoYXQubm9kZU5hbWUgPT09IFwicGF0aFwiICYmIChpc1dpdGhpbiA9ICFzaGFwZS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmJhcikgfHwgJCQuaXNXaXRoaW5CYXIodGhhdCkpIDogaXNXaXRoaW4gPSAhMSwgaXNXaXRoaW47XG4gIH0sXG4gIGdldEludGVycG9sYXRlOiBmdW5jdGlvbiBnZXRJbnRlcnBvbGF0ZShkKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgaW50ZXJwb2xhdGlvbiA9ICQkLmdldEludGVycG9sYXRlVHlwZShkKTtcbiAgICByZXR1cm4ge1xuICAgICAgXCJiYXNpc1wiOiBleHRlcm5hbF9jb21tb25qc19kM19zaGFwZV9jb21tb25qczJfZDNfc2hhcGVfYW1kX2QzX3NoYXBlX3Jvb3RfZDNfW1wiY3VydmVCYXNpc1wiXSxcbiAgICAgIFwiYmFzaXMtY2xvc2VkXCI6IGV4dGVybmFsX2NvbW1vbmpzX2QzX3NoYXBlX2NvbW1vbmpzMl9kM19zaGFwZV9hbWRfZDNfc2hhcGVfcm9vdF9kM19bXCJjdXJ2ZUJhc2lzQ2xvc2VkXCJdLFxuICAgICAgXCJiYXNpcy1vcGVuXCI6IGV4dGVybmFsX2NvbW1vbmpzX2QzX3NoYXBlX2NvbW1vbmpzMl9kM19zaGFwZV9hbWRfZDNfc2hhcGVfcm9vdF9kM19bXCJjdXJ2ZUJhc2lzT3BlblwiXSxcbiAgICAgIFwiYnVuZGxlXCI6IGV4dGVybmFsX2NvbW1vbmpzX2QzX3NoYXBlX2NvbW1vbmpzMl9kM19zaGFwZV9hbWRfZDNfc2hhcGVfcm9vdF9kM19bXCJjdXJ2ZUJ1bmRsZVwiXSxcbiAgICAgIFwiY2FyZGluYWxcIjogZXh0ZXJuYWxfY29tbW9uanNfZDNfc2hhcGVfY29tbW9uanMyX2QzX3NoYXBlX2FtZF9kM19zaGFwZV9yb290X2QzX1tcImN1cnZlQ2FyZGluYWxcIl0sXG4gICAgICBcImNhcmRpbmFsLWNsb3NlZFwiOiBleHRlcm5hbF9jb21tb25qc19kM19zaGFwZV9jb21tb25qczJfZDNfc2hhcGVfYW1kX2QzX3NoYXBlX3Jvb3RfZDNfW1wiY3VydmVDYXJkaW5hbENsb3NlZFwiXSxcbiAgICAgIFwiY2FyZGluYWwtb3BlblwiOiBleHRlcm5hbF9jb21tb25qc19kM19zaGFwZV9jb21tb25qczJfZDNfc2hhcGVfYW1kX2QzX3NoYXBlX3Jvb3RfZDNfW1wiY3VydmVDYXJkaW5hbE9wZW5cIl0sXG4gICAgICBcImNhdG11bGwtcm9tXCI6IGV4dGVybmFsX2NvbW1vbmpzX2QzX3NoYXBlX2NvbW1vbmpzMl9kM19zaGFwZV9hbWRfZDNfc2hhcGVfcm9vdF9kM19bXCJjdXJ2ZUNhdG11bGxSb21cIl0sXG4gICAgICBcImNhdG11bGwtcm9tLWNsb3NlZFwiOiBleHRlcm5hbF9jb21tb25qc19kM19zaGFwZV9jb21tb25qczJfZDNfc2hhcGVfYW1kX2QzX3NoYXBlX3Jvb3RfZDNfW1wiY3VydmVDYXRtdWxsUm9tQ2xvc2VkXCJdLFxuICAgICAgXCJjYXRtdWxsLXJvbS1vcGVuXCI6IGV4dGVybmFsX2NvbW1vbmpzX2QzX3NoYXBlX2NvbW1vbmpzMl9kM19zaGFwZV9hbWRfZDNfc2hhcGVfcm9vdF9kM19bXCJjdXJ2ZUNhdG11bGxSb21PcGVuXCJdLFxuICAgICAgXCJtb25vdG9uZS14XCI6IGV4dGVybmFsX2NvbW1vbmpzX2QzX3NoYXBlX2NvbW1vbmpzMl9kM19zaGFwZV9hbWRfZDNfc2hhcGVfcm9vdF9kM19bXCJjdXJ2ZU1vbm90b25lWFwiXSxcbiAgICAgIFwibW9ub3RvbmUteVwiOiBleHRlcm5hbF9jb21tb25qc19kM19zaGFwZV9jb21tb25qczJfZDNfc2hhcGVfYW1kX2QzX3NoYXBlX3Jvb3RfZDNfW1wiY3VydmVNb25vdG9uZVlcIl0sXG4gICAgICBcIm5hdHVyYWxcIjogZXh0ZXJuYWxfY29tbW9uanNfZDNfc2hhcGVfY29tbW9uanMyX2QzX3NoYXBlX2FtZF9kM19zaGFwZV9yb290X2QzX1tcImN1cnZlTmF0dXJhbFwiXSxcbiAgICAgIFwibGluZWFyLWNsb3NlZFwiOiBleHRlcm5hbF9jb21tb25qc19kM19zaGFwZV9jb21tb25qczJfZDNfc2hhcGVfYW1kX2QzX3NoYXBlX3Jvb3RfZDNfW1wiY3VydmVMaW5lYXJDbG9zZWRcIl0sXG4gICAgICBcImxpbmVhclwiOiBleHRlcm5hbF9jb21tb25qc19kM19zaGFwZV9jb21tb25qczJfZDNfc2hhcGVfYW1kX2QzX3NoYXBlX3Jvb3RfZDNfW1wiY3VydmVMaW5lYXJcIl0sXG4gICAgICBcInN0ZXBcIjogZXh0ZXJuYWxfY29tbW9uanNfZDNfc2hhcGVfY29tbW9uanMyX2QzX3NoYXBlX2FtZF9kM19zaGFwZV9yb290X2QzX1tcImN1cnZlU3RlcFwiXSxcbiAgICAgIFwic3RlcC1hZnRlclwiOiBleHRlcm5hbF9jb21tb25qc19kM19zaGFwZV9jb21tb25qczJfZDNfc2hhcGVfYW1kX2QzX3NoYXBlX3Jvb3RfZDNfW1wiY3VydmVTdGVwQWZ0ZXJcIl0sXG4gICAgICBcInN0ZXAtYmVmb3JlXCI6IGV4dGVybmFsX2NvbW1vbmpzX2QzX3NoYXBlX2NvbW1vbmpzMl9kM19zaGFwZV9hbWRfZDNfc2hhcGVfcm9vdF9kM19bXCJjdXJ2ZVN0ZXBCZWZvcmVcIl1cbiAgICB9W2ludGVycG9sYXRpb25dO1xuICB9LFxuICBnZXRJbnRlcnBvbGF0ZVR5cGU6IGZ1bmN0aW9uIGdldEludGVycG9sYXRlVHlwZShkKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgdHlwZSA9ICQkLmNvbmZpZy5zcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlLFxuICAgICAgICBpbnRlcnBvbGF0aW9uID0gJCQuaXNJbnRlcnBvbGF0aW9uVHlwZSh0eXBlKSA/IHR5cGUgOiBcImNhcmRpbmFsXCI7XG4gICAgcmV0dXJuICQkLmlzU3BsaW5lVHlwZShkKSA/IGludGVycG9sYXRpb24gOiAkJC5pc1N0ZXBUeXBlKGQpID8gJCQuY29uZmlnLmxpbmVfc3RlcF90eXBlIDogXCJsaW5lYXJcIjtcbiAgfVxufSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1pbnRlcnBvbGF0ZVwiLFwiY29tbW9uanMyXCI6XCJkMy1pbnRlcnBvbGF0ZVwiLFwiYW1kXCI6XCJkMy1pbnRlcnBvbGF0ZVwiLFwicm9vdFwiOlwiZDNcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc19kM19pbnRlcnBvbGF0ZV9jb21tb25qczJfZDNfaW50ZXJwb2xhdGVfYW1kX2QzX2ludGVycG9sYXRlX3Jvb3RfZDNfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3NoYXBlL2FyYy5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuXG5cblxuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICBpbml0UGllOiBmdW5jdGlvbiBpbml0UGllKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgZGF0YVR5cGUgPSBjb25maWcuZGF0YV90eXBlLFxuICAgICAgICBwYWRkaW5nID0gY29uZmlnLnBpZV9wYWRkaW5nLFxuICAgICAgICBzdGFydGluZ0FuZ2xlID0gY29uZmlnW1wiXCIuY29uY2F0KGRhdGFUeXBlLCBcIl9zdGFydGluZ0FuZ2xlXCIpXSB8fCAwLFxuICAgICAgICBwYWRBbmdsZSA9ICgkJC5oYXNUeXBlKFwicGllXCIpICYmIHBhZGRpbmcgPyBwYWRkaW5nICogLjAxIDogY29uZmlnW1wiXCIuY29uY2F0KGRhdGFUeXBlLCBcIl9wYWRBbmdsZVwiKV0pIHx8IDA7XG4gICAgJCQucGllID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NoYXBlX2NvbW1vbmpzMl9kM19zaGFwZV9hbWRfZDNfc2hhcGVfcm9vdF9kM19bXCJwaWVcIl0pKCkuc3RhcnRBbmdsZShzdGFydGluZ0FuZ2xlKS5lbmRBbmdsZShzdGFydGluZ0FuZ2xlICsgMiAqIE1hdGguUEkpLnBhZEFuZ2xlKHBhZEFuZ2xlKS5zb3J0VmFsdWVzKCQkLmlzT3JkZXJBc2MoKSB8fCAkJC5pc09yZGVyRGVzYygpID8gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiAkJC5pc09yZGVyQXNjKCkgPyBhIC0gYiA6IGIgLSBhO1xuICAgIH0gOiBudWxsKS52YWx1ZShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQudmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSArIGIudmFsdWU7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcbiAgfSxcbiAgdXBkYXRlUmFkaXVzOiBmdW5jdGlvbiB1cGRhdGVSYWRpdXMoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICByYWRpdXMgPSBjb25maWcucGllX2lubmVyUmFkaXVzLFxuICAgICAgICBwYWRkaW5nID0gY29uZmlnLnBpZV9wYWRkaW5nLFxuICAgICAgICB3ID0gY29uZmlnLmdhdWdlX3dpZHRoIHx8IGNvbmZpZy5kb251dF93aWR0aCxcbiAgICAgICAgZ2F1Z2VBcmNXaWR0aCA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGggKiBjb25maWcuZ2F1Z2VfYXJjc19taW5XaWR0aDtcbiAgICAkJC5yYWRpdXNFeHBhbmRlZCA9IE1hdGgubWluKCQkLmFyY1dpZHRoLCAkJC5hcmNIZWlnaHQpIC8gMiAqICgkJC5oYXNNdWx0aUFyY0dhdWdlKCkgPyAuODUgOiAxKSwgJCQucmFkaXVzID0gJCQucmFkaXVzRXhwYW5kZWQgKiAuOTUsICQkLmlubmVyUmFkaXVzUmF0aW8gPSB3ID8gKCQkLnJhZGl1cyAtIHcpIC8gJCQucmFkaXVzIDogLjYsICQkLmdhdWdlQXJjV2lkdGggPSB3IHx8IChnYXVnZUFyY1dpZHRoIDw9ICQkLnJhZGl1cyAtICQkLmlubmVyUmFkaXVzID8gJCQucmFkaXVzIC0gJCQuaW5uZXJSYWRpdXMgOiBnYXVnZUFyY1dpZHRoIDw9ICQkLnJhZGl1cyA/IGdhdWdlQXJjV2lkdGggOiAkJC5yYWRpdXMpO1xuICAgIHZhciBpbm5lclJhZGl1cyA9IHJhZGl1cyB8fCAocGFkZGluZyA/IHBhZGRpbmcgKiAoJCQuaW5uZXJSYWRpdXNSYXRpbyArIC4xKSA6IDApOyAvLyBOT1RFOiBpbm5lclJhZGl1cyBjYW4gYmUgYW4gb2JqZWN0IGJ5IHVzZXIgc2V0dGluZywgb25seSBmb3IgJ3BpZScgdHlwZVxuXG4gICAgJCQuaW5uZXJSYWRpdXMgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgfHwgJCQuaGFzVHlwZShcImdhdWdlXCIpID8gJCQucmFkaXVzICogJCQuaW5uZXJSYWRpdXNSYXRpbyA6IGlubmVyUmFkaXVzO1xuICB9LFxuICBnZXRJbm5lclJhZGl1czogZnVuY3Rpb24gZ2V0SW5uZXJSYWRpdXMoZCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHJhZGl1cyA9ICQkLmlubmVyUmFkaXVzO1xuICAgIHJldHVybiAhaXNOdW1iZXIocmFkaXVzKSAmJiBkICYmIChyYWRpdXMgPSByYWRpdXNbZC5kYXRhLmlkXSB8fCAwKSwgcmFkaXVzO1xuICB9LFxuICB1cGRhdGVBcmM6IGZ1bmN0aW9uIHVwZGF0ZUFyYygpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgICQkLnN2Z0FyYyA9ICQkLmdldFN2Z0FyYygpLCAkJC5zdmdBcmNFeHBhbmRlZCA9ICQkLmdldFN2Z0FyY0V4cGFuZGVkKCk7XG4gIH0sXG4gIHVwZGF0ZUFuZ2xlOiBmdW5jdGlvbiB1cGRhdGVBbmdsZShkVmFsdWUpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIHBpZSA9ICQkLnBpZSxcbiAgICAgICAgZCA9IGRWYWx1ZSxcbiAgICAgICAgZm91bmQgPSAhMTtcbiAgICBpZiAoIWNvbmZpZykgcmV0dXJuIG51bGw7XG4gICAgdmFyIHJhZGl1cyA9IE1hdGguUEkgKiAoY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAyIDogMSksXG4gICAgICAgIGdTdGFydCA9IGNvbmZpZy5nYXVnZV9zdGFydGluZ0FuZ2xlO1xuXG4gICAgaWYgKGQuZGF0YSAmJiAkJC5pc0dhdWdlVHlwZShkLmRhdGEpICYmICEkJC5oYXNNdWx0aUFyY0dhdWdlKCkpIHtcbiAgICAgIC8vIHRvIHByZXZlbnQgZXhjbHVkaW5nIHRvdGFsIGRhdGEgc3VtIGR1cmluZyB0aGUgaW5pdCh3aGVuIGRhdGEuaGlkZSBvcHRpb24gaXMgdXNlZCksIHVzZSAkJC5yZW5kZXJlZCBzdGF0ZSB2YWx1ZVxuICAgICAgdmFyIHRvdGFsU3VtID0gJCQuZ2V0VG90YWxEYXRhU3VtKCQkLnJlbmRlcmVkKTsgLy8gaWYgZ2F1Z2VfbWF4IGxlc3MgdGhhbiB0b3RhbFN1bSwgbWFrZSB0b3RhbFN1bSB0byBtYXggdmFsdWVcblxuICAgICAgdG90YWxTdW0gPiBjb25maWcuZ2F1Z2VfbWF4ICYmIChjb25maWcuZ2F1Z2VfbWF4ID0gdG90YWxTdW0pO1xuICAgICAgdmFyIGdFbmQgPSByYWRpdXMgKiAodG90YWxTdW0gLyAoY29uZmlnLmdhdWdlX21heCAtIGNvbmZpZy5nYXVnZV9taW4pKTtcbiAgICAgIHBpZSA9IHBpZS5zdGFydEFuZ2xlKGdTdGFydCkuZW5kQW5nbGUoZ0VuZCArIGdTdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKHBpZSgkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCkpLmZvckVhY2goZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgIGZvdW5kIHx8IHQuZGF0YS5pZCAhPT0gZC5kYXRhLmlkIHx8IChmb3VuZCA9ICEwLCBkID0gdCwgZC5pbmRleCA9IGkpO1xuICAgIH0pLCBpc05hTihkLnN0YXJ0QW5nbGUpICYmIChkLnN0YXJ0QW5nbGUgPSAwKSwgaXNOYU4oZC5lbmRBbmdsZSkgJiYgKGQuZW5kQW5nbGUgPSBkLnN0YXJ0QW5nbGUpLCBkLmRhdGEgJiYgJCQuaGFzTXVsdGlBcmNHYXVnZSgpKSB7XG4gICAgICB2YXIgbWF4VmFsdWUgPSAkJC5nZXRNaW5NYXhEYXRhKCkubWF4WzBdLnZhbHVlOyAvLyBpZiBnYXVnZV9tYXggbGVzcyB0aGFuIG1heFZhbHVlLCBtYWtlIG1heFZhbHVlIHRvIG1heCB2YWx1ZVxuXG4gICAgICBtYXhWYWx1ZSA+IGNvbmZpZy5nYXVnZV9tYXggJiYgKGNvbmZpZy5nYXVnZV9tYXggPSBtYXhWYWx1ZSk7XG4gICAgICB2YXIgZ01pbiA9IGNvbmZpZy5nYXVnZV9taW4sXG4gICAgICAgICAgZ01heCA9IGNvbmZpZy5nYXVnZV9tYXgsXG4gICAgICAgICAgZ1ZhbHVlID0gZC52YWx1ZSA8IGdNaW4gPyAwIDogZC52YWx1ZSA8IGdNYXggPyBkLnZhbHVlIC0gZ01pbiA6IGdNYXggLSBnTWluO1xuICAgICAgZC5zdGFydEFuZ2xlID0gZ1N0YXJ0LCBkLmVuZEFuZ2xlID0gZ1N0YXJ0ICsgcmFkaXVzIC8gKGdNYXggLSBnTWluKSAqIGdWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmQgPyBkIDogbnVsbDtcbiAgfSxcbiAgZ2V0U3ZnQXJjOiBmdW5jdGlvbiBnZXRTdmdBcmMoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgaXIgPSAkJC5nZXRJbm5lclJhZGl1cygpLFxuICAgICAgICBzaW5nbGVBcmNXaWR0aCA9ICQkLmdhdWdlQXJjV2lkdGggLyAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoLFxuICAgICAgICBoYXNNdWx0aUFyY0dhdWdlID0gJCQuaGFzTXVsdGlBcmNHYXVnZSgpLFxuICAgICAgICBhcmMgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2hhcGVfY29tbW9uanMyX2QzX3NoYXBlX2FtZF9kM19zaGFwZV9yb290X2QzX1tcImFyY1wiXSkoKS5vdXRlclJhZGl1cyhmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGhhc011bHRpQXJjR2F1Z2UgPyAkJC5yYWRpdXMgLSBzaW5nbGVBcmNXaWR0aCAqIGQuaW5kZXggOiAkJC5yYWRpdXM7XG4gICAgfSkuaW5uZXJSYWRpdXMoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBoYXNNdWx0aUFyY0dhdWdlID8gJCQucmFkaXVzIC0gc2luZ2xlQXJjV2lkdGggKiAoZC5pbmRleCArIDEpIDogaXNOdW1iZXIoaXIpID8gaXIgOiAwO1xuICAgIH0pLFxuICAgICAgICBuZXdBcmMgPSBmdW5jdGlvbiAoZCwgd2l0aG91dFVwZGF0ZSkge1xuICAgICAgdmFyIHBhdGggPSBcIk0gMCAwXCI7XG5cbiAgICAgIGlmIChkLnZhbHVlIHx8IGQuZGF0YSkge1xuICAgICAgICBpc051bWJlcihpcikgfHwgKGFyYyA9IGFyYy5pbm5lclJhZGl1cygkJC5nZXRJbm5lclJhZGl1cyhkKSkpO1xuICAgICAgICB2YXIgdXBkYXRlZCA9ICF3aXRob3V0VXBkYXRlICYmICQkLnVwZGF0ZUFuZ2xlKGQpO1xuICAgICAgICB3aXRob3V0VXBkYXRlID8gcGF0aCA9IGFyYyhkKSA6IHVwZGF0ZWQgJiYgKHBhdGggPSBhcmModXBkYXRlZCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ld0FyYy5jZW50cm9pZCA9IGFyYy5jZW50cm9pZCwgbmV3QXJjO1xuICB9LFxuICBnZXRTdmdBcmNFeHBhbmRlZDogZnVuY3Rpb24gZ2V0U3ZnQXJjRXhwYW5kZWQocmF0ZSkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIG5ld1JhdGUgPSByYXRlIHx8IDEsXG4gICAgICAgIHNpbmdsZUFyY1dpZHRoID0gJCQuZ2F1Z2VBcmNXaWR0aCAvICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGgsXG4gICAgICAgIGhhc011bHRpQXJjR2F1Z2UgPSAkJC5oYXNNdWx0aUFyY0dhdWdlKCksXG4gICAgICAgIGV4cGFuZFdpZHRoID0gTWF0aC5taW4oJCQucmFkaXVzRXhwYW5kZWQgKiBuZXdSYXRlIC0gJCQucmFkaXVzLCBzaW5nbGVBcmNXaWR0aCAqIC44IC0gKDEgLSBuZXdSYXRlKSAqIDEwMCksXG4gICAgICAgIGFyYyA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zaGFwZV9jb21tb25qczJfZDNfc2hhcGVfYW1kX2QzX3NoYXBlX3Jvb3RfZDNfW1wiYXJjXCJdKSgpLm91dGVyUmFkaXVzKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gaGFzTXVsdGlBcmNHYXVnZSA/ICQkLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogZC5pbmRleCArIGV4cGFuZFdpZHRoIDogJCQucmFkaXVzRXhwYW5kZWQgKiBuZXdSYXRlO1xuICAgIH0pLmlubmVyUmFkaXVzKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gaGFzTXVsdGlBcmNHYXVnZSA/ICQkLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogKGQuaW5kZXggKyAxKSA6ICQkLmlubmVyUmFkaXVzO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcbiAgICAgIHJldHVybiB1cGRhdGVkID8gKGhhc011bHRpQXJjR2F1Z2UgPyBhcmMgOiBhcmMuaW5uZXJSYWRpdXMoJCQuZ2V0SW5uZXJSYWRpdXMoZCkpKSh1cGRhdGVkKSA6IFwiTSAwIDBcIjtcbiAgICB9O1xuICB9LFxuICBnZXRBcmM6IGZ1bmN0aW9uIGdldEFyYyhkLCB3aXRob3V0VXBkYXRlLCBmb3JjZSkge1xuICAgIHJldHVybiBmb3JjZSB8fCB0aGlzLmlzQXJjVHlwZShkLmRhdGEpID8gdGhpcy5zdmdBcmMoZCwgd2l0aG91dFVwZGF0ZSkgOiBcIk0gMCAwXCI7XG4gIH0sXG4gIHRyYW5zZm9ybUZvckFyY0xhYmVsOiBmdW5jdGlvbiB0cmFuc2Zvcm1Gb3JBcmNMYWJlbChkKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCksXG4gICAgICAgIHRyYW5zbGF0ZSA9IFwiXCI7XG4gICAgaWYgKHVwZGF0ZWQpIGlmICgkJC5oYXNNdWx0aUFyY0dhdWdlKCkpIHtcbiAgICAgIHZhciB5MSA9IE1hdGguc2luKHVwZGF0ZWQuZW5kQW5nbGUgLSBNYXRoLlBJIC8gMiksXG4gICAgICAgICAgeCA9IE1hdGguY29zKHVwZGF0ZWQuZW5kQW5nbGUgLSBNYXRoLlBJIC8gMikgKiAoJCQucmFkaXVzRXhwYW5kZWQgKyAyNSksXG4gICAgICAgICAgeSA9IHkxICogKCQkLnJhZGl1c0V4cGFuZGVkICsgMTUgLSBNYXRoLmFicyh5MSAqIDEwKSkgKyAzO1xuICAgICAgdHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHgsIFwiLFwiKS5jb25jYXQoeSwgXCIpXCIpO1xuICAgIH0gZWxzZSBpZiAoISQkLmhhc1R5cGUoXCJnYXVnZVwiKSB8fCAkJC5kYXRhLnRhcmdldHMubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGMgPSB0aGlzLnN2Z0FyYy5jZW50cm9pZCh1cGRhdGVkKSxcbiAgICAgICAgICB4ID0gaXNOYU4oY1swXSkgPyAwIDogY1swXSxcbiAgICAgICAgICB5ID0gaXNOYU4oY1sxXSkgPyAwIDogY1sxXSxcbiAgICAgICAgICBoID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpLFxuICAgICAgICAgIHJhdGlvID0gJCQuaGFzVHlwZShcImRvbnV0XCIpICYmIGNvbmZpZy5kb251dF9sYWJlbF9yYXRpbyB8fCAkJC5oYXNUeXBlKFwicGllXCIpICYmIGNvbmZpZy5waWVfbGFiZWxfcmF0aW87XG4gICAgICByYXRpbyA9IHJhdGlvID8gaXNGdW5jdGlvbihyYXRpbykgPyByYXRpbyhkLCAkJC5yYWRpdXMsIGgpIDogcmF0aW8gOiAkJC5yYWRpdXMgJiYgKGggPyAoMzYgLyAkJC5yYWRpdXMgPiAuMzc1ID8gMS4xNzUgLSAzNiAvICQkLnJhZGl1cyA6IC44KSAqICQkLnJhZGl1cyAvIGggOiAwKSwgdHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHggKiByYXRpbywgXCIsXCIpLmNvbmNhdCh5ICogcmF0aW8sIFwiKVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zbGF0ZTtcbiAgfSxcbiAgY29udmVydFRvQXJjRGF0YTogZnVuY3Rpb24gY29udmVydFRvQXJjRGF0YShkKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTmFtZSh7XG4gICAgICBpZDogZC5kYXRhLmlkLFxuICAgICAgdmFsdWU6IGQudmFsdWUsXG4gICAgICByYXRpbzogdGhpcy5nZXRSYXRpbyhcImFyY1wiLCBkKSxcbiAgICAgIGluZGV4OiBkLmluZGV4XG4gICAgfSk7XG4gIH0sXG4gIHRleHRGb3JBcmNMYWJlbDogZnVuY3Rpb24gdGV4dEZvckFyY0xhYmVsKHNlbGVjdGlvbikge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xuICAgICQkLnNob3VsZFNob3dBcmNMYWJlbCgpICYmIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgbm9kZSA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKSh0aGlzKSxcbiAgICAgICAgICB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCksXG4gICAgICAgICAgcmF0aW8gPSAkJC5nZXRSYXRpbyhcImFyY1wiLCB1cGRhdGVkKSxcbiAgICAgICAgICBpc1VuZGVyVGhyZXNob2xkID0gaGFzR2F1Z2UgfHwgJCQubWVldHNBcmNMYWJlbFRocmVzaG9sZChyYXRpbyk7XG5cbiAgICAgIGlmIChpc1VuZGVyVGhyZXNob2xkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICh1cGRhdGVkIHx8IGQpLnZhbHVlLFxuICAgICAgICAgICAgdGV4dCA9ICgkJC5nZXRBcmNMYWJlbEZvcm1hdCgpIHx8ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdCkodmFsdWUsIHJhdGlvLCBkLmRhdGEuaWQpLnRvU3RyaW5nKCk7XG4gICAgICAgIHNldFRleHRWYWx1ZShub2RlLCB0ZXh0LCBbLTEsIDFdLCBoYXNHYXVnZSk7XG4gICAgICB9IGVsc2Ugbm9kZS50ZXh0KFwiXCIpO1xuICAgIH0pO1xuICB9LFxuICB0ZXh0Rm9yR2F1Z2VNaW5NYXg6IGZ1bmN0aW9uIHRleHRGb3JHYXVnZU1pbk1heCh2YWx1ZSwgaXNNYXgpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5nZXRHYXVnZUxhYmVsRXh0ZW50cygpO1xuICAgIHJldHVybiBmb3JtYXQgPyBmb3JtYXQodmFsdWUsIGlzTWF4KSA6IHZhbHVlO1xuICB9LFxuICBleHBhbmRBcmM6IGZ1bmN0aW9uIGV4cGFuZEFyYyh0YXJnZXRJZHMpIHtcbiAgICB2YXIgJCQgPSB0aGlzOyAvLyBNRU1POiBhdm9pZCB0byBjYW5jZWwgdHJhbnNpdGlvblxuXG4gICAgaWYgKCQkLnRyYW5zaXRpbmcpIHtcbiAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCQudHJhbnNpdGluZyB8fCAoY2xlYXJJbnRlcnZhbChpbnRlcnZhbCksICQkLmxlZ2VuZC5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmxlZ2VuZEl0ZW1Gb2N1c2VkKSkuc2l6ZSgpID4gMCAmJiAkJC5leHBhbmRBcmModGFyZ2V0SWRzKSk7XG4gICAgICB9LCAxMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5ld1RhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XG4gICAgJCQuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHMobmV3VGFyZ2V0SWRzLCBcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2hhcnRBcmMpKSkuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKCQkLnNob3VsZEV4cGFuZChkLmRhdGEuaWQpKSB7XG4gICAgICAgIHZhciBleHBhbmREdXJhdGlvbiA9ICQkLmdldEV4cGFuZENvbmZpZyhkLmRhdGEuaWQsIFwiZHVyYXRpb25cIiksXG4gICAgICAgICAgICBzdmdBcmNFeHBhbmRlZFN1YiA9ICQkLmdldFN2Z0FyY0V4cGFuZGVkKCQkLmdldEV4cGFuZENvbmZpZyhkLmRhdGEuaWQsIFwicmF0ZVwiKSk7XG4gICAgICAgIE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKSh0aGlzKS5zZWxlY3RBbGwoXCJwYXRoXCIpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihleHBhbmREdXJhdGlvbikuYXR0cihcImRcIiwgJCQuc3ZnQXJjRXhwYW5kZWQpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihleHBhbmREdXJhdGlvbiAqIDIpLmF0dHIoXCJkXCIsIHN2Z0FyY0V4cGFuZGVkU3ViKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgdW5leHBhbmRBcmM6IGZ1bmN0aW9uIHVuZXhwYW5kQXJjKHRhcmdldElkcykge1xuICAgIHZhciAkJCA9IHRoaXM7XG5cbiAgICBpZiAoISQkLnRyYW5zaXRpbmcpIHtcbiAgICAgIHZhciBuZXdUYXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpO1xuICAgICAgJCQuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHMobmV3VGFyZ2V0SWRzLCBcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2hhcnRBcmMpKSkuc2VsZWN0QWxsKFwicGF0aFwiKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuICQkLmdldEV4cGFuZENvbmZpZyhkLmRhdGEuaWQsIFwiZHVyYXRpb25cIik7XG4gICAgICB9KS5hdHRyKFwiZFwiLCAkJC5zdmdBcmMpLCAkJC5zdmcuc2VsZWN0QWxsKFwiXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmFyYykpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgZXhwYW5kIGNvbmZpZyB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgZGF0YSBJRFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IGNvbmZpZyBrZXk6ICdkdXJhdGlvbiB8IHJhdGUnXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEV4cGFuZENvbmZpZzogZnVuY3Rpb24gZ2V0RXhwYW5kQ29uZmlnKGlkLCBrZXkpIHtcbiAgICB2YXIgdHlwZSxcbiAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgcmV0dXJuICQkLmlzRG9udXRUeXBlKGlkKSA/IHR5cGUgPSBcImRvbnV0XCIgOiAkJC5pc0dhdWdlVHlwZShpZCkgPyB0eXBlID0gXCJnYXVnZVwiIDogJCQuaXNQaWVUeXBlKGlkKSAmJiAodHlwZSA9IFwicGllXCIpLCB0eXBlID8gY29uZmlnW1wiXCIuY29uY2F0KHR5cGUsIFwiX2V4cGFuZF9cIikuY29uY2F0KGtleSldIDoge1xuICAgICAgZHVyYXRpb246IDUwLFxuICAgICAgcmF0ZTogLjk4XG4gICAgfVtrZXldO1xuICB9LFxuICBzaG91bGRFeHBhbmQ6IGZ1bmN0aW9uIHNob3VsZEV4cGFuZChpZCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICByZXR1cm4gJCQuaXNEb251dFR5cGUoaWQpICYmIGNvbmZpZy5kb251dF9leHBhbmQgfHwgJCQuaXNHYXVnZVR5cGUoaWQpICYmIGNvbmZpZy5nYXVnZV9leHBhbmQgfHwgJCQuaXNQaWVUeXBlKGlkKSAmJiBjb25maWcucGllX2V4cGFuZDtcbiAgfSxcbiAgc2hvdWxkU2hvd0FyY0xhYmVsOiBmdW5jdGlvbiBzaG91bGRTaG93QXJjTGFiZWwoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgIHJldHVybiBbXCJwaWVcIiwgXCJkb251dFwiLCBcImdhdWdlXCJdLnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiAkJC5oYXNUeXBlKHYpICYmIGNvbmZpZ1tcIlwiLmNvbmNhdCh2LCBcIl9sYWJlbF9zaG93XCIpXTtcbiAgICB9KTtcbiAgfSxcbiAgbWVldHNBcmNMYWJlbFRocmVzaG9sZDogZnVuY3Rpb24gbWVldHNBcmNMYWJlbFRocmVzaG9sZChyYXRpbykge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgdGhyZXNob2xkID0gJCQuaGFzVHlwZShcImRvbnV0XCIpID8gY29uZmlnLmRvbnV0X2xhYmVsX3RocmVzaG9sZCA6IGNvbmZpZy5waWVfbGFiZWxfdGhyZXNob2xkO1xuICAgIHJldHVybiByYXRpbyA+PSB0aHJlc2hvbGQ7XG4gIH0sXG4gIGdldEFyY0xhYmVsRm9ybWF0OiBmdW5jdGlvbiBnZXRBcmNMYWJlbEZvcm1hdCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGZvcm1hdCA9IGNvbmZpZy5waWVfbGFiZWxfZm9ybWF0O1xuICAgIHJldHVybiAkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgPyBmb3JtYXQgPSBjb25maWcuZ2F1Z2VfbGFiZWxfZm9ybWF0IDogJCQuaGFzVHlwZShcImRvbnV0XCIpICYmIChmb3JtYXQgPSBjb25maWcuZG9udXRfbGFiZWxfZm9ybWF0KSwgZm9ybWF0O1xuICB9LFxuICBnZXRHYXVnZUxhYmVsRXh0ZW50czogZnVuY3Rpb24gZ2V0R2F1Z2VMYWJlbEV4dGVudHMoKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIHJldHVybiBjb25maWcuZ2F1Z2VfbGFiZWxfZXh0ZW50cztcbiAgfSxcbiAgZ2V0QXJjVGl0bGU6IGZ1bmN0aW9uIGdldEFyY1RpdGxlKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHR5cGUgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgJiYgXCJkb251dFwiIHx8ICQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiBcImdhdWdlXCI7XG4gICAgcmV0dXJuIHR5cGUgPyAkJC5jb25maWdbXCJcIi5jb25jYXQodHlwZSwgXCJfdGl0bGVcIildIDogXCJcIjtcbiAgfSxcbiAgdXBkYXRlVGFyZ2V0c0ZvckFyYzogZnVuY3Rpb24gdXBkYXRlVGFyZ2V0c0ZvckFyYyh0YXJnZXRzKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgbWFpbiA9ICQkLm1haW4sXG4gICAgICAgIGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpLFxuICAgICAgICBjbGFzc0NoYXJ0QXJjID0gJCQuY2xhc3NDaGFydEFyYy5iaW5kKCQkKSxcbiAgICAgICAgY2xhc3NBcmNzID0gJCQuY2xhc3NBcmNzLmJpbmQoJCQpLFxuICAgICAgICBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKSxcbiAgICAgICAgbWFpblBpZVVwZGF0ZSA9IG1haW4uc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaGFydEFyY3MpKS5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0QXJjKSkuZGF0YSgkJC5waWUodGFyZ2V0cykpLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGNsYXNzQ2hhcnRBcmMoZCkgKyBjbGFzc0ZvY3VzKGQuZGF0YSk7XG4gICAgfSksXG4gICAgICAgIG1haW5QaWVFbnRlciA9IG1haW5QaWVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QXJjKTtcbiAgICBtYWluUGllRW50ZXIuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NBcmNzKS5tZXJnZShtYWluUGllVXBkYXRlKSwgbWFpblBpZUVudGVyLmFwcGVuZChcInRleHRcIikuYXR0cihcImR5XCIsIGhhc0dhdWdlICYmICEkJC5oYXNNdWx0aVRhcmdldHMoKSA/IFwiLS4xZW1cIiA6IFwiLjM1ZW1cIikuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICB9LFxuICBpbml0QXJjOiBmdW5jdGlvbiBpbml0QXJjKCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgJCQuYXJjcyA9ICQkLm1haW4uc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaGFydCkpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLmNoYXJ0QXJjcykuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJhcmNcIikpLCAkJC5zZXRBcmNUaXRsZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgYXJjIHRpdGxlIHRleHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldEFyY1RpdGxlOiBmdW5jdGlvbiBzZXRBcmNUaXRsZSgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICB0aXRsZSA9ICQkLmdldEFyY1RpdGxlKCksXG4gICAgICAgIGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xuXG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICB2YXIgdGV4dCA9ICQkLmFyY3MuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiY2xhc3NcIiwgY29uZmlnX2NsYXNzZXNbaGFzR2F1Z2UgPyBcImNoYXJ0QXJjc0dhdWdlVGl0bGVcIiA6IFwiY2hhcnRBcmNzVGl0bGVcIl0pLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG4gICAgICBoYXNHYXVnZSAmJiB0ZXh0LmF0dHIoXCJkeVwiLCBcIi0wLjNlbVwiKS5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjI3cHhcIiksIHNldFRleHRWYWx1ZSh0ZXh0LCB0aXRsZSwgaGFzR2F1Z2UgPyB1bmRlZmluZWQgOiBbLS42LCAxLjM1XSwgITApO1xuICAgIH1cbiAgfSxcbiAgcmVkcmF3QXJjOiBmdW5jdGlvbiByZWRyYXdBcmMoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCwgd2l0aFRyYW5zZm9ybSkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgbWFpbiA9ICQkLm1haW4sXG4gICAgICAgIGhhc0ludGVyYWN0aW9uID0gY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQsXG4gICAgICAgIG1haW5BcmMgPSBtYWluLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYXJjcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYXJjKSkuZGF0YSgkJC5hcmNEYXRhLmJpbmQoJCQpKTtcbiAgICAvLyBiaW5kIGFyYyBldmVudHNcbiAgICBtYWluQXJjLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLnJlbW92ZSgpLCBtYWluQXJjID0gbWFpbkFyYy5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJjLmJpbmQoJCQpKS5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAkJC5jb2xvcihkLmRhdGEpO1xuICAgIH0pLnN0eWxlKFwiY3Vyc29yXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gaGFzSW50ZXJhY3Rpb24gJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSA/IFwicG9pbnRlclwiIDogbnVsbDtcbiAgICB9KS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkgJiYgKGQuc3RhcnRBbmdsZSA9IGNvbmZpZy5nYXVnZV9zdGFydGluZ0FuZ2xlLCBkLmVuZEFuZ2xlID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGUpLCB0aGlzLl9jdXJyZW50ID0gZDtcbiAgICB9KS5tZXJnZShtYWluQXJjKSwgJCQuaGFzTXVsdGlBcmNHYXVnZSgpICYmICQkLnJlZHJhd011bHRpQXJjR2F1Z2UoKSwgbWFpbkFyYy5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gISQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkgJiYgd2l0aFRyYW5zZm9ybSA/IFwic2NhbGUoMClcIiA6IFwiXCI7XG4gICAgfSkuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZCA9PT0gdGhpcy5fY3VycmVudCA/IFwiMFwiIDogXCIxXCI7XG4gICAgfSkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAkJC50cmFuc2l0aW5nID0gITA7XG4gICAgfSkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5hdHRyVHdlZW4oXCJkXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xuICAgICAgaWYgKCF1cGRhdGVkKSByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJNIDAgMFwiO1xuICAgICAgfTtcbiAgICAgIGlzTmFOKHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSkgJiYgKHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSA9IDApLCBpc05hTih0aGlzLl9jdXJyZW50LmVuZEFuZ2xlKSAmJiAodGhpcy5fY3VycmVudC5lbmRBbmdsZSA9IHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSk7XG4gICAgICB2YXIgaW50ZXJwb2xhdGUgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfaW50ZXJwb2xhdGVfY29tbW9uanMyX2QzX2ludGVycG9sYXRlX2FtZF9kM19pbnRlcnBvbGF0ZV9yb290X2QzX1tcImludGVycG9sYXRlXCJdKSh0aGlzLl9jdXJyZW50LCB1cGRhdGVkKTtcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGUoMCksIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBpbnRlcnBvbGF0ZWQgPSBpbnRlcnBvbGF0ZSh0KTtcbiAgICAgICAgLy8gZGF0YS5pZCB3aWxsIGJlIHVwZGF0ZWQgYnkgaW50ZXJwb3JhdG9yXG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZWQuZGF0YSA9IGQuZGF0YSwgJCQuZ2V0QXJjKGludGVycG9sYXRlZCwgITApO1xuICAgICAgfTtcbiAgICB9KS5hdHRyKFwidHJhbnNmb3JtXCIsIHdpdGhUcmFuc2Zvcm0gPyBcInNjYWxlKDEpXCIgOiBcIlwiKS5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBjb2xvcjtcbiAgICAgIHJldHVybiAkJC5sZXZlbENvbG9yID8gKGNvbG9yID0gJCQubGV2ZWxDb2xvcihkLmRhdGEudmFsdWVzWzBdLnZhbHVlKSwgY29uZmlnLmRhdGFfY29sb3JzW2QuZGF0YS5pZF0gPSBjb2xvcikgOiBjb2xvciA9ICQkLmNvbG9yKGQuZGF0YS5pZCksIGNvbG9yO1xuICAgIH0pIC8vIFdoZXJlIGdhdWdlIHJlYWRpbmcgY29sb3Igd291bGQgcmVjZWl2ZSBjdXN0b21pemF0aW9uLlxuICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpLmNhbGwoJCQuZW5kYWxsLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoJCQubGV2ZWxDb2xvcikge1xuICAgICAgICB2YXIgcGF0aCA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKSh0aGlzKSxcbiAgICAgICAgICAgIGQgPSBwYXRoLmRhdHVtKCk7XG4gICAgICAgICQkLnVwZGF0ZUxlZ2VuZEl0ZW1Db2xvcihkLmRhdGEuaWQsIHBhdGguc3R5bGUoXCJmaWxsXCIpKTtcbiAgICAgIH1cblxuICAgICAgJCQudHJhbnNpdGluZyA9ICExLCBjYWxsRm4oY29uZmlnLm9ucmVuZGVyZWQsICQkLCAkJC5hcGkpO1xuICAgIH0pLCBoYXNJbnRlcmFjdGlvbiAmJiAkJC5iaW5kQXJjRXZlbnQobWFpbkFyYyksICQkLnJlZHJhd0FyY1RleHQoZHVyYXRpb24pO1xuICB9LFxuICByZWRyYXdNdWx0aUFyY0dhdWdlOiBmdW5jdGlvbiByZWRyYXdNdWx0aUFyY0dhdWdlKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgYXJjTGFiZWxMaW5lcyA9ICQkLm1haW4uc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5hcmNzKSkuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5hcmNMYWJlbExpbmUpKS5kYXRhKCQkLmFyY0RhdGEuYmluZCgkJCkpLFxuICAgICAgICBtYWluQXJjTGFiZWxMaW5lID0gYXJjTGFiZWxMaW5lcy5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYXJjTGFiZWxMaW5lLCBcIiBcIikuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnRhcmdldCwgXCIgXCIpLmNvbmNhdChjb25maWdfY2xhc3Nlcy50YXJnZXQsIFwiLVwiKS5jb25jYXQoZC5kYXRhLmlkKTtcbiAgICB9KS5tZXJnZShhcmNMYWJlbExpbmVzKTtcbiAgICBtYWluQXJjTGFiZWxMaW5lLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuICQkLmxldmVsQ29sb3IgPyAkJC5sZXZlbENvbG9yKGQuZGF0YS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IoZC5kYXRhKTtcbiAgICB9KS5zdHlsZShcImRpc3BsYXlcIiwgY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyBcIlwiIDogXCJub25lXCIpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBsaW5lTGVuZ3RoID0gMCxcbiAgICAgICAgICBsaW5lVGhpY2tuZXNzID0gMixcbiAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICB5ID0gMCxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBcIlwiO1xuXG4gICAgICBpZiAoJCQuaGlkZGVuVGFyZ2V0SWRzLmluZGV4T2YoZC5kYXRhLmlkKSA8IDApIHtcbiAgICAgICAgdmFyIHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKSxcbiAgICAgICAgICAgIGlubmVyTGluZUxlbmd0aCA9ICQkLmdhdWdlQXJjV2lkdGggLyAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoICogKHVwZGF0ZWQuaW5kZXggKyAxKSxcbiAgICAgICAgICAgIGxpbmVBbmdsZSA9IHVwZGF0ZWQuZW5kQW5nbGUgLSBNYXRoLlBJIC8gMixcbiAgICAgICAgICAgIGFyY0lubmVyUmFkaXVzID0gJCQucmFkaXVzIC0gaW5uZXJMaW5lTGVuZ3RoLFxuICAgICAgICAgICAgbGluZVBvc2l0aW9uaW5nQW5nbGUgPSBsaW5lQW5nbGUgLSAoYXJjSW5uZXJSYWRpdXMgPT09IDAgPyAwIDogMSAvIGFyY0lubmVyUmFkaXVzKTtcbiAgICAgICAgbGluZUxlbmd0aCA9ICQkLnJhZGl1c0V4cGFuZGVkIC0gJCQucmFkaXVzICsgaW5uZXJMaW5lTGVuZ3RoLCB4ID0gTWF0aC5jb3MobGluZVBvc2l0aW9uaW5nQW5nbGUpICogYXJjSW5uZXJSYWRpdXMsIHkgPSBNYXRoLnNpbihsaW5lUG9zaXRpb25pbmdBbmdsZSkgKiBhcmNJbm5lclJhZGl1cywgdHJhbnNmb3JtID0gXCJyb3RhdGUoXCIuY29uY2F0KGxpbmVBbmdsZSAqIDE4MCAvIE1hdGguUEksIFwiLCBcIikuY29uY2F0KHgsIFwiLCBcIikuY29uY2F0KHksIFwiKVwiKTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMpLmF0dHIoXCJ4XCIsIHgpLmF0dHIoXCJ5XCIsIHkpLmF0dHIoXCJ3aWR0aFwiLCBsaW5lTGVuZ3RoKS5hdHRyKFwiaGVpZ2h0XCIsIGxpbmVUaGlja25lc3MpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKS5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCIwLCBcIi5jb25jYXQobGluZUxlbmd0aCArIGxpbmVUaGlja25lc3MsIFwiLCAwXCIpKTtcbiAgICB9KTtcbiAgfSxcbiAgYmluZEFyY0V2ZW50OiBmdW5jdGlvbiBiaW5kQXJjRXZlbnQoYXJjKSB7XG4gICAgZnVuY3Rpb24gc2VsZWN0QXJjKF90aGlzLCBhcmNEYXRhLCBpZCkge1xuICAgICAgJCQuZXhwYW5kQXJjKGlkKSwgJCQuYXBpLmZvY3VzKGlkKSwgJCQudG9nZ2xlRm9jdXNMZWdlbmQoaWQsICEwKSwgJCQuc2hvd1Rvb2x0aXAoW2FyY0RhdGFdLCBfdGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5zZWxlY3RBcmMoYXJjRGF0YSkge1xuICAgICAgdmFyIGlkID0gYXJjRGF0YSAmJiBhcmNEYXRhLmlkIHx8IHVuZGVmaW5lZDtcbiAgICAgICQkLnVuZXhwYW5kQXJjKGlkKSwgJCQuYXBpLnJldmVydCgpLCAkJC5yZXZlcnRMZWdlbmQoKSwgJCQuaGlkZVRvb2x0aXAoKTtcbiAgICB9XG5cbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBpc1RvdWNoID0gJCQuaW5wdXRUeXBlID09PSBcInRvdWNoXCIsXG4gICAgICAgIGlzTW91c2UgPSAkJC5pbnB1dFR5cGUgPT09IFwibW91c2VcIjtcblxuICAgIC8vIHRvdWNoIGV2ZW50c1xuICAgIGlmIChhcmMub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgdmFyIGFyY0RhdGEsXG4gICAgICAgICAgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xuICAgICAgdXBkYXRlZCAmJiAoYXJjRGF0YSA9ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCksICQkLnRvZ2dsZVNoYXBlICYmICQkLnRvZ2dsZVNoYXBlKHRoaXMsIGFyY0RhdGEsIGkpLCAkJC5jb25maWcuZGF0YV9vbmNsaWNrLmNhbGwoJCQuYXBpLCBhcmNEYXRhLCB0aGlzKSk7XG4gICAgfSksIGlzTW91c2UgJiYgYXJjLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBpZiAoISQkLnRyYW5zaXRpbmcpIC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKSxcbiAgICAgICAgICAgICAgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbCxcbiAgICAgICAgICAgICAgaWQgPSBhcmNEYXRhICYmIGFyY0RhdGEuaWQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGVjdEFyYyh0aGlzLCBhcmNEYXRhLCBpZCksICQkLnNldE92ZXJPdXQoITAsIGFyY0RhdGEpO1xuICAgICAgICB9XG4gICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKCEkJC50cmFuc2l0aW5nKSAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcbiAgICAgICAge1xuICAgICAgICAgIHZhciB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCksXG4gICAgICAgICAgICAgIGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGw7XG4gICAgICAgICAgdW5zZWxlY3RBcmMoKSwgJCQuc2V0T3Zlck91dCghMSwgYXJjRGF0YSk7XG4gICAgICAgIH1cbiAgICB9KS5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKSxcbiAgICAgICAgICBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xuICAgICAgJCQuc2hvd1Rvb2x0aXAoW2FyY0RhdGFdLCB0aGlzKTtcbiAgICB9KSwgaXNUb3VjaCAmJiAkJC5oYXNBcmNUeXBlKCkgJiYgISQkLnJhZGFycykge1xuICAgICAgdmFyIGdldEV2ZW50QXJjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG91Y2ggPSBleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wiZXZlbnRcIl0uY2hhbmdlZFRvdWNoZXNbMF0sXG4gICAgICAgICAgICBldmVudEFyYyA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKShicm93c2VyX2RvYy5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50QXJjO1xuICAgICAgfSxcbiAgICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoISQkLnRyYW5zaXRpbmcpIC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBldmVudEFyYyA9IGdldEV2ZW50QXJjKCksXG4gICAgICAgICAgICAgICAgZGF0dW0gPSBldmVudEFyYy5kYXR1bSgpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBkYXR1bSAmJiBkYXR1bS5kYXRhICYmIGRhdHVtLmRhdGEuaWQgPyAkJC51cGRhdGVBbmdsZShkYXR1bSkgOiBudWxsLFxuICAgICAgICAgICAgICAgIGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgaWQgPSBhcmNEYXRhICYmIGFyY0RhdGEuaWQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgJCQuY2FsbE92ZXJPdXRGb3JUb3VjaChhcmNEYXRhKSwgaXNVbmRlZmluZWQoaWQpID8gdW5zZWxlY3RBcmMoKSA6IHNlbGVjdEFyYyh0aGlzLCBhcmNEYXRhLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJCQuc3ZnLm9uKFwidG91Y2hzdGFydFwiLCBoYW5kbGVyKS5vbihcInRvdWNobW92ZVwiLCBoYW5kbGVyKTtcbiAgICB9XG4gIH0sXG4gIHJlZHJhd0FyY1RleHQ6IGZ1bmN0aW9uIHJlZHJhd0FyY1RleHQoZHVyYXRpb24pIHtcbiAgICB2YXIgdGV4dCxcbiAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIG1haW4gPSAkJC5tYWluLFxuICAgICAgICBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKSxcbiAgICAgICAgaGFzTXVsdGlBcmNHYXVnZSA9ICQkLmhhc011bHRpQXJjR2F1Z2UoKTtcblxuICAgIGlmIChoYXNHYXVnZSAmJiAkJC5kYXRhLnRhcmdldHMubGVuZ3RoID09PSAxICYmIGNvbmZpZy5nYXVnZV90aXRsZSB8fCAodGV4dCA9IG1haW4uc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaGFydEFyYykpLnNlbGVjdChcInRleHRcIikuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAkJC5pc0dhdWdlVHlwZShkLmRhdGEpID8gY29uZmlnX2NsYXNzZXMuZ2F1Z2VWYWx1ZSA6IG51bGw7XG4gICAgfSkuY2FsbCgkJC50ZXh0Rm9yQXJjTGFiZWwuYmluZCgkJCkpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQudHJhbnNmb3JtRm9yQXJjTGFiZWwuYmluZCgkJCkpLnN0eWxlKFwiZm9udC1zaXplXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSAmJiAkJC5kYXRhLnRhcmdldHMubGVuZ3RoID09PSAxICYmICFoYXNNdWx0aUFyY0dhdWdlID8gXCJcIi5jb25jYXQoTWF0aC5yb3VuZCgkJC5yYWRpdXMgLyA1KSwgXCJweFwiKSA6IG51bGw7XG4gICAgfSkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAkJC5pc1RhcmdldFRvU2hvdyhkLmRhdGEuaWQpICYmICQkLmlzQXJjVHlwZShkLmRhdGEpID8gXCIxXCIgOiBcIjBcIjtcbiAgICB9KSwgaGFzTXVsdGlBcmNHYXVnZSAmJiB0ZXh0LmF0dHIoXCJkeVwiLCBcIi0uMWVtXCIpKSwgbWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0QXJjc1RpdGxlKSkuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmhhc1R5cGUoXCJkb251dFwiKSB8fCBoYXNHYXVnZSA/IFwiMVwiIDogXCIwXCIpLCBoYXNHYXVnZSkge1xuICAgICAgdmFyIGlzRnVsbENpcmNsZSA9IGNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlLFxuICAgICAgICAgIHN0YXJ0QW5nbGUgPSAtMSAqIE1hdGguUEkgLyAyLFxuICAgICAgICAgIGVuZEFuZ2xlID0gKGlzRnVsbENpcmNsZSA/IC00IDogLTEpICogc3RhcnRBbmdsZTtcbiAgICAgIGlzRnVsbENpcmNsZSAmJiB0ZXh0ICYmIHRleHQuYXR0cihcImR5XCIsIFwiXCIuY29uY2F0KE1hdGgucm91bmQoJCQucmFkaXVzIC8gMTQpKSk7XG4gICAgICB2YXIgYmFja2dyb3VuZEFyYyA9ICQkLmFyY3Muc2VsZWN0KFwiXCIuY29uY2F0KGhhc011bHRpQXJjR2F1Z2UgPyBcImdcIiA6IFwiXCIsIFwiLlwiKS5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2hhcnRBcmNzQmFja2dyb3VuZCkpO1xuXG4gICAgICBpZiAoaGFzTXVsdGlBcmNHYXVnZSkge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICBiYWNrZ3JvdW5kQXJjID0gYmFja2dyb3VuZEFyYy5zZWxlY3RBbGwoXCJwYXRoLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaGFydEFyY3NCYWNrZ3JvdW5kKSkuZGF0YSgkJC5kYXRhLnRhcmdldHMpLCBiYWNrZ3JvdW5kQXJjLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2hhcnRBcmNzQmFja2dyb3VuZCwgXCIgXCIpLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaGFydEFyY3NCYWNrZ3JvdW5kLCBcIi1cIikuY29uY2F0KGkpO1xuICAgICAgICB9KS5tZXJnZShiYWNrZ3JvdW5kQXJjKS5hdHRyKFwiZFwiLCBmdW5jdGlvbiAoZDEpIHtcbiAgICAgICAgICBpZiAoJCQuaGlkZGVuVGFyZ2V0SWRzLmluZGV4T2YoZDEuaWQpID49IDApIHJldHVybiBcIk0gMCAwXCI7XG4gICAgICAgICAgdmFyIGQgPSB7XG4gICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICB2YWx1ZTogY29uZmlnLmdhdWdlX21heFxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4KytcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiAkJC5nZXRBcmMoZCwgITAsICEwKTtcbiAgICAgICAgfSksIGJhY2tncm91bmRBcmMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIGJhY2tncm91bmRBcmMuYXR0cihcImRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZCA9IHtcbiAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgdmFsdWU6IGNvbmZpZy5nYXVnZV9tYXhcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJCQuZ2V0QXJjKGQsICEwLCAhMCk7XG4gICAgICB9KTtcblxuICAgICAgJCQuYXJjcy5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0QXJjc0dhdWdlVW5pdCkpLmF0dHIoXCJkeVwiLCBcIi43NWVtXCIpLnRleHQoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyBjb25maWcuZ2F1Z2VfdW5pdHMgOiBcIlwiKSwgY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgJiYgKCQkLmFyY3Muc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaGFydEFyY3NHYXVnZU1pbikpLmF0dHIoXCJkeFwiLCBcIlwiLmNvbmNhdCgtMSAqICgkJC5pbm5lclJhZGl1cyArICgkJC5yYWRpdXMgLSAkJC5pbm5lclJhZGl1cykgLyAoaXNGdWxsQ2lyY2xlID8gMSA6IDIpKSwgXCJweFwiKSkuYXR0cihcImR5XCIsIFwiMS4yZW1cIikudGV4dCgkJC50ZXh0Rm9yR2F1Z2VNaW5NYXgoY29uZmlnLmdhdWdlX21pbiwgITEpKSwgIWlzRnVsbENpcmNsZSAmJiAkJC5hcmNzLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2hhcnRBcmNzR2F1Z2VNYXgpKS5hdHRyKFwiZHhcIiwgXCJcIi5jb25jYXQoJCQuaW5uZXJSYWRpdXMgKyAoJCQucmFkaXVzIC0gJCQuaW5uZXJSYWRpdXMpIC8gMiwgXCJweFwiKSkuYXR0cihcImR5XCIsIFwiMS4yZW1cIikudGV4dCgkJC50ZXh0Rm9yR2F1Z2VNaW5NYXgoY29uZmlnLmdhdWdlX21heCwgITApKSk7XG4gICAgfVxuICB9LFxuICBpbml0R2F1Z2U6IGZ1bmN0aW9uIGluaXRHYXVnZSgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGFyY3MgPSAkJC5hcmNzLFxuICAgICAgICBhcHBlbmRUZXh0ID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgYXJjcy5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc05hbWUpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG4gICAgfTtcblxuICAgICQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAoYXJjcy5hcHBlbmQoJCQuaGFzTXVsdGlBcmNHYXVnZSgpID8gXCJnXCIgOiBcInBhdGhcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLmNoYXJ0QXJjc0JhY2tncm91bmQpLCBjb25maWcuZ2F1Z2VfdW5pdHMgJiYgYXBwZW5kVGV4dChjb25maWdfY2xhc3Nlcy5jaGFydEFyY3NHYXVnZVVuaXQpLCBjb25maWcuZ2F1Z2VfbGFiZWxfc2hvdyAmJiAoYXBwZW5kVGV4dChjb25maWdfY2xhc3Nlcy5jaGFydEFyY3NHYXVnZU1pbiksICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSAmJiBhcHBlbmRUZXh0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0QXJjc0dhdWdlTWF4KSkpO1xuICB9LFxuICBnZXRHYXVnZUxhYmVsSGVpZ2h0OiBmdW5jdGlvbiBnZXRHYXVnZUxhYmVsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gMjAgOiAwO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3NoYXBlL2Jhci5qc1xuXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5cblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWxfQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcbiAgaW5pdEJhcjogZnVuY3Rpb24gaW5pdEJhcigpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgICQkLm1haW4uc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaGFydCkpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLmNoYXJ0QmFycyk7XG4gIH0sXG4gIHVwZGF0ZVRhcmdldHNGb3JCYXI6IGZ1bmN0aW9uIHVwZGF0ZVRhcmdldHNGb3JCYXIodGFyZ2V0cykge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgY2xhc3NDaGFydEJhciA9ICQkLmNsYXNzQ2hhcnRCYXIuYmluZCgkJCksXG4gICAgICAgIGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKSxcbiAgICAgICAgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCksXG4gICAgICAgIG1haW5CYXJVcGRhdGUgPSAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2hhcnRCYXJzKSkuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaGFydEJhcikpLmRhdGEodGFyZ2V0cykuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gY2xhc3NDaGFydEJhcihkKSArIGNsYXNzRm9jdXMoZCk7XG4gICAgfSksXG4gICAgICAgIG1haW5CYXJFbnRlciA9IG1haW5CYXJVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgIC8vIEJhcnMgZm9yIGVhY2ggZGF0YVxuICAgIG1haW5CYXJFbnRlci5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc0JhcnMpLnN0eWxlKFwiY3Vyc29yXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSA/IFwicG9pbnRlclwiIDogbnVsbDtcbiAgICB9KTtcbiAgfSxcbiAgdXBkYXRlQmFyOiBmdW5jdGlvbiB1cGRhdGVCYXIoZHVyYXRpb25Gb3JFeGl0KSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgYmFyRGF0YSA9ICQkLmJhckRhdGEuYmluZCgkJCksXG4gICAgICAgIGNsYXNzQmFyID0gJCQuY2xhc3NCYXIuYmluZCgkJCksXG4gICAgICAgIGluaXRpYWxPcGFjaXR5ID0gJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCk7XG4gICAgJCQubWFpbkJhciA9ICQkLm1haW4uc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5iYXJzKSkuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5iYXIpKS5kYXRhKGJhckRhdGEpLCAkJC5tYWluQmFyLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLnJlbW92ZSgpLCAkJC5tYWluQmFyID0gJCQubWFpbkJhci5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFyKS5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpLm1lcmdlKCQkLm1haW5CYXIpLnN0eWxlKFwib3BhY2l0eVwiLCBpbml0aWFsT3BhY2l0eSk7XG4gIH0sXG4gIHJlZHJhd0JhcjogZnVuY3Rpb24gcmVkcmF3QmFyKGRyYXdCYXIsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIFsod2l0aFRyYW5zaXRpb24gPyB0aGlzLm1haW5CYXIudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiB0aGlzLm1haW5CYXIpLmF0dHIoXCJkXCIsIGRyYXdCYXIpLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmNvbG9yKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXTtcbiAgfSxcbiAgZ2V0QmFyVzogZnVuY3Rpb24gZ2V0QmFyVyhheGlzLCBiYXJUYXJnZXRzTnVtKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIG1heERhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpLFxuICAgICAgICBpc0dyb3VwZWQgPSAkJC5pc0dyb3VwZWQoKSxcbiAgICAgICAgdGlja0ludGVydmFsID0gKCQkLnpvb21TY2FsZSB8fCAkJCkgJiYgISQkLmlzQ2F0ZWdvcml6ZWQoKSA/ICQkLnh4KCQkLnN1YlguZG9tYWluKClbMV0pIC8gbWF4RGF0YUNvdW50IDogYXhpcy50aWNrSW50ZXJ2YWwobWF4RGF0YUNvdW50KSxcbiAgICAgICAgZ2V0V2lkdGggPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHZhciB3aWR0aCA9IGlkID8gY29uZmlnLmJhcl93aWR0aFtpZF0gOiBjb25maWcuYmFyX3dpZHRoLFxuICAgICAgICAgIHJhdGlvID0gaWQgPyB3aWR0aC5yYXRpbyA6IGNvbmZpZy5iYXJfd2lkdGhfcmF0aW8sXG4gICAgICAgICAgbWF4ID0gaWQgPyB3aWR0aC5tYXggOiBjb25maWcuYmFyX3dpZHRoX21heCxcbiAgICAgICAgICB3ID0gaXNOdW1iZXIod2lkdGgpID8gd2lkdGggOiBiYXJUYXJnZXRzTnVtID8gdGlja0ludGVydmFsICogcmF0aW8gLyBiYXJUYXJnZXRzTnVtIDogMDtcbiAgICAgIHJldHVybiBtYXggJiYgdyA+IG1heCA/IG1heCA6IHc7XG4gICAgfTtcblxuICAgIHJldHVybiByZXN1bHQgPSBnZXRXaWR0aCgpLCAhaXNHcm91cGVkICYmIGlzT2JqZWN0VHlwZShjb25maWcuYmFyX3dpZHRoKSAmJiAocmVzdWx0ID0ge1xuICAgICAgd2lkdGg6IHJlc3VsdCxcbiAgICAgIHRvdGFsOiBbXVxuICAgIH0sICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBjb25maWcuYmFyX3dpZHRoW3YuaWRdICYmIChyZXN1bHRbdi5pZF0gPSBnZXRXaWR0aCh2LmlkKSwgcmVzdWx0LnRvdGFsLnB1c2gocmVzdWx0W3YuaWRdIHx8IHJlc3VsdC53aWR0aCkpO1xuICAgIH0pKSwgcmVzdWx0O1xuICB9LFxuICBnZXRCYXJzOiBmdW5jdGlvbiBnZXRCYXJzKGksIGlkKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgc3VmZml4ID0gaXNWYWx1ZShpKSA/IFwiLVwiLmNvbmNhdChpKSA6IFwiXCI7XG4gICAgcmV0dXJuIChpZCA/ICQkLm1haW4uc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5iYXJzKS5jb25jYXQoJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpKSkgOiAkJC5tYWluKS5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmJhcikuY29uY2F0KHN1ZmZpeCkpO1xuICB9LFxuICBleHBhbmRCYXJzOiBmdW5jdGlvbiBleHBhbmRCYXJzKGksIGlkLCByZXNldCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgcmVzZXQgJiYgJCQudW5leHBhbmRCYXJzKCksICQkLmdldEJhcnMoaSwgaWQpLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuRVhQQU5ERUQsICEwKTtcbiAgfSxcbiAgdW5leHBhbmRCYXJzOiBmdW5jdGlvbiB1bmV4cGFuZEJhcnMoaSkge1xuICAgIHRoaXMuZ2V0QmFycyhpKS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLkVYUEFOREVELCAhMSk7XG4gIH0sXG4gIGdlbmVyYXRlRHJhd0JhcjogZnVuY3Rpb24gZ2VuZXJhdGVEcmF3QmFyKGJhckluZGljZXMsIGlzU3ViKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBnZXRQb2ludHMgPSAkJC5nZW5lcmF0ZUdldEJhclBvaW50cyhiYXJJbmRpY2VzLCBpc1N1YiksXG4gICAgICAgIGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQsXG4gICAgICAgIGlzR3JvdXBlZCA9ICQkLmlzR3JvdXBlZCgpLFxuICAgICAgICBiYXJSYWRpdXMgPSBjb25maWcuYmFyX3JhZGl1cyxcbiAgICAgICAgYmFyUmFkaXVzUmF0aW8gPSBjb25maWcuYmFyX3JhZGl1c19yYXRpbyxcbiAgICAgICAgZ2V0UmFkaXVzID0gaXNOdW1iZXIoYmFyUmFkaXVzKSAmJiBiYXJSYWRpdXMgPiAwID8gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJhclJhZGl1cztcbiAgICB9IDogaXNOdW1iZXIoYmFyUmFkaXVzUmF0aW8pID8gZnVuY3Rpb24gKHcpIHtcbiAgICAgIHJldHVybiB3ICogYmFyUmFkaXVzUmF0aW87XG4gICAgfSA6IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAvLyA0IHBvaW50cyB0aGF0IG1ha2UgYSBiYXJcbiAgICAgIHZhciBwb2ludHMgPSBnZXRQb2ludHMoZCwgaSksXG4gICAgICAgICAgaW5kZXhYID0gK2lzUm90YXRlZCxcbiAgICAgICAgICBpbmRleFkgPSArIWluZGV4WCxcbiAgICAgICAgICBpc05lZ2F0aXZlID0gZC52YWx1ZSA8IDAsXG4gICAgICAgICAgcGF0aFJhZGl1cyA9IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICByYWRpdXMgPSAwOyAvLyBzd2l0Y2ggcG9pbnRzIGlmIGF4aXMgaXMgcm90YXRlZCwgbm90IGFwcGxpY2FibGUgZm9yIHN1YiBjaGFydFxuXG4gICAgICBpZiAoZ2V0UmFkaXVzICYmICFpc0dyb3VwZWQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaXNSb3RhdGVkID8gaW5kZXhZIDogaW5kZXhYLFxuICAgICAgICAgICAgYmFyVyA9IHBvaW50c1syXVtpbmRleF0gLSBwb2ludHNbMF1baW5kZXhdO1xuICAgICAgICByYWRpdXMgPSBnZXRSYWRpdXMoYmFyVyk7XG4gICAgICAgIHZhciBhcmMgPSBcImFcIi5jb25jYXQocmFkaXVzLCBcIixcIikuY29uY2F0KHJhZGl1cywgXCIgXCIpLmNvbmNhdChpc05lZ2F0aXZlID8gXCIxIDAgMFwiIDogXCIwIDAgMVwiLCBcIiBcIik7XG4gICAgICAgIHBhdGhSYWRpdXNbKyFpc1JvdGF0ZWRdID0gXCJcIi5jb25jYXQoYXJjKS5jb25jYXQocmFkaXVzLCBcIixcIikuY29uY2F0KHJhZGl1cyksIHBhdGhSYWRpdXNbK2lzUm90YXRlZF0gPSBcIlwiLmNvbmNhdChhcmMpLmNvbmNhdChbLXJhZGl1cywgcmFkaXVzXVtpc1JvdGF0ZWQgPyBcInNvcnRcIiA6IFwicmV2ZXJzZVwiXSgpKSwgaXNOZWdhdGl2ZSAmJiBwYXRoUmFkaXVzLnJldmVyc2UoKTtcbiAgICAgIH0gLy8gcGF0aCBzdHJpbmcgZGF0YSBzaG91bGRuJ3QgYmUgY29udGFpbmluZyBuZXcgbGluZSBjaGFyc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvNTMwXG5cblxuICAgICAgdmFyIHBhdGggPSBpc1JvdGF0ZWQgPyBcIkhcIi5jb25jYXQocG9pbnRzWzFdW2luZGV4WF0gLSByYWRpdXMsIFwiIFwiKS5jb25jYXQocGF0aFJhZGl1c1swXSwgXCJWXCIpLmNvbmNhdChwb2ludHNbMl1baW5kZXhZXSAtIHJhZGl1cywgXCIgXCIpLmNvbmNhdChwYXRoUmFkaXVzWzFdLCBcIkhcIikuY29uY2F0KHBvaW50c1szXVtpbmRleFhdKSA6IFwiVlwiLmNvbmNhdChwb2ludHNbMV1baW5kZXhZXSArIChpc05lZ2F0aXZlID8gLXJhZGl1cyA6IHJhZGl1cyksIFwiIFwiKS5jb25jYXQocGF0aFJhZGl1c1swXSwgXCJIXCIpLmNvbmNhdChwb2ludHNbMl1baW5kZXhYXSAtIHJhZGl1cywgXCIgXCIpLmNvbmNhdChwYXRoUmFkaXVzWzFdLCBcIlZcIikuY29uY2F0KHBvaW50c1szXVtpbmRleFldKTtcbiAgICAgIHJldHVybiBcIk1cIi5jb25jYXQocG9pbnRzWzBdW2luZGV4WF0sIFwiLFwiKS5jb25jYXQocG9pbnRzWzBdW2luZGV4WV0pLmNvbmNhdChwYXRoLCBcInpcIik7XG4gICAgfTtcbiAgfSxcbiAgZ2VuZXJhdGVHZXRCYXJQb2ludHM6IGZ1bmN0aW9uIGdlbmVyYXRlR2V0QmFyUG9pbnRzKGJhckluZGljZXMsIGlzU3ViKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgYXhpcyA9IGlzU3ViID8gJCQuc3ViWEF4aXMgOiAkJC54QXhpcyxcbiAgICAgICAgYmFyVGFyZ2V0c051bSA9ICQkLmdldEluZGljZXNNYXgoYmFySW5kaWNlcykgKyAxLFxuICAgICAgICBiYXJXID0gJCQuZ2V0QmFyVyhheGlzLCBiYXJUYXJnZXRzTnVtKSxcbiAgICAgICAgYmFyWCA9ICQkLmdldFNoYXBlWChiYXJXLCBiYXJJbmRpY2VzLCAhIWlzU3ViKSxcbiAgICAgICAgYmFyWSA9ICQkLmdldFNoYXBlWSghIWlzU3ViKSxcbiAgICAgICAgYmFyT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNCYXJUeXBlLCBiYXJJbmRpY2VzLCAhIWlzU3ViKSxcbiAgICAgICAgeVNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICB2YXIgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoJCQuZ2V0U2hhcGVZTWluKGQuaWQpKSxcbiAgICAgICAgICBvZmZzZXQgPSBiYXJPZmZzZXQoZCwgaSkgfHwgeTAsXG4gICAgICAgICAgd2lkdGggPSBpc051bWJlcihiYXJXKSA/IGJhclcgOiBiYXJXW2QuaWRdIHx8IGJhclcud2lkdGgsXG4gICAgICAgICAgcG9zWCA9IGJhclgoZCksXG4gICAgICAgICAgcG9zWSA9IGJhclkoZCk7XG4gICAgICAvLyA0IHBvaW50cyB0aGF0IG1ha2UgYSBiYXJcbiAgICAgIHJldHVybiAkJC5jb25maWcuYXhpc19yb3RhdGVkICYmIChkLnZhbHVlID4gMCAmJiBwb3NZIDwgeTAgfHwgZC52YWx1ZSA8IDAgJiYgeTAgPCBwb3NZKSAmJiAocG9zWSA9IHkwKSwgcG9zWSAtPSB5MCAtIG9mZnNldCwgW1twb3NYLCBvZmZzZXRdLCBbcG9zWCwgcG9zWV0sIFtwb3NYICsgd2lkdGgsIHBvc1ldLCBbcG9zWCArIHdpZHRoLCBvZmZzZXRdXTtcbiAgICB9O1xuICB9LFxuICBpc1dpdGhpbkJhcjogZnVuY3Rpb24gaXNXaXRoaW5CYXIodGhhdCkge1xuICAgIHZhciBtb3VzZSA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wibW91c2VcIl0pKHRoYXQpLFxuICAgICAgICBsaXN0ID0gZ2V0UmVjdFNlZ0xpc3QodGhhdCksXG4gICAgICAgIF9saXN0MiA9IF9zbGljZWRUb0FycmF5KGxpc3QsIDIpLFxuICAgICAgICBzZWcwID0gX2xpc3QyWzBdLFxuICAgICAgICBzZWcxID0gX2xpc3QyWzFdLFxuICAgICAgICB4ID0gTWF0aC5taW4oc2VnMC54LCBzZWcxLngpLFxuICAgICAgICB5ID0gTWF0aC5taW4oc2VnMC55LCBzZWcxLnkpLFxuICAgICAgICBvZmZzZXQgPSB0aGlzLmNvbmZpZy5iYXJfc2Vuc2l0aXZpdHksXG4gICAgICAgIF90aGF0JGdldEJCb3ggPSB0aGF0LmdldEJCb3goKSxcbiAgICAgICAgd2lkdGggPSBfdGhhdCRnZXRCQm94LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhhdCRnZXRCQm94LmhlaWdodDtcblxuICAgIHJldHVybiB4IC0gb2Zmc2V0IDwgbW91c2VbMF0gJiYgbW91c2VbMF0gPCB4ICsgd2lkdGggKyBvZmZzZXQgJiYgeSAtIG9mZnNldCA8IG1vdXNlWzFdICYmIG1vdXNlWzFdIDwgeSArIGhlaWdodCArIG9mZnNldDtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zaGFwZS9idWJibGUuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRCdWJibGU6IGZ1bmN0aW9uIGluaXRCdWJibGUoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICQkLmhhc1R5cGUoXCJidWJibGVcIikgJiYgKGNvbmZpZy5wb2ludF9zaG93ID0gITAsIGNvbmZpZy5wb2ludF90eXBlID0gXCJjaXJjbGVcIiwgY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5ID0gMjUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdXNlciBhZ2VudCdzIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBwYXRoIGluIHVzZXIgdW5pdHNcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR0dlb21ldHJ5RWxlbWVudC9nZXRUb3RhbExlbmd0aFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCYXNlTGVuZ3RoOiBmdW5jdGlvbiBnZXRCYXNlTGVuZ3RoKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNhY2hlS2V5ID0gXCIkYmFzZUxlbmd0aFwiLFxuICAgICAgICBiYXNlTGVuZ3RoID0gJCQuZ2V0Q2FjaGUoY2FjaGVLZXkpO1xuICAgIHJldHVybiBiYXNlTGVuZ3RoIHx8ICQkLmFkZENhY2hlKGNhY2hlS2V5LCBiYXNlTGVuZ3RoID0gZ2V0TWluTWF4KFwibWluXCIsIFskJC5heGVzLnguc2VsZWN0KFwicGF0aFwiKS5ub2RlKCkuZ2V0VG90YWxMZW5ndGgoKSwgJCQuYXhlcy55LnNlbGVjdChcInBhdGhcIikubm9kZSgpLmdldFRvdGFsTGVuZ3RoKCldKSksIGJhc2VMZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmFkaXVzIHZhbHVlIGZvciBidWJibGUgY2lyY2xlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgXHQgKi9cbiAgZ2V0QnViYmxlUjogZnVuY3Rpb24gZ2V0QnViYmxlUihkKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgbWF4UiA9ICQkLmNvbmZpZy5idWJibGVfbWF4UjtcbiAgICBpc0Z1bmN0aW9uKG1heFIpID8gbWF4UiA9IG1heFIoZCkgOiAhaXNOdW1iZXIobWF4UikgJiYgKG1heFIgPSAkJC5nZXRCYXNlTGVuZ3RoKCkgLyAoJCQuZ2V0TWF4RGF0YUNvdW50KCkgKiAyKSArIDEyKTtcbiAgICB2YXIgbWF4ID0gZ2V0TWluTWF4KFwibWF4XCIsICQkLmdldE1pbk1heERhdGEoKS5tYXgubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gJCQuaXNCdWJibGVaVHlwZShkKSA/ICQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwieVwiKSA6IGlzT2JqZWN0KGQudmFsdWUpID8gZC52YWx1ZS5taWQgOiBkLnZhbHVlO1xuICAgIH0pKSxcbiAgICAgICAgbWF4QXJlYSA9IG1heFIgKiBtYXhSICogTWF0aC5QSSxcbiAgICAgICAgYXJlYSA9ICgkJC5pc0J1YmJsZVpUeXBlKGQpID8gJCQuZ2V0QnViYmxlWkRhdGEoZC52YWx1ZSwgXCJ6XCIpIDogZC52YWx1ZSkgKiAobWF4QXJlYSAvIG1heCk7XG4gICAgcmV0dXJuIE1hdGguc3FydChhcmVhIC8gTWF0aC5QSSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBidWJibGUgZGltZW5zaW9uIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGQgZGF0YSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIHkgb3IgelxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCdWJibGVaRGF0YTogZnVuY3Rpb24gZ2V0QnViYmxlWkRhdGEoZCwgdHlwZSkge1xuICAgIHJldHVybiBpc09iamVjdChkKSA/IGRbdHlwZV0gOiBkW3R5cGUgPT09IFwieVwiID8gMCA6IDFdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYnViYmxlIGhhcyBkaW1lbnNpb24gZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdHxhcnJheX0gZCBkYXRhIHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0J1YmJsZVpUeXBlOiBmdW5jdGlvbiBpc0J1YmJsZVpUeXBlKGQpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgIHJldHVybiAkJC5pc0J1YmJsZVR5cGUoZCkgJiYgKGlzT2JqZWN0KGQudmFsdWUpICYmIChcInpcIiBpbiBkLnZhbHVlIHx8IFwieVwiIGluIGQudmFsdWUpIHx8IGlzQXJyYXkoZC52YWx1ZSkgJiYgZC52YWx1ZS5sZW5ndGggPT09IDIpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3NoYXBlL2xpbmUuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5cblxuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICBpbml0TGluZTogZnVuY3Rpb24gaW5pdExpbmUoKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2hhcnQpKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjb25maWdfY2xhc3Nlcy5jaGFydExpbmVzKTtcbiAgfSxcbiAgdXBkYXRlVGFyZ2V0c0ZvckxpbmU6IGZ1bmN0aW9uIHVwZGF0ZVRhcmdldHNGb3JMaW5lKHRhcmdldHMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGNsYXNzQ2hhcnRMaW5lID0gJCQuY2xhc3NDaGFydExpbmUuYmluZCgkJCksXG4gICAgICAgIGNsYXNzTGluZXMgPSAkJC5jbGFzc0xpbmVzLmJpbmQoJCQpLFxuICAgICAgICBjbGFzc0FyZWFzID0gJCQuY2xhc3NBcmVhcy5iaW5kKCQkKSxcbiAgICAgICAgY2xhc3NDaXJjbGVzID0gJCQuY2xhc3NDaXJjbGVzLmJpbmQoJCQpLFxuICAgICAgICBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKSxcbiAgICAgICAgbWFpbkxpbmVVcGRhdGUgPSAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2hhcnRMaW5lcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2hhcnRMaW5lKSkuZGF0YSh0YXJnZXRzKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBjbGFzc0NoYXJ0TGluZShkKSArIGNsYXNzRm9jdXMoZCk7XG4gICAgfSksXG4gICAgICAgIG1haW5MaW5lRW50ZXIgPSBtYWluTGluZVVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRMaW5lKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgIC8vIExpbmVzIGZvciBlYWNoIGRhdGFcbiAgICAvLyBBcmVhc1xuICAgIC8vIFVwZGF0ZSBkYXRlIGZvciBzZWxlY3RlZCBjaXJjbGVzXG4gICAgbWFpbkxpbmVFbnRlci5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xpbmVzKSwgbWFpbkxpbmVFbnRlci5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyZWFzKSwgY29uZmlnLnBvaW50X3Nob3cgJiYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIG1haW5MaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAkJC5nZW5lcmF0ZUNsYXNzKGNvbmZpZ19jbGFzc2VzLnNlbGVjdGVkQ2lyY2xlcywgZC5pZCk7XG4gICAgfSksIG1haW5MaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaXJjbGVzKS5zdHlsZShcImN1cnNvclwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkgPyBcInBvaW50ZXJcIiA6IG51bGw7XG4gICAgfSkpLCB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICQkLm1haW4uc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5zZWxlY3RlZENpcmNsZXMpLmNvbmNhdCgkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh0LmlkKSkpLnNlbGVjdEFsbChcIlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5zZWxlY3RlZENpcmNsZSkpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZC52YWx1ZSA9IHQudmFsdWVzW2QuaW5kZXhdLnZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIHVwZGF0ZUxpbmU6IGZ1bmN0aW9uIHVwZGF0ZUxpbmUoZHVyYXRpb25Gb3JFeGl0KSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC5tYWluTGluZSA9ICQkLm1haW4uc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5saW5lcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMubGluZSkpLmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpLCAkJC5tYWluTGluZS5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdCkuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKS5yZW1vdmUoKSwgJCQubWFpbkxpbmUgPSAkJC5tYWluTGluZS5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoJCQuY2xhc3NMaW5lLmJpbmQoJCQpKGQpLCBcIiBcIikuY29uY2F0KCQkLmV4dHJhTGluZUNsYXNzZXMoZCkgfHwgXCJcIik7XG4gICAgfSkuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpLm1lcmdlKCQkLm1haW5MaW5lKS5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpLnN0eWxlKFwic2hhcGUtcmVuZGVyaW5nXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gJCQuaXNTdGVwVHlwZShkKSA/IFwiY3Jpc3BFZGdlc1wiIDogXCJcIjtcbiAgICB9KS5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpO1xuICB9LFxuICByZWRyYXdMaW5lOiBmdW5jdGlvbiByZWRyYXdMaW5lKGRyYXdMaW5lLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBbKHdpdGhUcmFuc2l0aW9uID8gdGhpcy5tYWluTGluZS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKSA6IHRoaXMubWFpbkxpbmUpLmF0dHIoXCJkXCIsIGRyYXdMaW5lKS5zdHlsZShcInN0cm9rZVwiLCB0aGlzLmNvbG9yKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJ2ZSBpbnRlcnBvbGF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBkIERhdGEgb2JqZWN0XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q3VydmU6IGZ1bmN0aW9uIGdldEN1cnZlKGQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBpc1JvdGF0ZWRTdGVwVHlwZSA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgJCQuaXNTdGVwVHlwZShkKTtcbiAgICAvLyB3aGVuIGlzIHN0ZXAgJiByb3RhdGVkLCBzaG91bGQgYmUgY29tcHV0ZWQgaW4gZGlmZmVyZW50IHdheVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzQ3MVxuICAgIHJldHVybiBpc1JvdGF0ZWRTdGVwVHlwZSA/IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB2YXIgc3RlcCA9ICQkLmdldEludGVycG9sYXRlKGQpKGNvbnRleHQpOyAvLyBrZWVwIHRoZSBvcmlnaW5hbCBtZXRob2RcblxuICAgICAgcmV0dXJuIHN0ZXAub3JnUG9pbnQgPSBzdGVwLnBvaW50LCBzdGVwLnBvaW50Um90YXRlZCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHRoaXMuX3BvaW50ID09PSAxICYmICh0aGlzLl9wb2ludCA9IDIpO1xuICAgICAgICB2YXIgeTEgPSB0aGlzLl95ICogKDEgLSB0aGlzLl90KSArIHkgKiB0aGlzLl90O1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB5MSksIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkxKSwgdGhpcy5feCA9IHgsIHRoaXMuX3kgPSB5O1xuICAgICAgfSwgc3RlcC5wb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHRoaXMuX3BvaW50ID09PSAwID8gdGhpcy5vcmdQb2ludCh4LCB5KSA6IHRoaXMucG9pbnRSb3RhdGVkKHgsIHkpO1xuICAgICAgfSwgc3RlcDtcbiAgICB9IDogJCQuZ2V0SW50ZXJwb2xhdGUoZCk7XG4gIH0sXG4gIGdlbmVyYXRlRHJhd0xpbmU6IGZ1bmN0aW9uIGdlbmVyYXRlRHJhd0xpbmUobGluZUluZGljZXMsIGlzU3ViKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBsaW5lQ29ubmVjdE51bGwgPSBjb25maWcubGluZV9jb25uZWN0TnVsbCxcbiAgICAgICAgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZCxcbiAgICAgICAgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRMaW5lUG9pbnRzKGxpbmVJbmRpY2VzLCBpc1N1YiksXG4gICAgICAgIHlTY2FsZUdldHRlciA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlIDogJCQuZ2V0WVNjYWxlLFxuICAgICAgICB4VmFsdWUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xuICAgIH0sXG4gICAgICAgIHlWYWx1ZSA9IGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4gJCQuaXNHcm91cGVkKGQuaWQpID8gZ2V0UG9pbnRzKGQsIGkpWzBdWzFdIDogeVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpKCQkLmdldEJhc2VWYWx1ZShkKSk7XG4gICAgfSxcbiAgICAgICAgbGluZSA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zaGFwZV9jb21tb25qczJfZDNfc2hhcGVfYW1kX2QzX3NoYXBlX3Jvb3RfZDNfW1wibGluZVwiXSkoKTtcblxuICAgIGxpbmUgPSBpc1JvdGF0ZWQgPyBsaW5lLngoeVZhbHVlKS55KHhWYWx1ZSkgOiBsaW5lLngoeFZhbHVlKS55KHlWYWx1ZSksIGxpbmVDb25uZWN0TnVsbCB8fCAobGluZSA9IGxpbmUuZGVmaW5lZChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuICQkLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbDtcbiAgICB9KSk7XG4gICAgdmFyIHggPSBpc1N1YiA/ICQkLnN1YlggOiAkJC54O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIHBhdGgsXG4gICAgICAgICAgeSA9IHlTY2FsZUdldHRlci5jYWxsKCQkLCBkLmlkKSxcbiAgICAgICAgICB2YWx1ZXMgPSBsaW5lQ29ubmVjdE51bGwgPyAkJC5maWx0ZXJSZW1vdmVOdWxsKGQudmFsdWVzKSA6IGQudmFsdWVzLFxuICAgICAgICAgIHgwID0gMCxcbiAgICAgICAgICB5MCA9IDA7XG5cbiAgICAgIGlmICgkJC5pc0xpbmVUeXBlKGQpKSB7XG4gICAgICAgIHZhciByZWdpb25zID0gY29uZmlnLmRhdGFfcmVnaW9uc1tkLmlkXTtcbiAgICAgICAgcmVnaW9ucyA/IHBhdGggPSAkJC5saW5lV2l0aFJlZ2lvbnModmFsdWVzLCB4LCB5LCByZWdpb25zKSA6ICgkJC5pc1N0ZXBUeXBlKGQpICYmICh2YWx1ZXMgPSAkJC5jb252ZXJ0VmFsdWVzVG9TdGVwKHZhbHVlcykpLCBwYXRoID0gbGluZS5jdXJ2ZSgkJC5nZXRDdXJ2ZShkKSkodmFsdWVzKSk7XG4gICAgICB9IGVsc2UgdmFsdWVzWzBdICYmICh4MCA9IHgodmFsdWVzWzBdLngpLCB5MCA9IHkodmFsdWVzWzBdLnZhbHVlKSksIHBhdGggPSBpc1JvdGF0ZWQgPyBcIk0gXCIuY29uY2F0KHkwLCBcIiBcIikuY29uY2F0KHgwKSA6IFwiTSBcIi5jb25jYXQoeDAsIFwiIFwiKS5jb25jYXQoeTApO1xuXG4gICAgICByZXR1cm4gcGF0aCB8fCBcIk0gMCAwXCI7XG4gICAgfTtcbiAgfSxcbiAgZ2VuZXJhdGVHZXRMaW5lUG9pbnRzOiBmdW5jdGlvbiBnZW5lcmF0ZUdldExpbmVQb2ludHMobGluZUluZGljZXMsIGlzU3ViVmFsdWUpIHtcbiAgICAvLyBwYXJ0aWFsIGR1cGxpY2F0aW9uIG9mIGdlbmVyYXRlR2V0QmFyUG9pbnRzXG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBpc1N1YiA9ICEhaXNTdWJWYWx1ZSxcbiAgICAgICAgeCA9ICQkLmdldFNoYXBlWCgwLCBsaW5lSW5kaWNlcywgaXNTdWIpLFxuICAgICAgICB5ID0gJCQuZ2V0U2hhcGVZKGlzU3ViKSxcbiAgICAgICAgbGluZU9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzTGluZVR5cGUsIGxpbmVJbmRpY2VzLCBpc1N1YiksXG4gICAgICAgIHlTY2FsZSA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlIDogJCQuZ2V0WVNjYWxlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgdmFyIHkwID0geVNjYWxlLmNhbGwoJCQsIGQuaWQpKCQkLmdldFNoYXBlWU1pbihkLmlkKSksXG4gICAgICAgICAgb2Zmc2V0ID0gbGluZU9mZnNldChkLCBpKSB8fCB5MCxcbiAgICAgICAgICBwb3NYID0geChkKSxcbiAgICAgICAgICBwb3NZID0geShkKTtcbiAgICAgIGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKGQudmFsdWUgPiAwICYmIHBvc1kgPCB5MCB8fCBkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpICYmIChwb3NZID0geTApO1xuICAgICAgLy8gMSBwb2ludCB0aGF0IG1hcmtzIHRoZSBsaW5lIHBvc2l0aW9uXG4gICAgICB2YXIgcG9pbnQgPSBbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldO1xuICAgICAgcmV0dXJuIFtwb2ludCwgcG9pbnQsIC8vIGZyb20gaGVyZSBhbmQgYmVsb3csIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgcG9pbnQsIHBvaW50XTtcbiAgICB9O1xuICB9LFxuICBsaW5lV2l0aFJlZ2lvbnM6IGZ1bmN0aW9uIGxpbmVXaXRoUmVnaW9ucyhkLCB4LCB5LCBfcmVnaW9ucykge1xuICAgIHZhciB4cCxcbiAgICAgICAgeXAsXG4gICAgICAgIGRpZmYsXG4gICAgICAgIGRpZmZ4MixcbiAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQsXG4gICAgICAgIGlzVGltZVNlcmllcyA9ICQkLmlzVGltZVNlcmllcygpLFxuICAgICAgICB4T2Zmc2V0ID0gJCQuaXNDYXRlZ29yaXplZCgpID8gLjUgOiAwLFxuICAgICAgICByZWdpb25zID0gW10sXG4gICAgICAgIGRhc2hhcnJheSA9IFwiMiAyXCIsXG4gICAgICAgIGlzV2l0aGluUmVnaW9ucyA9IGZ1bmN0aW9uICh3aXRoaW5YLCB3aXRoaW5SZWdpb25zKSB7XG4gICAgICBmb3IgKHZhciByZWcsIGkgPSAwOyByZWcgPSB3aXRoaW5SZWdpb25zW2ldOyBpKyspIGlmIChyZWcuc3RhcnQgPCB3aXRoaW5YICYmIHdpdGhpblggPD0gcmVnLmVuZCkgcmV0dXJuIHJlZy5zdHlsZTtcblxuICAgICAgcmV0dXJuICExO1xuICAgIH07XG5cbiAgICAvLyBDaGVjayBzdGFydC9lbmQgb2YgcmVnaW9uc1xuICAgIGlmIChpc0RlZmluZWQoX3JlZ2lvbnMpKSB7XG4gICAgICB2YXIgZ2V0VmFsdWUgPSBmdW5jdGlvbiAodiwgZGVmKSB7XG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZCh2KSA/IGRlZiA6IGlzVGltZVNlcmllcyA/ICQkLnBhcnNlRGF0ZSh2KSA6IHY7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciByZWcsIGkgPSAwOyByZWcgPSBfcmVnaW9uc1tpXTsgaSsrKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGdldFZhbHVlKHJlZy5zdGFydCwgZFswXS54KSxcbiAgICAgICAgICAgIGVuZCA9IGdldFZhbHVlKHJlZy5lbmQsIGRbZC5sZW5ndGggLSAxXS54KSxcbiAgICAgICAgICAgIHN0eWxlID0gcmVnLnN0eWxlIHx8IHtcbiAgICAgICAgICBkYXNoYXJyYXk6IGRhc2hhcnJheVxuICAgICAgICB9O1xuICAgICAgICByZWdpb25zW2ldID0ge1xuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICBzdHlsZTogc3R5bGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIFNldCBzY2FsZXNcblxuXG4gICAgdmFyIHhWYWx1ZSA9IGlzUm90YXRlZCA/IGZ1bmN0aW9uIChkdCkge1xuICAgICAgcmV0dXJuIHkoZHQudmFsdWUpO1xuICAgIH0gOiBmdW5jdGlvbiAoZHQpIHtcbiAgICAgIHJldHVybiB4KGR0LngpO1xuICAgIH0sXG4gICAgICAgIHlWYWx1ZSA9IGlzUm90YXRlZCA/IGZ1bmN0aW9uIChkdCkge1xuICAgICAgcmV0dXJuIHgoZHQueCk7XG4gICAgfSA6IGZ1bmN0aW9uIChkdCkge1xuICAgICAgcmV0dXJuIHkoZHQudmFsdWUpO1xuICAgIH0sXG4gICAgICAgIGdlbmVyYXRlTSA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgIHJldHVybiBcIk1cIi5jb25jYXQocG9pbnRzWzBdWzBdLCBcIixcIikuY29uY2F0KHBvaW50c1swXVsxXSwgXCJMXCIpLmNvbmNhdChwb2ludHNbMV1bMF0sIFwiLFwiKS5jb25jYXQocG9pbnRzWzFdWzFdKTtcbiAgICB9LFxuICAgICAgICBzV2l0aFJlZ2lvbiA9IGlzVGltZVNlcmllcyA/IGZ1bmN0aW9uIChkMCwgZDEsIGssIHRpbWVzZXJpZXNEaWZmKSB7XG4gICAgICB2YXIgeDAgPSBkMC54LmdldFRpbWUoKSxcbiAgICAgICAgICB4RGlmZiA9IGQxLnggLSBkMC54LFxuICAgICAgICAgIHh2MCA9IG5ldyBEYXRlKHgwICsgeERpZmYgKiBrKSxcbiAgICAgICAgICB4djEgPSBuZXcgRGF0ZSh4MCArIHhEaWZmICogKGsgKyB0aW1lc2VyaWVzRGlmZikpLFxuICAgICAgICAgIHBvaW50cyA9IGlzUm90YXRlZCA/IFtbeSh5cChrKSksIHgoeHYwKV0sIFt5KHlwKGsgKyBkaWZmKSksIHgoeHYxKV1dIDogW1t4KHh2MCksIHkoeXAoaykpXSwgW3goeHYxKSwgeSh5cChrICsgZGlmZikpXV07XG4gICAgICByZXR1cm4gZ2VuZXJhdGVNKHBvaW50cyk7XG4gICAgfSA6IGZ1bmN0aW9uIChkMCwgZDEsIGssIG90aGVyRGlmZikge1xuICAgICAgdmFyIHBvaW50cyA9IGlzUm90YXRlZCA/IFtbeSh5cChrKSwgITApLCB4KHhwKGspKV0sIFt5KHlwKGsgKyBvdGhlckRpZmYpLCAhMCksIHgoeHAoayArIG90aGVyRGlmZikpXV0gOiBbW3goeHAoayksICEwKSwgeSh5cChrKSldLCBbeCh4cChrICsgb3RoZXJEaWZmKSwgITApLCB5KHlwKGsgKyBvdGhlckRpZmYpKV1dO1xuICAgICAgcmV0dXJuIGdlbmVyYXRlTShwb2ludHMpO1xuICAgIH0sXG4gICAgICAgIHBhdGggPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgZGF0YSwgX2kgPSAwOyBkYXRhID0gZFtfaV07IF9pKyspIHtcbiAgICAgIHZhciBwcmV2RGF0YSA9IGRbX2kgLSAxXSxcbiAgICAgICAgICBoYXNQcmV2RGF0YSA9IHByZXZEYXRhICYmIGlzVmFsdWUocHJldkRhdGEudmFsdWUpLFxuICAgICAgICAgIHN0eWxlID0gaXNXaXRoaW5SZWdpb25zKGRhdGEueCwgcmVnaW9ucyk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy8xMTcyXG4gICAgICBpZiAoaXNWYWx1ZShkYXRhLnZhbHVlKSkgLy8gRHJhdyBhcyBub3JtYWxcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHJlZ2lvbnMpIHx8ICFzdHlsZSB8fCAhaGFzUHJldkRhdGEpIHBhdGggKz0gXCJcIi5jb25jYXQoX2kgJiYgaGFzUHJldkRhdGEgPyBcIkxcIiA6IFwiTVwiKS5jb25jYXQoeFZhbHVlKGRhdGEpLCBcIixcIikuY29uY2F0KHlWYWx1ZShkYXRhKSk7ZWxzZSBpZiAoaGFzUHJldkRhdGEpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3R5bGUgPSBzdHlsZS5kYXNoYXJyYXkuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHN0eWxlID0gZGFzaGFycmF5LnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICB9IC8vIERyYXcgd2l0aCByZWdpb24gLy8gVE9ETzogRml4IGZvciBob3Jpem90YWwgY2hhcnRzXG5cblxuICAgICAgICAgIHhwID0gJCQuZ2V0U2NhbGUocHJldkRhdGEueCArIHhPZmZzZXQsIGRhdGEueCArIHhPZmZzZXQsIGlzVGltZVNlcmllcyksIHlwID0gJCQuZ2V0U2NhbGUocHJldkRhdGEudmFsdWUsIGRhdGEudmFsdWUpO1xuICAgICAgICAgIHZhciBkeCA9IHgoZGF0YS54KSAtIHgocHJldkRhdGEueCksXG4gICAgICAgICAgICAgIGR5ID0geShkYXRhLnZhbHVlKSAtIHkocHJldkRhdGEudmFsdWUpLFxuICAgICAgICAgICAgICBkZCA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xuICAgICAgICAgIGRpZmYgPSBzdHlsZVswXSAvIGRkLCBkaWZmeDIgPSBkaWZmICogc3R5bGVbMV07XG5cbiAgICAgICAgICBmb3IgKHZhciBfaiA9IGRpZmY7IF9qIDw9IDE7IF9qICs9IGRpZmZ4MikgcGF0aCArPSBzV2l0aFJlZ2lvbihwcmV2RGF0YSwgZGF0YSwgX2osIGRpZmYpLCBfaiArIGRpZmZ4MiA+PSAxICYmIChwYXRoICs9IHNXaXRoUmVnaW9uKHByZXZEYXRhLCBkYXRhLCAxLCAwKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcbiAgdXBkYXRlQXJlYUdyYWRpZW50OiBmdW5jdGlvbiB1cGRhdGVBcmVhR3JhZGllbnQoKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIGlkID0gXCJcIi5jb25jYXQoJCQuZGF0ZXRpbWVJZCwgXCItYXJlYUdyYWRpZW50XCIpLmNvbmNhdCgkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKSk7XG5cbiAgICAgIGlmICgkJC5pc0FyZWFUeXBlKGQpICYmICQkLmRlZnMuc2VsZWN0KFwiI1wiLmNvbmNhdChpZCkpLmVtcHR5KCkpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gJCQuY29sb3IoZCksXG4gICAgICAgICAgICBfJCQkY29uZmlnJGFyZWFfbGluZWEgPSAkJC5jb25maWcuYXJlYV9saW5lYXJHcmFkaWVudCxcbiAgICAgICAgICAgIF8kJCRjb25maWckYXJlYV9saW5lYTIgPSBfJCQkY29uZmlnJGFyZWFfbGluZWEueCxcbiAgICAgICAgICAgIHggPSBfJCQkY29uZmlnJGFyZWFfbGluZWEyID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfJCQkY29uZmlnJGFyZWFfbGluZWEyLFxuICAgICAgICAgICAgXyQkJGNvbmZpZyRhcmVhX2xpbmVhMyA9IF8kJCRjb25maWckYXJlYV9saW5lYS55LFxuICAgICAgICAgICAgeSA9IF8kJCRjb25maWckYXJlYV9saW5lYTMgPT09IHZvaWQgMCA/IFswLCAxXSA6IF8kJCRjb25maWckYXJlYV9saW5lYTMsXG4gICAgICAgICAgICBfJCQkY29uZmlnJGFyZWFfbGluZWE0ID0gXyQkJGNvbmZpZyRhcmVhX2xpbmVhLnN0b3BzLFxuICAgICAgICAgICAgc3RvcHMgPSBfJCQkY29uZmlnJGFyZWFfbGluZWE0ID09PSB2b2lkIDAgPyBbWzAsIGNvbG9yLCAxXSwgWzEsIGNvbG9yLCAwXV0gOiBfJCQkY29uZmlnJGFyZWFfbGluZWE0LFxuICAgICAgICAgICAgbGluZWFyR3JhZGllbnQgPSAkJC5kZWZzLmFwcGVuZChcImxpbmVhckdyYWRpZW50XCIpLmF0dHIoXCJpZFwiLCBcIlwiLmNvbmNhdChpZCkpLmF0dHIoXCJ4MVwiLCB4WzBdKS5hdHRyKFwieDJcIiwgeFsxXSkuYXR0cihcInkxXCIsIHlbMF0pLmF0dHIoXCJ5MlwiLCB5WzFdKTtcbiAgICAgICAgc3RvcHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHZhciBzdG9wQ29sb3IgPSBpc0Z1bmN0aW9uKHZbMV0pID8gdlsxXShkLmlkKSA6IHZbMV07XG4gICAgICAgICAgbGluZWFyR3JhZGllbnQuYXBwZW5kKFwic3RvcFwiKS5hdHRyKFwib2Zmc2V0XCIsIHZbMF0pLmF0dHIoXCJzdG9wLWNvbG9yXCIsIHN0b3BDb2xvciB8fCBjb2xvcikuYXR0cihcInN0b3Atb3BhY2l0eVwiLCB2WzJdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHVwZGF0ZUFyZWFDb2xvcjogZnVuY3Rpb24gdXBkYXRlQXJlYUNvbG9yKGQpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgIHJldHVybiAkJC5jb25maWcuYXJlYV9saW5lYXJHcmFkaWVudCA/IFwidXJsKCNcIi5jb25jYXQoJCQuZGF0ZXRpbWVJZCwgXCItYXJlYUdyYWRpZW50XCIpLmNvbmNhdCgkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKSwgXCIpXCIpIDogJCQuY29sb3IoZCk7XG4gIH0sXG4gIHVwZGF0ZUFyZWE6IGZ1bmN0aW9uIHVwZGF0ZUFyZWEoZHVyYXRpb25Gb3JFeGl0KSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC5jb25maWcuYXJlYV9saW5lYXJHcmFkaWVudCAmJiAkJC51cGRhdGVBcmVhR3JhZGllbnQoKSwgJCQubWFpbkFyZWEgPSAkJC5tYWluLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYXJlYXMpKS5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmFyZWEpKS5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKSwgJCQubWFpbkFyZWEuZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIikucmVtb3ZlKCksICQkLm1haW5BcmVhID0gJCQubWFpbkFyZWEuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0FyZWEuYmluZCgkJCkpLnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpLnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJCQub3JnQXJlYU9wYWNpdHkgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhpcykuc3R5bGUoXCJvcGFjaXR5XCIpLCBcIjBcIjtcbiAgICB9KS5tZXJnZSgkJC5tYWluQXJlYSksICQkLm1haW5BcmVhLnN0eWxlKFwib3BhY2l0eVwiLCAkJC5vcmdBcmVhT3BhY2l0eSk7XG4gIH0sXG4gIHJlZHJhd0FyZWE6IGZ1bmN0aW9uIHJlZHJhd0FyZWEoZHJhd0FyZWEsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICByZXR1cm4gWyh3aXRoVHJhbnNpdGlvbiA/ICQkLm1haW5BcmVhLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpIDogJCQubWFpbkFyZWEpLmF0dHIoXCJkXCIsIGRyYXdBcmVhKS5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlQXJlYUNvbG9yLmJpbmQoJCQpKS5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAoJCQuaXNBcmVhUmFuZ2VUeXBlKGQpID8gJCQub3JnQXJlYU9wYWNpdHkgLyAxLjc1IDogJCQub3JnQXJlYU9wYWNpdHkpICsgXCJcIjtcbiAgICB9KV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFyZWEgcGF0aCBkYXRhXG4gICAqIEBwYXJhbSBhcmVhSW5kaWNlc1xuICAgKiBAcGFyYW0gaXNTdWJcbiAgICogQHJldHVybiB7ZnVuY3Rpb24oKj0pOiAoKnxzdHJpbmcpfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2VuZXJhdGVEcmF3QXJlYTogZnVuY3Rpb24gZ2VuZXJhdGVEcmF3QXJlYShhcmVhSW5kaWNlcywgaXNTdWIpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGxpbmVDb25uZWN0TnVsbCA9IGNvbmZpZy5saW5lX2Nvbm5lY3ROdWxsLFxuICAgICAgICBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkLFxuICAgICAgICBnZXRQb2ludHMgPSAkJC5nZW5lcmF0ZUdldEFyZWFQb2ludHMoYXJlYUluZGljZXMsIGlzU3ViKSxcbiAgICAgICAgeVNjYWxlR2V0dGVyID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGUsXG4gICAgICAgIHhWYWx1ZSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gKGlzU3ViID8gJCQuc3VieHggOiAkJC54eCkuY2FsbCgkJCwgZCk7XG4gICAgfSxcbiAgICAgICAgdmFsdWUwID0gZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiAkJC5pc0dyb3VwZWQoZC5pZCkgPyBnZXRQb2ludHMoZCwgaSlbMF1bMV0gOiB5U2NhbGVHZXR0ZXIuY2FsbCgkJCwgZC5pZCkoJCQuaXNBcmVhUmFuZ2VUeXBlKGQpID8gJCQuZ2V0QXJlYVJhbmdlRGF0YShkLCBcImhpZ2hcIikgOiAkJC5nZXRTaGFwZVlNaW4oZC5pZCkpO1xuICAgIH0sXG4gICAgICAgIHZhbHVlMSA9IGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4gJCQuaXNHcm91cGVkKGQuaWQpID8gZ2V0UG9pbnRzKGQsIGkpWzFdWzFdIDogeVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpKCQkLmlzQXJlYVJhbmdlVHlwZShkKSA/ICQkLmdldEFyZWFSYW5nZURhdGEoZCwgXCJsb3dcIikgOiBkLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgcGF0aCxcbiAgICAgICAgICB2YWx1ZXMgPSBsaW5lQ29ubmVjdE51bGwgPyAkJC5maWx0ZXJSZW1vdmVOdWxsKGQudmFsdWVzKSA6IGQudmFsdWVzLFxuICAgICAgICAgIHgwID0gMCxcbiAgICAgICAgICB5MCA9IDA7XG5cbiAgICAgIGlmICgkJC5pc0FyZWFUeXBlKGQpKSB7XG4gICAgICAgIHZhciBhcmVhID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NoYXBlX2NvbW1vbmpzMl9kM19zaGFwZV9hbWRfZDNfc2hhcGVfcm9vdF9kM19bXCJhcmVhXCJdKSgpO1xuICAgICAgICBhcmVhID0gaXNSb3RhdGVkID8gYXJlYS55KHhWYWx1ZSkueDAodmFsdWUwKS54MSh2YWx1ZTEpIDogYXJlYS54KHhWYWx1ZSkueTAoY29uZmlnLmFyZWFfYWJvdmUgPyAwIDogdmFsdWUwKS55MSh2YWx1ZTEpLCBsaW5lQ29ubmVjdE51bGwgfHwgKGFyZWEgPSBhcmVhLmRlZmluZWQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gJCQuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsO1xuICAgICAgICB9KSksICQkLmlzU3RlcFR5cGUoZCkgJiYgKHZhbHVlcyA9ICQkLmNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKSksIHBhdGggPSBhcmVhLmN1cnZlKCQkLmdldEN1cnZlKGQpKSh2YWx1ZXMpO1xuICAgICAgfSBlbHNlIHZhbHVlc1swXSAmJiAoeDAgPSAkJC54KHZhbHVlc1swXS54KSwgeTAgPSAkJC5nZXRZU2NhbGUoZC5pZCkodmFsdWVzWzBdLnZhbHVlKSksIHBhdGggPSBpc1JvdGF0ZWQgPyBcIk0gXCIuY29uY2F0KHkwLCBcIiBcIikuY29uY2F0KHgwKSA6IFwiTSBcIi5jb25jYXQoeDAsIFwiIFwiKS5jb25jYXQoeTApO1xuXG4gICAgICByZXR1cm4gcGF0aCB8fCBcIk0gMCAwXCI7XG4gICAgfTtcbiAgfSxcbiAgZ2VuZXJhdGVHZXRBcmVhUG9pbnRzOiBmdW5jdGlvbiBnZW5lcmF0ZUdldEFyZWFQb2ludHMoYXJlYUluZGljZXMsIGlzU3ViKSB7XG4gICAgLy8gcGFydGlhbCBkdXBsaWNhdGlvbiBvZiBnZW5lcmF0ZUdldEJhclBvaW50c1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgeCA9ICQkLmdldFNoYXBlWCgwLCBhcmVhSW5kaWNlcywgISFpc1N1YiksXG4gICAgICAgIHkgPSAkJC5nZXRTaGFwZVkoISFpc1N1YiksXG4gICAgICAgIGFyZWFPZmZzZXQgPSAkJC5nZXRTaGFwZU9mZnNldCgkJC5pc0FyZWFUeXBlLCBhcmVhSW5kaWNlcywgISFpc1N1YiksXG4gICAgICAgIHlTY2FsZSA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlIDogJCQuZ2V0WVNjYWxlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgdmFyIHkwID0geVNjYWxlLmNhbGwoJCQsIGQuaWQpKCQkLmdldFNoYXBlWU1pbihkLmlkKSksXG4gICAgICAgICAgb2Zmc2V0ID0gYXJlYU9mZnNldChkLCBpKSB8fCB5MCxcbiAgICAgICAgICBwb3NYID0geChkKSxcbiAgICAgICAgICBwb3NZID0geShkKTtcbiAgICAgIC8vIDEgcG9pbnQgdGhhdCBtYXJrcyB0aGUgYXJlYSBwb3NpdGlvblxuICAgICAgcmV0dXJuIGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKGQudmFsdWUgPiAwICYmIHBvc1kgPCB5MCB8fCBkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpICYmIChwb3NZID0geTApLCBbW3Bvc1gsIG9mZnNldF0sIFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV0sIFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV0sIC8vIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgW3Bvc1gsIG9mZnNldF0gLy8gbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XG4gICAgICBdO1xuICAgIH07XG4gIH0sXG4gIHVwZGF0ZUNpcmNsZTogZnVuY3Rpb24gdXBkYXRlQ2lyY2xlKCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG5cbiAgICBpZiAoJCQuY29uZmlnLnBvaW50X3Nob3cpIHtcbiAgICAgICQkLm1haW5DaXJjbGUgPSAkJC5tYWluLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2lyY2xlcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2lyY2xlKSkuZGF0YShmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gISQkLmlzQmFyVHlwZShkKSAmJiAoISQkLmlzTGluZVR5cGUoZCkgfHwgJCQuc2hvdWxkRHJhd1BvaW50c0ZvckxpbmUoZCkpICYmICQkLmxhYmVsaXNoRGF0YShkKTtcbiAgICAgIH0pLCAkJC5tYWluQ2lyY2xlLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgIHZhciBmbiA9ICQkLnBvaW50KFwiY3JlYXRlXCIsIHRoaXMsICQkLnBvaW50Ui5iaW5kKCQkKSwgJCQuY29sb3IpO1xuICAgICAgJCQubWFpbkNpcmNsZSA9ICQkLm1haW5DaXJjbGUuZW50ZXIoKS5hcHBlbmQoZm4pLm1lcmdlKCQkLm1haW5DaXJjbGUpLnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKS5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHlGb3JDaXJjbGUuYmluZCgkJCkpO1xuICAgIH1cbiAgfSxcbiAgcmVkcmF3Q2lyY2xlOiBmdW5jdGlvbiByZWRyYXdDaXJjbGUoY3gsIGN5LCB3aXRoVHJhbnNpdGlvbiwgZmxvdykge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHNlbGVjdGVkQ2lyY2xlcyA9ICQkLm1haW4uc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5zZWxlY3RlZENpcmNsZSkpO1xuICAgIGlmICghJCQuY29uZmlnLnBvaW50X3Nob3cpIHJldHVybiBbXTtcbiAgICB2YXIgbWFpbkNpcmNsZXMgPSBbXTtcbiAgICAkJC5tYWluQ2lyY2xlLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBmbiA9ICQkLnBvaW50KFwidXBkYXRlXCIsICQkLCBjeCwgY3ksICQkLm9wYWNpdHlGb3JDaXJjbGUuYmluZCgkJCksICQkLmNvbG9yLCB3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKS5iaW5kKHRoaXMpLFxuICAgICAgICAgIHJlc3VsdCA9IGZuKGQpO1xuICAgICAgbWFpbkNpcmNsZXMucHVzaChyZXN1bHQpO1xuICAgIH0pO1xuICAgIHZhciBwb3NBdHRyID0gJCQuaXNDaXJjbGVQb2ludCgpID8gXCJjXCIgOiBcIlwiO1xuICAgIHJldHVybiBbbWFpbkNpcmNsZXMsIHNlbGVjdGVkQ2lyY2xlcy5hdHRyKFwiXCIuY29uY2F0KHBvc0F0dHIsIFwieFwiKSwgY3gpLmF0dHIoXCJcIi5jb25jYXQocG9zQXR0ciwgXCJ5XCIpLCBjeSldO1xuICB9LFxuICBjaXJjbGVYOiBmdW5jdGlvbiBjaXJjbGVYKGQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBoYXNWYWx1ZSA9IGlzVmFsdWUoZC54KTtcbiAgICByZXR1cm4gJCQuY29uZmlnLnpvb21fZW5hYmxlZCAmJiAkJC56b29tU2NhbGUgPyBoYXNWYWx1ZSA/ICQkLnpvb21TY2FsZShkLngpIDogbnVsbCA6IGhhc1ZhbHVlID8gJCQueChkLngpIDogbnVsbDtcbiAgfSxcbiAgdXBkYXRlQ2lyY2xlWTogZnVuY3Rpb24gdXBkYXRlQ2lyY2xlWSgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBnZXRQb2ludHMgPSAkJC5nZW5lcmF0ZUdldExpbmVQb2ludHMoJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzTGluZVR5cGUpLCAhMSk7XG5cbiAgICAkJC5jaXJjbGVZID0gZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHZhciBpZCA9IGQuaWQ7XG4gICAgICByZXR1cm4gJCQuaXNHcm91cGVkKGlkKSA/IGdldFBvaW50cyhkLCBpKVswXVsxXSA6ICQkLmdldFlTY2FsZShpZCkoJCQuZ2V0QmFzZVZhbHVlKGQpKTtcbiAgICB9O1xuICB9LFxuICBnZXRDaXJjbGVzOiBmdW5jdGlvbiBnZXRDaXJjbGVzKGksIGlkKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgc3VmZml4ID0gaXNWYWx1ZShpKSA/IFwiLVwiLmNvbmNhdChpKSA6IFwiXCI7XG4gICAgcmV0dXJuIChpZCA/ICQkLm1haW4uc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaXJjbGVzKS5jb25jYXQoJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpKSkgOiAkJC5tYWluKS5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNpcmNsZSkuY29uY2F0KHN1ZmZpeCkpO1xuICB9LFxuICBleHBhbmRDaXJjbGVzOiBmdW5jdGlvbiBleHBhbmRDaXJjbGVzKGksIGlkLCByZXNldCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHIgPSAkJC5wb2ludEV4cGFuZGVkUi5iaW5kKCQkKTtcbiAgICByZXNldCAmJiAkJC51bmV4cGFuZENpcmNsZXMoKTtcbiAgICB2YXIgY2lyY2xlcyA9ICQkLmdldENpcmNsZXMoaSwgaWQpLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuRVhQQU5ERUQsICEwKSxcbiAgICAgICAgc2NhbGUgPSByKGNpcmNsZXMpIC8gJCQuY29uZmlnLnBvaW50X3IsXG4gICAgICAgIHJhdGlvID0gMSAtIHNjYWxlO1xuICAgICQkLmlzQ2lyY2xlUG9pbnQoKSA/IGNpcmNsZXMuYXR0cihcInJcIiwgcikgOiBjaXJjbGVzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMpO1xuICAgICAgaWYgKHRoaXMudGFnTmFtZSA9PT0gXCJjaXJjbGVcIikgcG9pbnQuYXR0cihcInJcIiwgcik7ZWxzZSB7XG4gICAgICAgIHZhciBfdGhpcyRnZXRCQm94ID0gdGhpcy5nZXRCQm94KCksXG4gICAgICAgICAgICB3aWR0aCA9IF90aGlzJGdldEJCb3gud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRnZXRCQm94LmhlaWdodCxcbiAgICAgICAgICAgIHggPSByYXRpbyAqICgrcG9pbnQuYXR0cihcInhcIikgKyB3aWR0aCAvIDIpLFxuICAgICAgICAgICAgeSA9IHJhdGlvICogKCtwb2ludC5hdHRyKFwieVwiKSArIGhlaWdodCAvIDIpO1xuXG4gICAgICAgIHBvaW50LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHgsIFwiIFwiKS5jb25jYXQoeSwgXCIpIHNjYWxlKFwiKS5jb25jYXQoc2NhbGUsIFwiKVwiKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHVuZXhwYW5kQ2lyY2xlczogZnVuY3Rpb24gdW5leHBhbmRDaXJjbGVzKGkpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICByID0gJCQucG9pbnRSLmJpbmQoJCQpLFxuICAgICAgICBjaXJjbGVzID0gJCQuZ2V0Q2lyY2xlcyhpKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKSh0aGlzKS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLkVYUEFOREVEKTtcbiAgICB9KS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLkVYUEFOREVELCAhMSk7XG4gICAgY2lyY2xlcy5hdHRyKFwiclwiLCByKSwgJCQuaXNDaXJjbGVQb2ludCgpIHx8IGNpcmNsZXMuYXR0cihcInRyYW5zZm9ybVwiLCBcInNjYWxlKFwiLmNvbmNhdChyKGNpcmNsZXMpIC8gJCQuY29uZmlnLnBvaW50X3IsIFwiKVwiKSk7XG4gIH0sXG4gIHBvaW50UjogZnVuY3Rpb24gKGQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIHBvaW50UiA9IGNvbmZpZy5wb2ludF9yLFxuICAgICAgICByID0gcG9pbnRSO1xuICAgIHJldHVybiAkJC5pc1N0ZXBUeXBlKGQpID8gciA9IDAgOiAkJC5pc0J1YmJsZVR5cGUoZCkgPyByID0gJCQuZ2V0QnViYmxlUihkKSA6IGlzRnVuY3Rpb24ocG9pbnRSKSAmJiAociA9IHBvaW50UihkKSksIHI7XG4gIH0sXG4gIHBvaW50RXhwYW5kZWRSOiBmdW5jdGlvbiBwb2ludEV4cGFuZGVkUihkKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBzY2FsZSA9ICQkLmlzQnViYmxlVHlwZShkKSA/IDEuMTUgOiAxLjc1O1xuICAgIHJldHVybiBjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQgPyBjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX3IgfHwgJCQucG9pbnRSKGQpICogc2NhbGUgOiAkJC5wb2ludFIoZCk7XG4gIH0sXG4gIHBvaW50U2VsZWN0UjogZnVuY3Rpb24gcG9pbnRTZWxlY3RSKGQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBzZWxlY3RSID0gJCQuY29uZmlnLnBvaW50X3NlbGVjdF9yO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKHNlbGVjdFIpID8gc2VsZWN0UihkKSA6IHNlbGVjdFIgfHwgJCQucG9pbnRSKGQpICogNDtcbiAgfSxcbiAgaXNXaXRoaW5DaXJjbGU6IGZ1bmN0aW9uIGlzV2l0aGluQ2lyY2xlKG5vZGUsIHIpIHtcbiAgICB2YXIgbW91c2UgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcIm1vdXNlXCJdKShub2RlKSxcbiAgICAgICAgZWxlbWVudCA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKShub2RlKSxcbiAgICAgICAgcHJlZml4ID0gdGhpcy5pc0NpcmNsZVBvaW50KCkgPyBcImNcIiA6IFwiXCIsXG4gICAgICAgIGN4ID0gK2VsZW1lbnQuYXR0cihcIlwiLmNvbmNhdChwcmVmaXgsIFwieFwiKSksXG4gICAgICAgIGN5ID0gK2VsZW1lbnQuYXR0cihcIlwiLmNvbmNhdChwcmVmaXgsIFwieVwiKSk7XG5cbiAgICAvLyBpZiBub2RlIGRvbid0IGhhdmUgY3gveSBvciB4L3kgYXR0cmlidXRlIHZhbHVlXG4gICAgaWYgKCEoY3ggfHwgY3kpICYmIG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIHZhciBfcmVmID0gbm9kZS5nZXRCQm94ID8gbm9kZS5nZXRCQm94KCkgOiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIHggPSBfcmVmLngsXG4gICAgICAgICAgeSA9IF9yZWYueTtcblxuICAgICAgY3ggPSB4LCBjeSA9IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhjeCAtIG1vdXNlWzBdLCAyKSArIE1hdGgucG93KGN5IC0gbW91c2VbMV0sIDIpKSA8IChyIHx8IHRoaXMuY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KTtcbiAgfSxcbiAgaXNXaXRoaW5TdGVwOiBmdW5jdGlvbiBpc1dpdGhpblN0ZXAodGhhdCwgeSkge1xuICAgIHJldHVybiBNYXRoLmFicyh5IC0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJtb3VzZVwiXSkodGhhdClbMV0pIDwgMzA7XG4gIH0sXG4gIHNob3VsZERyYXdQb2ludHNGb3JMaW5lOiBmdW5jdGlvbiBzaG91bGREcmF3UG9pbnRzRm9yTGluZShkKSB7XG4gICAgdmFyIGxpbmVQb2ludCA9IHRoaXMuY29uZmlnLmxpbmVfcG9pbnQ7XG4gICAgcmV0dXJuIGxpbmVQb2ludCA9PT0gITAgfHwgaXNBcnJheShsaW5lUG9pbnQpICYmIGxpbmVQb2ludC5pbmRleE9mKGQuaWQpICE9PSAtMTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zaGFwZS9wb2ludC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIGhhc1ZhbGlkUG9pbnRUeXBlOiBmdW5jdGlvbiBoYXNWYWxpZFBvaW50VHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIC9eKGNpcmNsZXxyZWN0KGFuZ2xlKT98cG9seWdvbnxlbGxpcHNlfHVzZSkkL2kudGVzdCh0eXBlIHx8IHRoaXMuY29uZmlnLnBvaW50X3R5cGUpO1xuICB9LFxuICBoYXNWYWxpZFBvaW50RHJhd01ldGhvZHM6IGZ1bmN0aW9uIGhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyh0eXBlKSB7XG4gICAgdmFyIHBvaW50VHlwZSA9IHR5cGUgfHwgdGhpcy5jb25maWcucG9pbnRfdHlwZTtcbiAgICByZXR1cm4gaXNPYmplY3RUeXBlKHBvaW50VHlwZSkgJiYgaXNGdW5jdGlvbihwb2ludFR5cGUuY3JlYXRlKSAmJiBpc0Z1bmN0aW9uKHBvaW50VHlwZS51cGRhdGUpO1xuICB9LFxuICBpbnNlcnRQb2ludEluZm9EZWZzOiBmdW5jdGlvbiBpbnNlcnRQb2ludEluZm9EZWZzKHBvaW50LCBpZCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvcHlBdHRyID0gZnVuY3Rpb24gKGZyb20sIHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgbmFtZSwgYXR0cmlicyA9IGZyb20uYXR0cmlidXRlcywgaSA9IDA7IG5hbWUgPSBhdHRyaWJzW2ldOyBpKyspIG5hbWUgPSBuYW1lLm5hbWUsIHRhcmdldC5zZXRBdHRyaWJ1dGUobmFtZSwgZnJvbS5nZXRBdHRyaWJ1dGUobmFtZSkpO1xuICAgIH0sXG4gICAgICAgIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcocG9pbnQsIFwiaW1hZ2Uvc3ZnK3htbFwiKSxcbiAgICAgICAgbm9kZSA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIGNsb25lID0gYnJvd3Nlcl9kb2MuY3JlYXRlRWxlbWVudE5TKGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJuYW1lc3BhY2VzXCJdLnN2Zywgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcblxuICAgIGlmIChjbG9uZS5pZCA9IGlkLCBjbG9uZS5zdHlsZS5maWxsID0gXCJpbmhlcml0XCIsIGNsb25lLnN0eWxlLnN0cm9rZSA9IFwiaW5oZXJpdFwiLCBjb3B5QXR0cihub2RlLCBjbG9uZSksIG5vZGUuY2hpbGROb2RlcyAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKGNsb25lKTtcbiAgICAgIFwiaW5uZXJIVE1MXCIgaW4gY2xvbmUgPyBwYXJlbnQuaHRtbChub2RlLmlubmVySFRNTCkgOiB0b0FycmF5KG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICBjb3B5QXR0cih2LCBwYXJlbnQuYXBwZW5kKHYudGFnTmFtZSkubm9kZSgpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgICQkLmRlZnMubm9kZSgpLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgfSxcbiAgcG9pbnRGcm9tRGVmczogZnVuY3Rpb24gcG9pbnRGcm9tRGVmcyhpZCkge1xuICAgIHJldHVybiB0aGlzLmRlZnMuc2VsZWN0KFwiI1wiLmNvbmNhdChpZCkpO1xuICB9LFxuICB1cGRhdGVQb2ludENsYXNzOiBmdW5jdGlvbiB1cGRhdGVQb2ludENsYXNzKGQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBwb2ludENsYXNzID0gITE7XG4gICAgcmV0dXJuIChpc09iamVjdChkKSB8fCAkJC5tYWluQ2lyY2xlKSAmJiAocG9pbnRDbGFzcyA9IGQgPT09ICEwID8gJCQubWFpbkNpcmNsZS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gJCQuY2xhc3NDaXJjbGUuYmluZCgkJCkoZCk7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLmluZGV4T2YoY29uZmlnX2NsYXNzZXMuRVhQQU5ERUQpID4gLTEgJiYgKGNsYXNzTmFtZSArPSBcIiBcIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuRVhQQU5ERUQpKSwgdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBjbGFzc05hbWUpO1xuICAgIH0pIDogJCQuY2xhc3NDaXJjbGUoZCkpLCBwb2ludENsYXNzO1xuICB9LFxuICBnZW5lcmF0ZVBvaW50OiBmdW5jdGlvbiBnZW5lcmF0ZVBvaW50KCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgaWRzID0gW10sXG4gICAgICAgIHBhdHRlcm4gPSBub3RFbXB0eShjb25maWcucG9pbnRfcGF0dGVybikgPyBjb25maWcucG9pbnRfcGF0dGVybiA6IFtjb25maWcucG9pbnRfdHlwZV07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgaWQgPSBkLmlkIHx8IGQuZGF0YSAmJiBkLmRhdGEuaWQgfHwgZCxcbiAgICAgICAgICAgIGVsZW1lbnQgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhpcyk7XG4gICAgICAgIGlkcy5pbmRleE9mKGlkKSA8IDAgJiYgaWRzLnB1c2goaWQpO1xuICAgICAgICB2YXIgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIHBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgICAgaWYgKCQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSkgcG9pbnQgPSAkJFtwb2ludF07ZWxzZSBpZiAoISQkLmhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyhwb2ludCkpIHtcbiAgICAgICAgICB2YXIgcG9pbnRJZCA9IFwiXCIuY29uY2F0KCQkLmRhdGV0aW1lSWQsIFwiLXBvaW50LVwiKS5jb25jYXQoaWQpLFxuICAgICAgICAgICAgICBwb2ludEZyb21EZWZzID0gJCQucG9pbnRGcm9tRGVmcyhwb2ludElkKTtcbiAgICAgICAgICBpZiAocG9pbnRGcm9tRGVmcy5zaXplKCkgPCAxICYmICQkLmluc2VydFBvaW50SW5mb0RlZnMocG9pbnQsIHBvaW50SWQpLCBtZXRob2QgPT09IFwiY3JlYXRlXCIpIHJldHVybiAkJC5jdXN0b20uY3JlYXRlLmJpbmQoY29udGV4dCkuYXBwbHkodm9pZCAwLCBbZWxlbWVudCwgcG9pbnRJZF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInVwZGF0ZVwiKSByZXR1cm4gJCQuY3VzdG9tLnVwZGF0ZS5iaW5kKGNvbnRleHQpLmFwcGx5KHZvaWQgMCwgW2VsZW1lbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50W21ldGhvZF0uYmluZChjb250ZXh0KS5hcHBseSh2b2lkIDAsIFtlbGVtZW50XS5jb25jYXQoYXJncykpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBnZXRUcmFuc2l0aW9uTmFtZTogZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbk5hbWUoKSB7XG4gICAgcmV0dXJuIGdldFJhbmRvbSgpO1xuICB9LFxuICBjdXN0b206IHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50LCBpZCwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuYXBwZW5kKFwidXNlXCIpLmF0dHIoXCJ4bGluazpocmVmXCIsIFwiI1wiLmNvbmNhdChpZCkpLmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSkuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKS5ub2RlKCk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgb3BhY2l0eVN0eWxlRm4sIGZpbGxTdHlsZUZuLCB3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKSB7XG4gICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgIF9lbGVtZW50JG5vZGUkZ2V0QkJveCA9IGVsZW1lbnQubm9kZSgpLmdldEJCb3goKSxcbiAgICAgICAgICB3aWR0aCA9IF9lbGVtZW50JG5vZGUkZ2V0QkJveC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfZWxlbWVudCRub2RlJGdldEJCb3guaGVpZ2h0LFxuICAgICAgICAgIHhQb3NGbjIgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4geFBvc0ZuKGQpIC0gd2lkdGggLyAyO1xuICAgICAgfSxcbiAgICAgICAgICBtYWluQ2lyY2xlcyA9IGVsZW1lbnQ7XG5cbiAgICAgIGlmICh3aXRoVHJhbnNpdGlvbikge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSAkJC5nZXRUcmFuc2l0aW9uTmFtZSgpO1xuICAgICAgICBmbG93ICYmIG1haW5DaXJjbGVzLmF0dHIoXCJ4XCIsIHhQb3NGbjIpLCBtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzLnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpLCBzZWxlY3RlZENpcmNsZXMudHJhbnNpdGlvbigkJC5nZXRUcmFuc2l0aW9uTmFtZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1haW5DaXJjbGVzLmF0dHIoXCJ4XCIsIHhQb3NGbjIpLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uIHlQb3NGbjIoZCkge1xuICAgICAgICByZXR1cm4geVBvc0ZuKGQpIC0gaGVpZ2h0IC8gMjtcbiAgICAgIH0pLnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5U3R5bGVGbikuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcbiAgICB9XG4gIH0sXG4gIC8vICdjaXJjbGUnIGRhdGEgcG9pbnRcbiAgY2lyY2xlOiB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZWxlbWVudCwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuYXBwZW5kKFwiY2lyY2xlXCIpLmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSkuYXR0cihcInJcIiwgc2l6ZUZuKS5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pLm5vZGUoKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBvcGFjaXR5U3R5bGVGbiwgZmlsbFN0eWxlRm4sIHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xuXG4gICAgICBpZiAoJCQuaGFzVHlwZShcImJ1YmJsZVwiKSAmJiBtYWluQ2lyY2xlcy5hdHRyKFwiclwiLCAkJC5wb2ludFIuYmluZCgkJCkpLCB3aXRoVHJhbnNpdGlvbikge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSAkJC5nZXRUcmFuc2l0aW9uTmFtZSgpO1xuICAgICAgICBmbG93ICYmIG1haW5DaXJjbGVzLmF0dHIoXCJjeFwiLCB4UG9zRm4pLCBtYWluQ2lyY2xlcy5hdHRyKFwiY3hcIikgJiYgKG1haW5DaXJjbGVzID0gbWFpbkNpcmNsZXMudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSkpLCBzZWxlY3RlZENpcmNsZXMudHJhbnNpdGlvbigkJC5nZXRUcmFuc2l0aW9uTmFtZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1haW5DaXJjbGVzLmF0dHIoXCJjeFwiLCB4UG9zRm4pLmF0dHIoXCJjeVwiLCB5UG9zRm4pLnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5U3R5bGVGbikuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcbiAgICB9XG4gIH0sXG4gIC8vICdyZWN0YW5nbGUnIGRhdGEgcG9pbnRcbiAgcmVjdGFuZ2xlOiB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZWxlbWVudCwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xuICAgICAgdmFyIHJlY3RTaXplRm4gPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gc2l6ZUZuKGQpICogMjtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBlbGVtZW50LmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIHRoaXMudXBkYXRlUG9pbnRDbGFzcy5iaW5kKHRoaXMpKS5hdHRyKFwid2lkdGhcIiwgcmVjdFNpemVGbikuYXR0cihcImhlaWdodFwiLCByZWN0U2l6ZUZuKS5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pLm5vZGUoKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBvcGFjaXR5U3R5bGVGbiwgZmlsbFN0eWxlRm4sIHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcbiAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgciA9ICQkLmNvbmZpZy5wb2ludF9yLFxuICAgICAgICAgIHJlY3RYUG9zRm4gPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4geFBvc0ZuKGQpIC0gcjtcbiAgICAgIH0sXG4gICAgICAgICAgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xuXG4gICAgICBpZiAod2l0aFRyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25OYW1lID0gJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKTtcbiAgICAgICAgZmxvdyAmJiBtYWluQ2lyY2xlcy5hdHRyKFwieFwiLCByZWN0WFBvc0ZuKSwgbWFpbkNpcmNsZXMgPSBtYWluQ2lyY2xlcy50cmFuc2l0aW9uKHRyYW5zaXRpb25OYW1lKSwgc2VsZWN0ZWRDaXJjbGVzLnRyYW5zaXRpb24oJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYWluQ2lyY2xlcy5hdHRyKFwieFwiLCByZWN0WFBvc0ZuKS5hdHRyKFwieVwiLCBmdW5jdGlvbiByZWN0WVBvc0ZuKGQpIHtcbiAgICAgICAgcmV0dXJuIHlQb3NGbihkKSAtIHI7XG4gICAgICB9KS5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eVN0eWxlRm4pLnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbik7XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3NoYXBlL3JhZGFyLmpzXG5cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuXG4vKipcbiAqIEdldCB0aGUgcG9zaXRpb24gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDbG9ja3dpc2UgSWYgdGhlIGRpcmVjdGlvbiBpcyBjbG9ja3dpc2VcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIENvb3JkaW5hdGUgdHlwZSAneCcgb3IgJ3knXG4gKiBAcGFyYW0ge051bWJlcn0gZWRnZSBOdW1iZXIgb2YgZWRnZVxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcyBUaGUgaW5kZXhlZCBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhbmdlXG4gKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb24oaXNDbG9ja3dpc2UsIHR5cGUsIGVkZ2UsIHBvcywgcmFuZ2UsIHJhdGlvKSB7XG4gIHZhciBpbmRleCA9IGlzQ2xvY2t3aXNlICYmIHBvcyA+IDAgPyBlZGdlIC0gcG9zIDogcG9zLFxuICAgICAgciA9IDIgKiBNYXRoLlBJLFxuICAgICAgZnVuYyA9IHR5cGUgPT09IFwieFwiID8gTWF0aC5zaW4gOiBNYXRoLmNvcztcbiAgcmV0dXJuIHJhbmdlICogKDEgLSByYXRpbyAqIGZ1bmMoaW5kZXggKiByIC8gZWRnZSkpO1xufSAvLyBjYWNoZSBrZXlcblxuXG52YXIgcmFkYXJfY2FjaGVLZXkgPSBcIiRyYWRhclBvaW50c1wiO1xuZXh0ZW5kKENoYXJ0SW50ZXJuYWxfQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcbiAgaW5pdFJhZGFyOiBmdW5jdGlvbiBpbml0UmFkYXIoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICQkLmhhc1R5cGUoXCJyYWRhclwiKSAmJiAoJCQucmFkYXJzID0gJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0KSkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY29uZmlnX2NsYXNzZXMuY2hhcnRSYWRhcnMpLCAkJC5yYWRhcnMubGV2ZWxzID0gJCQucmFkYXJzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLmxldmVscyksICQkLnJhZGFycy5heGVzID0gJCQucmFkYXJzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLmF4aXMpLCAkJC5yYWRhcnMuc2hhcGVzID0gJCQucmFkYXJzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLnNoYXBlcyksICQkLm1heFZhbHVlID0gY29uZmlnLnJhZGFyX2F4aXNfbWF4IHx8ICQkLmdldE1pbk1heERhdGEoKS5tYXhbMF0udmFsdWUpO1xuICB9LFxuICBnZXRSYWRhclNpemU6IGZ1bmN0aW9uIGdldFJhZGFyU2l6ZSgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIHBhZGRpbmcgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoIDwgNCA/IC0yMCA6IDEwLFxuICAgICAgICBzaXplID0gKE1hdGgubWluKCQkLmFyY1dpZHRoLCAkJC5hcmNIZWlnaHQpIC0gcGFkZGluZykgLyAyO1xuICAgIHJldHVybiBbc2l6ZSwgc2l6ZV07XG4gIH0sXG4gIHVwZGF0ZVRhcmdldHNGb3JSYWRhcjogZnVuY3Rpb24gdXBkYXRlVGFyZ2V0c0ZvclJhZGFyKHRhcmdldHMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgaXNFbXB0eShjb25maWcuYXhpc194X2NhdGVnb3JpZXMpICYmIChjb25maWcuYXhpc194X2NhdGVnb3JpZXMgPSBnZXRSYW5nZSgwLCBnZXRNaW5NYXgoXCJtYXhcIiwgdGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbHVlcy5sZW5ndGg7XG4gICAgfSkpKSksICQkLmdlbmVyYXRlUmFkYXJQb2ludHMoKTtcbiAgfSxcbiAgZ2V0UmFkYXJQb3NpdGlvbjogZnVuY3Rpb24gZ2V0UmFkYXJQb3NpdGlvbih0eXBlLCBpbmRleCwgcmFuZ2UsIHJhdGlvKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBfJCQkZ2V0UmFkYXJTaXplID0gJCQuZ2V0UmFkYXJTaXplKCksXG4gICAgICAgIF8kJCRnZXRSYWRhclNpemUyID0gX3NsaWNlZFRvQXJyYXkoXyQkJGdldFJhZGFyU2l6ZSwgMiksXG4gICAgICAgIHdpZHRoID0gXyQkJGdldFJhZGFyU2l6ZTJbMF0sXG4gICAgICAgIGhlaWdodCA9IF8kJCRnZXRSYWRhclNpemUyWzFdLFxuICAgICAgICBlZGdlID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aCxcbiAgICAgICAgaXNDbG9ja3dpc2UgPSBjb25maWcucmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZSxcbiAgICAgICAgcG9zID0gdG9BcnJheSh0eXBlKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbihpc0Nsb2Nrd2lzZSwgdiwgZWRnZSwgaW5kZXgsIGlzRGVmaW5lZChyYW5nZSkgPyByYW5nZSA6IHR5cGUgPT09IFwieFwiID8gd2lkdGggOiBoZWlnaHQsIGlzTnVtYmVyKHJhdGlvKSA/IHJhdGlvIDogY29uZmlnLnJhZGFyX3NpemVfcmF0aW8pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBvcy5sZW5ndGggPT09IDEgPyBwb3NbMF0gOiBwb3M7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGRhdGEgcG9pbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZW5lcmF0ZVJhZGFyUG9pbnRzOiBmdW5jdGlvbiBnZW5lcmF0ZVJhZGFyUG9pbnRzKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMsXG4gICAgICAgIF8kJCRnZXRSYWRhclNpemUzID0gJCQuZ2V0UmFkYXJTaXplKCksXG4gICAgICAgIF8kJCRnZXRSYWRhclNpemU0ID0gX3NsaWNlZFRvQXJyYXkoXyQkJGdldFJhZGFyU2l6ZTMsIDIpLFxuICAgICAgICB3aWR0aCA9IF8kJCRnZXRSYWRhclNpemU0WzBdLFxuICAgICAgICBoZWlnaHQgPSBfJCQkZ2V0UmFkYXJTaXplNFsxXSxcbiAgICAgICAgcG9pbnRzID0gJCQuZ2V0Q2FjaGUocmFkYXJfY2FjaGVLZXkpIHx8IHt9LFxuICAgICAgICBzaXplID0gcG9pbnRzLl9zaXplO1xuXG4gICAgc2l6ZSAmJiAoc2l6ZS53aWR0aCA9PT0gd2lkdGggfHwgc2l6ZS5oZWlnaHQgPT09IGhlaWdodCkgfHwgKHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgcG9pbnRzW2QuaWRdID0gZC52YWx1ZXMubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgIHJldHVybiAkJC5nZXRSYWRhclBvc2l0aW9uKFtcInhcIiwgXCJ5XCJdLCBpLCB1bmRlZmluZWQsICQkLmdldFJhdGlvKFwicmFkYXJcIiwgdikpO1xuICAgICAgfSk7XG4gICAgfSksIHBvaW50cy5fc2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSwgJCQuYWRkQ2FjaGUocmFkYXJfY2FjaGVLZXksIHBvaW50cykpO1xuICB9LFxuICByZWRyYXdSYWRhcjogZnVuY3Rpb24gcmVkcmF3UmFkYXIoZHVyYXRpb25Gb3JFeGl0KSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgdHJhbnNsYXRlID0gJCQuZ2V0VHJhbnNsYXRlKFwicmFkYXJcIik7XG4gICAgdHJhbnNsYXRlICYmICgkJC5yYWRhcnMuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpLCAkJC5tYWluLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2lyY2xlcykpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlKSwgJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0VGV4dHMpKS5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zbGF0ZSksICQkLmdlbmVyYXRlUmFkYXJQb2ludHMoKSwgJCQudXBkYXRlUmFkYXJMZXZlbCgpLCAkJC51cGRhdGVSYWRhckF4ZXMoKSwgJCQudXBkYXRlUmFkYXJTaGFwZShkdXJhdGlvbkZvckV4aXQpKTtcbiAgfSxcbiAgZ2VuZXJhdGVHZXRSYWRhclBvaW50czogZnVuY3Rpb24gZ2VuZXJhdGVHZXRSYWRhclBvaW50cygpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBwb2ludHMgPSAkJC5nZXRDYWNoZShyYWRhcl9jYWNoZUtleSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICB2YXIgcG9pbnQgPSBwb2ludHNbZC5pZF1baV07XG4gICAgICByZXR1cm4gW3BvaW50LCBwb2ludCwgcG9pbnQsIHBvaW50XTtcbiAgICB9O1xuICB9LFxuICB1cGRhdGVSYWRhckxldmVsOiBmdW5jdGlvbiB1cGRhdGVSYWRhckxldmVsKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgXyQkJGdldFJhZGFyU2l6ZTUgPSAkJC5nZXRSYWRhclNpemUoKSxcbiAgICAgICAgXyQkJGdldFJhZGFyU2l6ZTYgPSBfc2xpY2VkVG9BcnJheShfJCQkZ2V0UmFkYXJTaXplNSwgMiksXG4gICAgICAgIHdpZHRoID0gXyQkJGdldFJhZGFyU2l6ZTZbMF0sXG4gICAgICAgIGhlaWdodCA9IF8kJCRnZXRSYWRhclNpemU2WzFdLFxuICAgICAgICBkZXB0aCA9IGNvbmZpZy5yYWRhcl9sZXZlbF9kZXB0aCxcbiAgICAgICAgZWRnZSA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGgsXG4gICAgICAgIHNob3dUZXh0ID0gY29uZmlnLnJhZGFyX2xldmVsX3RleHRfc2hvdyxcbiAgICAgICAgcmFkYXJMZXZlbHMgPSAkJC5yYWRhcnMubGV2ZWxzLFxuICAgICAgICBsZXZlbERhdGEgPSBnZXRSYW5nZSgwLCBkZXB0aCksXG4gICAgICAgIHJhZGl1cyA9IGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvICogTWF0aC5taW4od2lkdGgsIGhlaWdodCksXG4gICAgICAgIGxldmVsUmF0aW8gPSBsZXZlbERhdGEubWFwKGZ1bmN0aW9uIChsKSB7XG4gICAgICByZXR1cm4gcmFkaXVzICogKChsICsgMSkgLyBkZXB0aCk7XG4gICAgfSksXG4gICAgICAgIGxldmVsVGV4dEZvcm1hdCA9IGNvbmZpZy5yYWRhcl9sZXZlbF90ZXh0X2Zvcm1hdCxcbiAgICAgICAgcG9pbnRzID0gbGV2ZWxEYXRhLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgdmFyIHJhbmdlID0gbGV2ZWxSYXRpb1t2XSxcbiAgICAgICAgICBwb3MgPSBnZXRSYW5nZSgwLCBlZGdlKS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuICQkLmdldFJhZGFyUG9zaXRpb24oW1wieFwiLCBcInlcIl0sIGksIHJhbmdlLCAxKS5qb2luKFwiLFwiKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBvcy5qb2luKFwiIFwiKTtcbiAgICB9KSxcbiAgICAgICAgbGV2ZWwgPSByYWRhckxldmVscy5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmxldmVsKSkuZGF0YShsZXZlbERhdGEpO1xuXG4gICAgbGV2ZWwuZXhpdCgpLnJlbW92ZSgpO1xuICAgIHZhciBsZXZlbEVudGVyID0gbGV2ZWwuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmxldmVsLCBcIiBcIikuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmxldmVsLCBcIi1cIikuY29uY2F0KGkpO1xuICAgIH0pO1xuICAgIGxldmVsRW50ZXIuYXBwZW5kKFwicG9seWdvblwiKS5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnJhZGFyX2xldmVsX3Nob3cgPyBudWxsIDogXCJoaWRkZW5cIiksIHNob3dUZXh0ICYmIChyYWRhckxldmVscy5zZWxlY3QoXCJ0ZXh0XCIpLmVtcHR5KCkgJiYgcmFkYXJMZXZlbHMuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiZHhcIiwgXCItLjVlbVwiKS5hdHRyKFwiZHlcIiwgXCItLjdlbVwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpLnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGxldmVsVGV4dEZvcm1hdCgwKTtcbiAgICB9KSwgbGV2ZWxFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJkeFwiLCBcIi0uNWVtXCIpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIikudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGxldmVsVGV4dEZvcm1hdCgkJC5tYXhWYWx1ZSAvIGxldmVsRGF0YS5sZW5ndGggKiAoZCArIDEpKTtcbiAgICB9KSksIGxldmVsRW50ZXIubWVyZ2UobGV2ZWwpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIi5jb25jYXQod2lkdGggLSBsZXZlbFJhdGlvW2RdLCBcIiwgXCIpLmNvbmNhdChoZWlnaHQgLSBsZXZlbFJhdGlvW2RdLCBcIilcIik7XG4gICAgfSkuc2VsZWN0QWxsKFwicG9seWdvblwiKS5hdHRyKFwicG9pbnRzXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gcG9pbnRzW2RdO1xuICAgIH0pLCBzaG93VGV4dCAmJiByYWRhckxldmVscy5zZWxlY3RBbGwoXCJ0ZXh0XCIpLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gaXNVbmRlZmluZWQoZCkgPyB3aWR0aCA6IHBvaW50c1tkXS5zcGxpdChcIixcIilbMF07XG4gICAgfSkuYXR0cihcInlcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkKSA/IGhlaWdodCA6IDA7XG4gICAgfSk7XG4gIH0sXG4gIHVwZGF0ZVJhZGFyQXhlczogZnVuY3Rpb24gdXBkYXRlUmFkYXJBeGVzKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgXyQkJGdldFJhZGFyU2l6ZTcgPSAkJC5nZXRSYWRhclNpemUoKSxcbiAgICAgICAgXyQkJGdldFJhZGFyU2l6ZTggPSBfc2xpY2VkVG9BcnJheShfJCQkZ2V0UmFkYXJTaXplNywgMiksXG4gICAgICAgIHdpZHRoID0gXyQkJGdldFJhZGFyU2l6ZThbMF0sXG4gICAgICAgIGhlaWdodCA9IF8kJCRnZXRSYWRhclNpemU4WzFdLFxuICAgICAgICBjYXRlZ29yaWVzID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLFxuICAgICAgICBheGlzID0gJCQucmFkYXJzLmF4ZXMuc2VsZWN0QWxsKFwiZ1wiKS5kYXRhKGNhdGVnb3JpZXMpO1xuXG4gICAgYXhpcy5leGl0KCkucmVtb3ZlKCk7XG4gICAgdmFyIGF4aXNFbnRlciA9IGF4aXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmF4aXMsIFwiLVwiKS5jb25jYXQoaSk7XG4gICAgfSk7XG5cbiAgICAvLyBheGlzIHRleHRcbiAgICBpZiAoY29uZmlnLnJhZGFyX2F4aXNfbGluZV9zaG93ICYmIGF4aXNFbnRlci5hcHBlbmQoXCJsaW5lXCIpLCBjb25maWcucmFkYXJfYXhpc190ZXh0X3Nob3cgJiYgYXhpc0VudGVyLmFwcGVuZChcInRleHRcIiksIGF4aXMgPSBheGlzRW50ZXIubWVyZ2UoYXhpcyksIGNvbmZpZy5yYWRhcl9heGlzX2xpbmVfc2hvdyAmJiBheGlzLnNlbGVjdChcImxpbmVcIikuYXR0cihcIngxXCIsIHdpZHRoKS5hdHRyKFwieTFcIiwgaGVpZ2h0KS5hdHRyKFwieDJcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiAkJC5nZXRSYWRhclBvc2l0aW9uKFwieFwiLCBpKTtcbiAgICB9KS5hdHRyKFwieTJcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiAkJC5nZXRSYWRhclBvc2l0aW9uKFwieVwiLCBpKTtcbiAgICB9KSwgY29uZmlnLnJhZGFyX2F4aXNfdGV4dF9zaG93KSB7XG4gICAgICB2YXIgX2NvbmZpZyRyYWRhcl9heGlzX3RlID0gY29uZmlnLnJhZGFyX2F4aXNfdGV4dF9wb3NpdGlvbixcbiAgICAgICAgICBfY29uZmlnJHJhZGFyX2F4aXNfdGUyID0gX2NvbmZpZyRyYWRhcl9heGlzX3RlLngsXG4gICAgICAgICAgeCA9IF9jb25maWckcmFkYXJfYXhpc190ZTIgPT09IHZvaWQgMCA/IDAgOiBfY29uZmlnJHJhZGFyX2F4aXNfdGUyLFxuICAgICAgICAgIF9jb25maWckcmFkYXJfYXhpc190ZTMgPSBfY29uZmlnJHJhZGFyX2F4aXNfdGUueSxcbiAgICAgICAgICB5ID0gX2NvbmZpZyRyYWRhcl9heGlzX3RlMyA9PT0gdm9pZCAwID8gMCA6IF9jb25maWckcmFkYXJfYXhpc190ZTM7XG4gICAgICBheGlzLnNlbGVjdChcInRleHRcIikuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKS5hdHRyKFwiZHlcIiwgXCIuNWVtXCIpLmNhbGwoZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHNldFRleHRWYWx1ZShPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhpcyksIGQgKyBcIlwiLCBbLS42LCAxLjJdKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5kYXR1bShmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgIH07XG4gICAgICB9KS5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGlzVW5kZWZpbmVkKHRoaXMud2lkdGgpICYmICh0aGlzLndpZHRoID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIDIpO1xuICAgICAgICB2YXIgcG9zWCA9ICQkLmdldFJhZGFyUG9zaXRpb24oXCJ4XCIsIGQuaW5kZXgsIHVuZGVmaW5lZCwgMSksXG4gICAgICAgICAgICBwb3NZID0gTWF0aC5yb3VuZCgkJC5nZXRSYWRhclBvc2l0aW9uKFwieVwiLCBkLmluZGV4LCB1bmRlZmluZWQsIDEpKTtcbiAgICAgICAgcmV0dXJuIHBvc1ggPiB3aWR0aCA/IHBvc1ggKz0gdGhpcy53aWR0aCArIHggOiBNYXRoLnJvdW5kKHBvc1gpIDwgd2lkdGggJiYgKHBvc1ggLT0gdGhpcy53aWR0aCArIHgpLCBwb3NZID4gaGVpZ2h0ID8gKHBvc1kgLyAyID09PSBoZWlnaHQgJiYgdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgPT09IFwidHNwYW5cIiAmJiB0aGlzLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwiZHlcIiwgXCIwZW1cIiksIHBvc1kgKz0geSkgOiBwb3NZIDwgaGVpZ2h0ICYmIChwb3NZIC09IHkpLCBcInRyYW5zbGF0ZShcIi5jb25jYXQocG9zWCwgXCIgXCIpLmNvbmNhdChwb3NZLCBcIilcIik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAkJC5iaW5kRXZlbnQoKTtcbiAgfSxcbiAgYmluZEV2ZW50OiBmdW5jdGlvbiBiaW5kRXZlbnQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG5cbiAgICBpZiAoY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQpIHtcbiAgICAgIHZhciBpc01vdXNlID0gJCQuaW5wdXRUeXBlID09PSBcIm1vdXNlXCIsXG4gICAgICAgICAgZ2V0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wiZXZlbnRcIl0udGFyZ2V0OyAvLyBpbiBjYXNlIG9mIG11bHRpbGluZWQgYXhpcyB0ZXh0XG5cbiAgICAgICAgL3RzcGFuL2kudGVzdCh0YXJnZXQudGFnTmFtZSkgJiYgKHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGFyZ2V0KS5kYXR1bSgpO1xuICAgICAgICByZXR1cm4gZCAmJiBPYmplY3Qua2V5cyhkKS5sZW5ndGggPT09IDEgPyBkLmluZGV4IDogdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgICAgICBoaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCgpLFxuICAgICAgICAgICAgbm9JbmRleCA9IGlzVW5kZWZpbmVkKGluZGV4KTtcbiAgICAgICAgKGlzTW91c2UgfHwgbm9JbmRleCkgJiYgKF90aGlzLmhpZGVUb29sdGlwKCksIF90aGlzLnVuZXhwYW5kQ2lyY2xlcygpLCBpc01vdXNlID8gJCQuc2V0T3Zlck91dCghMSwgaW5kZXgpIDogbm9JbmRleCAmJiAkJC5jYWxsT3Zlck91dEZvclRvdWNoKCkpO1xuICAgICAgfTtcblxuICAgICAgJCQucmFkYXJzLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYXhpcykpLm9uKGlzTW91c2UgPyBcIm1vdXNlb3ZlciBcIiA6IFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghJCQudHJhbnNpdGluZykgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICAgICAgICAgICQkLnNlbGVjdFJlY3RGb3JTaW5nbGUoJCQuc3ZnLm5vZGUoKSwgbnVsbCwgaW5kZXgpLCBpc01vdXNlID8gJCQuc2V0T3Zlck91dCghMCwgaW5kZXgpIDogJCQuY2FsbE92ZXJPdXRGb3JUb3VjaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgfSkub24oXCJtb3VzZW91dFwiLCBpc01vdXNlID8gaGlkZSA6IG51bGwpLCBpc01vdXNlIHx8ICQkLnN2Zy5vbihcInRvdWNoc3RhcnRcIiwgaGlkZSk7XG4gICAgfVxuICB9LFxuICB1cGRhdGVSYWRhclNoYXBlOiBmdW5jdGlvbiB1cGRhdGVSYWRhclNoYXBlKGR1cmF0aW9uRm9yRXhpdCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMsXG4gICAgICAgIHBvaW50cyA9ICQkLmdldENhY2hlKHJhZGFyX2NhY2hlS2V5KSxcbiAgICAgICAgYXJlYXMgPSAkJC5yYWRhcnMuc2hhcGVzLnNlbGVjdEFsbChcInBvbHlnb25cIikuZGF0YSh0YXJnZXRzKSxcbiAgICAgICAgYXJlYXNFbnRlciA9IGFyZWFzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NDaGFydFJhZGFyLmJpbmQoJCQpKTtcbiAgICBhcmVhcy5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdCkucmVtb3ZlKCksIGFyZWFzRW50ZXIuYXBwZW5kKFwicG9seWdvblwiKS5tZXJnZShhcmVhcykuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKS5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcikuYXR0cihcInBvaW50c1wiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIHBvaW50c1tkLmlkXS5qb2luKFwiIFwiKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGRhdGEgcG9pbnQgeCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgb2JqZWN0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJhZGFyQ2lyY2xlWDogZnVuY3Rpb24gcmFkYXJDaXJjbGVYKGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDYWNoZShyYWRhcl9jYWNoZUtleSlbZC5pZF1bZC5pbmRleF1bMF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBkYXRhIHBvaW50IHkgY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByYWRhckNpcmNsZVk6IGZ1bmN0aW9uIHJhZGFyQ2lyY2xlWShkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGUocmFkYXJfY2FjaGVLZXkpW2QuaWRdW2QuaW5kZXhdWzFdO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ludGVybmFscy90ZXh0LmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgdGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdFRleHQ6IGZ1bmN0aW9uIGluaXRUZXh0KCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0KSkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY29uZmlnX2NsYXNzZXMuY2hhcnRUZXh0cyksICQkLm1haW5UZXh0ID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RBbGxcIl0pKFtdKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGNoYXJ0VGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gJCQuZGF0YS50YXJnZXRzXG4gICAqL1xuICB1cGRhdGVUYXJnZXRzRm9yVGV4dDogZnVuY3Rpb24gdXBkYXRlVGFyZ2V0c0ZvclRleHQodGFyZ2V0cykge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNsYXNzQ2hhcnRUZXh0ID0gJCQuY2xhc3NDaGFydFRleHQuYmluZCgkJCksXG4gICAgICAgIGNsYXNzVGV4dHMgPSAkJC5jbGFzc1RleHRzLmJpbmQoJCQpLFxuICAgICAgICBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKSxcbiAgICAgICAgbWFpblRleHRVcGRhdGUgPSAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2hhcnRUZXh0cykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuY2hhcnRUZXh0KSkuZGF0YSh0YXJnZXRzKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBjbGFzc0NoYXJ0VGV4dChkKSArIGNsYXNzRm9jdXMoZCk7XG4gICAgfSksXG4gICAgICAgIG1haW5UZXh0RW50ZXIgPSBtYWluVGV4dFVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRUZXh0KS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgIG1haW5UZXh0RW50ZXIuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NUZXh0cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBGYWRlLW91dCB0cmFuc2l0aW9uIGR1cmF0aW9uXG4gICAqL1xuICB1cGRhdGVUZXh0OiBmdW5jdGlvbiB1cGRhdGVUZXh0KGR1cmF0aW9uRm9yRXhpdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBkYXRhRm4gPSAkJC5sYWJlbGlzaERhdGEuYmluZCgkJCksXG4gICAgICAgIGNsYXNzVGV4dCA9ICQkLmNsYXNzVGV4dC5iaW5kKCQkKTtcblxuICAgICQkLm1haW5UZXh0ID0gJCQubWFpbi5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnRleHRzKSkuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy50ZXh0KSkuZGF0YShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIF90aGlzLmlzUmFkYXJUeXBlKGQpID8gZC52YWx1ZXMgOiBkYXRhRm4oZCk7XG4gICAgfSksICQkLm1haW5UZXh0LmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KS5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIikucmVtb3ZlKCksICQkLm1haW5UZXh0ID0gJCQubWFpblRleHQuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpLm1lcmdlKCQkLm1haW5UZXh0KS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NUZXh0KS5hdHRyKFwidGV4dC1hbmNob3JcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBjb25maWcuYXhpc19yb3RhdGVkID8gZC52YWx1ZSA8IDAgPyBcImVuZFwiIDogXCJzdGFydFwiIDogXCJtaWRkbGVcIjtcbiAgICB9KS5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlVGV4dENvbG9yLmJpbmQoJCQpKS5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIikudGV4dChmdW5jdGlvbiAoZCwgaSwgaikge1xuICAgICAgdmFyIHZhbHVlID0gJCQuaXNCdWJibGVaVHlwZShkKSA/ICQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwielwiKSA6IGQudmFsdWU7XG4gICAgICByZXR1cm4gJCQuZGF0YUxhYmVsRm9ybWF0KGQuaWQpKHZhbHVlLCBkLmlkLCBpLCBqKTtcbiAgICB9KTtcbiAgfSxcbiAgdXBkYXRlVGV4dENvbG9yOiBmdW5jdGlvbiB1cGRhdGVUZXh0Q29sb3IoZCkge1xuICAgIHZhciBjb2xvcixcbiAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICBsYWJlbENvbG9ycyA9ICQkLmNvbmZpZy5kYXRhX2xhYmVsc19jb2xvcnM7XG4gICAgcmV0dXJuIGlzU3RyaW5nKGxhYmVsQ29sb3JzKSA/IGNvbG9yID0gbGFiZWxDb2xvcnMgOiBpc09iamVjdChsYWJlbENvbG9ycykgJiYgKGNvbG9yID0gbGFiZWxDb2xvcnNbZC5pZF0pLCBjb2xvciB8fCAkJC5jb2xvcihkKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVkcmF3IGNoYXJ0VGV4dFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB4IFBvc2l0aW9uaW5nIGZ1bmN0aW9uIGZvciB4XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHkgUG9zaXRpb25pbmcgZnVuY3Rpb24gZm9yIHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3JGbG93XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb24gdHJhbnNpdGlvbiBpcyBlbmFibGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWRyYXdUZXh0OiBmdW5jdGlvbiByZWRyYXdUZXh0KHgsIHksIGZvckZsb3csIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgdCA9IGdldFJhbmRvbSgpLFxuICAgICAgICBvcGFjaXR5Rm9yVGV4dCA9IGZvckZsb3cgPyAwIDogJCQub3BhY2l0eUZvclRleHQuYmluZCgkJCk7XG4gICAgLy8gbmVlZCB0byByZXR1cm4gJ3RydWUnIGFzIG9mIGJlaW5nIHB1c2hlZCB0byB0aGUgcmVkcmF3IGxpc3RcbiAgICAvLyByZWY6IGdldFJlZHJhd0xpc3QoKVxuICAgIHJldHVybiAkJC5tYWluVGV4dC5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICB2YXIgdGV4dCA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKSh0aGlzKTsgLy8gZG8gbm90IGFwcGx5IHRyYW5zaXRpb24gZm9yIG5ld2x5IGFkZGVkIHRleHQgZWxlbWVudHNcblxuICAgICAgKHdpdGhUcmFuc2l0aW9uICYmIHRleHQuYXR0cihcInhcIikgPyB0ZXh0LnRyYW5zaXRpb24odCkgOiB0ZXh0KS5hdHRyKFwieFwiLCB4LmJpbmQodGhpcykoZCwgaSkpLmF0dHIoXCJ5XCIsIHkuYmluZCh0aGlzKShkLCBpKSkuc3R5bGUoXCJmaWxsXCIsICQkLnVwZGF0ZVRleHRDb2xvci5iaW5kKCQkKSkuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgb3BhY2l0eUZvclRleHQpO1xuICAgIH0pLCAhMDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHZhbHVlIG9mIHRoZSBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybnMge09iamVjdH0gdmFsdWUgb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgKi9cbiAgZ2V0VGV4dFJlY3Q6IGZ1bmN0aW9uIGdldFRleHRSZWN0KGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGJhc2UgPSBlbGVtZW50Lm5vZGUgPyBlbGVtZW50Lm5vZGUoKSA6IGVsZW1lbnQ7XG4gICAgL3RleHQvaS50ZXN0KGJhc2UudGFnTmFtZSkgfHwgKGJhc2UgPSBiYXNlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0XCIpKTtcbiAgICB2YXIgdGV4dCA9IGJhc2UudGV4dENvbnRlbnQsXG4gICAgICAgIGNhY2hlS2V5ID0gXCIkXCIuY29uY2F0KHRleHQucmVwbGFjZSgvXFxXL2csIFwiX1wiKSksXG4gICAgICAgIHJlY3QgPSAkJC5nZXRDYWNoZShjYWNoZUtleSk7XG4gICAgcmV0dXJuIHJlY3QgfHwgKCQkLnN2Zy5hcHBlbmQoXCJ0ZXh0XCIpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKS5zdHlsZShcImZvbnRcIiwgT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKGJhc2UpLnN0eWxlKFwiZm9udFwiKSkuY2xhc3NlZChjbGFzc05hbWUsICEwKS50ZXh0KHRleHQpLmNhbGwoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJlY3QgPSBnZXRCb3VuZGluZ1JlY3Qodi5ub2RlKCkpO1xuICAgIH0pLnJlbW92ZSgpLCAkJC5hZGRDYWNoZShjYWNoZUtleSwgcmVjdCkpLCByZWN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB4IG9yIHkgY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5kaWNlcyBJbmRpY2VzIHZhbHVlc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvclggd2hldGhlciBvciBub3QgdG8geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBjb29yZGluYXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2VuZXJhdGVYWUZvclRleHQ6IGZ1bmN0aW9uIGdlbmVyYXRlWFlGb3JUZXh0KGluZGljZXMsIGZvclgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICB0eXBlcyA9IE9iamVjdC5rZXlzKGluZGljZXMpLFxuICAgICAgICBwb2ludHMgPSB7fSxcbiAgICAgICAgZ2V0dGVyID0gZm9yWCA/ICQkLmdldFhGb3JUZXh0IDogJCQuZ2V0WUZvclRleHQ7XG4gICAgcmV0dXJuICQkLmhhc1R5cGUoXCJyYWRhclwiKSAmJiB0eXBlcy5wdXNoKFwicmFkYXJcIiksIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIHBvaW50c1t2XSA9ICQkW1wiZ2VuZXJhdGVHZXRcIi5jb25jYXQoY2FwaXRhbGl6ZSh2KSwgXCJQb2ludHNcIildKGluZGljZXNbdl0sICExKTtcbiAgICB9KSwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHZhciB0eXBlID0gJCQuaXNBcmVhVHlwZShkKSAmJiBcImFyZWFcIiB8fCAkJC5pc0JhclR5cGUoZCkgJiYgXCJiYXJcIiB8fCAkJC5pc1JhZGFyVHlwZShkKSAmJiBcInJhZGFyXCIgfHwgXCJsaW5lXCI7XG4gICAgICByZXR1cm4gZ2V0dGVyLmNhbGwoJCQsIHBvaW50c1t0eXBlXShkLCBpKSwgZCwgdGhpcyk7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNlbnRlcml6ZWQgdGV4dCBwb3NpdGlvbiBmb3IgYmFyIHR5cGUgZGF0YS5sYWJlbC50ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBEYXRhIHBvaW50cyBwb3NpdGlvblxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0ZXh0RWxlbWVudCBEYXRhIGxhYmVsIHRleHQgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBQb3NpdGlvbiB2YWx1ZVxuICAgKi9cbiAgZ2V0Q2VudGVyZWRUZXh0UG9zOiBmdW5jdGlvbiBnZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuICAgIGlmIChjb25maWcuZGF0YV9sYWJlbHMuY2VudGVyZWQgJiYgJCQuaXNCYXJUeXBlKGQpKSB7XG4gICAgICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nUmVjdCh0ZXh0RWxlbWVudCksXG4gICAgICAgICAgaXNQb3NpdGl2ZSA9IGQudmFsdWUgPj0gMDtcblxuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICB2YXIgdyA9IChpc1Bvc2l0aXZlID8gcG9pbnRzWzFdWzFdIC0gcG9pbnRzWzBdWzFdIDogcG9pbnRzWzBdWzFdIC0gcG9pbnRzWzFdWzFdKSAvIDIgKyByZWN0LndpZHRoIC8gMjtcbiAgICAgICAgcmV0dXJuIGlzUG9zaXRpdmUgPyAtdyAtIDMgOiB3ICsgMjtcbiAgICAgIH1cblxuICAgICAgdmFyIGggPSAoaXNQb3NpdGl2ZSA/IHBvaW50c1swXVsxXSAtIHBvaW50c1sxXVsxXSA6IHBvaW50c1sxXVsxXSAtIHBvaW50c1swXVsxXSkgLyAyICsgcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgcmV0dXJuIGlzUG9zaXRpdmUgPyBoIDogLWggLSAyO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YS5sYWJlbHMucG9zaXRpb24gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIERhdGEgaWQgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgeCB8IHlcbiAgICogQHJldHVybiB7TnVtYmVyfSBQb3NpdGlvbiB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VGV4dFBvczogZnVuY3Rpb24gZ2V0VGV4dFBvcyhpZCwgdHlwZSkge1xuICAgIHZhciBwb3MgPSB0aGlzLmNvbmZpZy5kYXRhX2xhYmVsc19wb3NpdGlvbjtcbiAgICByZXR1cm4gKGlkIGluIHBvcyA/IHBvc1tpZF0gOiBwb3MpW3R5cGVdIHx8IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybnMge051bWJlcn0geCBjb29yZGluYXRlXG4gICAqL1xuICBnZXRYRm9yVGV4dDogZnVuY3Rpb24gZ2V0WEZvclRleHQocG9pbnRzLCBkLCB0ZXh0RWxlbWVudCkge1xuICAgIHZhciB4UG9zLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcbiAgICAvLyBzaG93IGxhYmVscyByZWdhcmRsZXNzIG9mIHRoZSBkb21haW4gaWYgdmFsdWUgaXMgbnVsbFxuICAgIGlmIChpc1JvdGF0ZWQgPyAocGFkZGluZyA9ICQkLmlzQmFyVHlwZShkKSA/IDQgOiA2LCB4UG9zID0gcG9pbnRzWzJdWzFdICsgcGFkZGluZyAqIChkLnZhbHVlIDwgMCA/IC0xIDogMSkpIDogeFBvcyA9ICQkLmhhc1R5cGUoXCJiYXJcIikgPyAocG9pbnRzWzJdWzBdICsgcG9pbnRzWzBdWzBdKSAvIDIgOiBwb2ludHNbMF1bMF0sIGQudmFsdWUgPT09IG51bGwpIGlmICh4UG9zID4gJCQud2lkdGgpIHtcbiAgICAgIHZhciBfZ2V0Qm91bmRpbmdSZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KHRleHRFbGVtZW50KSxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRCb3VuZGluZ1JlY3Qud2lkdGg7XG5cbiAgICAgIHhQb3MgPSAkJC53aWR0aCAtIHdpZHRoO1xuICAgIH0gZWxzZSB4UG9zIDwgMCAmJiAoeFBvcyA9IDQpO1xuICAgIHJldHVybiBpc1JvdGF0ZWQgJiYgKHhQb3MgKz0gJCQuZ2V0Q2VudGVyZWRUZXh0UG9zKGQsIHBvaW50cywgdGV4dEVsZW1lbnQpKSwgeFBvcyArICQkLmdldFRleHRQb3MoZC5pZCwgXCJ4XCIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRleHRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHkgY29vcmRpbmF0ZVxuICAgKi9cbiAgZ2V0WUZvclRleHQ6IGZ1bmN0aW9uIGdldFlGb3JUZXh0KHBvaW50cywgZCwgdGV4dEVsZW1lbnQpIHtcbiAgICB2YXIgeVBvcyxcbiAgICAgICAgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQsXG4gICAgICAgIHIgPSBjb25maWcucG9pbnRfcixcbiAgICAgICAgcmVjdCA9IGdldEJvdW5kaW5nUmVjdCh0ZXh0RWxlbWVudCksXG4gICAgICAgIGJhc2VZID0gMztcbiAgICBpZiAoaXNSb3RhdGVkKSB5UG9zID0gKHBvaW50c1swXVswXSArIHBvaW50c1syXVswXSArIHJlY3QuaGVpZ2h0ICogLjYpIC8gMjtlbHNlIGlmICh5UG9zID0gcG9pbnRzWzJdWzFdLCBpc051bWJlcihyKSAmJiByID4gNSAmJiAoJCQuaXNMaW5lVHlwZShkKSB8fCAkJC5pc1NjYXR0ZXJUeXBlKGQpKSAmJiAoYmFzZVkgKz0gY29uZmlnLnBvaW50X3IgLyAyLjMpLCBkLnZhbHVlIDwgMCB8fCBkLnZhbHVlID09PSAwICYmICEkJC5oYXNQb3NpdGl2ZVZhbHVlICYmICQkLmhhc05lZ2F0aXZlVmFsdWUpIHlQb3MgKz0gcmVjdC5oZWlnaHQgKyAoJCQuaXNCYXJUeXBlKGQpID8gLWJhc2VZIDogYmFzZVkpO2Vsc2Uge1xuICAgICAgdmFyIGRpZmYgPSAtYmFzZVkgKiAyO1xuICAgICAgJCQuaXNCYXJUeXBlKGQpID8gZGlmZiA9IC1iYXNlWSA6ICQkLmlzQnViYmxlVHlwZShkKSAmJiAoZGlmZiA9IGJhc2VZKSwgeVBvcyArPSBkaWZmO1xuICAgIH0gLy8gc2hvdyBsYWJlbHMgcmVnYXJkbGVzcyBvZiB0aGUgZG9tYWluIGlmIHZhbHVlIGlzIG51bGxcblxuICAgIGlmIChkLnZhbHVlID09PSBudWxsICYmICFpc1JvdGF0ZWQpIHtcbiAgICAgIHZhciBib3hIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgIHlQb3MgPCBib3hIZWlnaHQgPyB5UG9zID0gYm94SGVpZ2h0IDogeVBvcyA+IHRoaXMuaGVpZ2h0ICYmICh5UG9zID0gdGhpcy5oZWlnaHQgLSA0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNSb3RhdGVkIHx8ICh5UG9zICs9ICQkLmdldENlbnRlcmVkVGV4dFBvcyhkLCBwb2ludHMsIHRleHRFbGVtZW50KSksIHlQb3MgKyAkJC5nZXRUZXh0UG9zKGQuaWQsIFwieVwiKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGlmIHR3byBvciBtb3JlIHRleHQgbm9kZXMgYXJlIG92ZXJsYXBwaW5nXG4gICAqIE1hcmsgb3ZlcmxhcHBpbmcgdGV4dCBub2RlcyB3aXRoIFwidGV4dC1vdmVybGFwcGluZ1wiIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICAgKiBAcGFyYW0ge0NoYXJ0SW50ZXJuYWx9ICQkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICAgKi9cbiAgbWFya092ZXJsYXBwZWQ6IGZ1bmN0aW9uIG1hcmtPdmVybGFwcGVkKGlkLCAkJCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgdGV4dE5vZGVzID0gJCQuYXJjcy5zZWxlY3RBbGwoc2VsZWN0b3IpLFxuICAgICAgICBmaWx0ZXJlZFRleHROb2RlcyA9IHRleHROb2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmRhdGEuaWQgIT09IGlkO1xuICAgIH0pLFxuICAgICAgICB0ZXh0Tm9kZSA9IHRleHROb2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmRhdGEuaWQgPT09IGlkO1xuICAgIH0pLFxuICAgICAgICB0cmFuc2xhdGUgPSBnZXRUcmFuc2xhdGlvbih0ZXh0Tm9kZS5ub2RlKCkpLFxuICAgICAgICBjYWxjSHlwbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpO1xuICAgIH07XG5cbiAgICB0ZXh0Tm9kZS5ub2RlKCkgJiYgZmlsdGVyZWRUZXh0Tm9kZXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZSA9IGdldFRyYW5zbGF0aW9uKHRoaXMpLFxuICAgICAgICAgIGZpbHRlcmVkVGV4dE5vZGUgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhpcyksXG4gICAgICAgICAgbm9kZUZvcldpZHRoID0gY2FsY0h5cG8odHJhbnNsYXRlLmUsIHRyYW5zbGF0ZS5mKSA+IGNhbGNIeXBvKGNvb3JkaW5hdGUuZSwgY29vcmRpbmF0ZS5mKSA/IHRleHROb2RlIDogZmlsdGVyZWRUZXh0Tm9kZSxcbiAgICAgICAgICBvdmVybGFwc1ggPSBNYXRoLmNlaWwoTWF0aC5hYnModHJhbnNsYXRlLmUgLSBjb29yZGluYXRlLmUpKSA8IE1hdGguY2VpbChub2RlRm9yV2lkdGgubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpKSxcbiAgICAgICAgICBvdmVybGFwc1kgPSBNYXRoLmNlaWwoTWF0aC5hYnModHJhbnNsYXRlLmYgLSBjb29yZGluYXRlLmYpKSA8IHBhcnNlSW50KHRleHROb2RlLnN0eWxlKFwiZm9udC1zaXplXCIpLCAxMCk7XG4gICAgICBmaWx0ZXJlZFRleHROb2RlLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuVGV4dE92ZXJsYXBwaW5nLCBvdmVybGFwc1ggJiYgb3ZlcmxhcHNZKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGlmIHR3byBvciBtb3JlIHRleHQgbm9kZXMgYXJlIG92ZXJsYXBwaW5nXG4gICAqIFJlbW92ZSBcInRleHQtb3ZlcmxhcHBpbmdcIiBjbGFzcyBvbiBzZWxlY3RlZCB0ZXh0IG5vZGVzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q2hhcnRJbnRlcm5hbH0gJCRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqL1xuICB1bmRvTWFya092ZXJsYXBwZWQ6IGZ1bmN0aW9uIHVuZG9NYXJrT3ZlcmxhcHBlZCgkJCwgc2VsZWN0b3IpIHtcbiAgICAkJC5hcmNzLnNlbGVjdEFsbChzZWxlY3RvcikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdEFsbFwiXSkoW3RoaXMsIHRoaXMucHJldmlvdXNTaWJsaW5nXSkuY2xhc3NlZChjb25maWdfY2xhc3Nlcy5UZXh0T3ZlcmxhcHBpbmcsICExKTtcbiAgICB9KTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbnRlcm5hbHMvdHlwZS5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG4gLy8gZGVmaW5lZCBjaGFydCB0eXBlcyBhcyBjYXRlZ29yeVxuXG52YXIgVFlQRVMgPSB7XG4gIEFyZWE6IFtcImFyZWFcIiwgXCJhcmVhLXNwbGluZVwiLCBcImFyZWEtc3BsaW5lLXJhbmdlXCIsIFwiYXJlYS1saW5lLXJhbmdlXCIsIFwiYXJlYS1zdGVwXCJdLFxuICBBcmVhUmFuZ2U6IFtcImFyZWEtc3BsaW5lLXJhbmdlXCIsIFwiYXJlYS1saW5lLXJhbmdlXCJdLFxuICBBcmM6IFtcInBpZVwiLCBcImRvbnV0XCIsIFwiZ2F1Z2VcIiwgXCJyYWRhclwiXSxcbiAgTGluZTogW1wibGluZVwiLCBcInNwbGluZVwiLCBcImFyZWFcIiwgXCJhcmVhLXNwbGluZVwiLCBcImFyZWEtc3BsaW5lLXJhbmdlXCIsIFwiYXJlYS1saW5lLXJhbmdlXCIsIFwic3RlcFwiLCBcImFyZWEtc3RlcFwiXSxcbiAgU3RlcDogW1wic3RlcFwiLCBcImFyZWEtc3RlcFwiXSxcbiAgU3BsaW5lOiBbXCJzcGxpbmVcIiwgXCJhcmVhLXNwbGluZVwiLCBcImFyZWEtc3BsaW5lLXJhbmdlXCJdXG59O1xuZXh0ZW5kKENoYXJ0SW50ZXJuYWxfQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcbiAgc2V0VGFyZ2V0VHlwZTogZnVuY3Rpb24gc2V0VGFyZ2V0VHlwZSh0YXJnZXRJZHMsIHR5cGUpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgJCQud2l0aG91dEZhZGVJbltpZF0gPSB0eXBlID09PSBjb25maWcuZGF0YV90eXBlc1tpZF0sIGNvbmZpZy5kYXRhX3R5cGVzW2lkXSA9IHR5cGU7XG4gICAgfSksIHRhcmdldElkcyB8fCAoY29uZmlnLmRhdGFfdHlwZSA9IHR5cGUpO1xuICB9LFxuICBoYXNUeXBlOiBmdW5jdGlvbiBoYXNUeXBlKHR5cGUsIHRhcmdldHNWYWx1ZSkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHR5cGVzID0gJCQuY29uZmlnLmRhdGFfdHlwZXMsXG4gICAgICAgIHRhcmdldHMgPSB0YXJnZXRzVmFsdWUgfHwgJCQuZGF0YS50YXJnZXRzLFxuICAgICAgICBoYXMgPSAhMTtcbiAgICByZXR1cm4gdGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCA/IHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB2YXIgdCA9IHR5cGVzW3RhcmdldC5pZF07XG4gICAgICAodCAmJiB0LmluZGV4T2YodHlwZSkgPj0gMCB8fCAhdCAmJiB0eXBlID09PSBcImxpbmVcIikgJiYgKGhhcyA9ICEwKTtcbiAgICB9KSA6IE9iamVjdC5rZXlzKHR5cGVzKS5sZW5ndGggPyBPYmplY3Qua2V5cyh0eXBlcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHR5cGVzW2lkXSA9PT0gdHlwZSAmJiAoaGFzID0gITApO1xuICAgIH0pIDogaGFzID0gJCQuY29uZmlnLmRhdGFfdHlwZSA9PT0gdHlwZSwgaGFzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBjb250YWlucyBnaXZlbiBjaGFydCB0eXBlc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIGtleVxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0c1xuICAgKiBAcGFyYW0ge0FycmF5fSBleGNsdWRlIEV4Y2x1ZGVkIHR5cGVzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXNUeXBlT2Y6IGZ1bmN0aW9uIGhhc1R5cGVPZih0eXBlLCB0YXJnZXRzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgZXhjbHVkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG5cbiAgICByZXR1cm4gIVRZUEVTW3R5cGVdLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIGV4Y2x1ZGUuaW5kZXhPZih2KSA9PT0gLTE7XG4gICAgfSkuZXZlcnkoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiAhX3RoaXMuaGFzVHlwZSh2LCB0YXJnZXRzKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgZ2l2ZW4gZGF0YSBpcyBjZXJ0YWluIGNoYXJ0IHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgY2hhcnQgdHlwZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNUeXBlT2Y6IGZ1bmN0aW9uIGlzVHlwZU9mKGQsIHR5cGUpIHtcbiAgICB2YXIgaWQgPSBpc1N0cmluZyhkKSA/IGQgOiBkLmlkLFxuICAgICAgICBkYXRhVHlwZSA9IHRoaXMuY29uZmlnLmRhdGFfdHlwZXNbaWRdO1xuICAgIHJldHVybiBpc0FycmF5KHR5cGUpID8gdHlwZS5pbmRleE9mKGRhdGFUeXBlKSA+PSAwIDogZGF0YVR5cGUgPT09IHR5cGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGNvbnRhaW5zIGFyYyB0eXBlcyBjaGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0c1xuICAgKiBAcGFyYW0ge0FycmF5fSBleGNsdWRlIEV4Y2x1ZGVkIHR5cGVzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXNBcmNUeXBlOiBmdW5jdGlvbiBoYXNBcmNUeXBlKHRhcmdldHMsIGV4Y2x1ZGUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNUeXBlT2YoXCJBcmNcIiwgdGFyZ2V0cywgZXhjbHVkZSk7XG4gIH0sXG4gIGhhc011bHRpQXJjR2F1Z2U6IGZ1bmN0aW9uIGhhc011bHRpQXJjR2F1Z2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzVHlwZShcImdhdWdlXCIpICYmIHRoaXMuY29uZmlnLmdhdWdlX3R5cGUgPT09IFwibXVsdGlcIjtcbiAgfSxcbiAgaXNMaW5lVHlwZTogZnVuY3Rpb24gaXNMaW5lVHlwZShkKSB7XG4gICAgdmFyIGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcbiAgICByZXR1cm4gIXRoaXMuY29uZmlnLmRhdGFfdHlwZXNbaWRdIHx8IHRoaXMuaXNUeXBlT2YoaWQsIFRZUEVTLkxpbmUpO1xuICB9LFxuICBpc1N0ZXBUeXBlOiBmdW5jdGlvbiBpc1N0ZXBUeXBlKGQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFUy5TdGVwKTtcbiAgfSxcbiAgaXNTcGxpbmVUeXBlOiBmdW5jdGlvbiBpc1NwbGluZVR5cGUoZCkge1xuICAgIHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLlNwbGluZSk7XG4gIH0sXG4gIGlzQXJlYVR5cGU6IGZ1bmN0aW9uIGlzQXJlYVR5cGUoZCkge1xuICAgIHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLkFyZWEpO1xuICB9LFxuICBpc0FyZWFSYW5nZVR5cGU6IGZ1bmN0aW9uIGlzQXJlYVJhbmdlVHlwZShkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgVFlQRVMuQXJlYVJhbmdlKTtcbiAgfSxcbiAgaXNCYXJUeXBlOiBmdW5jdGlvbiBpc0JhclR5cGUoZCkge1xuICAgIHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiYmFyXCIpO1xuICB9LFxuICBpc0J1YmJsZVR5cGU6IGZ1bmN0aW9uIGlzQnViYmxlVHlwZShkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJidWJibGVcIik7XG4gIH0sXG4gIGlzU2NhdHRlclR5cGU6IGZ1bmN0aW9uIGlzU2NhdHRlclR5cGUoZCkge1xuICAgIHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwic2NhdHRlclwiKTtcbiAgfSxcbiAgaXNQaWVUeXBlOiBmdW5jdGlvbiBpc1BpZVR5cGUoZCkge1xuICAgIHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwicGllXCIpO1xuICB9LFxuICBpc0dhdWdlVHlwZTogZnVuY3Rpb24gaXNHYXVnZVR5cGUoZCkge1xuICAgIHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiZ2F1Z2VcIik7XG4gIH0sXG4gIGlzRG9udXRUeXBlOiBmdW5jdGlvbiBpc0RvbnV0VHlwZShkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJkb251dFwiKTtcbiAgfSxcbiAgaXNSYWRhclR5cGU6IGZ1bmN0aW9uIGlzUmFkYXJUeXBlKGQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcInJhZGFyXCIpO1xuICB9LFxuICBpc0FyY1R5cGU6IGZ1bmN0aW9uIGlzQXJjVHlwZShkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQaWVUeXBlKGQpIHx8IHRoaXMuaXNEb251dFR5cGUoZCkgfHwgdGhpcy5pc0dhdWdlVHlwZShkKSB8fCB0aGlzLmlzUmFkYXJUeXBlKGQpO1xuICB9LFxuICAvLyBkZXRlcm1pbmUgaWYgaXMgJ2NpcmNsZScgZGF0YSBwb2ludFxuICBpc0NpcmNsZVBvaW50OiBmdW5jdGlvbiBpc0NpcmNsZVBvaW50KCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgcGF0dGVybiA9IGNvbmZpZy5wb2ludF9wYXR0ZXJuO1xuICAgIHJldHVybiBjb25maWcucG9pbnRfdHlwZSA9PT0gXCJjaXJjbGVcIiAmJiAoIXBhdHRlcm4gfHwgaXNBcnJheShwYXR0ZXJuKSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMCk7XG4gIH0sXG4gIGxpbmVEYXRhOiBmdW5jdGlvbiBsaW5lRGF0YShkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMaW5lVHlwZShkKSA/IFtkXSA6IFtdO1xuICB9LFxuICBhcmNEYXRhOiBmdW5jdGlvbiBhcmNEYXRhKGQpIHtcbiAgICByZXR1cm4gdGhpcy5pc0FyY1R5cGUoZC5kYXRhKSA/IFtkXSA6IFtdO1xuICB9LFxuICBiYXJEYXRhOiBmdW5jdGlvbiBiYXJEYXRhKGQpIHtcbiAgICByZXR1cm4gdGhpcy5pc0JhclR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YSBhZGFwdCBmb3IgZGF0YSBsYWJlbCBzaG93aW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgb2JqZWN0XG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbGFiZWxpc2hEYXRhOiBmdW5jdGlvbiBsYWJlbGlzaERhdGEoZCkge1xuICAgIHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSB8fCB0aGlzLmlzTGluZVR5cGUoZCkgfHwgdGhpcy5pc1NjYXR0ZXJUeXBlKGQpIHx8IHRoaXMuaXNCdWJibGVUeXBlKGQpIHx8IHRoaXMuaXNSYWRhclR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xuICB9LFxuICBiYXJMaW5lQnViYmxlRGF0YTogZnVuY3Rpb24gYmFyTGluZUJ1YmJsZURhdGEoZCkge1xuICAgIHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSB8fCB0aGlzLmlzTGluZVR5cGUoZCkgfHwgdGhpcy5pc0J1YmJsZVR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xuICB9LFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2hhcGUjY3VydmVzXG4gIGlzSW50ZXJwb2xhdGlvblR5cGU6IGZ1bmN0aW9uIGlzSW50ZXJwb2xhdGlvblR5cGUodHlwZSkge1xuICAgIHJldHVybiBbXCJiYXNpc1wiLCBcImJhc2lzLWNsb3NlZFwiLCBcImJhc2lzLW9wZW5cIiwgXCJidW5kbGVcIiwgXCJjYXJkaW5hbFwiLCBcImNhcmRpbmFsLWNsb3NlZFwiLCBcImNhcmRpbmFsLW9wZW5cIiwgXCJjYXRtdWxsLXJvbVwiLCBcImNhdG11bGwtcm9tLWNsb3NlZFwiLCBcImNhdG11bGwtcm9tLW9wZW5cIiwgXCJsaW5lYXJcIiwgXCJsaW5lYXItY2xvc2VkXCIsIFwibW9ub3RvbmUteFwiLCBcIm1vbm90b25lLXlcIiwgXCJuYXR1cmFsXCJdLmluZGV4T2YodHlwZSkgPj0gMDtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbnRlcm5hbHMvZ3JpZC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuIC8vIEdyaWQgcG9zaXRpb24gYW5kIHRleHQgYW5jaG9yIGhlbHBlcnNcblxudmFyIGdldEdyaWRUZXh0QW5jaG9yID0gZnVuY3Rpb24gKGQpIHtcbiAgcmV0dXJuIGlzVmFsdWUoZC5wb3NpdGlvbikgfHwgXCJlbmRcIjtcbn0sXG4gICAgZ2V0R3JpZFRleHREeCA9IGZ1bmN0aW9uIChkKSB7XG4gIHJldHVybiBkLnBvc2l0aW9uID09PSBcInN0YXJ0XCIgPyA0IDogZC5wb3NpdGlvbiA9PT0gXCJtaWRkbGVcIiA/IDAgOiAtNDtcbn0sXG4gICAgZ2V0R3JpZFRleHRYID0gZnVuY3Rpb24gKGlzWCwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICB2YXIgeCA9IGlzWCA/IDAgOiB3aWR0aDtcbiAgICByZXR1cm4gZC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiID8geCA9IGlzWCA/IC1oZWlnaHQgOiAwIDogZC5wb3NpdGlvbiA9PT0gXCJtaWRkbGVcIiAmJiAoeCA9IChpc1ggPyAtaGVpZ2h0IDogd2lkdGgpIC8gMiksIHg7XG4gIH07XG59O1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICBpbml0R3JpZDogZnVuY3Rpb24gaW5pdEdyaWQoKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC54Z3JpZCA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0QWxsXCJdKShbXSksICQkLmluaXRHcmlkTGluZXMoKSwgJCQuaW5pdEZvY3VzR3JpZCgpO1xuICB9LFxuICBpbml0R3JpZExpbmVzOiBmdW5jdGlvbiBpbml0R3JpZExpbmVzKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAoY29uZmlnLmdyaWRfeF9saW5lcy5sZW5ndGggfHwgY29uZmlnLmdyaWRfeV9saW5lcy5sZW5ndGgpICYmICgkJC5ncmlkTGluZXMgPSAkJC5tYWluLmluc2VydChcImdcIiwgXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0KS5jb25jYXQoY29uZmlnLmdyaWRfbGluZXNfZnJvbnQgPyBcIiArICpcIiA6IFwiXCIpKS5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLmNsaXBQYXRoRm9yR3JpZCkuYXR0cihcImNsYXNzXCIsIFwiXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmdyaWQsIFwiIFwiKS5jb25jYXQoY29uZmlnX2NsYXNzZXMuZ3JpZExpbmVzKSksICQkLmdyaWRMaW5lcy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjb25maWdfY2xhc3Nlcy54Z3JpZExpbmVzKSwgJCQuZ3JpZExpbmVzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLnlncmlkTGluZXMpLCAkJC54Z3JpZExpbmVzID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RBbGxcIl0pKFtdKSk7XG4gIH0sXG4gIHVwZGF0ZVhHcmlkOiBmdW5jdGlvbiB1cGRhdGVYR3JpZCh3aXRob3V0VXBkYXRlKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkLFxuICAgICAgICB4Z3JpZERhdGEgPSAkJC5nZW5lcmF0ZUdyaWREYXRhKGNvbmZpZy5ncmlkX3hfdHlwZSwgJCQueCksXG4gICAgICAgIHRpY2tPZmZzZXQgPSAkJC5pc0NhdGVnb3JpemVkKCkgPyAkJC54QXhpcy50aWNrT2Zmc2V0KCkgOiAwLFxuICAgICAgICBwb3MgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuICgkJC56b29tU2NhbGUgfHwgJCQueCkoZCkgKyB0aWNrT2Zmc2V0ICogKGlzUm90YXRlZCA/IC0xIDogMSk7XG4gICAgfTtcblxuICAgICQkLnhncmlkQXR0ciA9IGlzUm90YXRlZCA/IHtcbiAgICAgIFwieDFcIjogMCxcbiAgICAgIFwieDJcIjogJCQud2lkdGgsXG4gICAgICBcInkxXCI6IHBvcyxcbiAgICAgIFwieTJcIjogcG9zXG4gICAgfSA6IHtcbiAgICAgIFwieDFcIjogcG9zLFxuICAgICAgXCJ4MlwiOiBwb3MsXG4gICAgICBcInkxXCI6IDAsXG4gICAgICBcInkyXCI6ICQkLmhlaWdodFxuICAgIH0sICQkLnhncmlkID0gJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnhncmlkcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMueGdyaWQpKS5kYXRhKHhncmlkRGF0YSksICQkLnhncmlkLmV4aXQoKS5yZW1vdmUoKSwgJCQueGdyaWQgPSAkJC54Z3JpZC5lbnRlcigpLmFwcGVuZChcImxpbmVcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLnhncmlkKS5tZXJnZSgkJC54Z3JpZCksIHdpdGhvdXRVcGRhdGUgfHwgJCQueGdyaWQuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZ3JpZCA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKSh0aGlzKTtcbiAgICAgIE9iamVjdC5rZXlzKCQkLnhncmlkQXR0cikuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgZ3JpZC5hdHRyKGlkLCAkJC54Z3JpZEF0dHJbaWRdKS5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBncmlkLmF0dHIoaXNSb3RhdGVkID8gXCJ5MVwiIDogXCJ4MVwiKSA9PT0gKGlzUm90YXRlZCA/ICQkLmhlaWdodCA6IDApID8gXCIwXCIgOiBcIjFcIjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgdXBkYXRlWUdyaWQ6IGZ1bmN0aW9uIHVwZGF0ZVlHcmlkKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZCxcbiAgICAgICAgZ3JpZFZhbHVlcyA9ICQkLnlBeGlzLnRpY2tWYWx1ZXMoKSB8fCAkJC55LnRpY2tzKGNvbmZpZy5ncmlkX3lfdGlja3MpLFxuICAgICAgICBwb3MgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCgkJC55KGQpKTtcbiAgICB9O1xuXG4gICAgJCQueWdyaWQgPSAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMueWdyaWRzKSkuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy55Z3JpZCkpLmRhdGEoZ3JpZFZhbHVlcyksICQkLnlncmlkLmV4aXQoKS5yZW1vdmUoKSwgJCQueWdyaWQgPSAkJC55Z3JpZC5lbnRlcigpLmFwcGVuZChcImxpbmVcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLnlncmlkKS5tZXJnZSgkJC55Z3JpZCksICQkLnlncmlkLmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyBwb3MgOiAwKS5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gcG9zIDogJCQud2lkdGgpLmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAwIDogcG9zKS5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8gJCQuaGVpZ2h0IDogcG9zKSwgJCQuc21vb3RoTGluZXMoJCQueWdyaWQsIFwiZ3JpZFwiKTtcbiAgfSxcbiAgdXBkYXRlR3JpZDogZnVuY3Rpb24gdXBkYXRlR3JpZChkdXJhdGlvbikge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgLy8gaGlkZSBpZiBhcmMgdHlwZVxuICAgICQkLmdyaWRMaW5lcyB8fCAkJC5pbml0R3JpZExpbmVzKCksICQkLmdyaWQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsICQkLmhhc0FyY1R5cGUoKSA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIiksICQkLmhpZGVHcmlkRm9jdXMoKSwgJCQudXBkYXRlWEdyaWRMaW5lcyhkdXJhdGlvbiksICQkLnVwZGF0ZVlHcmlkTGluZXMoZHVyYXRpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgWCBHcmlkIGxpbmVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlWEdyaWRMaW5lczogZnVuY3Rpb24gdXBkYXRlWEdyaWRMaW5lcyhkdXJhdGlvbikge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIG1haW4gPSAkJC5tYWluLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG4gICAgY29uZmlnLmdyaWRfeF9zaG93ICYmICQkLnVwZGF0ZVhHcmlkKCksICQkLnhncmlkTGluZXMgPSBtYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMueGdyaWRMaW5lcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMueGdyaWRMaW5lKSkuZGF0YShjb25maWcuZ3JpZF94X2xpbmVzKSwgJCQueGdyaWRMaW5lcy5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLnJlbW92ZSgpO1xuICAgIC8vIGVudGVyXG4gICAgdmFyIHhncmlkTGluZSA9ICQkLnhncmlkTGluZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xuICAgIHhncmlkTGluZS5hcHBlbmQoXCJsaW5lXCIpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIiksIHhncmlkTGluZS5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgaXNSb3RhdGVkID8gXCJcIiA6IFwicm90YXRlKC05MClcIikuYXR0cihcImR5XCIsIC01KS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLCAkJC54Z3JpZExpbmVzID0geGdyaWRMaW5lLm1lcmdlKCQkLnhncmlkTGluZXMpLCAkJC54Z3JpZExpbmVzLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnhncmlkTGluZSwgXCIgXCIpLmNvbmNhdChkW1wiY2xhc3NcIl0gfHwgXCJcIikudHJpbSgpO1xuICAgIH0pLnNlbGVjdChcInRleHRcIikuYXR0cihcInRleHQtYW5jaG9yXCIsIGdldEdyaWRUZXh0QW5jaG9yKS5hdHRyKFwiZHhcIiwgZ2V0R3JpZFRleHREeCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC50ZXh0O1xuICAgIH0pLnRyYW5zaXRpb24oKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgWSBHcmlkIGxpbmVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlWUdyaWRMaW5lczogZnVuY3Rpb24gdXBkYXRlWUdyaWRMaW5lcyhkdXJhdGlvbikge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIG1haW4gPSAkJC5tYWluLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG4gICAgY29uZmlnLmdyaWRfeV9zaG93ICYmICQkLnVwZGF0ZVlHcmlkKCksICQkLnlncmlkTGluZXMgPSBtYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMueWdyaWRMaW5lcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMueWdyaWRMaW5lKSkuZGF0YShjb25maWcuZ3JpZF95X2xpbmVzKSwgJCQueWdyaWRMaW5lcy5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLnJlbW92ZSgpO1xuICAgIC8vIGVudGVyXG4gICAgdmFyIHlncmlkTGluZSA9ICQkLnlncmlkTGluZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xuICAgIHlncmlkTGluZS5hcHBlbmQoXCJsaW5lXCIpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIiksIHlncmlkTGluZS5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgaXNSb3RhdGVkID8gXCJyb3RhdGUoLTkwKVwiIDogXCJcIikuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKSwgJCQueWdyaWRMaW5lcyA9IHlncmlkTGluZS5tZXJnZSgkJC55Z3JpZExpbmVzKTtcbiAgICAvLyB1cGRhdGVcbiAgICB2YXIgeXYgPSAkJC55di5iaW5kKCQkKTtcbiAgICAkJC55Z3JpZExpbmVzLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnlncmlkTGluZSwgXCIgXCIpLmNvbmNhdChkW1wiY2xhc3NcIl0gfHwgXCJcIikudHJpbSgpO1xuICAgIH0pLnNlbGVjdChcImxpbmVcIikudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8geXYgOiAwKS5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8geXYgOiAkJC53aWR0aCkuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IDAgOiB5dikuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/ICQkLmhlaWdodCA6IHl2KS50cmFuc2l0aW9uKCkuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKSwgJCQueWdyaWRMaW5lcy5zZWxlY3QoXCJ0ZXh0XCIpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBnZXRHcmlkVGV4dEFuY2hvcikuYXR0cihcImR4XCIsIGdldEdyaWRUZXh0RHgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuYXR0cihcImR5XCIsIC01KS5hdHRyKFwieFwiLCBnZXRHcmlkVGV4dFgoaXNSb3RhdGVkLCAkJC53aWR0aCwgJCQuaGVpZ2h0KSkuYXR0cihcInlcIiwgeXYpLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLnRleHQ7XG4gICAgfSkudHJhbnNpdGlvbigpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG4gIH0sXG4gIHJlZHJhd0dyaWQ6IGZ1bmN0aW9uIHJlZHJhd0dyaWQod2l0aFRyYW5zaXRpb24pIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkLFxuICAgICAgICB4diA9ICQkLnh2LmJpbmQoJCQpLFxuICAgICAgICBsaW5lcyA9ICQkLnhncmlkTGluZXMuc2VsZWN0KFwibGluZVwiKSxcbiAgICAgICAgdGV4dHMgPSAkJC54Z3JpZExpbmVzLnNlbGVjdChcInRleHRcIik7XG4gICAgcmV0dXJuIGxpbmVzID0gKHdpdGhUcmFuc2l0aW9uID8gbGluZXMudHJhbnNpdGlvbigpIDogbGluZXMpLmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyAwIDogeHYpLmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyAkJC53aWR0aCA6IHh2KS5hdHRyKFwieTFcIiwgaXNSb3RhdGVkID8geHYgOiAwKS5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8geHYgOiAkJC5oZWlnaHQpLCB0ZXh0cyA9ICh3aXRoVHJhbnNpdGlvbiA/IHRleHRzLnRyYW5zaXRpb24oKSA6IHRleHRzKS5hdHRyKFwieFwiLCBnZXRHcmlkVGV4dFgoIWlzUm90YXRlZCwgJCQud2lkdGgsICQkLmhlaWdodCkpLmF0dHIoXCJ5XCIsIHh2KS50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC50ZXh0O1xuICAgIH0pLCBbKHdpdGhUcmFuc2l0aW9uID8gbGluZXMudHJhbnNpdGlvbigpIDogbGluZXMpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIiksICh3aXRoVHJhbnNpdGlvbiA/IHRleHRzLnRyYW5zaXRpb24oKSA6IHRleHRzKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXTtcbiAgfSxcbiAgaW5pdEZvY3VzR3JpZDogZnVuY3Rpb24gaW5pdEZvY3VzR3JpZCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGlzRnJvbnQgPSBjb25maWcuZ3JpZF9mcm9udCxcbiAgICAgICAgY2xhc3NOYW1lID0gXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzW2lzRnJvbnQgJiYgJCQuZ3JpZExpbmVzID8gXCJncmlkTGluZXNcIiA6IFwiY2hhcnRcIl0pLmNvbmNhdChpc0Zyb250ID8gXCIgKyAqXCIgOiBcIlwiKTtcbiAgICAkJC5ncmlkID0gJCQubWFpbi5pbnNlcnQoXCJnXCIsIGNsYXNzTmFtZSkuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5jbGlwUGF0aEZvckdyaWQpLmF0dHIoXCJjbGFzc1wiLCBjb25maWdfY2xhc3Nlcy5ncmlkKSwgY29uZmlnLmdyaWRfeF9zaG93ICYmICQkLmdyaWQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY29uZmlnX2NsYXNzZXMueGdyaWRzKSwgY29uZmlnLmdyaWRfeV9zaG93ICYmICQkLmdyaWQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY29uZmlnX2NsYXNzZXMueWdyaWRzKSwgY29uZmlnLmdyaWRfZm9jdXNfc2hvdyAmJiAoJCQuZ3JpZC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjb25maWdfY2xhc3Nlcy54Z3JpZEZvY3VzKS5hcHBlbmQoXCJsaW5lXCIpLmF0dHIoXCJjbGFzc1wiLCBjb25maWdfY2xhc3Nlcy54Z3JpZEZvY3VzKSwgY29uZmlnLmdyaWRfZm9jdXNfeSAmJiAhY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCAmJiAkJC5ncmlkLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLnlncmlkRm9jdXMpLmFwcGVuZChcImxpbmVcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLnlncmlkRm9jdXMpKTtcbiAgfSxcblxuICAvKipcbiAgICogU2hvdyBncmlkIGZvY3VzIGxpbmVcbiAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWREYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzaG93R3JpZEZvY3VzOiBmdW5jdGlvbiBzaG93R3JpZEZvY3VzKHNlbGVjdGVkRGF0YSkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZCxcbiAgICAgICAgZGF0YVRvU2hvdyA9IHNlbGVjdGVkRGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkICYmIGlzVmFsdWUoJCQuZ2V0QmFzZVZhbHVlKGQpKTtcbiAgICB9KTtcblxuICAgIC8vIEhpZGUgd2hlbiBidWJibGUvc2NhdHRlci9zdGFuZm9yZCBwbG90IGV4aXN0c1xuICAgIGlmICghKCFjb25maWcudG9vbHRpcF9zaG93IHx8IGRhdGFUb1Nob3cubGVuZ3RoID09PSAwIHx8ICQkLmhhc1R5cGUoXCJidWJibGVcIikgfHwgJCQuaGFzQXJjVHlwZSgpKSkge1xuICAgICAgdmFyIGZvY3VzRWwgPSAkJC5tYWluLnNlbGVjdEFsbChcImxpbmUuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnhncmlkRm9jdXMsIFwiLCBsaW5lLlwiKS5jb25jYXQoY29uZmlnX2NsYXNzZXMueWdyaWRGb2N1cykpLFxuICAgICAgICAgIGlzRWRnZSA9IGNvbmZpZy5ncmlkX2ZvY3VzX2VkZ2UgJiYgIWNvbmZpZy50b29sdGlwX2dyb3VwZWQsXG4gICAgICAgICAgeHggPSAkJC54eC5iaW5kKCQkKTtcbiAgICAgIGZvY3VzRWwuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKS5kYXRhKGRhdGFUb1Nob3cuY29uY2F0KGRhdGFUb1Nob3cpKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciB4eSxcbiAgICAgICAgICAgIGVsID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMpLFxuICAgICAgICAgICAgcG9zID0ge1xuICAgICAgICAgIHg6IHh4KGQpLFxuICAgICAgICAgIHk6ICQkLmdldFlTY2FsZShkLmlkKShkLnZhbHVlKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZWwuY2xhc3NlZChjb25maWdfY2xhc3Nlcy54Z3JpZEZvY3VzKSkgeHkgPSBpc1JvdGF0ZWQgPyBbbnVsbCwgLy8geDFcbiAgICAgICAgcG9zLngsIC8vIHkxXG4gICAgICAgIGlzRWRnZSA/IHBvcy55IDogJCQud2lkdGgsIC8vIHgyXG4gICAgICAgIHBvcy54IC8vIHkyXG4gICAgICAgIF0gOiBbcG9zLngsIGlzRWRnZSA/IHBvcy55IDogbnVsbCwgcG9zLngsICQkLmhlaWdodF07ZWxzZSB7XG4gICAgICAgICAgdmFyIGlzWTIgPSAkJC5heGlzLmdldElkKGQuaWQpID09PSBcInkyXCI7XG4gICAgICAgICAgeHkgPSBpc1JvdGF0ZWQgPyBbcG9zLnksIC8vIHgxXG4gICAgICAgICAgaXNFZGdlICYmICFpc1kyID8gcG9zLnggOiBudWxsLCAvLyB5MVxuICAgICAgICAgIHBvcy55LCAvLyB4MlxuICAgICAgICAgIGlzRWRnZSAmJiBpc1kyID8gcG9zLnggOiAkJC5oZWlnaHQgLy8geTJcbiAgICAgICAgICBdIDogW2lzRWRnZSAmJiBpc1kyID8gcG9zLnggOiBudWxsLCBwb3MueSwgaXNFZGdlICYmICFpc1kyID8gcG9zLnggOiAkJC53aWR0aCwgcG9zLnldO1xuICAgICAgICB9XG4gICAgICAgIFtcIngxXCIsIFwieTFcIiwgXCJ4MlwiLCBcInkyXCJdLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICByZXR1cm4gZWwuYXR0cih2LCB4eVtpXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksICQkLnNtb290aExpbmVzKGZvY3VzRWwsIFwiZ3JpZFwiKTtcbiAgICB9XG4gIH0sXG4gIGhpZGVHcmlkRm9jdXM6IGZ1bmN0aW9uIGhpZGVHcmlkRm9jdXMoKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC5pbnB1dFR5cGUgPT09IFwibW91c2VcIiAmJiAkJC5tYWluLnNlbGVjdEFsbChcImxpbmUuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnhncmlkRm9jdXMsIFwiLCBsaW5lLlwiKS5jb25jYXQoY29uZmlnX2NsYXNzZXMueWdyaWRGb2N1cykpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgfSxcbiAgdXBkYXRlR3JpZEZvY3VzOiBmdW5jdGlvbiB1cGRhdGVHcmlkRm9jdXMoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgeGdyaWRGb2N1cyA9ICQkLmdyaWQuc2VsZWN0KFwibGluZS5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMueGdyaWRGb2N1cykpO1xuXG4gICAgaWYgKCEoJCQuaW5wdXRUeXBlID09PSBcInRvdWNoXCIpKSB7XG4gICAgICB2YXIgX2lzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XG4gICAgICB4Z3JpZEZvY3VzLmF0dHIoXCJ4MVwiLCBfaXNSb3RhdGVkID8gMCA6IC0xMCkuYXR0cihcIngyXCIsIF9pc1JvdGF0ZWQgPyAkJC53aWR0aCA6IC0xMCkuYXR0cihcInkxXCIsIF9pc1JvdGF0ZWQgPyAtMTAgOiAwKS5hdHRyKFwieTJcIiwgX2lzUm90YXRlZCA/IC0xMCA6ICQkLmhlaWdodCk7XG4gICAgfSBlbHNlIGlmICgheGdyaWRGb2N1cy5lbXB0eSgpKSB7XG4gICAgICB2YXIgZCA9IHhncmlkRm9jdXMuZGF0dW0oKTtcbiAgICAgIGQgJiYgJCQuc2hvd0dyaWRGb2N1cyhbZF0pO1xuICAgIH0gLy8gbmVlZCB0byByZXR1cm4gJ3RydWUnIGFzIG9mIGJlaW5nIHB1c2hlZCB0byB0aGUgcmVkcmF3IGxpc3RcbiAgICAvLyByZWY6IGdldFJlZHJhd0xpc3QoKVxuXG5cbiAgICByZXR1cm4gITA7XG4gIH0sXG4gIGdlbmVyYXRlR3JpZERhdGE6IGZ1bmN0aW9uIGdlbmVyYXRlR3JpZERhdGEodHlwZSwgc2NhbGUpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICB0aWNrTnVtID0gJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmF4aXNYKSkuc2VsZWN0QWxsKFwiLnRpY2tcIikuc2l6ZSgpLFxuICAgICAgICBncmlkRGF0YSA9IFtdO1xuXG4gICAgaWYgKHR5cGUgPT09IFwieWVhclwiKSB7XG4gICAgICB2YXIgeERvbWFpbiA9ICQkLmdldFhEb21haW4oKSxcbiAgICAgICAgICBmaXJzdFllYXIgPSB4RG9tYWluWzBdLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgbGFzdFllYXIgPSB4RG9tYWluWzFdLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBmaXJzdFllYXI7IGkgPD0gbGFzdFllYXI7IGkrKykgZ3JpZERhdGEucHVzaChuZXcgRGF0ZShcIlwiLmNvbmNhdChpLCBcIi0wMS0wMSAwMDowMDowMFwiKSkpO1xuICAgIH0gZWxzZSBncmlkRGF0YSA9IHNjYWxlLnRpY2tzKDEwKSwgZ3JpZERhdGEubGVuZ3RoID4gdGlja051bSAmJiAoZ3JpZERhdGEgPSBncmlkRGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAoZCArIFwiXCIpLmluZGV4T2YoXCIuXCIpIDwgMDtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZ3JpZERhdGE7XG4gIH0sXG4gIGdldEdyaWRGaWx0ZXJUb1JlbW92ZTogZnVuY3Rpb24gZ2V0R3JpZEZpbHRlclRvUmVtb3ZlKHBhcmFtcykge1xuICAgIHJldHVybiBwYXJhbXMgPyBmdW5jdGlvbiAobGluZSkge1xuICAgICAgdmFyIGZvdW5kID0gITE7XG4gICAgICByZXR1cm4gKGlzQXJyYXkocGFyYW1zKSA/IHBhcmFtcy5jb25jYXQoKSA6IFtwYXJhbXNdKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAoXCJ2YWx1ZVwiIGluIHBhcmFtICYmIGxpbmUudmFsdWUgPT09IHBhcmFtLnZhbHVlIHx8IFwiY2xhc3NcIiBpbiBwYXJhbSAmJiBsaW5lW1wiY2xhc3NcIl0gPT09IHBhcmFtW1wiY2xhc3NcIl0pICYmIChmb3VuZCA9ICEwKTtcbiAgICAgIH0pLCBmb3VuZDtcbiAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH07XG4gIH0sXG4gIHJlbW92ZUdyaWRMaW5lczogZnVuY3Rpb24gcmVtb3ZlR3JpZExpbmVzKHBhcmFtcywgZm9yWCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgdG9SZW1vdmUgPSAkJC5nZXRHcmlkRmlsdGVyVG9SZW1vdmUocGFyYW1zKSxcbiAgICAgICAgY2xhc3NMaW5lcyA9IGZvclggPyBjb25maWdfY2xhc3Nlcy54Z3JpZExpbmVzIDogY29uZmlnX2NsYXNzZXMueWdyaWRMaW5lcyxcbiAgICAgICAgY2xhc3NMaW5lID0gZm9yWCA/IGNvbmZpZ19jbGFzc2VzLnhncmlkTGluZSA6IGNvbmZpZ19jbGFzc2VzLnlncmlkTGluZTtcbiAgICAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY2xhc3NMaW5lcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY2xhc3NMaW5lKSkuZmlsdGVyKHRvUmVtb3ZlKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pLnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIikucmVtb3ZlKCk7XG4gICAgdmFyIGdyaWRMaW5lcyA9IFwiZ3JpZF9cIi5jb25jYXQoZm9yWCA/IFwieFwiIDogXCJ5XCIsIFwiX2xpbmVzXCIpO1xuICAgIGNvbmZpZ1tncmlkTGluZXNdID0gY29uZmlnW2dyaWRMaW5lc10uZmlsdGVyKGZ1bmN0aW9uIHRvU2hvdyhsaW5lKSB7XG4gICAgICByZXR1cm4gIXRvUmVtb3ZlKGxpbmUpO1xuICAgIH0pO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ludGVybmFscy90b29sdGlwLmpzXG5cblxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuXG5cblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWxfQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSB0b29sdGlwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0VG9vbHRpcDogZnVuY3Rpb24gaW5pdFRvb2x0aXAoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBiaW5kdG8gPSBjb25maWcudG9vbHRpcF9jb250ZW50cy5iaW5kdG87XG5cbiAgICAvLyBTaG93IHRvb2x0aXAgaWYgbmVlZGVkXG4gICAgaWYgKCQkLnRvb2x0aXAgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkoYmluZHRvKSwgJCQudG9vbHRpcC5lbXB0eSgpICYmICgkJC50b29sdGlwID0gJCQuc2VsZWN0Q2hhcnQuc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpLmFwcGVuZChcImRpdlwiKS5hdHRyKFwiY2xhc3NcIiwgY29uZmlnX2NsYXNzZXMudG9vbHRpcENvbnRhaW5lcikuc3R5bGUoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIikpLCBjb25maWcudG9vbHRpcF9pbml0X3Nob3cpIHtcbiAgICAgIGlmICgkJC5pc1RpbWVTZXJpZXMoKSAmJiBpc1N0cmluZyhjb25maWcudG9vbHRpcF9pbml0X3gpKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgdGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0c1swXTtcblxuICAgICAgICBmb3IgKGNvbmZpZy50b29sdGlwX2luaXRfeCA9ICQkLnBhcnNlRGF0ZShjb25maWcudG9vbHRpcF9pbml0X3gpLCBpID0gMDsgKHZhbCA9IHRhcmdldHMudmFsdWVzW2ldKSAmJiB2YWwueCAtIGNvbmZpZy50b29sdGlwX2luaXRfeCAhPT0gMDsgaSsrKTtcblxuICAgICAgICBjb25maWcudG9vbHRpcF9pbml0X3ggPSBpO1xuICAgICAgfVxuXG4gICAgICAkJC50b29sdGlwLmh0bWwoJCQuZ2V0VG9vbHRpcEhUTUwoJCQuZGF0YS50YXJnZXRzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gJCQuYWRkTmFtZShkLnZhbHVlc1tjb25maWcudG9vbHRpcF9pbml0X3hdKTtcbiAgICAgIH0pLCAkJC5heGlzLmdldFhBeGlzVGlja0Zvcm1hdCgpLCAkJC5nZXRZRm9ybWF0KCQkLmhhc0FyY1R5cGUobnVsbCwgW1wicmFkYXJcIl0pKSwgJCQuY29sb3IpKSwgYmluZHRvIHx8ICQkLnRvb2x0aXAuc3R5bGUoXCJ0b3BcIiwgY29uZmlnLnRvb2x0aXBfaW5pdF9wb3NpdGlvbi50b3ApLnN0eWxlKFwibGVmdFwiLCBjb25maWcudG9vbHRpcF9pbml0X3Bvc2l0aW9uLmxlZnQpLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgIH1cblxuICAgICQkLmJpbmRUb29sdGlwUmVzaXplUG9zKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdG9vbHRpcCBIVE1MIHN0cmluZ1xuICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3NcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7U3RyaW5nfSBGb3JtYXR0ZWQgSFRNTCBzdHJpbmdcbiAgICovXG4gIGdldFRvb2x0aXBIVE1MOiBmdW5jdGlvbiBnZXRUb29sdGlwSFRNTCgpIHtcbiAgICBmb3IgKHZhciBfY29uZmlnJHRvb2x0aXBfY29udGUsIF8kJCwgJCQgPSB0aGlzLCBjb25maWcgPSAkJC5jb25maWcsIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oY29uZmlnLnRvb2x0aXBfY29udGVudHMpID8gKF9jb25maWckdG9vbHRpcF9jb250ZSA9IGNvbmZpZy50b29sdGlwX2NvbnRlbnRzKS5jYWxsLmFwcGx5KF9jb25maWckdG9vbHRpcF9jb250ZSwgWyQkXS5jb25jYXQoYXJncykpIDogKF8kJCA9ICQkKS5nZXRUb29sdGlwQ29udGVudC5hcHBseShfJCQsIGFyZ3MpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b29sdGlwIGNvbnRlbnQoSFRNTCBzdHJpbmcpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkIGRhdGFcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFRpdGxlRm9ybWF0IERlZmF1bHQgdGl0bGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRlZmF1bHRWYWx1ZUZvcm1hdCBEZWZhdWx0IGZvcm1hdCBmb3IgZWFjaCBkYXRhIHZhbHVlIGluIHRoZSB0b29sdGlwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb2xvciBDb2xvciBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBodG1sXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gZ2V0VG9vbHRpcENvbnRlbnQoZCwgZGVmYXVsdFRpdGxlRm9ybWF0LCBkZWZhdWx0VmFsdWVGb3JtYXQsIGNvbG9yKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICB0aXRsZUZvcm1hdCA9IGNvbmZpZy50b29sdGlwX2Zvcm1hdF90aXRsZSB8fCBkZWZhdWx0VGl0bGVGb3JtYXQsXG4gICAgICAgIG5hbWVGb3JtYXQgPSBjb25maWcudG9vbHRpcF9mb3JtYXRfbmFtZSB8fCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSxcbiAgICAgICAgdmFsdWVGb3JtYXQgPSBjb25maWcudG9vbHRpcF9mb3JtYXRfdmFsdWUgfHwgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkgPyBmdW5jdGlvbiAodiwgcmF0aW8pIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCgocmF0aW8gKiAxMDApLnRvRml4ZWQoMiksIFwiJVwiKTtcbiAgICB9IDogZGVmYXVsdFZhbHVlRm9ybWF0KSxcbiAgICAgICAgb3JkZXIgPSBjb25maWcudG9vbHRpcF9vcmRlcixcbiAgICAgICAgZ2V0Um93VmFsdWUgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gJCQuaXNCdWJibGVaVHlwZShyb3cpID8gJCQuZ2V0QnViYmxlWkRhdGEocm93LnZhbHVlLCBcInpcIikgOiAkJC5nZXRCYXNlVmFsdWUocm93KTtcbiAgICB9LFxuICAgICAgICBnZXRCZ0NvbG9yID0gJCQubGV2ZWxDb2xvciA/IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiAkJC5sZXZlbENvbG9yKHJvdy52YWx1ZSk7XG4gICAgfSA6IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBjb2xvcihyb3cpO1xuICAgIH0sXG4gICAgICAgIGNvbnRlbnRzID0gY29uZmlnLnRvb2x0aXBfY29udGVudHMsXG4gICAgICAgIHRwbFN0ciA9IGNvbnRlbnRzLnRlbXBsYXRlLFxuICAgICAgICB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcygpO1xuXG4gICAgaWYgKG9yZGVyID09PSBudWxsICYmICQkLmlzR3JvdXBlZCgpKSB7XG4gICAgICAvLyBmb3Igc3RhY2tlZCBkYXRhLCBvcmRlciBzaG91bGQgYWxpZ25lZCB3aXRoIHRoZSB2aXN1YWxseSBkaXNwbGF5ZWQgZGF0YVxuICAgICAgdmFyIGlkcyA9ICQkLm9yZGVyVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpLm1hcChmdW5jdGlvbiAoaTIpIHtcbiAgICAgICAgcmV0dXJuIGkyLmlkO1xuICAgICAgfSkucmV2ZXJzZSgpO1xuICAgICAgZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciB2MSA9IGEgPyBhLnZhbHVlIDogbnVsbCxcbiAgICAgICAgICAgIHYyID0gYiA/IGIudmFsdWUgOiBudWxsO1xuICAgICAgICByZXR1cm4gdjEgPiAwICYmIHYyID4gMCAmJiAodjEgPSBhLmlkID8gaWRzLmluZGV4T2YoYS5pZCkgOiBudWxsLCB2MiA9IGIuaWQgPyBpZHMuaW5kZXhPZihiLmlkKSA6IG51bGwpLCB2MSAtIHYyO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgvXihhc2N8ZGVzYykkLy50ZXN0KG9yZGVyKSkge1xuICAgICAgZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciB2MSA9IGEgPyBnZXRSb3dWYWx1ZShhKSA6IG51bGwsXG4gICAgICAgICAgICB2MiA9IGIgPyBnZXRSb3dWYWx1ZShiKSA6IG51bGw7XG4gICAgICAgIHJldHVybiBvcmRlciA9PT0gXCJhc2NcIiA/IHYxIC0gdjIgOiB2MiAtIHYxO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlzRnVuY3Rpb24ob3JkZXIpICYmIGQuc29ydChvcmRlcik7XG5cbiAgICB2YXIgdGV4dCxcbiAgICAgICAgcm93LFxuICAgICAgICBwYXJhbSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGksXG4gICAgICAgIHRwbCA9ICQkLmdldFRvb2x0aXBDb250ZW50VGVtcGxhdGUodHBsU3RyKSxcbiAgICAgICAgbGVuID0gZC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIGlmIChyb3cgPSBkW2ldLCByb3cgJiYgKGdldFJvd1ZhbHVlKHJvdykgfHwgZ2V0Um93VmFsdWUocm93KSA9PT0gMCkpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZCh0ZXh0KSkge1xuICAgICAgICB2YXIgdGl0bGUgPSBzYW5pdGlzZSh0aXRsZUZvcm1hdCA/IHRpdGxlRm9ybWF0KHJvdy54KSA6IHJvdy54KTtcbiAgICAgICAgdGV4dCA9IHRwbFByb2Nlc3ModHBsWzBdLCB7XG4gICAgICAgICAgQ0xBU1NfVE9PTFRJUDogY29uZmlnX2NsYXNzZXMudG9vbHRpcCxcbiAgICAgICAgICBUSVRMRTogaXNWYWx1ZSh0aXRsZSkgPyB0cGxTdHIgPyB0aXRsZSA6IFwiPHRyPjx0aCBjb2xzcGFuPVxcXCIyXFxcIj5cIi5jb25jYXQodGl0bGUsIFwiPC90aD48L3RyPlwiKSA6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbSA9IFtyb3cucmF0aW8sIHJvdy5pZCwgcm93LmluZGV4LCBkXSwgdmFsdWUgPSBzYW5pdGlzZSh2YWx1ZUZvcm1hdC5hcHBseSh2b2lkIDAsIFtnZXRSb3dWYWx1ZShyb3cpXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhcmFtKSkpKSwgJCQuaXNBcmVhUmFuZ2VUeXBlKHJvdykpIHtcbiAgICAgICAgdmFyIF9tYXAgPSBbXCJoaWdoXCIsIFwibG93XCJdLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiBzYW5pdGlzZSh2YWx1ZUZvcm1hdC5hcHBseSh2b2lkIDAsIFskJC5nZXRBcmVhUmFuZ2VEYXRhKHJvdywgdildLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocGFyYW0pKSkpO1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIF9tYXAyID0gX3NsaWNlZFRvQXJyYXkoX21hcCwgMiksXG4gICAgICAgICAgICBoaWdoID0gX21hcDJbMF0sXG4gICAgICAgICAgICBsb3cgPSBfbWFwMlsxXTtcblxuICAgICAgICB2YWx1ZSA9IFwiPGI+TWlkOjwvYj4gXCIuY29uY2F0KHZhbHVlLCBcIiA8Yj5IaWdoOjwvYj4gXCIpLmNvbmNhdChoaWdoLCBcIiA8Yj5Mb3c6PC9iPiBcIikuY29uY2F0KGxvdyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFNraXAgZWxlbWVudHMgd2hlbiB0aGVpciBuYW1lIGlzIHNldCB0byBudWxsXG4gICAgICAgICAgaWYgKHJvdy5uYW1lID09PSBudWxsKSByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgIHZhciBuYW1lID0gc2FuaXRpc2UobmFtZUZvcm1hdC5hcHBseSh2b2lkIDAsIFtyb3cubmFtZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXJhbSkpKSksXG4gICAgICAgICAgICAgIGNvbG9yID0gZ2V0QmdDb2xvcihyb3cpLFxuICAgICAgICAgICAgICBjb250ZW50VmFsdWUgPSB7XG4gICAgICAgICAgICBDTEFTU19UT09MVElQX05BTUU6IGNvbmZpZ19jbGFzc2VzLnRvb2x0aXBOYW1lICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgocm93LmlkKSxcbiAgICAgICAgICAgIENPTE9SOiB0cGxTdHIgfHwgISQkLnBhdHRlcm5zID8gY29sb3IgOiBcIjxzdmc+PHJlY3Qgc3R5bGU9XFxcImZpbGw6XCIuY29uY2F0KGNvbG9yLCBcIlxcXCIgd2lkdGg9XFxcIjEwXFxcIiBoZWlnaHQ9XFxcIjEwXFxcIj48L3JlY3Q+PC9zdmc+XCIpLFxuICAgICAgICAgICAgTkFNRTogbmFtZSxcbiAgICAgICAgICAgIFZBTFVFOiB2YWx1ZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodHBsU3RyICYmIGlzT2JqZWN0KGNvbnRlbnRzLnRleHQpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0YXJnZXRJZHMuaW5kZXhPZihyb3cuaWQpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udGVudHMudGV4dCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRWYWx1ZVtrZXldID0gY29udGVudHMudGV4dFtrZXldW2luZGV4XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRleHQgKz0gdHBsUHJvY2Vzcyh0cGxbMV0sIGNvbnRlbnRWYWx1ZSk7XG4gICAgICAgIH0oKTtcblxuICAgICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGV4dCwgXCI8L3RhYmxlPlwiKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBjb250ZW50IHRlbXBsYXRlIHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdHBsU3RyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGVtcGxhdGUgc3RyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRUb29sdGlwQ29udGVudFRlbXBsYXRlOiBmdW5jdGlvbiBnZXRUb29sdGlwQ29udGVudFRlbXBsYXRlKHRwbFN0cikge1xuICAgIHJldHVybiAodHBsU3RyIHx8IFwiPHRhYmxlIGNsYXNzPVxcXCJ7PUNMQVNTX1RPT0xUSVB9XFxcIj48dGJvZHk+XFxuXFx0XFx0XFx0XFx0ez1USVRMRX1cXG5cXHRcXHRcXHRcXHR7ezx0ciBjbGFzcz1cXFwiez1DTEFTU19UT09MVElQX05BTUV9XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8dGQgY2xhc3M9XFxcIm5hbWVcXFwiPlwiLmNvbmNhdCh0aGlzLnBhdHRlcm5zID8gXCJ7PUNPTE9SfVwiIDogXCI8c3BhbiBzdHlsZT1cXFwiYmFja2dyb3VuZC1jb2xvcjp7PUNPTE9SfVxcXCI+PC9zcGFuPlwiLCBcIns9TkFNRX08L3RkPlxcblxcdFxcdFxcdFxcdFxcdDx0ZCBjbGFzcz1cXFwidmFsdWVcXFwiPns9VkFMVUV9PC90ZD5cXG5cXHRcXHRcXHRcXHQ8L3RyPn19XFxuXFx0XFx0XFx0PC90Ym9keT48L3RhYmxlPlwiKSkucmVwbGFjZSgvKFxccj9cXG58XFx0KS9nLCBcIlwiKS5zcGxpdCgve3soLiopfX0vKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFUb1Nob3cgZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdFdpZHRoIFdpZHRoIHZhbHVlIG9mIHRvb2x0aXAgZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdEhlaWdodCBIZWlnaHQgdmFsdWUgb2YgdG9vbHRpcCBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybnMge09iamVjdH0gdG9wLCBsZWZ0IHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uIHRvb2x0aXBQb3NpdGlvbihkYXRhVG9TaG93LCB0V2lkdGgsIHRIZWlnaHQsIGVsZW1lbnQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSxcbiAgICAgICAgc3ZnTGVmdCA9ICQkLmdldFN2Z0xlZnQoITApLFxuICAgICAgICBfZDNNb3VzZSA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wibW91c2VcIl0pKGVsZW1lbnQpLFxuICAgICAgICBfZDNNb3VzZTIgPSBfc2xpY2VkVG9BcnJheShfZDNNb3VzZSwgMiksXG4gICAgICAgIGxlZnQgPSBfZDNNb3VzZTJbMF0sXG4gICAgICAgIHRvcCA9IF9kM01vdXNlMlsxXSxcbiAgICAgICAgY2hhcnRSaWdodCA9IHN2Z0xlZnQgKyAkJC5jdXJyZW50V2lkdGggLSAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCEwKSxcbiAgICAgICAgY2hhcnRMZWZ0ID0gJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCEwKSxcbiAgICAgICAgc2l6ZSA9IDIwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRvb2x0aXAgcG9zaXRpb25cbiAgICBpZiAodG9wICs9IHNpemUsICQkLmhhc0FyY1R5cGUoKSkge1xuICAgICAgdmFyIHJhdyA9ICQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiIHx8ICQkLmhhc1R5cGUoXCJyYWRhclwiKTtcbiAgICAgIHJhdyB8fCAodG9wICs9IGhhc0dhdWdlID8gJCQuaGVpZ2h0IDogJCQuaGVpZ2h0IC8gMiwgbGVmdCArPSAoJCQud2lkdGggLSAoJCQuaXNMZWdlbmRSaWdodCA/ICQkLmdldExlZ2VuZFdpZHRoKCkgOiAwKSkgLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGFTY2FsZSA9ICQkLngoZGF0YVRvU2hvd1swXS54KTtcbiAgICAgIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAodG9wID0gZGF0YVNjYWxlICsgc2l6ZSwgbGVmdCArPSBzdmdMZWZ0ICsgMTAwLCBjaGFydFJpZ2h0IC09IHN2Z0xlZnQpIDogKHRvcCAtPSA1LCBsZWZ0ID0gc3ZnTGVmdCArIGNoYXJ0TGVmdCArIHNpemUgKyAoJCQuem9vbVNjYWxlID8gbGVmdCA6IGRhdGFTY2FsZSkpO1xuICAgIH0gLy8gd2hlbiB0b29sdGlwIGxlZnQgKyB0V2lkdGggPiBjaGFydCdzIHdpZHRoXG5cblxuICAgIGxlZnQgKyB0V2lkdGggKyAxNSA+IGNoYXJ0UmlnaHQgJiYgKGxlZnQgLT0gdFdpZHRoICsgY2hhcnRMZWZ0KSwgdG9wICsgdEhlaWdodCA+ICQkLmN1cnJlbnRIZWlnaHQgJiYgKHRvcCAtPSBoYXNHYXVnZSA/IHRIZWlnaHQgKiAzIDogdEhlaWdodCArIDMwKTtcbiAgICB2YXIgcG9zID0ge1xuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0XG4gICAgfTsgLy8gbWFrZSBzdXJlIHRvIG5vdCBiZSBwb3NpdGlvbmVkIG91dCBvZiB2aWV3cG9ydFxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBvcykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgcG9zW3ZdIDwgMCAmJiAocG9zW3ZdID0gMCk7XG4gICAgfSksIHBvcztcbiAgfSxcblxuICAvKipcbiAgICogU2hvdyB0aGUgdG9vbHRpcFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0ZWREYXRhXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHNob3dUb29sdGlwOiBmdW5jdGlvbiBzaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIGVsZW1lbnQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGJpbmR0byA9IGNvbmZpZy50b29sdGlwX2NvbnRlbnRzLmJpbmR0byxcbiAgICAgICAgZm9yQXJjID0gJCQuaGFzQXJjVHlwZShudWxsLCBbXCJyYWRhclwiXSksXG4gICAgICAgIGRhdGFUb1Nob3cgPSBzZWxlY3RlZERhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZCAmJiBpc1ZhbHVlKCQkLmdldEJhc2VWYWx1ZShkKSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZGF0YVRvU2hvdy5sZW5ndGggIT09IDAgJiYgY29uZmlnLnRvb2x0aXBfc2hvdykge1xuICAgICAgdmFyIGRhdHVtID0gJCQudG9vbHRpcC5kYXR1bSgpLFxuICAgICAgICAgIF9yZWYgPSBkYXR1bSB8fCB7fSxcbiAgICAgICAgICBfcmVmJHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgICAgICB3aWR0aCA9IF9yZWYkd2lkdGggPT09IHZvaWQgMCA/IDAgOiBfcmVmJHdpZHRoLFxuICAgICAgICAgIF9yZWYkaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0ID0gX3JlZiRoZWlnaHQgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGhlaWdodCxcbiAgICAgICAgICBkYXRhU3RyID0gSlNPTi5zdHJpbmdpZnkoc2VsZWN0ZWREYXRhKTtcblxuICAgICAgaWYgKCFkYXR1bSB8fCBkYXR1bS5jdXJyZW50ICE9PSBkYXRhU3RyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHNlbGVjdGVkRGF0YS5jb25jYXQoKS5zb3J0KClbMF0uaW5kZXg7XG4gICAgICAgIGNhbGxGbihjb25maWcudG9vbHRpcF9vbnNob3csICQkLCAkJC5hcGksIHNlbGVjdGVkRGF0YSksICQkLnRvb2x0aXAuaHRtbCgkJC5nZXRUb29sdGlwSFRNTChzZWxlY3RlZERhdGEsICQkLmF4aXMuZ2V0WEF4aXNUaWNrRm9ybWF0KCksICQkLmdldFlGb3JtYXQoZm9yQXJjKSwgJCQuY29sb3IpKS5zdHlsZShcImRpc3BsYXlcIiwgbnVsbCkuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIG51bGwpIC8vIGZvciBJRTlcbiAgICAgICAgLmRhdHVtKGRhdHVtID0ge1xuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICBjdXJyZW50OiBkYXRhU3RyLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCA9ICQkLnRvb2x0aXAucHJvcGVydHkoXCJvZmZzZXRXaWR0aFwiKSxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA9ICQkLnRvb2x0aXAucHJvcGVydHkoXCJvZmZzZXRIZWlnaHRcIilcbiAgICAgICAgfSksIGNhbGxGbihjb25maWcudG9vbHRpcF9vbnNob3duLCAkJCwgJCQuYXBpLCBzZWxlY3RlZERhdGEpLCAkJC5faGFuZGxlTGlua2VkQ2hhcnRzKCEwLCBpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYmluZHRvKSB7XG4gICAgICAgIHZhciBmblBvcyA9IGNvbmZpZy50b29sdGlwX3Bvc2l0aW9uIHx8ICQkLnRvb2x0aXBQb3NpdGlvbixcbiAgICAgICAgICAgIHBvcyA9IGZuUG9zLmNhbGwodGhpcywgZGF0YVRvU2hvdywgd2lkdGgsIGhlaWdodCwgZWxlbWVudCk7IC8vIEdldCB0b29sdGlwIGRpbWVuc2lvbnNcblxuICAgICAgICBbXCJ0b3BcIiwgXCJsZWZ0XCJdLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBwb3Nbdl07XG4gICAgICAgICAgJCQudG9vbHRpcC5zdHlsZSh2LCBcIlwiLmNvbmNhdCh2YWx1ZSwgXCJweFwiKSksIHYgIT09IFwibGVmdFwiIHx8IGRhdHVtLnhQb3NJblBlcmNlbnQgfHwgKGRhdHVtLnhQb3NJblBlcmNlbnQgPSB2YWx1ZSAvICQkLmN1cnJlbnRXaWR0aCAqIDEwMCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRqdXN0IHRvb2x0aXAgcG9zaXRpb24gb24gcmVzaXplIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiaW5kVG9vbHRpcFJlc2l6ZVBvczogZnVuY3Rpb24gYmluZFRvb2x0aXBSZXNpemVQb3MoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgcmVzaXplRnVuY3Rpb24gPSAkJC5yZXNpemVGdW5jdGlvbixcbiAgICAgICAgdG9vbHRpcCA9ICQkLnRvb2x0aXA7XG4gICAgcmVzaXplRnVuY3Rpb24uYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0b29sdGlwLnN0eWxlKFwiZGlzcGxheVwiKSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgIHZhciBjdXJyZW50V2lkdGggPSAkJC5jdXJyZW50V2lkdGgsXG4gICAgICAgICAgICBfdG9vbHRpcCRkYXR1bSA9IHRvb2x0aXAuZGF0dW0oKSxcbiAgICAgICAgICAgIHdpZHRoID0gX3Rvb2x0aXAkZGF0dW0ud2lkdGgsXG4gICAgICAgICAgICB4UG9zSW5QZXJjZW50ID0gX3Rvb2x0aXAkZGF0dW0ueFBvc0luUGVyY2VudCxcbiAgICAgICAgICAgIF92YWx1ZSA9IGN1cnJlbnRXaWR0aCAvIDEwMCAqIHhQb3NJblBlcmNlbnQsXG4gICAgICAgICAgICBkaWZmID0gY3VycmVudFdpZHRoIC0gKF92YWx1ZSArIHdpZHRoKTtcblxuICAgICAgICBkaWZmIDwgMCAmJiAoX3ZhbHVlICs9IGRpZmYpLCB0b29sdGlwLnN0eWxlKFwibGVmdFwiLCBcIlwiLmNvbmNhdChfdmFsdWUsIFwicHhcIikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSB0b29sdGlwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRm9yY2UgdG8gaGlkZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGlkZVRvb2x0aXA6IGZ1bmN0aW9uIGhpZGVUb29sdGlwKGZvcmNlKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgYXBpID0gJCQuYXBpLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIHRvb2x0aXAgPSAkJC50b29sdGlwO1xuXG4gICAgaWYgKHRvb2x0aXAuc3R5bGUoXCJkaXNwbGF5XCIpICE9PSBcIm5vbmVcIiAmJiAoIWNvbmZpZy50b29sdGlwX2RvTm90SGlkZSB8fCBmb3JjZSkpIHtcbiAgICAgIHZhciBzZWxlY3RlZERhdGEgPSBKU09OLnBhcnNlKHRoaXMudG9vbHRpcC5kYXR1bSgpLmN1cnJlbnQpO1xuICAgICAgLy8gaGlkZSB0b29sdGlwXG4gICAgICBjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25oaWRlLCAkJCwgYXBpLCBzZWxlY3RlZERhdGEpLCB0b29sdGlwLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIikuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpIC8vIGZvciBJRTlcbiAgICAgIC5kYXR1bShudWxsKSwgY2FsbEZuKGNvbmZpZy50b29sdGlwX29uaGlkZGVuLCAkJCwgYXBpLCBzZWxlY3RlZERhdGEpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVG9nZ2xlIGRpc3BsYXkgZm9yIGxpbmtlZCBjaGFydCBpbnN0YW5jZXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBzaG93IHRydWU6IHNob3csIGZhbHNlOiBoaWRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCB4IEF4aXMgaW5kZXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVMaW5rZWRDaGFydHM6IGZ1bmN0aW9uIF9oYW5kbGVMaW5rZWRDaGFydHMoc2hvdywgaW5kZXgpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuXG4gICAgaWYgKCQkLmNvbmZpZy50b29sdGlwX2xpbmtlZCkge1xuICAgICAgdmFyIGxpbmtlZE5hbWUgPSAkJC5jb25maWcudG9vbHRpcF9saW5rZWRfbmFtZTtcbiAgICAgICgkJC5hcGkuaW50ZXJuYWwuY2hhcnRzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjICE9PSAkJC5hcGkpIHtcbiAgICAgICAgICB2YXIgX2NvbmZpZyA9IGMuaW50ZXJuYWwuY29uZmlnLFxuICAgICAgICAgICAgICBpc0xpbmtlZCA9IF9jb25maWcudG9vbHRpcF9saW5rZWQsXG4gICAgICAgICAgICAgIG5hbWUgPSBfY29uZmlnLnRvb2x0aXBfbGlua2VkX25hbWUsXG4gICAgICAgICAgICAgIGlzSW5Eb20gPSBicm93c2VyX2RvYy5ib2R5LmNvbnRhaW5zKGMuZWxlbWVudCk7XG5cbiAgICAgICAgICBpZiAoaXNMaW5rZWQgJiYgbGlua2VkTmFtZSA9PT0gbmFtZSAmJiBpc0luRG9tKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGMuaW50ZXJuYWwudG9vbHRpcC5kYXRhKClbMF0sXG4gICAgICAgICAgICAgICAgaXNOb3RTYW1lSW5kZXggPSBpbmRleCAhPT0gKGRhdGEgJiYgZGF0YS5pbmRleCk7XG5cbiAgICAgICAgICAgIC8vIHByZXZlbnQgdGhyb3dpbmcgZXJyb3IgZm9yIG5vbi1wYWlyZWQgbGlua2VkIGluZGV4ZXNcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHNob3cgJiYgaXNOb3RTYW1lSW5kZXggPyBjLnRvb2x0aXAuc2hvdyh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgIH0pIDogIXNob3cgJiYgYy50b29sdGlwLmhpZGUoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaW50ZXJuYWxzL2xlZ2VuZC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBsZWdlbmQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0TGVnZW5kOiBmdW5jdGlvbiBpbml0TGVnZW5kKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAkJC5sZWdlbmRJdGVtVGV4dEJveCA9IHt9LCAkJC5sZWdlbmRIYXNSZW5kZXJlZCA9ICExLCAkJC5sZWdlbmQgPSAkJC5zdmcuYXBwZW5kKFwiZ1wiKSwgY29uZmlnLmxlZ2VuZF9zaG93ID8gKCQkLmxlZ2VuZC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImxlZ2VuZFwiKSksICQkLnVwZGF0ZUxlZ2VuZCgpKSA6ICgkJC5sZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpLCAkJC5oaWRkZW5MZWdlbmRJZHMgPSAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGxlZ2VuZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkcyBJRCdzIG9mIHRhcmdldFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoVHJhbnNmb3JtIDogV2hldGhlciB0byB1c2UgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtOiBXaGV0aGVyIHRyYW5zaXRpb24gaXMgdXNlZCB3aGVuIHVzaW5nIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgLyB3aXRoVHJhbnNpdGlvbiA6IHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9ucyBSZXR1cm4gdmFsdWUgb2YgdGhlIGdlbmVyYXRlVHJhbnNpdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUxlZ2VuZDogZnVuY3Rpb24gdXBkYXRlTGVnZW5kKHRhcmdldElkcywgb3B0aW9ucywgdHJhbnNpdGlvbnMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIG9wdGlvbnogPSBvcHRpb25zIHx8IHtcbiAgICAgIHdpdGhUcmFuc2Zvcm06ICExLFxuICAgICAgd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06ICExLFxuICAgICAgd2l0aFRyYW5zaXRpb246ICExXG4gICAgfTtcbiAgICAvLyB0b2dnbGUgbGVnZW5kIHN0YXRlXG4gICAgLy8gVXBkYXRlIHNpemUgYW5kIHNjYWxlXG4gICAgLy8gVXBkYXRlIGcgcG9zaXRpb25zXG4gICAgb3B0aW9uei53aXRoVHJhbnNpdGlvbiA9IGdldE9wdGlvbihvcHRpb256LCBcIndpdGhUcmFuc2l0aW9uXCIsICEwKSwgb3B0aW9uei53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb256LCBcIndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtXCIsICEwKSwgY29uZmlnLmxlZ2VuZF9jb250ZW50c19iaW5kdG8gJiYgY29uZmlnLmxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZSA/ICQkLnVwZGF0ZUxlZ2VuZFRlbXBsYXRlKCkgOiAkJC51cGRhdGVMZWdlbmRFbGVtZW50KHRhcmdldElkcyB8fCAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLCBvcHRpb256LCB0cmFuc2l0aW9ucyksICQkLmxlZ2VuZC5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmxlZ2VuZEl0ZW0pKS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmxlZ2VuZEl0ZW1IaWRkZW4sIGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuICEkJC5pc1RhcmdldFRvU2hvdyhpZCk7XG4gICAgfSksICQkLnVwZGF0ZVNjYWxlcyghMSwgISQkLnpvb21TY2FsZSksICQkLnVwZGF0ZVN2Z1NpemUoKSwgJCQudHJhbnNmb3JtQWxsKG9wdGlvbnoud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0sIHRyYW5zaXRpb25zKSwgJCQubGVnZW5kSGFzUmVuZGVyZWQgPSAhMDtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGxlZ2VuZCB1c2luZyB0ZW1wbGF0ZSBvcHRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUxlZ2VuZFRlbXBsYXRlOiBmdW5jdGlvbiB1cGRhdGVMZWdlbmRUZW1wbGF0ZSgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIHdyYXBwZXIgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkoY29uZmlnLmxlZ2VuZF9jb250ZW50c19iaW5kdG8pLFxuICAgICAgICB0ZW1wbGF0ZSA9IGNvbmZpZy5sZWdlbmRfY29udGVudHNfdGVtcGxhdGU7XG5cbiAgICBpZiAoIXdyYXBwZXIuZW1wdHkoKSkge1xuICAgICAgdmFyIHRhcmdldHMgPSAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLFxuICAgICAgICAgIGlkcyA9IFtdLFxuICAgICAgICAgIGh0bWwgPSBcIlwiO1xuICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gaXNGdW5jdGlvbih0ZW1wbGF0ZSkgPyB0ZW1wbGF0ZS5jYWxsKCQkLCB2LCAkJC5jb2xvcih2KSwgJCQuYXBpLmRhdGEodilbMF0udmFsdWVzKSA6IHRwbFByb2Nlc3ModGVtcGxhdGUsIHtcbiAgICAgICAgICBDT0xPUjogJCQuY29sb3IodiksXG4gICAgICAgICAgVElUTEU6IHZcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRlbnQgJiYgKGlkcy5wdXNoKHYpLCBodG1sICs9IGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbGVnZW5kSXRlbSA9IHdyYXBwZXIuaHRtbChodG1sKS5zZWxlY3RBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgfSkuZGF0YShpZHMpO1xuICAgICAgJCQuc2V0TGVnZW5kSXRlbShsZWdlbmRJdGVtKSwgJCQubGVnZW5kID0gd3JhcHBlcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgbGVnZW5kLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iZWpjdH0gc2l6ZSBTXG4gICAqL1xuICB1cGRhdGVTaXplRm9yTGVnZW5kOiBmdW5jdGlvbiB1cGRhdGVTaXplRm9yTGVnZW5kKHNpemUpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIHdpZHRoID0gc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQsXG4gICAgICAgIGluc2V0TGVnZW5kUG9zaXRpb24gPSB7XG4gICAgICB0b3A6ICQkLmlzTGVnZW5kVG9wID8gJCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSArIGNvbmZpZy5sZWdlbmRfaW5zZXRfeSArIDUuNSA6ICQkLmN1cnJlbnRIZWlnaHQgLSBoZWlnaHQgLSAkJC5nZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpIC0gY29uZmlnLmxlZ2VuZF9pbnNldF95LFxuICAgICAgbGVmdDogJCQuaXNMZWdlbmRMZWZ0ID8gJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCkgKyBjb25maWcubGVnZW5kX2luc2V0X3ggKyAuNSA6ICQkLmN1cnJlbnRXaWR0aCAtIHdpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpIC0gY29uZmlnLmxlZ2VuZF9pbnNldF94ICsgLjVcbiAgICB9O1xuICAgICQkLm1hcmdpbjMgPSB7XG4gICAgICB0b3A6ICQkLmlzTGVnZW5kUmlnaHQgPyAwIDogJCQuaXNMZWdlbmRJbnNldCA/IGluc2V0TGVnZW5kUG9zaXRpb24udG9wIDogJCQuY3VycmVudEhlaWdodCAtIGhlaWdodCxcbiAgICAgIHJpZ2h0OiBOYU4sXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAkJC5pc0xlZ2VuZFJpZ2h0ID8gJCQuY3VycmVudFdpZHRoIC0gd2lkdGggOiAkJC5pc0xlZ2VuZEluc2V0ID8gaW5zZXRMZWdlbmRQb3NpdGlvbi5sZWZ0IDogMFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBMZWdlbmRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uLlxuICAgKi9cbiAgdHJhbnNmb3JtTGVnZW5kOiBmdW5jdGlvbiB0cmFuc2Zvcm1MZWdlbmQod2l0aFRyYW5zaXRpb24pIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgICh3aXRoVHJhbnNpdGlvbiA/ICQkLmxlZ2VuZC50cmFuc2l0aW9uKCkgOiAkJC5sZWdlbmQpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwibGVnZW5kXCIpKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBsZWdlbmQgc3RlcFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgKi9cbiAgdXBkYXRlTGVnZW5kU3RlcDogZnVuY3Rpb24gdXBkYXRlTGVnZW5kU3RlcChzdGVwKSB7XG4gICAgdGhpcy5sZWdlbmRTdGVwID0gc3RlcDtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGxlZ2VuZCBpdGVtIHdpZHRoXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKi9cbiAgdXBkYXRlTGVnZW5kSXRlbVdpZHRoOiBmdW5jdGlvbiB1cGRhdGVMZWdlbmRJdGVtV2lkdGgodykge1xuICAgIHRoaXMubGVnZW5kSXRlbVdpZHRoID0gdztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGxlZ2VuZCBpdGVtIGhlaWdodFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAqL1xuICB1cGRhdGVMZWdlbmRJdGVtSGVpZ2h0OiBmdW5jdGlvbiB1cGRhdGVMZWdlbmRJdGVtSGVpZ2h0KGgpIHtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1IZWlnaHQgPSBoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgbGVnZW5kIGl0ZW0gY29sb3JcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIENvcnJlc3BvbmRpbmcgZGF0YSBJRCB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWVcbiAgICovXG4gIHVwZGF0ZUxlZ2VuZEl0ZW1Db2xvcjogZnVuY3Rpb24gdXBkYXRlTGVnZW5kSXRlbUNvbG9yKGlkLCBjb2xvcikge1xuICAgIHRoaXMubGVnZW5kLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMubGVnZW5kSXRlbSwgXCItXCIpLmNvbmNhdChpZCwgXCIgbGluZVwiKSkuc3R5bGUoXCJzdHJva2VcIiwgY29sb3IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmRcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfSB3aWR0aFxuICAgKi9cbiAgZ2V0TGVnZW5kV2lkdGg6IGZ1bmN0aW9uIGdldExlZ2VuZFdpZHRoKCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgcmV0dXJuICQkLmNvbmZpZy5sZWdlbmRfc2hvdyA/ICQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/ICQkLmxlZ2VuZEl0ZW1XaWR0aCAqICgkJC5sZWdlbmRTdGVwICsgMSkgOiAkJC5jdXJyZW50V2lkdGggOiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhlaWdodCBvZiB0aGUgbGVnZW5kXG4gICAqIEByZXR1cm4ge051bWJlcn0gaGVpZ2h0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRMZWdlbmRIZWlnaHQ6IGZ1bmN0aW9uIGdldExlZ2VuZEhlaWdodCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgIHJldHVybiAkJC5jb25maWcubGVnZW5kX3Nob3cgPyAkJC5pc0xlZ2VuZFJpZ2h0ID8gJCQuY3VycmVudEhlaWdodCA6IE1hdGgubWF4KDIwLCAkJC5sZWdlbmRJdGVtSGVpZ2h0KSAqICgkJC5sZWdlbmRTdGVwICsgMSkgOiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxlZ2VuZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZDMuU2VsZWN0XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IG9wYWNpdHlcbiAgICovXG4gIG9wYWNpdHlGb3JMZWdlbmQ6IGZ1bmN0aW9uIG9wYWNpdHlGb3JMZWdlbmQobGVnZW5kSXRlbSkge1xuICAgIHJldHVybiBsZWdlbmRJdGVtLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMubGVnZW5kSXRlbUhpZGRlbikgPyBudWxsIDogXCIxXCI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3BhY2l0eSBvZiB0aGUgbGVnZW5kIHRoYXQgaXMgdW5mb2N1c2VkXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWdlbmRJdGVtLCBkMy5TZWxlY3RcbiAgICogQHJldHVybnMge051bWJlcn0gb3BhY2l0eVxuICAgKi9cbiAgb3BhY2l0eUZvclVuZm9jdXNlZExlZ2VuZDogZnVuY3Rpb24gb3BhY2l0eUZvclVuZm9jdXNlZExlZ2VuZChsZWdlbmRJdGVtKSB7XG4gICAgcmV0dXJuIGxlZ2VuZEl0ZW0uY2xhc3NlZChjb25maWdfY2xhc3Nlcy5sZWdlbmRJdGVtSGlkZGVuKSA/IG51bGwgOiBcIjAuM1wiO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBmb2N1cyBvZiB0aGUgbGVnZW5kXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IElEJ3Mgb2YgdGFyZ2V0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gZm9jdXMuXG4gICAqL1xuICB0b2dnbGVGb2N1c0xlZ2VuZDogZnVuY3Rpb24gdG9nZ2xlRm9jdXNMZWdlbmQodGFyZ2V0SWRzLCBmb2N1cykge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHRhcmdldElkeiA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XG4gICAgJCQubGVnZW5kLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMubGVnZW5kSXRlbSkpLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiB0YXJnZXRJZHouaW5kZXhPZihpZCkgPj0gMDtcbiAgICB9KS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmb2N1cykudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMCkuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoZm9jdXMgPyAkJC5vcGFjaXR5Rm9yTGVnZW5kIDogJCQub3BhY2l0eUZvclVuZm9jdXNlZExlZ2VuZCkuY2FsbCgkJCwgT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMpKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV2ZXJ0IHRoZSBsZWdlbmQgdG8gaXRzIGRlZmF1bHQgc3RhdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJldmVydExlZ2VuZDogZnVuY3Rpb24gcmV2ZXJ0TGVnZW5kKCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgJCQubGVnZW5kLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMubGVnZW5kSXRlbSkpLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMubGVnZW5kSXRlbUZvY3VzZWQsICExKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTAwKS5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICQkLm9wYWNpdHlGb3JMZWdlbmQoT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMpKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU2hvd3MgdGhlIGxlZ2VuZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxuICAgKi9cbiAgc2hvd0xlZ2VuZDogZnVuY3Rpb24gc2hvd0xlZ2VuZCh0YXJnZXRJZHMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgY29uZmlnLmxlZ2VuZF9zaG93IHx8IChjb25maWcubGVnZW5kX3Nob3cgPSAhMCwgJCQubGVnZW5kLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIiksICEkJC5sZWdlbmRIYXNSZW5kZXJlZCAmJiAkJC51cGRhdGVMZWdlbmQoKSksICQkLnJlbW92ZUhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpLCAkJC5sZWdlbmQuc2VsZWN0QWxsKCQkLnNlbGVjdG9yTGVnZW5kcyh0YXJnZXRJZHMpKS5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpLnRyYW5zaXRpb24oKS5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICQkLm9wYWNpdHlGb3JMZWdlbmQoT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMpKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogSGlkZSB0aGUgbGVnZW5kXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IElEJ3Mgb2YgdGFyZ2V0XG4gICAqL1xuICBoaWRlTGVnZW5kOiBmdW5jdGlvbiBoaWRlTGVnZW5kKHRhcmdldElkcykge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICBjb25maWcubGVnZW5kX3Nob3cgJiYgaXNFbXB0eSh0YXJnZXRJZHMpICYmIChjb25maWcubGVnZW5kX3Nob3cgPSAhMSwgJCQubGVnZW5kLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKSksICQkLmFkZEhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpLCAkJC5sZWdlbmQuc2VsZWN0QWxsKCQkLnNlbGVjdG9yTGVnZW5kcyh0YXJnZXRJZHMpKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgdGhlIExlZ2VuZEl0ZW1UZXh0Qm94IGNhY2hlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xlYXJMZWdlbmRJdGVtVGV4dEJveENhY2hlOiBmdW5jdGlvbiBjbGVhckxlZ2VuZEl0ZW1UZXh0Qm94Q2FjaGUoKSB7XG4gICAgdGhpcy5sZWdlbmRJdGVtVGV4dEJveCA9IHt9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgbGVnZW5kIGl0ZW0gc3R5bGUgJiBiaW5kIGV2ZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gaXRlbVxuICAgKi9cbiAgc2V0TGVnZW5kSXRlbTogZnVuY3Rpb24gc2V0TGVnZW5kSXRlbShpdGVtKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBpc1RvdWNoID0gJCQuaW5wdXRUeXBlID09PSBcInRvdWNoXCIsXG4gICAgICAgIGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xuICAgIGl0ZW0uYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgdmFyIG5vZGUgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhpcyksXG4gICAgICAgICAgaXRlbUNsYXNzID0gIW5vZGUuZW1wdHkoKSAmJiBub2RlLmF0dHIoXCJjbGFzc1wiKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGl0ZW1DbGFzcyArICQkLmdlbmVyYXRlQ2xhc3MoY29uZmlnX2NsYXNzZXMubGVnZW5kSXRlbSwgaWQpO1xuICAgIH0pLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiAkJC5pc0xlZ2VuZFRvU2hvdyhpZCkgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCI7XG4gICAgfSkuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICBjYWxsRm4oY29uZmlnLmxlZ2VuZF9pdGVtX29uY2xpY2ssICQkLCBpZCkgfHwgKGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJldmVudFwiXS5hbHRLZXkgPyAoJCQuYXBpLmhpZGUoKSwgJCQuYXBpLnNob3coaWQpKSA6ICgkJC5hcGkudG9nZ2xlKGlkKSwgIWlzVG91Y2ggJiYgJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gJCQuYXBpLmZvY3VzKGlkKSA6ICQkLmFwaS5yZXZlcnQoKSkpLCBpc1RvdWNoICYmICQkLmhpZGVUb29sdGlwKCk7XG4gICAgfSksIGlzVG91Y2ggfHwgaXRlbS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgY2FsbEZuKGNvbmZpZy5sZWdlbmRfaXRlbV9vbm91dCwgJCQsIGlkKSB8fCAoT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMpLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMubGVnZW5kSXRlbUZvY3VzZWQsICExKSwgaGFzR2F1Z2UgJiYgJCQudW5kb01hcmtPdmVybGFwcGVkKCQkLCBcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuZ2F1Z2VWYWx1ZSkpLCAkJC5hcGkucmV2ZXJ0KCkpO1xuICAgIH0pLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgY2FsbEZuKGNvbmZpZy5sZWdlbmRfaXRlbV9vbm92ZXIsICQkLCBpZCkgfHwgKE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0XCJdKSh0aGlzKS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmxlZ2VuZEl0ZW1Gb2N1c2VkLCAhMCksIGhhc0dhdWdlICYmICQkLm1hcmtPdmVybGFwcGVkKGlkLCAkJCwgXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmdhdWdlVmFsdWUpKSwgISQkLnRyYW5zaXRpbmcgJiYgJCQuaXNUYXJnZXRUb1Nob3coaWQpICYmICQkLmFwaS5mb2N1cyhpZCkpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGxlZ2VuZFxuICAgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJZHMgSUQncyBvZiB0YXJnZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgd2l0aFRyYW5zZm9ybSA6IFdoZXRoZXIgdG8gdXNlIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgLyB3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogV2hldGhlciB0cmFuc2l0aW9uIGlzIHVzZWQgd2hlbiB1c2luZyB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb24gOiB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uLlxuICBcdCAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVMZWdlbmRFbGVtZW50OiBmdW5jdGlvbiB1cGRhdGVMZWdlbmRFbGVtZW50KHRhcmdldElkcywgb3B0aW9ucykge1xuICAgIHZhciB4Rm9yTGVnZW5kLFxuICAgICAgICB5Rm9yTGVnZW5kLFxuICAgICAgICBiYWNrZ3JvdW5kLFxuICAgICAgICAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgcG9zTWluID0gMTAsXG4gICAgICAgIHRpbGVXaWR0aCA9IGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoICsgNSxcbiAgICAgICAgbWF4V2lkdGggPSAwLFxuICAgICAgICBtYXhIZWlnaHQgPSAwLFxuICAgICAgICB0b3RhbExlbmd0aCA9IDAsXG4gICAgICAgIG9mZnNldHMgPSB7fSxcbiAgICAgICAgd2lkdGhzID0ge30sXG4gICAgICAgIGhlaWdodHMgPSB7fSxcbiAgICAgICAgbWFyZ2lucyA9IFswXSxcbiAgICAgICAgc3RlcHMgPSB7fSxcbiAgICAgICAgc3RlcCA9IDAsXG4gICAgICAgIGlzTGVnZW5kUmlnaHRPckluc2V0ID0gJCQuaXNMZWdlbmRSaWdodCB8fCAkJC5pc0xlZ2VuZEluc2V0LFxuICAgICAgICB0YXJnZXRJZHogPSB0YXJnZXRJZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuICFpc0RlZmluZWQoY29uZmlnLmRhdGFfbmFtZXNbaWRdKSB8fCBjb25maWcuZGF0YV9uYW1lc1tpZF0gIT09IG51bGw7XG4gICAgfSksXG4gICAgICAgIHdpdGhUcmFuc2l0aW9uID0gb3B0aW9ucy53aXRoVHJhbnNpdGlvbixcbiAgICAgICAgZ2V0VGV4dEJveCA9IGZ1bmN0aW9uICh0ZXh0RWxlbWVudCwgaWQpIHtcbiAgICAgIHJldHVybiAkJC5sZWdlbmRJdGVtVGV4dEJveFtpZF0gfHwgKCQkLmxlZ2VuZEl0ZW1UZXh0Qm94W2lkXSA9ICQkLmdldFRleHRSZWN0KHRleHRFbGVtZW50LCBjb25maWdfY2xhc3Nlcy5sZWdlbmRJdGVtKSksICQkLmxlZ2VuZEl0ZW1UZXh0Qm94W2lkXTtcbiAgICB9LFxuICAgICAgICB1cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbiAodGV4dEVsZW1lbnQsIGlkLCBpbmRleCkge1xuICAgICAgdmFyIG1hcmdpbixcbiAgICAgICAgICBpc0xhc3QgPSBpbmRleCA9PT0gdGFyZ2V0SWR6Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgYm94ID0gZ2V0VGV4dEJveCh0ZXh0RWxlbWVudCwgaWQpLFxuICAgICAgICAgIGl0ZW1XaWR0aCA9IGJveC53aWR0aCArIHRpbGVXaWR0aCArIChpc0xhc3QgJiYgIWlzTGVnZW5kUmlnaHRPckluc2V0ID8gMCA6IDEwKSArIGNvbmZpZy5sZWdlbmRfcGFkZGluZyxcbiAgICAgICAgICBpdGVtSGVpZ2h0ID0gYm94LmhlaWdodCArIDQsXG4gICAgICAgICAgaXRlbUxlbmd0aCA9IGlzTGVnZW5kUmlnaHRPckluc2V0ID8gaXRlbUhlaWdodCA6IGl0ZW1XaWR0aCxcbiAgICAgICAgICBhcmVhTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAkJC5nZXRMZWdlbmRIZWlnaHQoKSA6ICQkLmdldExlZ2VuZFdpZHRoKCksXG4gICAgICAgICAgdXBkYXRlVmFsdWVzID0gZnVuY3Rpb24gKGlkMiwgd2l0aG91dFN0ZXApIHtcbiAgICAgICAgd2l0aG91dFN0ZXAgfHwgKG1hcmdpbiA9IChhcmVhTGVuZ3RoIC0gdG90YWxMZW5ndGggLSBpdGVtTGVuZ3RoKSAvIDIsIG1hcmdpbiA8IHBvc01pbiAmJiAobWFyZ2luID0gKGFyZWFMZW5ndGggLSBpdGVtTGVuZ3RoKSAvIDIsIHRvdGFsTGVuZ3RoID0gMCwgc3RlcCsrKSksIHN0ZXBzW2lkMl0gPSBzdGVwLCBtYXJnaW5zW3N0ZXBdID0gJCQuaXNMZWdlbmRJbnNldCA/IDEwIDogbWFyZ2luLCBvZmZzZXRzW2lkMl0gPSB0b3RhbExlbmd0aCwgdG90YWxMZW5ndGggKz0gaXRlbUxlbmd0aDtcbiAgICAgIH07XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCAmJiAodG90YWxMZW5ndGggPSAwLCBzdGVwID0gMCwgbWF4V2lkdGggPSAwLCBtYXhIZWlnaHQgPSAwKSwgY29uZmlnLmxlZ2VuZF9zaG93ICYmICEkJC5pc0xlZ2VuZFRvU2hvdyhpZCkpIHJldHVybiB3aWR0aHNbaWRdID0gMCwgaGVpZ2h0c1tpZF0gPSAwLCBzdGVwc1tpZF0gPSAwLCB2b2lkIChvZmZzZXRzW2lkXSA9IDApO1xuICAgICAgd2lkdGhzW2lkXSA9IGl0ZW1XaWR0aCwgaGVpZ2h0c1tpZF0gPSBpdGVtSGVpZ2h0LCAoIW1heFdpZHRoIHx8IGl0ZW1XaWR0aCA+PSBtYXhXaWR0aCkgJiYgKG1heFdpZHRoID0gaXRlbVdpZHRoKSwgKCFtYXhIZWlnaHQgfHwgaXRlbUhlaWdodCA+PSBtYXhIZWlnaHQpICYmIChtYXhIZWlnaHQgPSBpdGVtSGVpZ2h0KTtcbiAgICAgIHZhciBtYXhMZW5ndGggPSBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IG1heEhlaWdodCA6IG1heFdpZHRoO1xuICAgICAgY29uZmlnLmxlZ2VuZF9lcXVhbGx5ID8gKE9iamVjdC5rZXlzKHdpZHRocykuZm9yRWFjaChmdW5jdGlvbiAoaWQyKSB7XG4gICAgICAgIHJldHVybiB3aWR0aHNbaWQyXSA9IG1heFdpZHRoO1xuICAgICAgfSksIE9iamVjdC5rZXlzKGhlaWdodHMpLmZvckVhY2goZnVuY3Rpb24gKGlkMikge1xuICAgICAgICByZXR1cm4gaGVpZ2h0c1tpZDJdID0gbWF4SGVpZ2h0O1xuICAgICAgfSksIG1hcmdpbiA9IChhcmVhTGVuZ3RoIC0gbWF4TGVuZ3RoICogdGFyZ2V0SWR6Lmxlbmd0aCkgLyAyLCBtYXJnaW4gPCBwb3NNaW4gPyAodG90YWxMZW5ndGggPSAwLCBzdGVwID0gMCwgdGFyZ2V0SWR6LmZvckVhY2goZnVuY3Rpb24gKGlkMikge1xuICAgICAgICByZXR1cm4gdXBkYXRlVmFsdWVzKGlkMik7XG4gICAgICB9KSkgOiB1cGRhdGVWYWx1ZXMoaWQsICEwKSkgOiB1cGRhdGVWYWx1ZXMoaWQpO1xuICAgIH07XG5cbiAgICAkJC5pc0xlZ2VuZEluc2V0ICYmIChzdGVwID0gY29uZmlnLmxlZ2VuZF9pbnNldF9zdGVwID8gY29uZmlnLmxlZ2VuZF9pbnNldF9zdGVwIDogdGFyZ2V0SWR6Lmxlbmd0aCwgJCQudXBkYXRlTGVnZW5kU3RlcChzdGVwKSksICQkLmlzTGVnZW5kUmlnaHQgPyAoeEZvckxlZ2VuZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIG1heFdpZHRoICogc3RlcHNbaWRdO1xuICAgIH0sIHlGb3JMZWdlbmQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBtYXJnaW5zW3N0ZXBzW2lkXV0gKyBvZmZzZXRzW2lkXTtcbiAgICB9KSA6ICQkLmlzTGVnZW5kSW5zZXQgPyAoeEZvckxlZ2VuZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIG1heFdpZHRoICogc3RlcHNbaWRdICsgMTA7XG4gICAgfSwgeUZvckxlZ2VuZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xuICAgIH0pIDogKHhGb3JMZWdlbmQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBtYXJnaW5zW3N0ZXBzW2lkXV0gKyBvZmZzZXRzW2lkXTtcbiAgICB9LCB5Rm9yTGVnZW5kID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gbWF4SGVpZ2h0ICogc3RlcHNbaWRdO1xuICAgIH0pO1xuXG4gICAgdmFyIHhGb3JMZWdlbmRUZXh0ID0gZnVuY3Rpb24gKGlkLCBpKSB7XG4gICAgICByZXR1cm4geEZvckxlZ2VuZChpZCwgaSkgKyA0ICsgY29uZmlnLmxlZ2VuZF9pdGVtX3RpbGVfd2lkdGg7XG4gICAgfSxcbiAgICAgICAgeEZvckxlZ2VuZFJlY3QgPSBmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHJldHVybiB4Rm9yTGVnZW5kKGlkLCBpKTtcbiAgICB9LFxuICAgICAgICB4MUZvckxlZ2VuZFRpbGUgPSBmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHJldHVybiB4Rm9yTGVnZW5kKGlkLCBpKSAtIDI7XG4gICAgfSxcbiAgICAgICAgeDJGb3JMZWdlbmRUaWxlID0gZnVuY3Rpb24gKGlkLCBpKSB7XG4gICAgICByZXR1cm4geEZvckxlZ2VuZChpZCwgaSkgLSAyICsgY29uZmlnLmxlZ2VuZF9pdGVtX3RpbGVfd2lkdGg7XG4gICAgfSxcbiAgICAgICAgeUZvckxlZ2VuZFRleHQgPSBmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHJldHVybiB5Rm9yTGVnZW5kKGlkLCBpKSArIDk7XG4gICAgfSxcbiAgICAgICAgeUZvckxlZ2VuZFJlY3QgPSBmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHJldHVybiB5Rm9yTGVnZW5kKGlkLCBpKSAtIDU7XG4gICAgfSxcbiAgICAgICAgeUZvckxlZ2VuZFRpbGUgPSBmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHJldHVybiB5Rm9yTGVnZW5kKGlkLCBpKSArIDQ7XG4gICAgfSxcbiAgICAgICAgcG9zID0gLTIwMCxcbiAgICAgICAgbCA9ICQkLmxlZ2VuZC5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmxlZ2VuZEl0ZW0pKS5kYXRhKHRhcmdldElkeikuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xuXG4gICAgJCQuc2V0TGVnZW5kSXRlbShsKSwgbC5hcHBlbmQoXCJ0ZXh0XCIpLnRleHQoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZDtcbiAgICB9KS5lYWNoKGZ1bmN0aW9uIChpZCwgaSkge1xuICAgICAgdXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcbiAgICB9KS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKS5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRUZXh0IDogcG9zKS5hdHRyKFwieVwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUZXh0KSwgbC5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCBjb25maWdfY2xhc3Nlcy5sZWdlbmRJdGVtRXZlbnQpLnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKS5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRSZWN0IDogcG9zKS5hdHRyKFwieVwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRSZWN0KTtcbiAgICB2YXIgdXNlUG9pbnQgPSAkJC5jb25maWcubGVnZW5kX3VzZVBvaW50O1xuXG4gICAgaWYgKHVzZVBvaW50KSB7XG4gICAgICB2YXIgaWRzID0gW107XG4gICAgICBsLmFwcGVuZChmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IG5vdEVtcHR5KGNvbmZpZy5wb2ludF9wYXR0ZXJuKSA/IGNvbmZpZy5wb2ludF9wYXR0ZXJuIDogW2NvbmZpZy5wb2ludF90eXBlXTtcbiAgICAgICAgaWRzLmluZGV4T2YoZCkgPT09IC0xICYmIGlkcy5wdXNoKGQpO1xuICAgICAgICB2YXIgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGQpICUgcGF0dGVybi5sZW5ndGhdO1xuICAgICAgICByZXR1cm4gcG9pbnQgPT09IFwicmVjdGFuZ2xlXCIgJiYgKHBvaW50ID0gXCJyZWN0XCIpLCBicm93c2VyX2RvYy5jcmVhdGVFbGVtZW50TlMoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcIm5hbWVzcGFjZXNcIl0uc3ZnLCAkJC5oYXNWYWxpZFBvaW50VHlwZShwb2ludCkgPyBwb2ludCA6IFwidXNlXCIpO1xuICAgICAgfSkuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLmxlZ2VuZEl0ZW1Qb2ludCkuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAkJC5jb2xvcihkKTtcbiAgICAgIH0pLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpLmF0dHIoXCJocmVmXCIsIGZ1bmN0aW9uIChkYXRhLCBpZHgsIHNlbGVjdGlvbikge1xuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdGlvbltpZHhdLFxuICAgICAgICAgICAgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBub2RlTmFtZSA9PT0gXCJ1c2VcIiA/IFwiI1wiLmNvbmNhdCgkJC5kYXRldGltZUlkLCBcIi1wb2ludC1cIikuY29uY2F0KGRhdGEpIDogdW5kZWZpbmVkO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGwuYXBwZW5kKFwibGluZVwiKS5hdHRyKFwiY2xhc3NcIiwgY29uZmlnX2NsYXNzZXMubGVnZW5kSXRlbVRpbGUpLnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKS5hdHRyKFwieDFcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MUZvckxlZ2VuZFRpbGUgOiBwb3MpLmF0dHIoXCJ5MVwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKS5hdHRyKFwieDJcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MkZvckxlZ2VuZFRpbGUgOiBwb3MpLmF0dHIoXCJ5MlwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKS5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX2hlaWdodCk7IC8vIFNldCBiYWNrZ3JvdW5kIGZvciBpbnNldCBsZWdlbmRcblxuXG4gICAgYmFja2dyb3VuZCA9ICQkLmxlZ2VuZC5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmxlZ2VuZEJhY2tncm91bmQsIFwiIHJlY3RcIikpLCAkJC5pc0xlZ2VuZEluc2V0ICYmIG1heFdpZHRoID4gMCAmJiBiYWNrZ3JvdW5kLnNpemUoKSA9PT0gMCAmJiAoYmFja2dyb3VuZCA9ICQkLmxlZ2VuZC5pbnNlcnQoXCJnXCIsIFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5sZWdlbmRJdGVtKSkuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLmxlZ2VuZEJhY2tncm91bmQpLmFwcGVuZChcInJlY3RcIikpO1xuICAgIHZhciB0ZXh0cyA9ICQkLmxlZ2VuZC5zZWxlY3RBbGwoXCJ0ZXh0XCIpLmRhdGEodGFyZ2V0SWR6KS50ZXh0KGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIGlzRGVmaW5lZChjb25maWcuZGF0YV9uYW1lc1tpZF0pID8gY29uZmlnLmRhdGFfbmFtZXNbaWRdIDogaWQ7XG4gICAgfSkgLy8gTUVNTzogbmVlZGVkIGZvciB1cGRhdGVcbiAgICAuZWFjaChmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHVwZGF0ZVBvc2l0aW9ucyh0aGlzLCBpZCwgaSk7XG4gICAgfSk7XG4gICAgKHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpLmF0dHIoXCJ4XCIsIHhGb3JMZWdlbmRUZXh0KS5hdHRyKFwieVwiLCB5Rm9yTGVnZW5kVGV4dCk7XG4gICAgdmFyIHJlY3RzID0gJCQubGVnZW5kLnNlbGVjdEFsbChcInJlY3QuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmxlZ2VuZEl0ZW1FdmVudCkpLmRhdGEodGFyZ2V0SWR6KTtcblxuICAgIGlmICgod2l0aFRyYW5zaXRpb24gPyByZWN0cy50cmFuc2l0aW9uKCkgOiByZWN0cykuYXR0cihcIndpZHRoXCIsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHdpZHRoc1tpZF07XG4gICAgfSkuYXR0cihcImhlaWdodFwiLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBoZWlnaHRzW2lkXTtcbiAgICB9KS5hdHRyKFwieFwiLCB4Rm9yTGVnZW5kUmVjdCkuYXR0cihcInlcIiwgeUZvckxlZ2VuZFJlY3QpLCB1c2VQb2ludCkge1xuICAgICAgdmFyIHRpbGVzID0gJCQubGVnZW5kLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMubGVnZW5kSXRlbVBvaW50KSkuZGF0YSh0YXJnZXRJZHopO1xuICAgICAgKHdpdGhUcmFuc2l0aW9uID8gdGlsZXMudHJhbnNpdGlvbigpIDogdGlsZXMpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmFkaXVzLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHBvaW50UiA9ICQkLmNvbmZpZy5wb2ludF9yLFxuICAgICAgICAgICAgeCA9IFwieFwiLFxuICAgICAgICAgICAgeSA9IFwieVwiLFxuICAgICAgICAgICAgeE9mZnNldCA9IDIsXG4gICAgICAgICAgICB5T2Zmc2V0ID0gMi41O1xuXG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gXCJjaXJjbGVcIikge1xuICAgICAgICAgIHZhciBzaXplID0gcG9pbnRSICogLjI7XG4gICAgICAgICAgeCA9IFwiY3hcIiwgeSA9IFwiY3lcIiwgcmFkaXVzID0gcG9pbnRSICsgc2l6ZSwgeE9mZnNldCA9IHBvaW50UiAqIDIsIHlPZmZzZXQgPSAtc2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJyZWN0XCIpIHtcbiAgICAgICAgICB2YXIgX3NpemUgPSBwb2ludFIgKiAyLjU7XG5cbiAgICAgICAgICB3aWR0aCA9IF9zaXplLCBoZWlnaHQgPSBfc2l6ZSwgeU9mZnNldCA9IDM7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhpcykuYXR0cih4LCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiB4MUZvckxlZ2VuZFRpbGUoZCkgKyB4T2Zmc2V0O1xuICAgICAgICB9KS5hdHRyKHksIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIHlGb3JMZWdlbmRUaWxlKGQpIC0geU9mZnNldDtcbiAgICAgICAgfSkuYXR0cihcInJcIiwgcmFkaXVzKS5hdHRyKFwid2lkdGhcIiwgd2lkdGgpLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3RpbGVzID0gJCQubGVnZW5kLnNlbGVjdEFsbChcImxpbmUuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmxlZ2VuZEl0ZW1UaWxlKSkuZGF0YSh0YXJnZXRJZHopO1xuXG4gICAgICAod2l0aFRyYW5zaXRpb24gPyBfdGlsZXMudHJhbnNpdGlvbigpIDogX3RpbGVzKS5zdHlsZShcInN0cm9rZVwiLCAkJC5sZXZlbENvbG9yID8gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiAkJC5sZXZlbENvbG9yKCQkLmNhY2hlW2lkXS52YWx1ZXNbMF0udmFsdWUpO1xuICAgICAgfSA6ICQkLmNvbG9yKS5hdHRyKFwieDFcIiwgeDFGb3JMZWdlbmRUaWxlKS5hdHRyKFwieTFcIiwgeUZvckxlZ2VuZFRpbGUpLmF0dHIoXCJ4MlwiLCB4MkZvckxlZ2VuZFRpbGUpLmF0dHIoXCJ5MlwiLCB5Rm9yTGVnZW5kVGlsZSk7XG4gICAgfVxuXG4gICAgYmFja2dyb3VuZCAmJiAod2l0aFRyYW5zaXRpb24gPyBiYWNrZ3JvdW5kLnRyYW5zaXRpb24oKSA6IGJhY2tncm91bmQpLmF0dHIoXCJoZWlnaHRcIiwgJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgLSAxMikuYXR0cihcIndpZHRoXCIsIG1heFdpZHRoICogKHN0ZXAgKyAxKSArIDEwKSwgJCQudXBkYXRlTGVnZW5kSXRlbVdpZHRoKG1heFdpZHRoKSwgJCQudXBkYXRlTGVnZW5kSXRlbUhlaWdodChtYXhIZWlnaHQpLCAkJC51cGRhdGVMZWdlbmRTdGVwKHN0ZXApO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ludGVybmFscy90aXRsZS5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuLyoqXG4gKiBHZXQgdGhlIHRleHQgcG9zaXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBwb3MgcmlnaHQsIGxlZnQgb3IgY2VudGVyXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggY2hhcnQgd2lkdGhcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9IHRleHQtYW5jaG9yIHZhbHVlIG9yIHBvc2l0aW9uIGluIHBpeGVsXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBnZXRUZXh0UG9zID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcG9zaXRpb24sXG4gICAgICBwb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwibGVmdFwiLFxuICAgICAgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCxcbiAgICAgIGlzTnVtID0gaXNOdW1iZXIod2lkdGgpO1xuICByZXR1cm4gcG9zaXRpb24gPSBwb3MuaW5kZXhPZihcImNlbnRlclwiKSA+IC0xID8gaXNOdW0gPyB3aWR0aCAvIDIgOiBcIm1pZGRsZVwiIDogcG9zLmluZGV4T2YoXCJyaWdodFwiKSA+IC0xID8gaXNOdW0gPyB3aWR0aCA6IFwiZW5kXCIgOiBpc051bSA/IDAgOiBcInN0YXJ0XCIsIHBvc2l0aW9uO1xufTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWxfQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSB0aXRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdFRpdGxlOiBmdW5jdGlvbiBpbml0VGl0bGUoKSB7XG4gICAgdmFyICQkID0gdGhpcztcblxuICAgIGlmICgkJC5jb25maWcudGl0bGVfdGV4dCkge1xuICAgICAgJCQudGl0bGUgPSAkJC5zdmcuYXBwZW5kKFwiZ1wiKTtcbiAgICAgIHZhciB0ZXh0ID0gJCQudGl0bGUuYXBwZW5kKFwidGV4dFwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIGdldFRleHRQb3MoJCQuY29uZmlnLnRpdGxlX3Bvc2l0aW9uKSkuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLnRpdGxlKTtcbiAgICAgIHNldFRleHRWYWx1ZSh0ZXh0LCAkJC5jb25maWcudGl0bGVfdGV4dCwgWy4zLCAxLjVdKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZHJhdyB0aXRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVkcmF3VGl0bGU6IGZ1bmN0aW9uIHJlZHJhd1RpdGxlKCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG5cbiAgICBpZiAoJCQudGl0bGUpIHtcbiAgICAgIHZhciB5ID0gJCQueUZvclRpdGxlLmNhbGwoJCQpO1xuICAgICAgL2cvaS50ZXN0KCQkLnRpdGxlLm5vZGUoKS50YWdOYW1lKSA/ICQkLnRpdGxlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGdldFRleHRQb3MoJCQuY29uZmlnLnRpdGxlX3Bvc2l0aW9uLCAkJC5jdXJyZW50V2lkdGgpLCBcIiwgXCIpLmNvbmNhdCh5LCBcIilcIikpIDogJCQudGl0bGUuYXR0cihcInhcIiwgJCQueEZvclRpdGxlLmNhbGwoJCQpKS5hdHRyKFwieVwiLCB5KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHggYXR0cmlidXRlIHZhbHVlIG9mIHRoZSB0aXRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB4IGF0dHJpYnV0ZSB2YWx1ZVxuICAgKi9cbiAgeEZvclRpdGxlOiBmdW5jdGlvbiB4Rm9yVGl0bGUoKSB7XG4gICAgdmFyIHgsXG4gICAgICAgICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBwb3NpdGlvbiA9IGNvbmZpZy50aXRsZV9wb3NpdGlvbiB8fCBcImxlZnRcIixcbiAgICAgICAgdGV4dFJlY3RXaWR0aCA9ICQkLmdldFRleHRSZWN0KCQkLnRpdGxlLCBjb25maWdfY2xhc3Nlcy50aXRsZSkud2lkdGg7XG4gICAgcmV0dXJuIC8ocmlnaHR8Y2VudGVyKS8udGVzdChwb3NpdGlvbikgPyAoeCA9ICQkLmN1cnJlbnRXaWR0aCAtIHRleHRSZWN0V2lkdGgsIHBvc2l0aW9uLmluZGV4T2YoXCJyaWdodFwiKSA+PSAwID8geCA9ICQkLmN1cnJlbnRXaWR0aCAtIHRleHRSZWN0V2lkdGggLSBjb25maWcudGl0bGVfcGFkZGluZy5yaWdodCA6IHBvc2l0aW9uLmluZGV4T2YoXCJjZW50ZXJcIikgPj0gMCAmJiAoeCA9ICgkJC5jdXJyZW50V2lkdGggLSB0ZXh0UmVjdFdpZHRoKSAvIDIpKSA6IHggPSBjb25maWcudGl0bGVfcGFkZGluZy5sZWZ0IHx8IDAsIHg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHkgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSB0aXRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB5IGF0dHJpYnV0ZSB2YWx1ZVxuICAgKi9cbiAgeUZvclRpdGxlOiBmdW5jdGlvbiB5Rm9yVGl0bGUoKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICByZXR1cm4gKCQkLmNvbmZpZy50aXRsZV9wYWRkaW5nLnRvcCB8fCAwKSArICQkLmdldFRleHRSZWN0KCQkLnRpdGxlLCBjb25maWdfY2xhc3Nlcy50aXRsZSkuaGVpZ2h0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGl0bGUgcGFkZGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBwYWRkaW5nIHZhbHVlXG4gICAqL1xuICBnZXRUaXRsZVBhZGRpbmc6IGZ1bmN0aW9uIGdldFRpdGxlUGFkZGluZygpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgIHJldHVybiAkJC55Rm9yVGl0bGUoKSArICgkJC5jb25maWcudGl0bGVfcGFkZGluZy5ib3R0b20gfHwgMCk7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaW50ZXJuYWxzL2NsaXAuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIGluaXRDbGlwOiBmdW5jdGlvbiBpbml0Q2xpcCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzOyAvLyBNRU1POiBjbGlwSWQgbmVlZHMgdG8gYmUgdW5pcXVlIGJlY2F1c2UgaXQgY29uZmxpY3RzIHdoZW4gbXVsdGlwbGUgY2hhcnRzIGV4aXN0XG5cbiAgICAvLyBEZWZpbmUgJ2NsaXAtcGF0aCcgYXR0cmlidXRlIHZhbHVlc1xuICAgICQkLmNsaXBJZCA9IFwiXCIuY29uY2F0KCQkLmRhdGV0aW1lSWQsIFwiLWNsaXBcIiksICQkLmNsaXBJZEZvclhBeGlzID0gXCJcIi5jb25jYXQoJCQuY2xpcElkLCBcIi14YXhpc1wiKSwgJCQuY2xpcElkRm9yWUF4aXMgPSBcIlwiLmNvbmNhdCgkJC5jbGlwSWQsIFwiLXlheGlzXCIpLCAkJC5jbGlwSWRGb3JHcmlkID0gXCJcIi5jb25jYXQoJCQuY2xpcElkLCBcIi1ncmlkXCIpLCAkJC5jbGlwUGF0aCA9ICQkLmdldENsaXBQYXRoKCQkLmNsaXBJZCksICQkLmNsaXBQYXRoRm9yWEF4aXMgPSAkJC5nZXRDbGlwUGF0aCgkJC5jbGlwSWRGb3JYQXhpcyksICQkLmNsaXBQYXRoRm9yWUF4aXMgPSAkJC5nZXRDbGlwUGF0aCgkJC5jbGlwSWRGb3JZQXhpcyksICQkLmNsaXBQYXRoRm9yR3JpZCA9ICQkLmdldENsaXBQYXRoKCQkLmNsaXBJZEZvckdyaWQpO1xuICB9LFxuICBnZXRDbGlwUGF0aDogZnVuY3Rpb24gZ2V0Q2xpcFBhdGgoaWQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgaWYgKCFjb25maWcuY2xpcFBhdGggJiYgLy1jbGlwJC8udGVzdChpZCkgfHwgIWNvbmZpZy5heGlzX3hfY2xpcFBhdGggJiYgLy1jbGlwLXhheGlzJC8udGVzdChpZCkgfHwgIWNvbmZpZy5heGlzX3lfY2xpcFBhdGggJiYgLy1jbGlwLXlheGlzJC8udGVzdChpZCkpIHJldHVybiBudWxsO1xuICAgIHZhciBpc0lFOSA9ICEhd2luLm5hdmlnYXRvciAmJiB3aW4ubmF2aWdhdG9yLmFwcFZlcnNpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKFwibXNpZSA5LlwiKSA+PSAwO1xuICAgIHJldHVybiBcInVybChcIi5jb25jYXQoaXNJRTkgPyBcIlwiIDogYnJvd3Nlcl9kb2MuVVJMLnNwbGl0KFwiI1wiKVswXSwgXCIjXCIpLmNvbmNhdChpZCwgXCIpXCIpO1xuICB9LFxuICBhcHBlbmRDbGlwOiBmdW5jdGlvbiBhcHBlbmRDbGlwKHBhcmVudCwgaWQpIHtcbiAgICByZXR1cm4gcGFyZW50LmFwcGVuZChcImNsaXBQYXRoXCIpLmF0dHIoXCJpZFwiLCBpZCkuYXBwZW5kKFwicmVjdFwiKTtcbiAgfSxcbiAgZ2V0QXhpc0NsaXBYOiBmdW5jdGlvbiBnZXRBeGlzQ2xpcFgoZm9ySG9yaXpvbnRhbCkge1xuICAgIC8vIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnRcbiAgICB2YXIgbGVmdCA9IE1hdGgubWF4KDMwLCB0aGlzLm1hcmdpbi5sZWZ0KTtcbiAgICByZXR1cm4gZm9ySG9yaXpvbnRhbCA/IC0oMSArIGxlZnQpIDogLShsZWZ0IC0gMSk7XG4gIH0sXG4gIGdldEF4aXNDbGlwWTogZnVuY3Rpb24gZ2V0QXhpc0NsaXBZKGZvckhvcml6b250YWwpIHtcbiAgICByZXR1cm4gZm9ySG9yaXpvbnRhbCA/IC0yMCA6IC10aGlzLm1hcmdpbi50b3A7XG4gIH0sXG4gIGdldFhBeGlzQ2xpcFg6IGZ1bmN0aW9uIGdldFhBeGlzQ2xpcFgoKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICByZXR1cm4gJCQuZ2V0QXhpc0NsaXBYKCEkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcbiAgfSxcbiAgZ2V0WEF4aXNDbGlwWTogZnVuY3Rpb24gZ2V0WEF4aXNDbGlwWSgpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgIHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuICB9LFxuICBnZXRZQXhpc0NsaXBYOiBmdW5jdGlvbiBnZXRZQXhpc0NsaXBYKCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgcmV0dXJuICQkLmNvbmZpZy5heGlzX3lfaW5uZXIgPyAtMSA6ICQkLmdldEF4aXNDbGlwWCgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcbiAgfSxcbiAgZ2V0WUF4aXNDbGlwWTogZnVuY3Rpb24gZ2V0WUF4aXNDbGlwWSgpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgIHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG4gIH0sXG4gIGdldEF4aXNDbGlwV2lkdGg6IGZ1bmN0aW9uIGdldEF4aXNDbGlwV2lkdGgoZm9ySG9yaXpvbnRhbCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGxlZnQgPSBNYXRoLm1heCgzMCwgJCQubWFyZ2luLmxlZnQpLFxuICAgICAgICByaWdodCA9IE1hdGgubWF4KDMwLCAkJC5tYXJnaW4ucmlnaHQpO1xuICAgIC8vIHdpZHRoICsgYXhpcyBsaW5lIHdpZHRoICsgcGFkZGluZyBmb3IgbGVmdC9yaWdodFxuICAgIHJldHVybiBmb3JIb3Jpem9udGFsID8gJCQud2lkdGggKyAyICsgbGVmdCArIHJpZ2h0IDogJCQubWFyZ2luLmxlZnQgKyAyMDtcbiAgfSxcbiAgZ2V0QXhpc0NsaXBIZWlnaHQ6IGZ1bmN0aW9uIGdldEF4aXNDbGlwSGVpZ2h0KGZvckhvcml6b250YWwpIHtcbiAgICAvLyBsZXNzIHRoYW4gMjAgaXMgbm90IGVub3VnaCB0byBzaG93IHRoZSBheGlzIGxhYmVsICdvdXRlcicgd2l0aG91dCBsZWdlbmRcbiAgICByZXR1cm4gKGZvckhvcml6b250YWwgPyB0aGlzLm1hcmdpbi5ib3R0b20gOiB0aGlzLm1hcmdpbi50b3AgKyB0aGlzLmhlaWdodCkgKyAyMDtcbiAgfSxcbiAgZ2V0WEF4aXNDbGlwV2lkdGg6IGZ1bmN0aW9uIGdldFhBeGlzQ2xpcFdpZHRoKCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgcmV0dXJuICQkLmdldEF4aXNDbGlwV2lkdGgoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuICB9LFxuICBnZXRYQXhpc0NsaXBIZWlnaHQ6IGZ1bmN0aW9uIGdldFhBeGlzQ2xpcEhlaWdodCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgIHJldHVybiAkJC5nZXRBeGlzQ2xpcEhlaWdodCghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG4gIH0sXG4gIGdldFlBeGlzQ2xpcFdpZHRoOiBmdW5jdGlvbiBnZXRZQXhpc0NsaXBXaWR0aCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgIHJldHVybiAkJC5nZXRBeGlzQ2xpcFdpZHRoKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpICsgKCQkLmNvbmZpZy5heGlzX3lfaW5uZXIgPyAyMCA6IDApO1xuICB9LFxuICBnZXRZQXhpc0NsaXBIZWlnaHQ6IGZ1bmN0aW9uIGdldFlBeGlzQ2xpcEhlaWdodCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgIHJldHVybiAkJC5nZXRBeGlzQ2xpcEhlaWdodCgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcbiAgfSxcbiAgdXBkYXRlWEF4aXNUaWNrQ2xpcDogZnVuY3Rpb24gdXBkYXRlWEF4aXNUaWNrQ2xpcCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBuZXdYQXhpc0hlaWdodCA9ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieFwiKTtcblxuICAgIGlmICgkJC5kZWZzICYmICEkJC5jbGlwWEF4aXNUaWNrVGV4dHMpIHtcbiAgICAgIHZhciBjbGlwSWQgPSBcIlwiLmNvbmNhdCgkJC5jbGlwSWQsIFwiLXhheGlzdGlja3RleHRzXCIpO1xuICAgICAgJCQuY2xpcFhBeGlzVGlja1RleHRzID0gJCQuYXBwZW5kQ2xpcCgkJC5kZWZzLCBjbGlwSWQpLCAkJC5jbGlwUGF0aEZvclhBeGlzVGlja1RleHRzID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcElkKSwgJCQuY2xpcElkRm9yWEF4aXNUaWNrVGV4dHMgPSBjbGlwSWQ7XG4gICAgfVxuXG4gICAgISQkLmNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUgJiYgJCQuZ2V0QXhpc1RpY2tSb3RhdGUoXCJ4XCIpICYmIG5ld1hBeGlzSGVpZ2h0ICE9PSAkJC54QXhpc0hlaWdodCAmJiAoJCQuc2V0WEF4aXNUaWNrQ2xpcFdpZHRoKCksICQkLnNldFhBeGlzVGlja1RleHRDbGlwUGF0aFdpZHRoKCkpLCAkJC54QXhpc0hlaWdodCA9IG5ld1hBeGlzSGVpZ2h0O1xuICB9LFxuICBzZXRYQXhpc1RpY2tDbGlwV2lkdGg6IGZ1bmN0aW9uIHNldFhBeGlzVGlja0NsaXBXaWR0aCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIHhBeGlzVGlja1JvdGF0ZSA9ICQkLmdldEF4aXNUaWNrUm90YXRlKFwieFwiKTtcblxuICAgIGlmICghY29uZmlnLmF4aXNfeF90aWNrX211bHRpbGluZSAmJiB4QXhpc1RpY2tSb3RhdGUpIHtcbiAgICAgIHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKE1hdGguUEkgLyAxODAgKiBNYXRoLmFicyh4QXhpc1RpY2tSb3RhdGUpKTtcbiAgICAgICQkLnhBeGlzVGlja0NsaXBQYXRoTWF4V2lkdGggPSAoJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoXCJ4XCIpIC0gMjApIC8gc2luUm90YXRpb247XG4gICAgfSBlbHNlICQkLnhBeGlzVGlja0NsaXBQYXRoTWF4V2lkdGggPSBudWxsO1xuICB9LFxuICBzZXRYQXhpc1RpY2tUZXh0Q2xpcFBhdGhXaWR0aDogZnVuY3Rpb24gc2V0WEF4aXNUaWNrVGV4dENsaXBQYXRoV2lkdGgoKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC5zdmcgJiYgJCQuc3ZnLnNlbGVjdChcIiNcIi5jb25jYXQoJCQuY2xpcElkRm9yWEF4aXNUaWNrVGV4dHMsIFwiIHJlY3RcIikpLmF0dHIoXCJ3aWR0aFwiLCAkJC54QXhpc1RpY2tDbGlwUGF0aE1heFdpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsIDMwKTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbnRlcm5hbHMvcmVnaW9uLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4gLy8gc2VsZWN0aW9uXG5cblxuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIGluaXRSZWdpb246IGZ1bmN0aW9uIGluaXRSZWdpb24oKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC5yZWdpb24gPSAkJC5tYWluLmFwcGVuZChcImdcIikuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5jbGlwUGF0aCkuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLnJlZ2lvbnMpO1xuICB9LFxuICB1cGRhdGVSZWdpb246IGZ1bmN0aW9uIHVwZGF0ZVJlZ2lvbihkdXJhdGlvbikge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAvLyBoaWRlIGlmIGFyYyB0eXBlXG4gICAgLy8gc2VsZWN0IDxnPiBlbGVtZW50XG4gICAgJCQucmVnaW9uLnN0eWxlKFwidmlzaWJpbGl0eVwiLCAkJC5oYXNBcmNUeXBlKCkgPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCIpLCAkJC5tYWluUmVnaW9uID0gJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnJlZ2lvbnMpKS5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnJlZ2lvbikpLmRhdGEoY29uZmlnLnJlZ2lvbnMpLCAkJC5tYWluUmVnaW9uLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIikucmVtb3ZlKCksICQkLm1haW5SZWdpb24gPSAkJC5tYWluUmVnaW9uLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5tZXJnZSgkJC5tYWluUmVnaW9uKS5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NSZWdpb24uYmluZCgkJCkpLCAkJC5tYWluUmVnaW9uLmFwcGVuZChcInJlY3RcIikuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpO1xuICB9LFxuICByZWRyYXdSZWdpb246IGZ1bmN0aW9uIHJlZHJhd1JlZ2lvbih3aXRoVHJhbnNpdGlvbikge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIHJlZ2lvbnMgPSAkJC5tYWluUmVnaW9uLnNlbGVjdChcInJlY3RcIik7XG4gICAgcmV0dXJuIHJlZ2lvbnMgPSAod2l0aFRyYW5zaXRpb24gPyByZWdpb25zLnRyYW5zaXRpb24oKSA6IHJlZ2lvbnMpLmF0dHIoXCJ4XCIsICQkLnJlZ2lvblguYmluZCgkJCkpLmF0dHIoXCJ5XCIsICQkLnJlZ2lvblkuYmluZCgkJCkpLmF0dHIoXCJ3aWR0aFwiLCAkJC5yZWdpb25XaWR0aC5iaW5kKCQkKSkuYXR0cihcImhlaWdodFwiLCAkJC5yZWdpb25IZWlnaHQuYmluZCgkJCkpLCBbKHdpdGhUcmFuc2l0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkgOiByZWdpb25zKS5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGlzVmFsdWUoZC5vcGFjaXR5KSA/IGQub3BhY2l0eSA6IFwiMC4xXCI7XG4gICAgfSkub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMucGFyZW50Tm9kZSkuc2VsZWN0QWxsKFwicmVjdDpub3QoW3hdKVwiKS5yZW1vdmUoKTtcbiAgICB9KV07XG4gIH0sXG4gIGdldFJlZ2lvblhZOiBmdW5jdGlvbiBnZXRSZWdpb25YWSh0eXBlLCBkKSB7XG4gICAgdmFyIHNjYWxlLFxuICAgICAgICAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZCxcbiAgICAgICAgaXNYID0gdHlwZSA9PT0gXCJ4XCIsXG4gICAgICAgIGtleSA9IFwic3RhcnRcIixcbiAgICAgICAgcG9zID0gMDtcbiAgICByZXR1cm4gZC5heGlzID09PSBcInlcIiB8fCBkLmF4aXMgPT09IFwieTJcIiA/ICghaXNYICYmIChrZXkgPSBcImVuZFwiKSwgKGlzWCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQpICYmIGtleSBpbiBkICYmIChzY2FsZSA9ICQkW2QuYXhpc10sIHBvcyA9IHNjYWxlKGRba2V5XSkpKSA6IChpc1ggPyAhaXNSb3RhdGVkIDogaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCAmJiAoc2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQueCwgcG9zID0gc2NhbGUoJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5wYXJzZURhdGUoZFtrZXldKSA6IGRba2V5XSkpLCBwb3M7XG4gIH0sXG4gIHJlZ2lvblg6IGZ1bmN0aW9uIHJlZ2lvblgoZCkge1xuICAgIHJldHVybiB0aGlzLmdldFJlZ2lvblhZKFwieFwiLCBkKTtcbiAgfSxcbiAgcmVnaW9uWTogZnVuY3Rpb24gcmVnaW9uWShkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVnaW9uWFkoXCJ5XCIsIGQpO1xuICB9LFxuICBnZXRSZWdpb25TaXplOiBmdW5jdGlvbiBnZXRSZWdpb25TaXplKHR5cGUsIGQpIHtcbiAgICB2YXIgc2NhbGUsXG4gICAgICAgICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkLFxuICAgICAgICBpc1dpZHRoID0gdHlwZSA9PT0gXCJ3aWR0aFwiLFxuICAgICAgICBzdGFydCA9ICQkW2lzV2lkdGggPyBcInJlZ2lvblhcIiA6IFwicmVnaW9uWVwiXShkKSxcbiAgICAgICAga2V5ID0gXCJlbmRcIixcbiAgICAgICAgZW5kID0gJCRbdHlwZV07XG4gICAgcmV0dXJuIGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIgPyAoIWlzV2lkdGggJiYgKGtleSA9IFwic3RhcnRcIiksIChpc1dpZHRoID8gaXNSb3RhdGVkIDogIWlzUm90YXRlZCkgJiYga2V5IGluIGQgJiYgKHNjYWxlID0gJCRbZC5heGlzXSwgZW5kID0gc2NhbGUoZFtrZXldKSkpIDogKGlzV2lkdGggPyAhaXNSb3RhdGVkIDogaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCAmJiAoc2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQueCwgZW5kID0gc2NhbGUoJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5wYXJzZURhdGUoZFtrZXldKSA6IGRba2V5XSkpLCBlbmQgPCBzdGFydCA/IDAgOiBlbmQgLSBzdGFydDtcbiAgfSxcbiAgcmVnaW9uV2lkdGg6IGZ1bmN0aW9uIHJlZ2lvbldpZHRoKGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWdpb25TaXplKFwid2lkdGhcIiwgZCk7XG4gIH0sXG4gIHJlZ2lvbkhlaWdodDogZnVuY3Rpb24gcmVnaW9uSGVpZ2h0KGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWdpb25TaXplKFwiaGVpZ2h0XCIsIGQpO1xuICB9LFxuICBpc1JlZ2lvbk9uWDogZnVuY3Rpb24gaXNSZWdpb25PblgoZCkge1xuICAgIHJldHVybiAhZC5heGlzIHx8IGQuYXhpcyA9PT0gXCJ4XCI7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaW50ZXJhY3Rpb25zL2RyYWcuanNcblxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBkcmFnZ2luZy5cbiAgICogRGF0YSBwb2ludHMgY2FuIGJlIHNlbGVjdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgT2JqZWN0XG4gICAqL1xuICBkcmFnOiBmdW5jdGlvbiBkcmFnKG1vdXNlKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBtYWluID0gJCQubWFpbjtcblxuICAgIGlmICghJCQuaGFzQXJjVHlwZSgpICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmICggLy8gZG8gbm90aGluZyBpZiBub3Qgc2VsZWN0YWJsZVxuICAgICFjb25maWcuem9vbV9lbmFibGVkIHx8ICQkLnpvb20uYWx0RG9tYWluKSAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUgLy8gc2tpcCB3aGVuIHNpbmdsZSBzZWxlY3Rpb24gYmVjYXVzZSBkcmFnIGlzIHVzZWQgZm9yIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICkge1xuICAgICAgICB2YXIgXyQkJGRyYWdTdGFydCA9IF9zbGljZWRUb0FycmF5KCQkLmRyYWdTdGFydCwgMiksXG4gICAgICAgICAgICBzeCA9IF8kJCRkcmFnU3RhcnRbMF0sXG4gICAgICAgICAgICBzeSA9IF8kJCRkcmFnU3RhcnRbMV0sXG4gICAgICAgICAgICBfbW91c2UgPSBfc2xpY2VkVG9BcnJheShtb3VzZSwgMiksXG4gICAgICAgICAgICBteCA9IF9tb3VzZVswXSxcbiAgICAgICAgICAgIG15ID0gX21vdXNlWzFdLFxuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKHN4LCBteCksXG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgoc3gsIG14KSxcbiAgICAgICAgICAgIG1pblkgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCA/ICQkLm1hcmdpbi50b3AgOiBNYXRoLm1pbihzeSwgbXkpLFxuICAgICAgICAgICAgbWF4WSA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gJCQuaGVpZ2h0IDogTWF0aC5tYXgoc3ksIG15KTtcblxuICAgICAgICBtYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuZHJhZ2FyZWEpKS5hdHRyKFwieFwiLCBtaW5YKS5hdHRyKFwieVwiLCBtaW5ZKS5hdHRyKFwid2lkdGhcIiwgbWF4WCAtIG1pblgpLmF0dHIoXCJoZWlnaHRcIiwgbWF4WSAtIG1pblkpLCBtYWluLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuc2hhcGVzKSkuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5zaGFwZSkpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpO1xuICAgICAgICB9KS5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgdmFyIHRvZ2dsZSxcbiAgICAgICAgICAgICAgc2hhcGUgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhpcyksXG4gICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLlNFTEVDVEVEKSxcbiAgICAgICAgICAgICAgaXNJbmNsdWRlZCA9IHNoYXBlLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuSU5DTFVERUQpLFxuICAgICAgICAgICAgICBpc1dpdGhpbiA9ICExO1xuXG4gICAgICAgICAgaWYgKHNoYXBlLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuY2lyY2xlKSkge1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5hdHRyKFwiY3hcIikgKiAxLFxuICAgICAgICAgICAgICAgIHkgPSBzaGFwZS5hdHRyKFwiY3lcIikgKiAxO1xuICAgICAgICAgICAgdG9nZ2xlID0gJCQudG9nZ2xlUG9pbnQsIGlzV2l0aGluID0gbWluWCA8IHggJiYgeCA8IG1heFggJiYgbWluWSA8IHkgJiYgeSA8IG1heFk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzaGFwZS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmJhcikpIHtcbiAgICAgICAgICAgIHZhciBfZ2V0UGF0aEJveCA9IGdldFBhdGhCb3godGhpcyksXG4gICAgICAgICAgICAgICAgX3ggPSBfZ2V0UGF0aEJveC54LFxuICAgICAgICAgICAgICAgIHkgPSBfZ2V0UGF0aEJveC55LFxuICAgICAgICAgICAgICAgIHdpZHRoID0gX2dldFBhdGhCb3gud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gX2dldFBhdGhCb3guaGVpZ2h0O1xuXG4gICAgICAgICAgICB0b2dnbGUgPSAkJC50b2dnbGVQYXRoLCBpc1dpdGhpbiA9ICEobWF4WCA8IF94IHx8IF94ICsgd2lkdGggPCBtaW5YKSAmJiAhKG1heFkgPCB5IHx8IHkgKyBoZWlnaHQgPCBtaW5ZKTtcbiAgICAgICAgICB9IGVsc2UgLy8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgaXNXaXRoaW4gXiBpc0luY2x1ZGVkICYmIChzaGFwZS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLklOQ0xVREVELCAhaXNJbmNsdWRlZCksIHNoYXBlLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuU0VMRUNURUQsICFpc1NlbGVjdGVkKSwgdG9nZ2xlLmNhbGwoJCQsICFpc1NlbGVjdGVkLCBzaGFwZSwgZCwgaSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGRyYWcgc3RhcnRzLlxuICAgKiBBZGRzIGFuZCBTaG93cyB0aGUgZHJhZyBhcmVhLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgT2JqZWN0XG4gICAqL1xuICBkcmFnc3RhcnQ6IGZ1bmN0aW9uIGRyYWdzdGFydChtb3VzZSkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAkJC5oYXNBcmNUeXBlKCkgfHwgIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkIHx8ICgkJC5kcmFnU3RhcnQgPSBtb3VzZSwgJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0KSkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIiwgY29uZmlnX2NsYXNzZXMuZHJhZ2FyZWEpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjAuMVwiKSwgJCQuc2V0RHJhZ1N0YXR1cyghMCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgZHJhZyBmaW5pc2hlcy5cbiAgICogUmVtb3ZlcyB0aGUgZHJhZyBhcmVhLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHJhZ2VuZDogZnVuY3Rpb24gZHJhZ2VuZCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgJCQuaGFzQXJjVHlwZSgpIHx8ICFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCB8fCAoJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmRyYWdhcmVhKSkudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMCkuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKS5yZW1vdmUoKSwgJCQubWFpbi5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnNoYXBlKSkuY2xhc3NlZChjb25maWdfY2xhc3Nlcy5JTkNMVURFRCwgITEpLCAkJC5zZXREcmFnU3RhdHVzKCExKSk7XG4gIH0sXG4gIHNldERyYWdTdGF0dXM6IGZ1bmN0aW9uIHNldERyYWdTdGF0dXMoaXNEcmFnZ2luZykge1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBpc0RyYWdnaW5nO1xuICB9XG59KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWNvbG9yXCIsXCJjb21tb25qczJcIjpcImQzLWNvbG9yXCIsXCJhbWRcIjpcImQzLWNvbG9yXCIsXCJyb290XCI6XCJkM1wifVxudmFyIGV4dGVybmFsX2NvbW1vbmpzX2QzX2NvbG9yX2NvbW1vbmpzMl9kM19jb2xvcl9hbWRfZDNfY29sb3Jfcm9vdF9kM18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaW50ZXJuYWxzL3NlbGVjdGlvbi5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBTZWxlY3QgYSBwb2ludFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHBvaW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKi9cbiAgc2VsZWN0UG9pbnQ6IGZ1bmN0aW9uIHNlbGVjdFBvaW50KHRhcmdldCwgZCwgaSkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZCxcbiAgICAgICAgY3ggPSAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWSA6ICQkLmNpcmNsZVgpLmJpbmQoJCQpLFxuICAgICAgICBjeSA9IChpc1JvdGF0ZWQgPyAkJC5jaXJjbGVYIDogJCQuY2lyY2xlWSkuYmluZCgkJCksXG4gICAgICAgIHIgPSAkJC5wb2ludFNlbGVjdFIuYmluZCgkJCk7XG4gICAgLy8gYWRkIHNlbGVjdGVkLWNpcmNsZSBvbiBsb3cgbGF5ZXIgZ1xuICAgIGNhbGxGbihjb25maWcuZGF0YV9vbnNlbGVjdGVkLCAkJC5hcGksIGQsIHRhcmdldC5ub2RlKCkpLCAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuc2VsZWN0ZWRDaXJjbGVzKS5jb25jYXQoJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCkpKS5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnNlbGVjdGVkQ2lyY2xlLCBcIi1cIikuY29uY2F0KGkpKS5kYXRhKFtkXSkuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIikuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAkJC5nZW5lcmF0ZUNsYXNzKGNvbmZpZ19jbGFzc2VzLnNlbGVjdGVkQ2lyY2xlLCBpKTtcbiAgICB9KS5hdHRyKFwiY3hcIiwgY3gpLmF0dHIoXCJjeVwiLCBjeSkuYXR0cihcInN0cm9rZVwiLCAkJC5jb2xvcikuYXR0cihcInJcIiwgZnVuY3Rpb24gKGQyKSB7XG4gICAgICByZXR1cm4gJCQucG9pbnRTZWxlY3RSKGQyKSAqIDEuNDtcbiAgICB9KS50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTAwKS5hdHRyKFwiclwiLCByKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5lbGVjdCBhIHBvaW50XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcG9pbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuICB1bnNlbGVjdFBvaW50OiBmdW5jdGlvbiB1bnNlbGVjdFBvaW50KHRhcmdldCwgZCwgaSkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgLy8gcmVtb3ZlIHNlbGVjdGVkLWNpcmNsZSBmcm9tIGxvdyBsYXllciBnXG4gICAgY2FsbEZuKCQkLmNvbmZpZy5kYXRhX29udW5zZWxlY3RlZCwgJCQuYXBpLCBkLCB0YXJnZXQubm9kZSgpKSwgJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnNlbGVjdGVkQ2lyY2xlcykuY29uY2F0KCQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpKSkuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5zZWxlY3RlZENpcmNsZSwgXCItXCIpLmNvbmNhdChpKSkudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMCkuYXR0cihcInJcIiwgMCkucmVtb3ZlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBwb2ludHNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byBzZWxlY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcG9pbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuICB0b2dnbGVQb2ludDogZnVuY3Rpb24gdG9nZ2xlUG9pbnQoc2VsZWN0ZWQsIHRhcmdldCwgZCwgaSkge1xuICAgIHZhciBtZXRob2QgPSBcIlwiLmNvbmNhdChzZWxlY3RlZCA/IFwiXCIgOiBcInVuXCIsIFwic2VsZWN0UG9pbnRcIik7XG4gICAgdGhpc1ttZXRob2RdKHRhcmdldCwgZCwgaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBzZWxlY3RQYXRoOiBmdW5jdGlvbiBzZWxlY3RQYXRoKHRhcmdldCwgZCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICBjYWxsRm4oY29uZmlnLmRhdGFfb25zZWxlY3RlZCwgJCQsIGQsIHRhcmdldC5ub2RlKCkpLCBjb25maWcuaW50ZXJhY3Rpb25fYnJpZ2h0ZW4gJiYgdGFyZ2V0LnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMDApLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX2NvbG9yX2NvbW1vbmpzMl9kM19jb2xvcl9hbWRfZDNfY29sb3Jfcm9vdF9kM19bXCJyZ2JcIl0pKCQkLmNvbG9yKGQpKS5icmlnaHRlciguNzUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbmVsZWN0IGEgcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIHVuc2VsZWN0UGF0aDogZnVuY3Rpb24gdW5zZWxlY3RQYXRoKHRhcmdldCwgZCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICBjYWxsRm4oY29uZmlnLmRhdGFfb251bnNlbGVjdGVkLCAkJCwgZCwgdGFyZ2V0Lm5vZGUoKSksIGNvbmZpZy5pbnRlcmFjdGlvbl9icmlnaHRlbiAmJiB0YXJnZXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMCkuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAkJC5jb2xvcihkKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIGxpbmVzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gc2VsZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHNoYXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKi9cbiAgdG9nZ2xlUGF0aDogZnVuY3Rpb24gdG9nZ2xlUGF0aChzZWxlY3RlZCwgdGFyZ2V0LCBkLCBpKSB7XG4gICAgdGhpc1tcIlwiLmNvbmNhdChzZWxlY3RlZCA/IFwiXCIgOiBcInVuXCIsIFwic2VsZWN0UGF0aFwiKV0odGFyZ2V0LCBkLCBpKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9nZ2xlIG1ldGhvZCBvZiB0aGUgdGFyZ2V0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgc2hhcGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSB0b2dnbGUgbWV0aG9kXG4gICAqL1xuICBnZXRUb2dnbGU6IGZ1bmN0aW9uIGdldFRvZ2dsZSh0aGF0LCBkKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICByZXR1cm4gdGhhdC5ub2RlTmFtZSA9PT0gXCJwYXRoXCIgPyAkJC50b2dnbGVQYXRoIDogJCQuaXNTdGVwVHlwZShkKSA/IGZ1bmN0aW9uICgpIHt9IDogLy8gY2lyY2xlIGlzIGhpZGRlbiBpbiBzdGVwIGNoYXJ0LCBzbyB0cmVhdCBhcyB3aXRoaW4gdGhlIGNsaWNrIGFyZWFcbiAgICAkJC50b2dnbGVQb2ludDtcbiAgfSxcblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIHNoYXBlc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHNoYXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKi9cbiAgdG9nZ2xlU2hhcGU6IGZ1bmN0aW9uIHRvZ2dsZVNoYXBlKHRoYXQsIGQsIGkpIHtcbiAgICB2YXIgdG9nZ2xlZFNoYXBlLFxuICAgICAgICAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgc2hhcGUgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhhdCksXG4gICAgICAgIGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLlNFTEVDVEVEKSxcbiAgICAgICAgdG9nZ2xlID0gJCQuZ2V0VG9nZ2xlKHRoYXQsIGQpLmJpbmQoJCQpO1xuXG4gICAgaWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkpIHtcbiAgICAgIGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX211bHRpcGxlKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5zaGFwZXMpO1xuICAgICAgICBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCAmJiAoc2VsZWN0b3IgKz0gJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCkpLCAkJC5tYWluLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5zaGFwZSkpLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICB2YXIgc2hhcGUgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhpcyk7XG4gICAgICAgICAgc2hhcGUuY2xhc3NlZChjb25maWdfY2xhc3Nlcy5TRUxFQ1RFRCkgJiYgKHRvZ2dsZWRTaGFwZSA9IHNoYXBlLCB0b2dnbGUoITEsIHNoYXBlLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuU0VMRUNURUQsICExKSwgZCwgaSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdG9nZ2xlZFNoYXBlICYmIHRvZ2dsZWRTaGFwZS5ub2RlKCkgPT09IHNoYXBlLm5vZGUoKSB8fCAoc2hhcGUuY2xhc3NlZChjb25maWdfY2xhc3Nlcy5TRUxFQ1RFRCwgIWlzU2VsZWN0ZWQpLCB0b2dnbGUoIWlzU2VsZWN0ZWQsIHNoYXBlLCBkLCBpKSk7XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ludGVyYWN0aW9ucy9zdWJjaGFydC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuXG5cbmV4dGVuZChDaGFydEludGVybmFsX0NoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBicnVzaC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRCcnVzaDogZnVuY3Rpb24gaW5pdEJydXNoKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcbiAgICAkJC5icnVzaCA9IGlzUm90YXRlZCA/IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19icnVzaF9jb21tb25qczJfZDNfYnJ1c2hfYW1kX2QzX2JydXNoX3Jvb3RfZDNfW1wiYnJ1c2hZXCJdKSgpIDogT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX2JydXNoX2NvbW1vbmpzMl9kM19icnVzaF9hbWRfZDNfYnJ1c2hfcm9vdF9kM19bXCJicnVzaFhcIl0pKCk7XG5cbiAgICAvLyBzZXQgXCJicnVzaFwiIGV2ZW50XG4gICAgdmFyIGxhc3REb21haW4sXG4gICAgICAgIHRpbWVvdXQsXG4gICAgICAgIGJydXNoSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICQkLnJlZHJhd0ZvckJydXNoKCk7XG4gICAgfSxcbiAgICAgICAgZ2V0QnJ1c2hTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJydXNoID0gJCQuc3ZnLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYnJ1c2gsIFwiIC5vdmVybGF5XCIpKSxcbiAgICAgICAgICBicnVzaFNpemUgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICByZXR1cm4gYnJ1c2guc2l6ZSgpICYmIChicnVzaFNpemUud2lkdGggPSArYnJ1c2guYXR0cihcIndpZHRoXCIpLCBicnVzaFNpemUuaGVpZ2h0ID0gK2JydXNoLmF0dHIoXCJoZWlnaHRcIikpLCBicnVzaFNpemVbaXNSb3RhdGVkID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl07XG4gICAgfTtcblxuICAgIC8vIHNldCB0aGUgYnJ1c2ggZXh0ZW50XG4gICAgJCQuYnJ1c2gub24oXCJzdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkJC5pbnB1dFR5cGUgPT09IFwidG91Y2hcIiAmJiAkJC5oaWRlVG9vbHRpcCgpLCBicnVzaEhhbmRsZXIoKTtcbiAgICB9KS5vbihcImJydXNoXCIsIGJydXNoSGFuZGxlcikub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgbGFzdERvbWFpbiA9ICQkLngub3JnRG9tYWluKCk7XG4gICAgfSksICQkLmJydXNoLnVwZGF0ZVJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpLCB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBfdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBsYXN0RG9tYWluICYmIE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19icnVzaF9jb21tb25qczJfZDNfYnJ1c2hfYW1kX2QzX2JydXNoX3Jvb3RfZDNfW1wiYnJ1c2hTZWxlY3Rpb25cIl0pKHNlbGVjdGlvbi5ub2RlKCkpICYmIF90aGlzLm1vdmUoc2VsZWN0aW9uLCBsYXN0RG9tYWluLm1hcCgkJC5zdWJYLm9yZ1NjYWxlKCkpKTtcbiAgICAgIH0sIDApO1xuICAgIH0sICQkLmJydXNoLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBleHRlbnQgPSB0aGlzLmV4dGVudCgpKCk7XG4gICAgICByZXR1cm4gZXh0ZW50WzFdLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gaXNOYU4odik7XG4gICAgICB9KS5sZW5ndGggPT09IDAgJiYgJCQuY29udGV4dCAmJiAkJC5jb250ZXh0LnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYnJ1c2gpKS5jYWxsKHRoaXMpLCB0aGlzO1xuICAgIH0sICQkLmJydXNoLnNjYWxlID0gZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICB2YXIgaCA9IGNvbmZpZy5zdWJjaGFydF9zaXplX2hlaWdodCB8fCBnZXRCcnVzaFNpemUoKSxcbiAgICAgICAgICBleHRlbnQgPSAkJC5nZXRFeHRlbnQoKTtcbiAgICAgIC8vIFtbeDAsIHkwXSwgW3gxLCB5MV1dLCB3aGVyZSBbeDAsIHkwXSBpcyB0aGUgdG9wLWxlZnQgY29ybmVyIGFuZCBbeDEsIHkxXSBpcyB0aGUgYm90dG9tLXJpZ2h0IGNvcm5lclxuICAgICAgLy8gd2hlbiBleHRlbnQgdXBkYXRlcywgYnJ1c2ggc2VsZWN0aW9uIGFsc28gYmUgcmUtYXBwbGllZFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2lzc3Vlcy8yOTE4XG4gICAgICAhZXh0ZW50ICYmIHNjYWxlLnJhbmdlID8gZXh0ZW50ID0gW1swLCAwXSwgW3NjYWxlLnJhbmdlKClbMV0sIGhdXSA6IGlzQXJyYXkoZXh0ZW50KSAmJiAoZXh0ZW50ID0gZXh0ZW50Lm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICByZXR1cm4gW3YsIGkgPiAwID8gaCA6IGldO1xuICAgICAgfSkpLCBpc1JvdGF0ZWQgJiYgZXh0ZW50WzFdLnJldmVyc2UoKSwgdGhpcy5leHRlbnQoZXh0ZW50KSwgdGhpcy51cGRhdGUoKTtcbiAgICB9LCAkJC5icnVzaC5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJCQuY29udGV4dCA/ICQkLmNvbnRleHQuc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5icnVzaCkpIDogT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKFtdKTtcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBzdWJjaGFydC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRTdWJjaGFydDogZnVuY3Rpb24gaW5pdFN1YmNoYXJ0KCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgdmlzaWJpbGl0eSA9IGNvbmZpZy5zdWJjaGFydF9zaG93ID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiLFxuICAgICAgICBjbGlwSWQgPSBcIlwiLmNvbmNhdCgkJC5jbGlwSWQsIFwiLXN1YmNoYXJ0XCIpLFxuICAgICAgICBjbGlwUGF0aCA9ICQkLmdldENsaXBQYXRoKGNsaXBJZCk7XG4gICAgJCQuY2xpcElkRm9yU3ViY2hhcnQgPSBjbGlwSWQsICQkLmFwcGVuZENsaXAoJCQuZGVmcywgY2xpcElkKSwgJCQuaW5pdEJydXNoKCksICQkLmNvbnRleHQgPSAkJC5zdmcuYXBwZW5kKFwiZ1wiKS5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImNvbnRleHRcIikpO1xuICAgIHZhciBjb250ZXh0ID0gJCQuY29udGV4dDtcbiAgICAvLyBEZWZpbmUgZyBmb3IgY2hhcnQgYXJlYVxuICAgIC8vIERlZmluZSBnIGZvciBiYXIgY2hhcnQgYXJlYVxuICAgIC8vIERlZmluZSBnIGZvciBsaW5lIGNoYXJ0IGFyZWFcbiAgICAvLyBBZGQgZXh0ZW50IHJlY3QgZm9yIEJydXNoXG4gICAgLy8gQVRURU5USU9OOiBUaGlzIG11c3QgYmUgY2FsbGVkIEFGVEVSIGNoYXJ0IGFkZGVkXG4gICAgLy8gQWRkIEF4aXNcbiAgICBjb250ZXh0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCB2aXNpYmlsaXR5KSwgY29udGV4dC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGlwLXBhdGhcIiwgY2xpcFBhdGgpLmF0dHIoXCJjbGFzc1wiLCBjb25maWdfY2xhc3Nlcy5jaGFydCksICQkLmhhc1R5cGUoXCJiYXJcIikgJiYgY29udGV4dC5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0KSkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY29uZmlnX2NsYXNzZXMuY2hhcnRCYXJzKSwgY29udGV4dC5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0KSkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY29uZmlnX2NsYXNzZXMuY2hhcnRMaW5lcyksIGNvbnRleHQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXBQYXRoKS5hdHRyKFwiY2xhc3NcIiwgY29uZmlnX2NsYXNzZXMuYnJ1c2gpLmNhbGwoJCQuYnJ1c2gpLCAkJC5heGVzLnN1YnggPSBjb250ZXh0LmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNvbmZpZ19jbGFzc2VzLmF4aXNYKS5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInN1YnhcIikpLmF0dHIoXCJjbGlwLXBhdGhcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IFwiXCIgOiAkJC5jbGlwUGF0aEZvclhBeGlzKS5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnN1YmNoYXJ0X2F4aXNfeF9zaG93ID8gdmlzaWJpbGl0eSA6IFwiaGlkZGVuXCIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3ViIGNoYXJ0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAkJC5kYXRhLnRhcmdldHNcbiAgICovXG4gIHVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydDogZnVuY3Rpb24gdXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0KHRhcmdldHMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb250ZXh0ID0gJCQuY29udGV4dCxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBjbGFzc0NoYXJ0QmFyID0gJCQuY2xhc3NDaGFydEJhci5iaW5kKCQkKSxcbiAgICAgICAgY2xhc3NCYXJzID0gJCQuY2xhc3NCYXJzLmJpbmQoJCQpLFxuICAgICAgICBjbGFzc0NoYXJ0TGluZSA9ICQkLmNsYXNzQ2hhcnRMaW5lLmJpbmQoJCQpLFxuICAgICAgICBjbGFzc0xpbmVzID0gJCQuY2xhc3NMaW5lcy5iaW5kKCQkKSxcbiAgICAgICAgY2xhc3NBcmVhcyA9ICQkLmNsYXNzQXJlYXMuYmluZCgkJCk7XG5cbiAgICBpZiAoY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcbiAgICAgIC8vIC0tIEJhciAtLS8vXG4gICAgICB2YXIgY29udGV4dEJhclVwZGF0ZSA9IGNvbnRleHQuc2VsZWN0KFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5jaGFydEJhcnMpKS5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0QmFyKSkuZGF0YSh0YXJnZXRzKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEJhciksXG4gICAgICAgICAgY29udGV4dEJhckVudGVyID0gY29udGV4dEJhclVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIikuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEJhcikubWVyZ2UoY29udGV4dEJhclVwZGF0ZSk7XG4gICAgICBjb250ZXh0QmFyRW50ZXIuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NCYXJzKTtcbiAgICAgIC8vIC0tIExpbmUgLS0vL1xuICAgICAgdmFyIGNvbnRleHRMaW5lVXBkYXRlID0gY29udGV4dC5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0TGluZXMpKS5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmNoYXJ0TGluZSkpLmRhdGEodGFyZ2V0cykuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRMaW5lKSxcbiAgICAgICAgICBjb250ZXh0TGluZUVudGVyID0gY29udGV4dExpbmVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRMaW5lKS5tZXJnZShjb250ZXh0TGluZVVwZGF0ZSk7XG4gICAgICAvLyBMaW5lcyBmb3IgZWFjaCBkYXRhXG4gICAgICAvLyBBcmVhXG4gICAgICAvLyAtLSBCcnVzaCAtLS8vXG4gICAgICBjb250ZXh0TGluZUVudGVyLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzTGluZXMpLCAkJC5oYXNUeXBlKFwiYXJlYVwiKSAmJiBjb250ZXh0TGluZUVudGVyLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzQXJlYXMpLCBjb250ZXh0LnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYnJ1c2gsIFwiIHJlY3RcIikpLmF0dHIoY29uZmlnLmF4aXNfcm90YXRlZCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAkJC53aWR0aDIgOiAkJC5oZWlnaHQyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYmFyIG9mIHRoZSBzdWIgY2hhcnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGR1cmF0aW9uRm9yRXhpdFxuICAgKi9cbiAgdXBkYXRlQmFyRm9yU3ViY2hhcnQ6IGZ1bmN0aW9uIHVwZGF0ZUJhckZvclN1YmNoYXJ0KGR1cmF0aW9uRm9yRXhpdCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgJCQuY29udGV4dEJhciA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5iYXJzKSkuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5iYXIpKS5kYXRhKCQkLmJhckRhdGEuYmluZCgkJCkpLCAkJC5jb250ZXh0QmFyLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KS5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpLnJlbW92ZSgpLCAkJC5jb250ZXh0QmFyID0gJCQuY29udGV4dEJhci5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQmFyLmJpbmQoJCQpKS5zdHlsZShcInN0cm9rZVwiLCBcIm5vbmVcIikuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKS5tZXJnZSgkJC5jb250ZXh0QmFyKS5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWRyYXcgdGhlIGJhciBvZiB0aGUgc3ViY2hhcnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggaW4gc3ViY2hhcnQgYmFyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRyYW5zaXRpb24gZHVyYXRpb25cbiAgICovXG4gIHJlZHJhd0JhckZvclN1YmNoYXJ0OiBmdW5jdGlvbiByZWRyYXdCYXJGb3JTdWJjaGFydChkcmF3QmFyT25TdWIsIHdpdGhUcmFuc2l0aW9uLCBkdXJhdGlvbikge1xuICAgIHZhciBjb250ZXh0QmFyID0gd2l0aFRyYW5zaXRpb24gPyB0aGlzLmNvbnRleHRCYXIudHJhbnNpdGlvbihnZXRSYW5kb20oKSkuZHVyYXRpb24oZHVyYXRpb24pIDogdGhpcy5jb250ZXh0QmFyO1xuICAgIGNvbnRleHRCYXIuYXR0cihcImRcIiwgZHJhd0Jhck9uU3ViKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGxpbmUgb2YgdGhlIHN1YiBjaGFydFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxuICAgKi9cbiAgdXBkYXRlTGluZUZvclN1YmNoYXJ0OiBmdW5jdGlvbiB1cGRhdGVMaW5lRm9yU3ViY2hhcnQoZHVyYXRpb25Gb3JFeGl0KSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC5jb250ZXh0TGluZSA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5saW5lcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMubGluZSkpLmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpLCAkJC5jb250ZXh0TGluZS5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdCkuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKS5yZW1vdmUoKSwgJCQuY29udGV4dExpbmUgPSAkJC5jb250ZXh0TGluZS5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzTGluZS5iaW5kKCQkKSkuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpLm1lcmdlKCQkLmNvbnRleHRMaW5lKS5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWRyYXcgdGhlIGxpbmUgb2YgdGhlIHN1YmNoYXJ0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGluIHN1YmNoYXJ0IGxpbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0cmFuc2l0aW9uIGR1cmF0aW9uXG4gICAqL1xuICByZWRyYXdMaW5lRm9yU3ViY2hhcnQ6IGZ1bmN0aW9uIHJlZHJhd0xpbmVGb3JTdWJjaGFydChkcmF3TGluZU9uU3ViLCB3aXRoVHJhbnNpdGlvbiwgZHVyYXRpb24pIHtcbiAgICB2YXIgY29udGV4dExpbmUgPSB3aXRoVHJhbnNpdGlvbiA/IHRoaXMuY29udGV4dExpbmUudHJhbnNpdGlvbihnZXRSYW5kb20oKSkuZHVyYXRpb24oZHVyYXRpb24pIDogdGhpcy5jb250ZXh0TGluZTtcbiAgICBjb250ZXh0TGluZS5hdHRyKFwiZFwiLCBkcmF3TGluZU9uU3ViKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGFyZWEgb2YgdGhlIHN1YiBjaGFydFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxuICAgKi9cbiAgdXBkYXRlQXJlYUZvclN1YmNoYXJ0OiBmdW5jdGlvbiB1cGRhdGVBcmVhRm9yU3ViY2hhcnQoZHVyYXRpb25Gb3JFeGl0KSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICAkJC5jb250ZXh0QXJlYSA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5hcmVhcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuYXJlYSkpLmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpLCAkJC5jb250ZXh0QXJlYS5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdCkuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKS5yZW1vdmUoKSwgJCQuY29udGV4dEFyZWEgPSAkJC5jb250ZXh0QXJlYS5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJlYS5iaW5kKCQkKSkuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKS5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICQkLm9yZ0FyZWFPcGFjaXR5ID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMpLnN0eWxlKFwib3BhY2l0eVwiKSwgXCIwXCI7XG4gICAgfSkubWVyZ2UoJCQuY29udGV4dEFyZWEpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZHJhdyB0aGUgYXJlYSBvZiB0aGUgc3ViY2hhcnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggaW4gc3ViY2hhcnQgbGluZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRyYW5zaXRpb24gZHVyYXRpb25cbiAgICovXG4gIHJlZHJhd0FyZWFGb3JTdWJjaGFydDogZnVuY3Rpb24gcmVkcmF3QXJlYUZvclN1YmNoYXJ0KGRyYXdBcmVhT25TdWIsIHdpdGhUcmFuc2l0aW9uLCBkdXJhdGlvbikge1xuICAgIHZhciBjb250ZXh0QXJlYSA9IHdpdGhUcmFuc2l0aW9uID8gdGhpcy5jb250ZXh0QXJlYS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKS5kdXJhdGlvbihkdXJhdGlvbikgOiB0aGlzLmNvbnRleHRBcmVhO1xuICAgIGNvbnRleHRBcmVhLmF0dHIoXCJkXCIsIGRyYXdBcmVhT25TdWIpLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmNvbG9yKS5zdHlsZShcIm9wYWNpdHlcIiwgdGhpcy5vcmdBcmVhT3BhY2l0eSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZHJhdyBzdWJjaGFydC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aXRoU3ViY2hhcnQgd2hldGhlciBvciBub3QgdG8gc2hvdyBzdWJjaGFydFxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gZHVyYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IHNoYXBlIFNoYXBlJ3MgaW5mb1xuICAgKi9cbiAgcmVkcmF3U3ViY2hhcnQ6IGZ1bmN0aW9uIHJlZHJhd1N1YmNoYXJ0KHdpdGhTdWJjaGFydCwgZHVyYXRpb24sIHNoYXBlKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICQkLmNvbnRleHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5zdWJjaGFydF9zaG93ID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKSwgY29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgKGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJldmVudFwiXSAmJiBleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wiZXZlbnRcIl0udHlwZSA9PT0gXCJ6b29tXCIgJiYgJCQuYnJ1c2gudXBkYXRlKCksIHdpdGhTdWJjaGFydCAmJiAoIWJydXNoRW1wdHkoJCQpICYmICQkLmJydXNoLnVwZGF0ZSgpLCBPYmplY3Qua2V5cyhzaGFwZS50eXBlKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICB2YXIgbmFtZSA9IGNhcGl0YWxpemUodiksXG4gICAgICAgICAgZHJhdyA9ICQkW1wiZ2VuZXJhdGVEcmF3XCIuY29uY2F0KG5hbWUpXShzaGFwZS5pbmRpY2VzW3ZdLCAhMCk7XG4gICAgICAkJFtcInVwZGF0ZVwiLmNvbmNhdChuYW1lLCBcIkZvclN1YmNoYXJ0XCIpXShkdXJhdGlvbiksICQkW1wicmVkcmF3XCIuY29uY2F0KG5hbWUsIFwiRm9yU3ViY2hhcnRcIildKGRyYXcsIGR1cmF0aW9uLCBkdXJhdGlvbik7XG4gICAgfSkpKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVkcmF3IHRoZSBicnVzaC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlZHJhd0ZvckJydXNoOiBmdW5jdGlvbiByZWRyYXdGb3JCcnVzaCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuICAgICQkLnJlZHJhdyh7XG4gICAgICB3aXRoVHJhbnNpdGlvbjogITEsXG4gICAgICB3aXRoWTogJCQuY29uZmlnLnpvb21fcmVzY2FsZSxcbiAgICAgIHdpdGhTdWJjaGFydDogITEsXG4gICAgICB3aXRoVXBkYXRlWERvbWFpbjogITAsXG4gICAgICB3aXRoRGltZW5zaW9uOiAhMVxuICAgIH0pLCAkJC5jb25maWcuc3ViY2hhcnRfb25icnVzaC5jYWxsKCQkLmFwaSwgJCQueC5vcmdEb21haW4oKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBjb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5kaWNhdGVzIHRyYW5zaXRpb24gaXMgZW5hYmxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZ2VuZXJhdGVUcmFuc2l0aW9ucyBtZXRob2Qgb2YgQXhpcy5cbiAgICovXG4gIHRyYW5zZm9ybUNvbnRleHQ6IGZ1bmN0aW9uIHRyYW5zZm9ybUNvbnRleHQod2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKSB7XG4gICAgdmFyIHN1YlhBeGlzLFxuICAgICAgICAkJCA9IHRoaXM7XG4gICAgdHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1N1YlggPyBzdWJYQXhpcyA9IHRyYW5zaXRpb25zLmF4aXNTdWJYIDogKHN1YlhBeGlzID0gJCQuY29udGV4dC5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmF4aXNYKSksIHdpdGhUcmFuc2l0aW9uICYmIChzdWJYQXhpcyA9IHN1YlhBeGlzLnRyYW5zaXRpb24oKSkpLCAkJC5jb250ZXh0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiY29udGV4dFwiKSksIHN1YlhBeGlzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwic3VieFwiKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBleHRlbnQgdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0FycmF5fSBkZWZhdWx0IGV4dGVudFxuICAgKi9cbiAgZ2V0RXh0ZW50OiBmdW5jdGlvbiBnZXRFeHRlbnQoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgZXh0ZW50ID0gJCQuY29uZmlnLmF4aXNfeF9leHRlbnQ7XG4gICAgcmV0dXJuIGV4dGVudCAmJiAoaXNGdW5jdGlvbihleHRlbnQpID8gZXh0ZW50ID0gZXh0ZW50KCQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKSwgJCQuc3ViWCkgOiAkJC5pc1RpbWVTZXJpZXMoKSAmJiBleHRlbnQuZXZlcnkoaXNOYU4pICYmIChleHRlbnQgPSBleHRlbnQubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gJCQuc3ViWCgkJC5wYXJzZURhdGUodikpO1xuICAgIH0pKSksIGV4dGVudDtcbiAgfVxufSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy16b29tXCIsXCJjb21tb25qczJcIjpcImQzLXpvb21cIixcImFtZFwiOlwiZDMtem9vbVwiLFwicm9vdFwiOlwiZDNcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc19kM196b29tX2NvbW1vbmpzMl9kM196b29tX2FtZF9kM196b29tX3Jvb3RfZDNfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ludGVyYWN0aW9ucy96b29tLmpzXG5cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuXG5cblxuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB6b29tLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdFpvb206IGZ1bmN0aW9uIGluaXRab29tKCkge1xuICAgIHZhciAkJCA9IHRoaXM7XG4gICAgJCQuem9vbVNjYWxlID0gbnVsbCwgJCQuZ2VuZXJhdGVab29tKCksICQkLmluaXRab29tQmVoYXZpb3VyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJpbmQgem9vbSBldmVudFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGJpbmQgV2VhdGhlciBiaW5kIG9yIHVuYm91bmRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRab29tRXZlbnQ6IGZ1bmN0aW9uIGJpbmRab29tRXZlbnQoKSB7XG4gICAgdmFyIGJpbmQgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkKSB8fCBhcmd1bWVudHNbMF0sXG4gICAgICAgICQkID0gdGhpcyxcbiAgICAgICAgem9vbUVuYWJsZWQgPSAkJC5jb25maWcuem9vbV9lbmFibGVkO1xuICAgICQkLnJlZHJhd0V2ZW50UmVjdCgpO1xuICAgIHZhciBldmVudFJlY3RzID0gJCQubWFpbi5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmV2ZW50UmVjdHMpKTtcbiAgICB6b29tRW5hYmxlZCAmJiBiaW5kID8gISQkLmNvbmZpZy5zdWJjaGFydF9zaG93ICYmICQkLmJpbmRab29tT25FdmVudFJlY3QoZXZlbnRSZWN0cywgem9vbUVuYWJsZWQudHlwZSkgOiBiaW5kID09PSAhMSAmJiAoJCQuYXBpLnVuem9vbSgpLCBldmVudFJlY3RzLm9uKFwiLnpvb21cIiwgbnVsbCkub24oXCIuZHJhZ1wiLCBudWxsKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHpvb21cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdlbmVyYXRlWm9vbTogZnVuY3Rpb24gZ2VuZXJhdGVab29tKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgem9vbSA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM196b29tX2NvbW1vbmpzMl9kM196b29tX2FtZF9kM196b29tX3Jvb3RfZDNfW1wiem9vbVwiXSkoKS5kdXJhdGlvbigwKS5vbihcInN0YXJ0XCIsICQkLm9uWm9vbVN0YXJ0LmJpbmQoJCQpKS5vbihcInpvb21cIiwgJCQub25ab29tLmJpbmQoJCQpKS5vbihcImVuZFwiLCAkJC5vblpvb21FbmQuYmluZCgkJCkpO1xuICAgIC8vIGdldCB6b29tIGV4dGVudFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHNjYWxlIGFjY29yZGluZyB6b29tIHRyYW5zZm9ybSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHpvb20ub3JnU2NhbGVFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXh0ZW50ID0gY29uZmlnLnpvb21fZXh0ZW50IHx8IFsxLCAxMF07XG4gICAgICByZXR1cm4gW2V4dGVudFswXSwgTWF0aC5tYXgoJCQuZ2V0TWF4RGF0YUNvdW50KCkgLyBleHRlbnRbMV0sIGV4dGVudFsxXSldO1xuICAgIH0sIHpvb20udXBkYXRlU2NhbGVFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmF0aW8gPSBkaWZmRG9tYWluKCQkLngub3JnRG9tYWluKCkpIC8gZGlmZkRvbWFpbigkJC5nZXRab29tRG9tYWluKCkpLFxuICAgICAgICAgIGV4dGVudCA9IHRoaXMub3JnU2NhbGVFeHRlbnQoKTtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlRXh0ZW50KFtleHRlbnRbMF0gKiByYXRpbywgZXh0ZW50WzFdICogcmF0aW9dKSwgdGhpcztcbiAgICB9LCB6b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlID0gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgJCQub3JnWFNjYWxlICYmICQkLm9yZ1hTY2FsZS5yYW5nZSgkJC54LnJhbmdlKCkpO1xuICAgICAgLy8gcmVzY2FsZSBmcm9tIHRoZSBvcmlnaW5hbCBzY2FsZVxuICAgICAgdmFyIG5ld1NjYWxlID0gdHJhbnNmb3JtW2NvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInJlc2NhbGVZXCIgOiBcInJlc2NhbGVYXCJdKCQkLm9yZ1hTY2FsZSB8fCAkJC54KSxcbiAgICAgICAgICBkb21haW4gPSAkJC50cmltWERvbWFpbihuZXdTY2FsZS5kb21haW4oKSksXG4gICAgICAgICAgcmVzY2FsZSA9IGNvbmZpZy56b29tX3Jlc2NhbGU7XG4gICAgICBuZXdTY2FsZS5kb21haW4oZG9tYWluLCAkJC5vcmdYRG9tYWluKSwgJCQuem9vbVNjYWxlID0gJCQuZ2V0Q3VzdG9taXplZFNjYWxlKG5ld1NjYWxlKSwgJCQueEF4aXMuc2NhbGUoJCQuem9vbVNjYWxlKSwgcmVzY2FsZSAmJiAoISQkLm9yZ1hTY2FsZSAmJiAoJCQub3JnWFNjYWxlID0gJCQueC5jb3B5KCkpLCAkJC54LmRvbWFpbihkb21haW4pKTtcbiAgICB9LCAkJC56b29tID0gem9vbTtcbiAgfSxcblxuICAvKipcbiAgICogJ3N0YXJ0JyBldmVudCBsaXN0ZW5lclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25ab29tU3RhcnQ6IGZ1bmN0aW9uIG9uWm9vbVN0YXJ0KCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGV2ZW50ID0gZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcImV2ZW50XCJdLnNvdXJjZUV2ZW50O1xuICAgIGV2ZW50ICYmICgkJC56b29tLnN0YXJ0RXZlbnQgPSBldmVudCwgY2FsbEZuKCQkLmNvbmZpZy56b29tX29uem9vbXN0YXJ0LCAkJC5hcGksIGV2ZW50KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqICd6b29tJyBldmVudCBsaXN0ZW5lclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25ab29tOiBmdW5jdGlvbiBvblpvb20oKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBldmVudCA9IGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJldmVudFwiXSxcbiAgICAgICAgc291cmNlRXZlbnQgPSBldmVudC5zb3VyY2VFdmVudDtcblxuICAgIGlmIChjb25maWcuem9vbV9lbmFibGVkICYmIGV2ZW50LnNvdXJjZUV2ZW50ICYmICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGggIT09IDAgJiYgKCQkLnpvb21TY2FsZSB8fCAhKHNvdXJjZUV2ZW50LnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID4gLTEpIHx8IHNvdXJjZUV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAxKSkge1xuICAgICAgdmFyIGlzTW91c2Vtb3ZlID0gc291cmNlRXZlbnQudHlwZSA9PT0gXCJtb3VzZW1vdmVcIixcbiAgICAgICAgICBpc1pvb21PdXQgPSBzb3VyY2VFdmVudC53aGVlbERlbHRhIDwgMCxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBldmVudC50cmFuc2Zvcm07XG4gICAgICAhaXNNb3VzZW1vdmUgJiYgaXNab29tT3V0ICYmICQkLnguZG9tYWluKCkuZXZlcnkoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgcmV0dXJuIHYgIT09ICQkLm9yZ1hEb21haW5baV07XG4gICAgICB9KSAmJiAkJC54LmRvbWFpbigkJC5vcmdYRG9tYWluKSwgJCQuem9vbS51cGRhdGVUcmFuc2Zvcm1TY2FsZSh0cmFuc2Zvcm0pLCAkJC5pc0NhdGVnb3JpemVkKCkgJiYgJCQueC5vcmdEb21haW4oKVswXSA9PT0gJCQub3JnWERvbWFpblswXSAmJiAkJC54LmRvbWFpbihbJCQub3JnWERvbWFpblswXSAtIDFlLTEwLCAkJC54Lm9yZ0RvbWFpbigpWzFdXSksICQkLnJlZHJhdyh7XG4gICAgICAgIHdpdGhUcmFuc2l0aW9uOiAhMSxcbiAgICAgICAgd2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGUsXG4gICAgICAgIHdpdGhTdWJjaGFydDogITEsXG4gICAgICAgIHdpdGhFdmVudFJlY3Q6ICExLFxuICAgICAgICB3aXRoRGltZW5zaW9uOiAhMVxuICAgICAgfSksICQkLmNhbmNlbENsaWNrID0gaXNNb3VzZW1vdmUsIGNhbGxGbihjb25maWcuem9vbV9vbnpvb20sICQkLmFwaSwgJCQuem9vbVNjYWxlLmRvbWFpbigpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqICdlbmQnIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblpvb21FbmQ6IGZ1bmN0aW9uIG9uWm9vbUVuZCgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBzdGFydEV2ZW50ID0gJCQuem9vbS5zdGFydEV2ZW50LFxuICAgICAgICBldmVudCA9IGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJldmVudFwiXSAmJiBleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wiZXZlbnRcIl0uc291cmNlRXZlbnQ7XG4gICAgc3RhcnRFdmVudCAmJiBzdGFydEV2ZW50LnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID4gLTEgJiYgKHN0YXJ0RXZlbnQgPSBzdGFydEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLCBldmVudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKTtcbiAgICAvLyBpZiBjbGljaywgZG8gbm90aGluZy4gb3RoZXJ3aXNlLCBjbGljayBpbnRlcmFjdGlvbiB3aWxsIGJlIGNhbmNlbGVkLlxuICAgICFzdGFydEV2ZW50IHx8IGV2ZW50ICYmIHN0YXJ0RXZlbnQuY2xpZW50WCA9PT0gZXZlbnQuY2xpZW50WCAmJiBzdGFydEV2ZW50LmNsaWVudFkgPT09IGV2ZW50LmNsaWVudFkgfHwgKCQkLnJlZHJhd0V2ZW50UmVjdCgpLCAkJC51cGRhdGVab29tKCksIGNhbGxGbigkJC5jb25maWcuem9vbV9vbnpvb21lbmQsICQkLmFwaSwgJCRbJCQuem9vbVNjYWxlID8gXCJ6b29tU2NhbGVcIiA6IFwic3ViWFwiXS5kb21haW4oKSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgem9vbSBkb21haW5cbiAgICogQHJldHVybnMge0FycmF5fSB6b29tIGRvbWFpblxuICBcdCAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRab29tRG9tYWluOiBmdW5jdGlvbiBnZXRab29tRG9tYWluKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgXyQkJG9yZ1hEb21haW4gPSBfc2xpY2VkVG9BcnJheSgkJC5vcmdYRG9tYWluLCAyKSxcbiAgICAgICAgbWluID0gXyQkJG9yZ1hEb21haW5bMF0sXG4gICAgICAgIG1heCA9IF8kJCRvcmdYRG9tYWluWzFdO1xuXG4gICAgcmV0dXJuIGlzRGVmaW5lZChjb25maWcuem9vbV94X21pbikgJiYgKG1pbiA9IGdldE1pbk1heChcIm1pblwiLCBbbWluLCBjb25maWcuem9vbV94X21pbl0pKSwgaXNEZWZpbmVkKGNvbmZpZy56b29tX3hfbWF4KSAmJiAobWF4ID0gZ2V0TWluTWF4KFwibWF4XCIsIFttYXgsIGNvbmZpZy56b29tX3hfbWF4XSkpLCBbbWluLCBtYXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgem9vbVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIHVuem9vbVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlWm9vbTogZnVuY3Rpb24gdXBkYXRlWm9vbShmb3JjZSkge1xuICAgIHZhciAkJCA9IHRoaXM7XG5cbiAgICBpZiAoJCQuem9vbVNjYWxlKSB7XG4gICAgICB2YXIgem9vbURvbWFpbiA9ICQkLnpvb21TY2FsZS5kb21haW4oKSxcbiAgICAgICAgICB4RG9tYWluID0gJCQuc3ViWC5kb21haW4oKSxcbiAgICAgICAgICBkZWx0YSA9IC4wMTUsXG4gICAgICAgICAgaXNmdWxseVNob3duID0gKHpvb21Eb21haW5bMF0gPD0geERvbWFpblswXSB8fCB6b29tRG9tYWluWzBdIC0gZGVsdGEgPD0geERvbWFpblswXSkgJiYgKHhEb21haW5bMV0gPD0gem9vbURvbWFpblsxXSB8fCB4RG9tYWluWzFdIDw9IHpvb21Eb21haW5bMV0gLSBkZWx0YSk7XG4gICAgICAoZm9yY2UgfHwgaXNmdWxseVNob3duKSAmJiAoJCQueEF4aXMuc2NhbGUoJCQuc3ViWCksICQkLnguZG9tYWluKCQkLnN1Ylgub3JnRG9tYWluKCkpLCAkJC56b29tU2NhbGUgPSBudWxsKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEF0dGFjaCB6b29tIGV2ZW50IG9uIDxyZWN0PlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmluZFpvb21PbkV2ZW50UmVjdDogZnVuY3Rpb24gYmluZFpvb21PbkV2ZW50UmVjdChldmVudFJlY3RzLCB0eXBlKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgYmVoYXZpb3VyID0gdHlwZSA9PT0gXCJkcmFnXCIgPyAkJC56b29tQmVoYXZpb3VyIDogJCQuem9vbTtcbiAgICBldmVudFJlY3RzLmNhbGwoYmVoYXZpb3VyKS5vbihcImRibGNsaWNrLnpvb21cIiwgbnVsbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGRyYWcgYmVoYXZpb3VyIHVzZWQgZm9yIHpvb21pbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0Wm9vbUJlaGF2aW91cjogZnVuY3Rpb24gaW5pdFpvb21CZWhhdmlvdXIoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkLFxuICAgICAgICBzdGFydCA9IDAsXG4gICAgICAgIGVuZCA9IDAsXG4gICAgICAgIHpvb21SZWN0ID0gbnVsbCxcbiAgICAgICAgcHJvcCA9IHtcbiAgICAgIGF4aXM6IGlzUm90YXRlZCA/IFwieVwiIDogXCJ4XCIsXG4gICAgICBhdHRyOiBpc1JvdGF0ZWQgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLFxuICAgICAgaW5kZXg6IGlzUm90YXRlZCA/IDEgOiAwXG4gICAgfTtcbiAgICAkJC56b29tQmVoYXZpb3VyID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX2RyYWdfY29tbW9uanMyX2QzX2RyYWdfYW1kX2QzX2RyYWdfcm9vdF9kM19bXCJkcmFnXCJdKSgpLmNsaWNrRGlzdGFuY2UoNCkub24oXCJzdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkJC5zZXREcmFnU3RhdHVzKCEwKSwgem9vbVJlY3QgfHwgKHpvb21SZWN0ID0gJCQubWFpbi5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGlwLXBhdGhcIiwgJCQuY2xpcFBhdGgpLmF0dHIoXCJjbGFzc1wiLCBjb25maWdfY2xhc3Nlcy56b29tQnJ1c2gpLmF0dHIoXCJ3aWR0aFwiLCBpc1JvdGF0ZWQgPyAkJC53aWR0aCA6IDApLmF0dHIoXCJoZWlnaHRcIiwgaXNSb3RhdGVkID8gMCA6ICQkLmhlaWdodCkpLCBzdGFydCA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wibW91c2VcIl0pKHRoaXMpW3Byb3AuaW5kZXhdLCBlbmQgPSBzdGFydCwgem9vbVJlY3QuYXR0cihwcm9wLmF4aXMsIHN0YXJ0KS5hdHRyKHByb3AuYXR0ciwgMCksICQkLm9uWm9vbVN0YXJ0KCk7XG4gICAgfSkub24oXCJkcmFnXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVuZCA9IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wibW91c2VcIl0pKHRoaXMpW3Byb3AuaW5kZXhdLCB6b29tUmVjdC5hdHRyKHByb3AuYXhpcywgTWF0aC5taW4oc3RhcnQsIGVuZCkpLmF0dHIocHJvcC5hdHRyLCBNYXRoLmFicyhlbmQgLSBzdGFydCkpO1xuICAgIH0pLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmLFxuICAgICAgICAgIHNjYWxlID0gJCQuem9vbVNjYWxlIHx8ICQkLng7XG5cbiAgICAgIGlmICgkJC5zZXREcmFnU3RhdHVzKCExKSwgem9vbVJlY3QuYXR0cihwcm9wLmF4aXMsIDApLmF0dHIocHJvcC5hdHRyLCAwKSwgc3RhcnQgPiBlbmQgJiYgKF9yZWYgPSBbZW5kLCBzdGFydF0sIHN0YXJ0ID0gX3JlZlswXSwgZW5kID0gX3JlZlsxXSwgX3JlZiksIHN0YXJ0IDwgMCAmJiAoZW5kICs9IE1hdGguYWJzKHN0YXJ0KSwgc3RhcnQgPSAwKSwgc3RhcnQgIT09IGVuZCkgJCQuYXBpLnpvb20oW3N0YXJ0LCBlbmRdLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gc2NhbGUuaW52ZXJ0KHYpO1xuICAgICAgfSkpLCAkJC5vblpvb21FbmQoKTtlbHNlIGlmICgkJC5pc011bHRpcGxlWCgpKSAkJC5jbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTLmJpbmQodGhpcykoJCQpO2Vsc2Uge1xuICAgICAgICB2YXIgX2V2ZW50ID0gZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcImV2ZW50XCJdLnNvdXJjZUV2ZW50IHx8IGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJldmVudFwiXSxcbiAgICAgICAgICAgIF9yZWYyID0gXCJjbGllbnRYXCIgaW4gX2V2ZW50ID8gW19ldmVudC5jbGllbnRYLCBfZXZlbnQuY2xpZW50WV0gOiBbX2V2ZW50LngsIF9ldmVudC55XSxcbiAgICAgICAgICAgIF9yZWYzID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIsIDIpLFxuICAgICAgICAgICAgeCA9IF9yZWYzWzBdLFxuICAgICAgICAgICAgeSA9IF9yZWYzWzFdLFxuICAgICAgICAgICAgdGFyZ2V0ID0gYnJvd3Nlcl9kb2MuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcblxuICAgICAgICAkJC5jbGlja0hhbmRsZXJGb3JTaW5nbGVYLmJpbmQodGFyZ2V0KShPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGFyZ2V0KS5kYXR1bSgpLCAkJCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHNldFpvb21SZXNldEJ1dHRvbjogZnVuY3Rpb24gc2V0Wm9vbVJlc2V0QnV0dG9uKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgcmVzZXRCdXR0b24gPSBjb25maWcuem9vbV9yZXNldEJ1dHRvbjtcbiAgICByZXNldEJ1dHRvbiAmJiBjb25maWcuem9vbV9lbmFibGVkLnR5cGUgPT09IFwiZHJhZ1wiICYmICgkJC56b29tLnJlc2V0QnRuID8gJCQuem9vbS5yZXNldEJ0bi5zdHlsZShcImRpc3BsYXlcIiwgbnVsbCkgOiAkJC56b29tLnJlc2V0QnRuID0gJCQuc2VsZWN0Q2hhcnQuYXBwZW5kKFwiZGl2XCIpLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuYnV0dG9uLCAhMCkuYXBwZW5kKFwic3BhblwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzRnVuY3Rpb24ocmVzZXRCdXR0b24ub25jbGljaykgJiYgcmVzZXRCdXR0b24ub25jbGljayh0aGlzKSwgJCQuYXBpLnVuem9vbS5jYWxsKCQkKTtcbiAgICB9KS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmJ1dHRvblpvb21SZXNldCwgITApLnRleHQocmVzZXRCdXR0b24udGV4dCB8fCBcIlJlc2V0IFpvb21cIikpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ludGVybmFscy9jb2xvci5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuXG5cblxuLyoqXG4gKiBTZXQgcGF0dGVybidzIGJhY2tncm91bmQgY29sb3JcbiAqIChpdCBhZGRzIGEgPHJlY3Q+IGVsZW1lbnQgdG8gc2ltdWxhdGUgYmctY29sb3IpXG4gKiBAcGFyYW0ge1NWR1BhdHRlcm5FbGVtZW50fSBwYXR0ZXJuIFNWRyBwYXR0ZXJuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBJRCB0byBiZSBzZXRcbiAqIEByZXR1cm4ge3tpZDogc3RyaW5nLCBub2RlOiBTVkdQYXR0ZXJuRWxlbWVudH19XG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBjb2xvcml6ZVBhdHRlcm4gPSBmdW5jdGlvbiAocGF0dGVybiwgY29sb3IsIGlkKSB7XG4gIHZhciBub2RlID0gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHBhdHRlcm4uY2xvbmVOb2RlKCEwKSk7XG4gIHJldHVybiBub2RlLmF0dHIoXCJpZFwiLCBpZCkuaW5zZXJ0KFwicmVjdFwiLCBcIjpmaXJzdC1jaGlsZFwiKS5hdHRyKFwid2lkdGhcIiwgbm9kZS5hdHRyKFwid2lkdGhcIikpLmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5hdHRyKFwiaGVpZ2h0XCIpKS5zdHlsZShcImZpbGxcIiwgY29sb3IpLCB7XG4gICAgaWQ6IGlkLFxuICAgIG5vZGU6IG5vZGUubm9kZSgpXG4gIH07XG59LFxuICAgIHNjaGVtZUNhdGVnb3J5MTAgPSBbXCIjMWY3N2I0XCIsIFwiI2ZmN2YwZVwiLCBcIiMyY2EwMmNcIiwgXCIjZDYyNzI4XCIsIFwiIzk0NjdiZFwiLCBcIiM4YzU2NGJcIiwgXCIjZTM3N2MyXCIsIFwiIzdmN2Y3ZlwiLCBcIiNiY2JkMjJcIiwgXCIjMTdiZWNmXCJdOyAvLyBSZXBsYWNlbWVudCBvZiBkMy5zY2hlbWVDYXRlZ29yeTEwLlxuLy8gQ29udGFpbmVkIGRpZmZlcmVudGx5IGRlcGVuZCBvbiBkMyB2ZXJzaW9uOiB2NChkMy1zY2FsZSksIHY1KGQzLXNjYWxlLWNocm9tYXRpYylcblxuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogR2V0IGNvbG9yIHBhdHRlcm4gZnJvbSBDU1MgZmlsZVxuICAgKiBDU1Mgc2hvdWxkIGJlIGRlZmluZWQgYXM6IGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiMwMGM3M2M7I2ZhNzE3MTsgLi4uXCIpO1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldENvbG9yRnJvbUNzczogZnVuY3Rpb24gZ2V0Q29sb3JGcm9tQ3NzKCkge1xuICAgIHZhciBib2R5ID0gYnJvd3Nlcl9kb2MuYm9keSxcbiAgICAgICAgcGF0dGVybiA9IGJvZHlbXCJfX2NvbG9yUGF0dGVybl9fXCJdO1xuXG4gICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICB2YXIgc3BhbiA9IGJyb3dzZXJfZG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3Bhbi5jbGFzc05hbWUgPSBjb25maWdfY2xhc3Nlcy5jb2xvclBhdHRlcm4sIHNwYW4uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCBib2R5LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgdmFyIGNvbnRlbnQgPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZShzcGFuKS5iYWNrZ3JvdW5kSW1hZ2U7XG4gICAgICBzcGFuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3BhbiksIGNvbnRlbnQuaW5kZXhPZihcIjtcIikgPiAtMSAmJiAocGF0dGVybiA9IGNvbnRlbnQucmVwbGFjZSgvdXJsW14jXSp8W1wiJygpXXwoXFxzfCUyMCkvZywgXCJcIikuc3BsaXQoXCI7XCIpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi50cmltKCkucmVwbGFjZSgvW1xcXCInXFxzXS9nLCBcIlwiKTtcbiAgICAgIH0pLmZpbHRlcihCb29sZWFuKSwgYm9keVtcIl9fY29sb3JQYXR0ZXJuX19cIl0gPSBwYXR0ZXJuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfSxcbiAgZ2VuZXJhdGVDb2xvcjogZnVuY3Rpb24gZ2VuZXJhdGVDb2xvcigpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIGNvbG9ycyA9IGNvbmZpZy5kYXRhX2NvbG9ycyxcbiAgICAgICAgY2FsbGJhY2sgPSBjb25maWcuZGF0YV9jb2xvcixcbiAgICAgICAgaWRzID0gW10sXG4gICAgICAgIHBhdHRlcm4gPSBub3RFbXB0eShjb25maWcuY29sb3JfcGF0dGVybikgPyBjb25maWcuY29sb3JfcGF0dGVybiA6IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zY2FsZV9jb21tb25qczJfZDNfc2NhbGVfYW1kX2QzX3NjYWxlX3Jvb3RfZDNfW1wic2NhbGVPcmRpbmFsXCJdKSgkJC5nZXRDb2xvckZyb21Dc3MoKSB8fCBzY2hlbWVDYXRlZ29yeTEwKS5yYW5nZSgpLFxuICAgICAgICBvcmlnaW5hbENvbG9yUGF0dGVybiA9IHBhdHRlcm47XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjb25maWcuY29sb3JfdGlsZXMpKSB7XG4gICAgICB2YXIgdGlsZXMgPSBjb25maWcuY29sb3JfdGlsZXMoKSxcbiAgICAgICAgICBjb2xvcml6ZWRQYXR0ZXJucyA9IHBhdHRlcm4ubWFwKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICB2YXIgY29sb3IgPSBwLnJlcGxhY2UoL1sjXFwoXFwpXFxzLF0vZywgXCJcIiksXG4gICAgICAgICAgICBpZCA9IFwiXCIuY29uY2F0KCQkLmRhdGV0aW1lSWQsIFwiLXBhdHRlcm4tXCIpLmNvbmNhdChjb2xvciwgXCItXCIpLmNvbmNhdChpbmRleCk7XG4gICAgICAgIHJldHVybiBjb2xvcml6ZVBhdHRlcm4odGlsZXNbaW5kZXggJSB0aWxlcy5sZW5ndGhdLCBwLCBpZCk7XG4gICAgICB9KTsgLy8gQWRkIGJhY2tncm91bmQgY29sb3IgdG8gcGF0dGVybnNcblxuICAgICAgcGF0dGVybiA9IGNvbG9yaXplZFBhdHRlcm5zLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gXCJ1cmwoI1wiLmNvbmNhdChwLmlkLCBcIilcIik7XG4gICAgICB9KSwgJCQucGF0dGVybnMgPSBjb2xvcml6ZWRQYXR0ZXJucztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBjb2xvcixcbiAgICAgICAgICBpZCA9IGQuaWQgfHwgZC5kYXRhICYmIGQuZGF0YS5pZCB8fCBkLFxuICAgICAgICAgIGlzTGluZSA9ICQkLmlzVHlwZU9mKGlkLCBbXCJsaW5lXCIsIFwic3BsaW5lXCIsIFwic3RlcFwiXSkgfHwgISQkLmNvbmZpZy5kYXRhX3R5cGVzW2lkXTtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbG9yc1tpZF0pID8gY29sb3IgPSBjb2xvcnNbaWRdKGQpIDogY29sb3JzW2lkXSA/IGNvbG9yID0gY29sb3JzW2lkXSA6IChpZHMuaW5kZXhPZihpZCkgPCAwICYmIGlkcy5wdXNoKGlkKSwgY29sb3IgPSBpc0xpbmUgPyBvcmlnaW5hbENvbG9yUGF0dGVybltpZHMuaW5kZXhPZihpZCkgJSBvcmlnaW5hbENvbG9yUGF0dGVybi5sZW5ndGhdIDogcGF0dGVybltpZHMuaW5kZXhPZihpZCkgJSBwYXR0ZXJuLmxlbmd0aF0sIGNvbG9yc1tpZF0gPSBjb2xvciksIGlzRnVuY3Rpb24oY2FsbGJhY2spID8gY2FsbGJhY2soY29sb3IsIGQpIDogY29sb3I7XG4gICAgfTtcbiAgfSxcbiAgZ2VuZXJhdGVMZXZlbENvbG9yOiBmdW5jdGlvbiBnZW5lcmF0ZUxldmVsQ29sb3IoKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBjb2xvcnMgPSBjb25maWcuY29sb3JfcGF0dGVybixcbiAgICAgICAgdGhyZXNob2xkID0gY29uZmlnLmNvbG9yX3RocmVzaG9sZCxcbiAgICAgICAgYXNWYWx1ZSA9IHRocmVzaG9sZC51bml0ID09PSBcInZhbHVlXCIsXG4gICAgICAgIG1heCA9IHRocmVzaG9sZC5tYXggfHwgMTAwLFxuICAgICAgICB2YWx1ZXMgPSB0aHJlc2hvbGQudmFsdWVzICYmIHRocmVzaG9sZC52YWx1ZXMubGVuZ3RoID8gdGhyZXNob2xkLnZhbHVlcyA6IFtdO1xuICAgIHJldHVybiBub3RFbXB0eSh0aHJlc2hvbGQpID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgdiA9IGFzVmFsdWUgPyB2YWx1ZSA6IHZhbHVlICogMTAwIC8gbWF4LFxuICAgICAgICAgIGNvbG9yID0gY29sb3JzW2NvbG9ycy5sZW5ndGggLSAxXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSBpZiAodiA8PSB2YWx1ZXNbaV0pIHtcbiAgICAgICAgY29sb3IgPSBjb2xvcnNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfSA6IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGF0YSBvdmVyIGNvbG9yLlxuICAgKiBXaGVuIGlzIG91dCwgd2lsbCByZXN0b3JlIGluIGl0cyBwcmV2aW91cyBjb2xvciB2YWx1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3ZlciB0cnVlOiBzZXQgb3ZlcmVkIGNvbG9yLCBmYWxzZTogcmVzdG9yZVxuICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IGQgdGFyZ2V0IGluZGV4IG9yIGRhdGEgb2JqZWN0IGZvciBBcmMgdHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0T3ZlckNvbG9yOiBmdW5jdGlvbiBzZXRPdmVyQ29sb3IoaXNPdmVyLCBkKSB7XG4gICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBvbm92ZXIgPSBjb25maWcuY29sb3Jfb25vdmVyLFxuICAgICAgICBjb2xvciA9IGlzT3ZlciA/IG9ub3ZlciA6ICQkLmNvbG9yO1xuICAgIGlzT2JqZWN0KGNvbG9yKSA/IGNvbG9yID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYuaWQ7XG4gICAgICByZXR1cm4gaWQgaW4gb25vdmVyID8gb25vdmVyW2lkXSA6ICQkLmNvbG9yKGlkKTtcbiAgICB9IDogaXNTdHJpbmcoY29sb3IpICYmIChjb2xvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbm92ZXI7XG4gICAgfSksIGlzT2JqZWN0KGQpID8gJCQubWFpbi5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmFyYykuY29uY2F0KCQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpKSkuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKGQpKSA6ICQkLm1haW4uc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5zaGFwZSwgXCItXCIpLmNvbmNhdChkKSkuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbnRlcm5hbHMvZm9ybWF0LmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuXG52YXIgZ2V0Rm9ybWF0ID0gZnVuY3Rpb24gKCQkLCB0eXBlVmFsdWUsIHYpIHtcbiAgdmFyIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgIHR5cGUgPSBcImF4aXNfXCIuY29uY2F0KHR5cGVWYWx1ZSwgXCJfdGlja19mb3JtYXRcIiksXG4gICAgICBmb3JtYXQgPSBjb25maWdbdHlwZV0gPyBjb25maWdbdHlwZV0gOiAkJC5kZWZhdWx0VmFsdWVGb3JtYXQ7XG4gIHJldHVybiBmb3JtYXQodik7XG59O1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICBnZXRZRm9ybWF0OiBmdW5jdGlvbiBnZXRZRm9ybWF0KGZvckFyYykge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGZvcm1hdEZvclkgPSAkJC55Rm9ybWF0LFxuICAgICAgICBmb3JtYXRGb3JZMiA9ICQkLnkyRm9ybWF0O1xuICAgIHJldHVybiBmb3JBcmMgJiYgISQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAoZm9ybWF0Rm9yWSA9ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdCwgZm9ybWF0Rm9yWTIgPSAkJC5kZWZhdWx0QXJjVmFsdWVGb3JtYXQpLCBmdW5jdGlvbiAodiwgcmF0aW8sIGlkKSB7XG4gICAgICB2YXIgZm9ybWF0ID0gJCQuYXhpcy5nZXRJZChpZCkgPT09IFwieTJcIiA/IGZvcm1hdEZvclkyIDogZm9ybWF0Rm9yWTtcbiAgICAgIHJldHVybiBmb3JtYXQuY2FsbCgkJCwgdiwgcmF0aW8pO1xuICAgIH07XG4gIH0sXG4gIHlGb3JtYXQ6IGZ1bmN0aW9uIHlGb3JtYXQodikge1xuICAgIHJldHVybiBnZXRGb3JtYXQodGhpcywgXCJ5XCIsIHYpO1xuICB9LFxuICB5MkZvcm1hdDogZnVuY3Rpb24geTJGb3JtYXQodikge1xuICAgIHJldHVybiBnZXRGb3JtYXQodGhpcywgXCJ5MlwiLCB2KTtcbiAgfSxcbiAgZGVmYXVsdFZhbHVlRm9ybWF0OiBmdW5jdGlvbiBkZWZhdWx0VmFsdWVGb3JtYXQodikge1xuICAgIHJldHVybiBpc1ZhbHVlKHYpID8gK3YgOiBcIlwiO1xuICB9LFxuICBkZWZhdWx0QXJjVmFsdWVGb3JtYXQ6IGZ1bmN0aW9uIGRlZmF1bHRBcmNWYWx1ZUZvcm1hdCh2LCByYXRpbykge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCgocmF0aW8gKiAxMDApLnRvRml4ZWQoMSksIFwiJVwiKTtcbiAgfSxcbiAgZGF0YUxhYmVsRm9ybWF0OiBmdW5jdGlvbiBkYXRhTGFiZWxGb3JtYXQodGFyZ2V0SWQpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBkYXRhTGFiZWxzID0gJCQuY29uZmlnLmRhdGFfbGFiZWxzLFxuICAgICAgICBkZWZhdWx0Rm9ybWF0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBpc1ZhbHVlKHYpID8gK3YgOiBcIlwiO1xuICAgIH0sXG4gICAgICAgIGZvcm1hdCA9IGRlZmF1bHRGb3JtYXQ7XG5cbiAgICByZXR1cm4gaXNGdW5jdGlvbihkYXRhTGFiZWxzLmZvcm1hdCkgPyBmb3JtYXQgPSBkYXRhTGFiZWxzLmZvcm1hdCA6IGlzT2JqZWN0VHlwZShkYXRhTGFiZWxzLmZvcm1hdCkgJiYgKGRhdGFMYWJlbHMuZm9ybWF0W3RhcmdldElkXSA/IGZvcm1hdCA9IGRhdGFMYWJlbHMuZm9ybWF0W3RhcmdldElkXSA9PT0gITAgPyBkZWZhdWx0Rm9ybWF0IDogZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdIDogZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSksIGZvcm1hdDtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbnRlcm5hbHMvY2FjaGUuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQWRkIGNhY2hlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRGF0YVR5cGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZENhY2hlOiBmdW5jdGlvbiBhZGRDYWNoZShrZXksIHZhbHVlKSB7XG4gICAgdmFyIGlzRGF0YVR5cGUgPSAhIShhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCkgJiYgYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuY2FjaGVba2V5XSA9IGlzRGF0YVR5cGUgPyB0aGlzLmNsb25lVGFyZ2V0KHZhbHVlKSA6IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgY2FjaGVcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGtleVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVtb3ZlQ2FjaGU6IGZ1bmN0aW9uIHJlbW92ZUNhY2hlKGtleSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0b0FycmF5KGtleSkuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIGRlbGV0ZSBfdGhpcy5jYWNoZVt2XTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNhaGNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0RhdGFUeXBlXG4gICAqIEByZXR1cm4geyp9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRDYWNoZTogZnVuY3Rpb24gZ2V0Q2FjaGUoa2V5KSB7XG4gICAgdmFyIGlzRGF0YVR5cGUgPSAhIShhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCkgJiYgYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKGlzRGF0YVR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGlkLCBpID0gMDsgaWQgPSBrZXlbaV07IGkrKykgaWQgaW4gdGhpcy5jYWNoZSAmJiB0YXJnZXRzLnB1c2godGhpcy5jbG9uZVRhcmdldCh0aGlzLmNhY2hlW2lkXSkpO1xuXG4gICAgICByZXR1cm4gdGFyZ2V0cztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jYWNoZVtrZXldIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlc2V0IGNhY2hlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsIHRydWU6IHJlc2V0IGFsbCBkYXRhLCBmYWxzZTogcmVzZXQgb25seSAnJCcgcHJlZml4ZWQga2V5IGRhdGFcbiAgICogQHByaXZhdGVcbiAgXHQgKi9cbiAgcmVzZXRDYWNoZTogZnVuY3Rpb24gcmVzZXRDYWNoZShhbGwpIHtcbiAgICB2YXIgJCQgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgeCBpbiAkJC5jYWNoZSkgKGFsbCB8fCAvXlxcJC8udGVzdCh4KSkgJiYgKCQkLmNhY2hlW3hdID0gbnVsbCk7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaW50ZXJuYWxzL2NsYXNzLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICBnZW5lcmF0ZUNsYXNzOiBmdW5jdGlvbiBnZW5lcmF0ZUNsYXNzKHByZWZpeCwgdGFyZ2V0SWQpIHtcbiAgICByZXR1cm4gXCIgXCIuY29uY2F0KHByZWZpeCwgXCIgXCIpLmNvbmNhdChwcmVmaXggKyB0aGlzLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHRhcmdldElkKSk7XG4gIH0sXG4gIGNsYXNzVGV4dDogZnVuY3Rpb24gY2xhc3NUZXh0KGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKGNvbmZpZ19jbGFzc2VzLnRleHQsIGQuaW5kZXgpO1xuICB9LFxuICBjbGFzc1RleHRzOiBmdW5jdGlvbiBjbGFzc1RleHRzKGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKGNvbmZpZ19jbGFzc2VzLnRleHRzLCBkLmlkKTtcbiAgfSxcbiAgY2xhc3NTaGFwZTogZnVuY3Rpb24gY2xhc3NTaGFwZShkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhjb25maWdfY2xhc3Nlcy5zaGFwZSwgZC5pbmRleCk7XG4gIH0sXG4gIGNsYXNzU2hhcGVzOiBmdW5jdGlvbiBjbGFzc1NoYXBlcyhkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhjb25maWdfY2xhc3Nlcy5zaGFwZXMsIGQuaWQpO1xuICB9LFxuICBnZW5lcmF0ZUV4dHJhTGluZUNsYXNzOiBmdW5jdGlvbiBnZW5lcmF0ZUV4dHJhTGluZUNsYXNzKCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGNsYXNzZXMgPSAkJC5jb25maWcubGluZV9jbGFzc2VzIHx8IFtdLFxuICAgICAgICBpZHMgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBpZCA9IGQuaWQgfHwgZC5kYXRhICYmIGQuZGF0YS5pZCB8fCBkO1xuICAgICAgcmV0dXJuIGlkcy5pbmRleE9mKGlkKSA8IDAgJiYgaWRzLnB1c2goaWQpLCBjbGFzc2VzW2lkcy5pbmRleE9mKGlkKSAlIGNsYXNzZXMubGVuZ3RoXTtcbiAgICB9O1xuICB9LFxuICBjbGFzc0xpbmU6IGZ1bmN0aW9uIGNsYXNzTGluZShkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhjb25maWdfY2xhc3Nlcy5saW5lLCBkLmlkKTtcbiAgfSxcbiAgY2xhc3NMaW5lczogZnVuY3Rpb24gY2xhc3NMaW5lcyhkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoY29uZmlnX2NsYXNzZXMubGluZXMsIGQuaWQpO1xuICB9LFxuICBjbGFzc0NpcmNsZTogZnVuY3Rpb24gY2xhc3NDaXJjbGUoZCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoY29uZmlnX2NsYXNzZXMuY2lyY2xlLCBkLmluZGV4KTtcbiAgfSxcbiAgY2xhc3NDaXJjbGVzOiBmdW5jdGlvbiBjbGFzc0NpcmNsZXMoZCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKGNvbmZpZ19jbGFzc2VzLmNpcmNsZXMsIGQuaWQpO1xuICB9LFxuICBjbGFzc0JhcjogZnVuY3Rpb24gY2xhc3NCYXIoZCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoY29uZmlnX2NsYXNzZXMuYmFyLCBkLmluZGV4KTtcbiAgfSxcbiAgY2xhc3NCYXJzOiBmdW5jdGlvbiBjbGFzc0JhcnMoZCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKGNvbmZpZ19jbGFzc2VzLmJhcnMsIGQuaWQpO1xuICB9LFxuICBjbGFzc0FyYzogZnVuY3Rpb24gY2xhc3NBcmMoZCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZC5kYXRhKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhjb25maWdfY2xhc3Nlcy5hcmMsIGQuZGF0YS5pZCk7XG4gIH0sXG4gIGNsYXNzQXJjczogZnVuY3Rpb24gY2xhc3NBcmNzKGQpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkLmRhdGEpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKGNvbmZpZ19jbGFzc2VzLmFyY3MsIGQuZGF0YS5pZCk7XG4gIH0sXG4gIGNsYXNzQXJlYTogZnVuY3Rpb24gY2xhc3NBcmVhKGQpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKGNvbmZpZ19jbGFzc2VzLmFyZWEsIGQuaWQpO1xuICB9LFxuICBjbGFzc0FyZWFzOiBmdW5jdGlvbiBjbGFzc0FyZWFzKGQpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhjb25maWdfY2xhc3Nlcy5hcmVhcywgZC5pZCk7XG4gIH0sXG4gIGNsYXNzUmVnaW9uOiBmdW5jdGlvbiBjbGFzc1JlZ2lvbihkLCBpKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuZ2VuZXJhdGVDbGFzcyhjb25maWdfY2xhc3Nlcy5yZWdpb24sIGkpLCBcIiBcIikuY29uY2F0KFwiY2xhc3NcIiBpbiBkID8gZFtcImNsYXNzXCJdIDogXCJcIik7XG4gIH0sXG4gIGNsYXNzRXZlbnQ6IGZ1bmN0aW9uIGNsYXNzRXZlbnQoZCkge1xuICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoY29uZmlnX2NsYXNzZXMuZXZlbnRSZWN0LCBkLmluZGV4KTtcbiAgfSxcbiAgY2xhc3NUYXJnZXQ6IGZ1bmN0aW9uIGNsYXNzVGFyZ2V0KGlkKSB7XG4gICAgdmFyIGFkZGl0aW9uYWxDbGFzc1N1ZmZpeCA9IHRoaXMuY29uZmlnLmRhdGFfY2xhc3Nlc1tpZF0sXG4gICAgICAgIGFkZGl0aW9uYWxDbGFzcyA9IFwiXCI7XG4gICAgcmV0dXJuIGFkZGl0aW9uYWxDbGFzc1N1ZmZpeCAmJiAoYWRkaXRpb25hbENsYXNzID0gXCIgXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnRhcmdldCwgXCItXCIpLmNvbmNhdChhZGRpdGlvbmFsQ2xhc3NTdWZmaXgpKSwgdGhpcy5nZW5lcmF0ZUNsYXNzKGNvbmZpZ19jbGFzc2VzLnRhcmdldCwgaWQpICsgYWRkaXRpb25hbENsYXNzO1xuICB9LFxuICBjbGFzc0ZvY3VzOiBmdW5jdGlvbiBjbGFzc0ZvY3VzKGQpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc0ZvY3VzZWQoZCkgKyB0aGlzLmNsYXNzRGVmb2N1c2VkKGQpO1xuICB9LFxuICBjbGFzc0ZvY3VzZWQ6IGZ1bmN0aW9uIGNsYXNzRm9jdXNlZChkKSB7XG4gICAgcmV0dXJuIFwiIFwiLmNvbmNhdCh0aGlzLmZvY3VzZWRUYXJnZXRJZHMuaW5kZXhPZihkLmlkKSA+PSAwID8gY29uZmlnX2NsYXNzZXMuZm9jdXNlZCA6IFwiXCIpO1xuICB9LFxuICBjbGFzc0RlZm9jdXNlZDogZnVuY3Rpb24gY2xhc3NEZWZvY3VzZWQoZCkge1xuICAgIHJldHVybiBcIiBcIi5jb25jYXQodGhpcy5kZWZvY3VzZWRUYXJnZXRJZHMuaW5kZXhPZihkLmlkKSA+PSAwID8gY29uZmlnX2NsYXNzZXMuZGVmb2N1c2VkIDogXCJcIik7XG4gIH0sXG4gIGNsYXNzQ2hhcnRUZXh0OiBmdW5jdGlvbiBjbGFzc0NoYXJ0VGV4dChkKSB7XG4gICAgcmV0dXJuIGNvbmZpZ19jbGFzc2VzLmNoYXJ0VGV4dCArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XG4gIH0sXG4gIGNsYXNzQ2hhcnRMaW5lOiBmdW5jdGlvbiBjbGFzc0NoYXJ0TGluZShkKSB7XG4gICAgcmV0dXJuIGNvbmZpZ19jbGFzc2VzLmNoYXJ0TGluZSArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XG4gIH0sXG4gIGNsYXNzQ2hhcnRCYXI6IGZ1bmN0aW9uIGNsYXNzQ2hhcnRCYXIoZCkge1xuICAgIHJldHVybiBjb25maWdfY2xhc3Nlcy5jaGFydEJhciArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XG4gIH0sXG4gIGNsYXNzQ2hhcnRBcmM6IGZ1bmN0aW9uIGNsYXNzQ2hhcnRBcmMoZCkge1xuICAgIHJldHVybiBjb25maWdfY2xhc3Nlcy5jaGFydEFyYyArIHRoaXMuY2xhc3NUYXJnZXQoZC5kYXRhLmlkKTtcbiAgfSxcbiAgY2xhc3NDaGFydFJhZGFyOiBmdW5jdGlvbiBjbGFzc0NoYXJ0UmFkYXIoZCkge1xuICAgIHJldHVybiBjb25maWdfY2xhc3Nlcy5jaGFydFJhZGFyICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcbiAgfSxcbiAgZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXg6IGZ1bmN0aW9uIGdldFRhcmdldFNlbGVjdG9yU3VmZml4KHRhcmdldElkKSB7XG4gICAgcmV0dXJuIHRhcmdldElkIHx8IHRhcmdldElkID09PSAwID8gXCItXCIuY29uY2F0KHRhcmdldElkKS5yZXBsYWNlKC9bXFxzPyFAIyQlXiYqKClfPSssLjw+J1wiOjtcXFtcXF1cXC98fmB7fVxcXFxdL2csIFwiLVwiKSA6IFwiXCI7XG4gIH0sXG4gIHNlbGVjdG9yVGFyZ2V0OiBmdW5jdGlvbiBzZWxlY3RvclRhcmdldChpZCwgcHJlZml4KSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHByZWZpeCB8fCBcIlwiLCBcIi5cIikuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnRhcmdldCArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpKTtcbiAgfSxcbiAgc2VsZWN0b3JUYXJnZXRzOiBmdW5jdGlvbiBzZWxlY3RvclRhcmdldHMoaWRzVmFsdWUsIHByZWZpeCkge1xuICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgIGlkcyA9IGlkc1ZhbHVlIHx8IFtdO1xuICAgIHJldHVybiBpZHMubGVuZ3RoID8gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiAkJC5zZWxlY3RvclRhcmdldChpZCwgcHJlZml4KTtcbiAgICB9KSA6IG51bGw7XG4gIH0sXG4gIHNlbGVjdG9yTGVnZW5kOiBmdW5jdGlvbiBzZWxlY3RvckxlZ2VuZChpZCkge1xuICAgIHJldHVybiBcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMubGVnZW5kSXRlbSArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpKTtcbiAgfSxcbiAgc2VsZWN0b3JMZWdlbmRzOiBmdW5jdGlvbiBzZWxlY3RvckxlZ2VuZHMoaWRzKSB7XG4gICAgdmFyICQkID0gdGhpcztcbiAgICByZXR1cm4gaWRzICYmIGlkcy5sZW5ndGggPyBpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuICQkLnNlbGVjdG9yTGVnZW5kKGlkKTtcbiAgICB9KSA6IG51bGw7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYXBpL2FwaS5mb2N1cy5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuXG5leHRlbmQoQ2hhcnRfQ2hhcnQucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBUaGlzIEFQSSBoaWdobGlnaHRzIHNwZWNpZmllZCB0YXJnZXRzIGFuZCBmYWRlIG91dCB0aGUgb3RoZXJzLjxicj48YnI+XG4gICAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgaGlnaGxpZ2h0ZWQuXG4gICAqIEBtZXRob2QgZm9jdXNcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzVmFsdWUgVGFyZ2V0IGlkcyB0byBiZSBoaWdobGlnaHRlZC5cbiAgICogQGV4YW1wbGVcbiAgICogIC8vIGRhdGExIHdpbGwgYmUgaGlnaGxpZ2h0ZWQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSBmYWRlZCBvdXRcbiAgICogIGNoYXJ0LmZvY3VzKFwiZGF0YTFcIik7XG4gICAqXG4gICAqIC8vIGRhdGExIGFuZCBkYXRhMiB3aWxsIGJlIGhpZ2hsaWdodGVkIGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgZmFkZWQgb3V0XG4gICAqIGNoYXJ0LmZvY3VzKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuICAgKlxuICAgKiAvLyBhbGwgdGFyZ2V0cyB3aWxsIGJlIGhpZ2hsaWdodGVkXG4gICAqIGNoYXJ0LmZvY3VzKCk7XG4gICAqL1xuICBmb2N1czogZnVuY3Rpb24gZm9jdXModGFyZ2V0SWRzVmFsdWUpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSksXG4gICAgICAgIGNhbmRpZGF0ZXMgPSAkJC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzVGFyZ2V0VG9TaG93LCAkJCkpKTtcbiAgICB0aGlzLnJldmVydCgpLCB0aGlzLmRlZm9jdXMoKSwgY2FuZGlkYXRlcy5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmZvY3VzZWQsICEwKS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmRlZm9jdXNlZCwgITEpLCAkJC5oYXNBcmNUeXBlKCkgJiYgKCQkLmV4cGFuZEFyYyh0YXJnZXRJZHMpLCAkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgJCQubWFya092ZXJsYXBwZWQodGFyZ2V0SWRzVmFsdWUsICQkLCBcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuZ2F1Z2VWYWx1ZSkpKSwgJCQudG9nZ2xlRm9jdXNMZWdlbmQodGFyZ2V0SWRzLCAhMCksICQkLmZvY3VzZWRUYXJnZXRJZHMgPSB0YXJnZXRJZHMsICQkLmRlZm9jdXNlZFRhcmdldElkcyA9ICQkLmRlZm9jdXNlZFRhcmdldElkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMDtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBBUEkgZmFkZXMgb3V0IHNwZWNpZmllZCB0YXJnZXRzIGFuZCByZXZlcnRzIHRoZSBvdGhlcnMuPGJyPjxicj5cbiAgICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSBmYWRlZCBvdXQuXG4gICAqIEBtZXRob2QgZGVmb2N1c1xuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBUYXJnZXQgaWRzIHRvIGJlIGZhZGVkIG91dC5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZGF0YTEgd2lsbCBiZSBmYWRlZCBvdXQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSByZXZlcnRlZC5cbiAgICogY2hhcnQuZGVmb2N1cyhcImRhdGExXCIpO1xuICAgKlxuICAgKiAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBmYWRlZCBvdXQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSByZXZlcnRlZC5cbiAgICogY2hhcnQuZGVmb2N1cyhbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcbiAgICpcbiAgICogLy8gYWxsIHRhcmdldHMgd2lsbCBiZSBmYWRlZCBvdXQuXG4gICAqIGNoYXJ0LmRlZm9jdXMoKTtcbiAgICovXG4gIGRlZm9jdXM6IGZ1bmN0aW9uIGRlZm9jdXModGFyZ2V0SWRzVmFsdWUpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSksXG4gICAgICAgIGNhbmRpZGF0ZXMgPSAkJC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzVGFyZ2V0VG9TaG93LCAkJCkpKTtcbiAgICBjYW5kaWRhdGVzLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuZm9jdXNlZCwgITEpLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuZGVmb2N1c2VkLCAhMCksICQkLmhhc0FyY1R5cGUoKSAmJiAoJCQudW5leHBhbmRBcmModGFyZ2V0SWRzKSwgJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICQkLnVuZG9NYXJrT3ZlcmxhcHBlZCgkJCwgXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLmdhdWdlVmFsdWUpKSksICQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgITEpLCAkJC5mb2N1c2VkVGFyZ2V0SWRzID0gJCQuZm9jdXNlZFRhcmdldElkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMDtcbiAgICB9KSwgJCQuZGVmb2N1c2VkVGFyZ2V0SWRzID0gdGFyZ2V0SWRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSByZXZlcnRzIHNwZWNpZmllZCB0YXJnZXRzLjxicj48YnI+XG4gICAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgcmV2ZXJ0ZWQuXG4gICAqIEBtZXRob2QgcmV2ZXJ0XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFRhcmdldCBpZHMgdG8gYmUgcmV2ZXJ0ZWRcbiAgICogQGV4YW1wbGVcbiAgICogLy8gZGF0YTEgd2lsbCBiZSByZXZlcnRlZC5cbiAgICogY2hhcnQucmV2ZXJ0KFwiZGF0YTFcIik7XG4gICAqXG4gICAqIC8vIGRhdGExIGFuZCBkYXRhMiB3aWxsIGJlIHJldmVydGVkLlxuICAgKiBjaGFydC5yZXZlcnQoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG4gICAqXG4gICAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgcmV2ZXJ0ZWQuXG4gICAqIGNoYXJ0LnJldmVydCgpO1xuICAgKi9cbiAgcmV2ZXJ0OiBmdW5jdGlvbiByZXZlcnQodGFyZ2V0SWRzVmFsdWUpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSksXG4gICAgICAgIGNhbmRpZGF0ZXMgPSAkJC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMpKTtcbiAgICAvLyBzaG91bGQgYmUgZm9yIGFsbCB0YXJnZXRzXG4gICAgY2FuZGlkYXRlcy5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmZvY3VzZWQsICExKS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmRlZm9jdXNlZCwgITEpLCAkJC5oYXNBcmNUeXBlKCkgJiYgJCQudW5leHBhbmRBcmModGFyZ2V0SWRzKSwgJCQuY29uZmlnLmxlZ2VuZF9zaG93ICYmICgkJC5zaG93TGVnZW5kKHRhcmdldElkcy5maWx0ZXIoJCQuaXNMZWdlbmRUb1Nob3cuYmluZCgkJCkpKSwgJCQubGVnZW5kLnNlbGVjdEFsbCgkJC5zZWxlY3RvckxlZ2VuZHModGFyZ2V0SWRzKSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhpcykuY2xhc3NlZChjb25maWdfY2xhc3Nlcy5sZWdlbmRJdGVtRm9jdXNlZCk7XG4gICAgfSkuY2xhc3NlZChjb25maWdfY2xhc3Nlcy5sZWdlbmRJdGVtRm9jdXNlZCwgITEpKSwgJCQuZm9jdXNlZFRhcmdldElkcyA9IFtdLCAkJC5kZWZvY3VzZWRUYXJnZXRJZHMgPSBbXTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9hcGkvYXBpLnNob3cuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5leHRlbmQoQ2hhcnRfQ2hhcnQucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBTaG93L0hpZGUgZGF0YSBzZXJpZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zaG93SGlkZTogZnVuY3Rpb24gX3Nob3dIaWRlKHNob3csIHRhcmdldElkc1ZhbHVlLCBvcHRpb25zKSB7XG4gICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xuICAgICQkW1wiXCIuY29uY2F0KHNob3cgPyBcInJlbW92ZVwiIDogXCJhZGRcIiwgXCJIaWRkZW5UYXJnZXRJZHNcIildKHRhcmdldElkcyk7XG4gICAgdmFyIHRhcmdldHMgPSAkJC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMpKSxcbiAgICAgICAgb3BhY2l0eSA9IHNob3cgPyBcIjFcIiA6IFwiMFwiO1xuICAgIHRhcmdldHMudHJhbnNpdGlvbigpLnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5LCBcImltcG9ydGFudFwiKS5jYWxsKCQkLmVuZGFsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgdGFyZ2V0cy5zdHlsZShcIm9wYWNpdHlcIiwgbnVsbCkuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHkpO1xuICAgIH0pLCBvcHRpb25zLndpdGhMZWdlbmQgJiYgJCRbXCJcIi5jb25jYXQoc2hvdyA/IFwic2hvd1wiIDogXCJoaWRlXCIsIFwiTGVnZW5kXCIpXSh0YXJnZXRJZHMpLCAkJC5yZWRyYXcoe1xuICAgICAgd2l0aFVwZGF0ZU9yZ1hEb21haW46ICEwLFxuICAgICAgd2l0aFVwZGF0ZVhEb21haW46ICEwLFxuICAgICAgd2l0aExlZ2VuZDogITBcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU2hvdyBkYXRhIHNlcmllcyBvbiBjaGFydFxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW3RhcmdldElkc1ZhbHVlPWFsbF0gVGhlIHRhcmdldCBpZCB2YWx1ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxuICAgKlxuICAgKiAgICB8IEtleSB8IFR5cGUgfCBkZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxuICAgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XG4gICAqICAgIHwgd2l0aExlZ2VuZCB8IEJvb2xlYW4gfCBmYWxzZSB8IHdoZXRoZXIgb3Igbm90IGRpc3BsYXkgbGVnZW5kIHxcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gc2hvdyAnZGF0YTEnXG4gICAqIGNoYXJ0LnNob3coXCJkYXRhMVwiKTtcbiAgICpcbiAgICogLy8gc2hvdyAnZGF0YTEnIGFuZCAnZGF0YTMnXG4gICAqIGNoYXJ0LnNob3coW1wiZGF0YTFcIiwgXCJkYXRhM1wiXSk7XG4gICAqL1xuICBzaG93OiBmdW5jdGlvbiBzaG93KHRhcmdldElkc1ZhbHVlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdGhpcy5fc2hvd0hpZGUoITAsIHRhcmdldElkc1ZhbHVlLCBvcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogSGlkZSBkYXRhIHNlcmllcyBmcm9tIGNoYXJ0XG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWU9YWxsXSBUaGUgdGFyZ2V0IGlkIHZhbHVlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG4gICAqXG4gICAqICAgIHwgS2V5IHwgVHlwZSB8IGRlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XG4gICAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcbiAgICogICAgfCB3aXRoTGVnZW5kIHwgQm9vbGVhbiB8IGZhbHNlIHwgd2hldGhlciBvciBub3QgZGlzcGxheSBsZWdlbmQgfFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBoaWRlICdkYXRhMSdcbiAgICogY2hhcnQuaGlkZShcImRhdGExXCIpO1xuICAgKlxuICAgKiAvLyBoaWRlICdkYXRhMScgYW5kICdkYXRhMydcbiAgICogY2hhcnQuaGlkZShbXCJkYXRhMVwiLCBcImRhdGEzXCJdKTtcbiAgICovXG4gIGhpZGU6IGZ1bmN0aW9uIGhpZGUodGFyZ2V0SWRzVmFsdWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB0aGlzLl9zaG93SGlkZSghMSwgdGFyZ2V0SWRzVmFsdWUsIG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb2dnbGUgZGF0YSBzZXJpZXMgb24gY2hhcnQuIFdoZW4gdGFyZ2V0IGRhdGEgaXMgaGlkZGVuLCBpdCB3aWxsIHNob3cuIElmIGlzIHNob3duLCBpdCB3aWxsIGhpZGUgaW4gdmljZSB2ZXJzYS5cbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW3RhcmdldElkc1ZhbHVlPWFsbF0gVGhlIHRhcmdldCBpZCB2YWx1ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxuICAgKlxuICAgKiAgICB8IEtleSB8IFR5cGUgfCBkZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxuICAgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XG4gICAqICAgIHwgd2l0aExlZ2VuZCB8IEJvb2xlYW4gfCBmYWxzZSB8IHdoZXRoZXIgb3Igbm90IGRpc3BsYXkgbGVnZW5kIHxcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gdG9nZ2xlICdkYXRhMSdcbiAgICogY2hhcnQudG9nZ2xlKFwiZGF0YTFcIik7XG4gICAqXG4gICAqIC8vIHRvZ2dsZSAnZGF0YTEnIGFuZCAnZGF0YTMnXG4gICAqIGNoYXJ0LnRvZ2dsZShbXCJkYXRhMVwiLCBcImRhdGEzXCJdKTtcbiAgICovXG4gIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKHRhcmdldElkcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgIHRhcmdldHMgPSB7XG4gICAgICBzaG93OiBbXSxcbiAgICAgIGhpZGU6IFtdXG4gICAgfTtcblxuICAgIC8vIHNvcnQgc2hvdyAmIGhpZGUgdGFyZ2V0IGlkc1xuICAgIC8vIHBlcmZvcm0gc2hvdyAmIGhpZGUgdGFzayBzZXBhcmF0ZWx5XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvNDU0XG4gICAgJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHRhcmdldHNbJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gXCJoaWRlXCIgOiBcInNob3dcIl0ucHVzaChpZCk7XG4gICAgfSksIHRhcmdldHMuc2hvdy5sZW5ndGggJiYgdGhpcy5zaG93KHRhcmdldHMuc2hvdywgb3B0aW9ucyksIHRhcmdldHMuaGlkZS5sZW5ndGggJiYgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaGlkZSh0YXJnZXRzLmhpZGUsIG9wdGlvbnMpO1xuICAgIH0sIDApO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FwaS9hcGkuem9vbS5qc1xuXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZG9tYWluIGlzIHdpdGhpbiB6b29tIHJhbmdlXG4gKiBAcGFyYW0ge0FycmF5fSBkb21haW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciB3aXRoaW5SYW5nZSA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlKSB7XG4gIHZhciBfcmFuZ2UgPSBfc2xpY2VkVG9BcnJheShyYW5nZSwgMiksXG4gICAgICBtaW4gPSBfcmFuZ2VbMF0sXG4gICAgICBtYXggPSBfcmFuZ2VbMV07XG5cbiAgcmV0dXJuIGRvbWFpbi5ldmVyeShmdW5jdGlvbiAodiwgaSkge1xuICAgIHJldHVybiBpID09PSAwID8gdiA+PSBtaW4gOiB2IDw9IG1heDtcbiAgfSk7XG59LFxuICAgIGFwaV96b29tX3pvb20gPSBmdW5jdGlvbiAoZG9tYWluVmFsdWUpIHtcbiAgdmFyIHJlc3VsdERvbWFpbixcbiAgICAgICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgIGRvbWFpbiA9IGRvbWFpblZhbHVlO1xuXG4gIGlmICgkJC5jb25maWcuem9vbV9lbmFibGVkICYmIGRvbWFpbiAmJiB3aXRoaW5SYW5nZShkb21haW4sICQkLmdldFpvb21Eb21haW4oKSkpIHtcbiAgICB2YXIgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCk7XG5cbiAgICBpZiAoaXNUaW1lU2VyaWVzICYmIChkb21haW4gPSBkb21haW4ubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gJCQucGFyc2VEYXRlKHgpO1xuICAgIH0pKSwgJCQuY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcbiAgICAgIHZhciB4U2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQueDtcbiAgICAgICQkLmJydXNoLmdldFNlbGVjdGlvbigpLmNhbGwoJCQuYnJ1c2gubW92ZSwgW3hTY2FsZShkb21haW5bMF0pLCB4U2NhbGUoZG9tYWluWzFdKV0pLCByZXN1bHREb21haW4gPSBkb21haW47XG4gICAgfSBlbHNlICQkLnguZG9tYWluKGRvbWFpbiksICQkLnpvb21TY2FsZSA9ICQkLngsICQkLnhBeGlzLnNjYWxlKCQkLnpvb21TY2FsZSksIHJlc3VsdERvbWFpbiA9ICQkLnpvb21TY2FsZS5vcmdEb21haW4oKTtcblxuICAgICQkLnJlZHJhdyh7XG4gICAgICB3aXRoVHJhbnNpdGlvbjogITAsXG4gICAgICB3aXRoWTogJCQuY29uZmlnLnpvb21fcmVzY2FsZSxcbiAgICAgIHdpdGhEaW1lbnNpb246ICExXG4gICAgfSksICQkLnNldFpvb21SZXNldEJ1dHRvbigpLCBjYWxsRm4oJCQuY29uZmlnLnpvb21fb256b29tLCAkJC5hcGksIHJlc3VsdERvbWFpbik7XG4gIH0gZWxzZSByZXN1bHREb21haW4gPSAkJC56b29tU2NhbGUgPyAkJC56b29tU2NhbGUuZG9tYWluKCkgOiAkJC54Lm9yZ0RvbWFpbigpO1xuXG4gIHJldHVybiByZXN1bHREb21haW47XG59O1xuLyoqXG4gKiBab29tIGJ5IGdpdmluZyB4IGRvbWFpbi5cbiAqIC0gKipOT1RFOioqXG4gKiAgLSBGb3IgYHdoZWVsYCB0eXBlIHpvb20sIHRoZSBtaW5pbXVtIHpvb20gcmFuZ2Ugd2lsbCBiZSBzZXQgYXMgdGhlIGdpdmVuIGRvbWFpbi4gVG8gZ2V0IHRoZSBpbml0aWFsIHN0YXRlLCBbLnVuem9vbSgpXSgjdW56b29tKSBzaG91bGQgYmUgY2FsbGVkLlxuICogIC0gVG8gYmUgdXNlZCBbem9vbS5lbmFibGVkXShPcHRpb25zLmh0bWwjLnpvb20pIG9wdGlvbiBzaG91bGQgYmUgc2V0IGFzIGB0cnV0aHlgLlxuICogQG1ldGhvZCB6b29tXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQHBhcmFtIHtBcnJheX0gZG9tYWluVmFsdWUgSWYgZG9tYWluIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSB6b29tZWQgdG8gdGhlIGdpdmVuIGRvbWFpbi4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjdXJyZW50IHpvb21lZCBkb21haW4gd2lsbCBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4ge0FycmF5fSBkb21haW4gdmFsdWUgaW4gYXJyYXlcbiAqIEBleGFtcGxlXG4gKiAgLy8gWm9vbSB0byBzcGVjaWZpZWQgZG9tYWluXG4gKiAgY2hhcnQuem9vbShbMTAsIDIwXSk7XG4gKlxuICogIC8vIEdldCB0aGUgY3VycmVudCB6b29tZWQgZG9tYWluXG4gKiAgY2hhcnQuem9vbSgpO1xuICovXG5cblxuZXh0ZW5kKGFwaV96b29tX3pvb20sIHtcbiAgLyoqXG4gICAqIEVuYWJsZSBhbmQgZGlzYWJsZSB6b29taW5nLlxuICAgKiBAbWV0aG9kIHpvb23igKRlbmFibGVcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSBlbmFibGVkIFBvc3NpYmxlIHN0cmluZyB2YWx1ZXMgYXJlIFwid2hlZWxcIiBvciBcImRyYWdcIi4gSWYgZW5hYmxlZCBpcyB0cnVlLCBcIndoZWVsXCIgd2lsbCBiZSB1c2VkLiBJZiBmYWxzZSBpcyBnaXZlbiwgem9vbWluZyB3aWxsIGJlIGRpc2FibGVkLjxicj5XaGVuIHNldCB0byBmYWxzZSwgdGhlIGN1cnJlbnQgem9vbWluZyBzdGF0dXMgd2lsbCBiZSByZXNldC5cbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEVuYWJsZSB6b29taW5nIHVzaW5nIHRoZSBtb3VzZSB3aGVlbFxuICAgKiAgY2hhcnQuem9vbS5lbmFibGUodHJ1ZSk7XG4gICAqICAvLyBPclxuICAgKiAgY2hhcnQuem9vbS5lbmFibGUoXCJ3aGVlbFwiKTtcbiAgICpcbiAgICogIC8vIEVuYWJsZSB6b29taW5nIGJ5IGRyYWdnaW5nXG4gICAqICBjaGFydC56b29tLmVuYWJsZShcImRyYWdcIik7XG4gICAqXG4gICAqICAvLyBEaXNhYmxlIHpvb21pbmdcbiAgICogIGNoYXJ0Lnpvb20uZW5hYmxlKGZhbHNlKTtcbiAgICovXG4gIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIHZhciBlbmFibGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIndoZWVsXCIsXG4gICAgICAgICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICBlbmFibGVUeXBlID0gZW5hYmxlZDtcbiAgICBlbmFibGVkICYmIChlbmFibGVUeXBlID0gaXNTdHJpbmcoZW5hYmxlZCkgJiYgL14oZHJhZ3x3aGVlbCkkLy50ZXN0KGVuYWJsZWQpID8ge1xuICAgICAgdHlwZTogZW5hYmxlZFxuICAgIH0gOiBlbmFibGVkKSwgY29uZmlnLnpvb21fZW5hYmxlZCA9IGVuYWJsZVR5cGUsICQkLnpvb20gPyBlbmFibGVkID09PSAhMSAmJiAkJC5iaW5kWm9vbUV2ZW50KCExKSA6ICgkJC5pbml0Wm9vbSgpLCAkJC5iaW5kWm9vbUV2ZW50KCkpLCAkJC51cGRhdGVBbmRSZWRyYXcoKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IG9yIGdldCB4IEF4aXMgbWF4aW11bSB6b29tIHJhbmdlIHZhbHVlXG4gICAqIEBtZXRob2Qgem9vbeKApG1heFxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4XSBtYXhpbXVtIHZhbHVlIHRvIHNldCBmb3Igem9vbVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHpvb20gbWF4IHZhbHVlXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBTZXQgbWF4aW11bSByYW5nZSB2YWx1ZVxuICAgKiAgY2hhcnQuem9vbS5tYXgoMjApO1xuICAgKi9cbiAgbWF4OiBmdW5jdGlvbiBtYXgoX21heCkge1xuICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICByZXR1cm4gKF9tYXggPT09IDAgfHwgX21heCkgJiYgKGNvbmZpZy56b29tX3hfbWF4ID0gZ2V0TWluTWF4KFwibWF4XCIsIFskJC5vcmdYRG9tYWluWzFdLCBfbWF4XSkpLCBjb25maWcuem9vbV94X21heDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IG9yIGdldCB4IEF4aXMgbWluaW11bSB6b29tIHJhbmdlIHZhbHVlXG4gICAqIEBtZXRob2Qgem9vbeKApG1pblxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluXSBtaW5pbXVtIHZhbHVlIHRvIHNldCBmb3Igem9vbVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHpvb20gbWluIHZhbHVlXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBTZXQgbWluaW11bSByYW5nZSB2YWx1ZVxuICAgKiAgY2hhcnQuem9vbS5taW4oLTEpO1xuICAgKi9cbiAgbWluOiBmdW5jdGlvbiBtaW4oX21pbikge1xuICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICByZXR1cm4gKF9taW4gPT09IDAgfHwgX21pbikgJiYgKGNvbmZpZy56b29tX3hfbWluID0gZ2V0TWluTWF4KFwibWluXCIsIFskJC5vcmdYRG9tYWluWzBdLCBfbWluXSkpLCBjb25maWcuem9vbV94X21pbjtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IHpvb20gcmFuZ2VcbiAgICogQG1ldGhvZCB6b29t4oCkcmFuZ2VcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JhbmdlXVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHpvb20gcmFuZ2UgdmFsdWVcbiAgICoge1xuICAgKiAgIG1pbjogMCxcbiAgICogICBtYXg6IDEwMFxuICAgKiB9XG4gICAqIEBleGFtcGxlXG4gICAqICBjaGFydC56b29tLnJhbmdlKHtcbiAgICogICAgICBtaW46IDEwLFxuICAgKiAgICAgIG1heDogMTAwXG4gICAqICB9KTtcbiAgICovXG4gIHJhbmdlOiBmdW5jdGlvbiByYW5nZShfcmFuZ2UyKSB7XG4gICAgdmFyIHpvb20gPSB0aGlzLnpvb207XG5cbiAgICBpZiAoaXNPYmplY3QoX3JhbmdlMikpIHtcbiAgICAgIHZhciBtaW4gPSBfcmFuZ2UyLm1pbixcbiAgICAgICAgICBtYXggPSBfcmFuZ2UyLm1heDtcbiAgICAgIGlzRGVmaW5lZChtaW4pICYmIHpvb20ubWluKG1pbiksIGlzRGVmaW5lZChtYXgpICYmIHpvb20ubWF4KG1heCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogem9vbS5taW4oKSxcbiAgICAgIG1heDogem9vbS5tYXgoKVxuICAgIH07XG4gIH1cbn0pLCBleHRlbmQoQ2hhcnRfQ2hhcnQucHJvdG90eXBlLCB7XG4gIHpvb206IGFwaV96b29tX3pvb20sXG5cbiAgLyoqXG4gICAqIFVuem9vbSB6b29tZWQgYXJlYVxuICAgKiBAbWV0aG9kIHVuem9vbVxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBleGFtcGxlXG4gICAqICBjaGFydC51bnpvb20oKTtcbiAgICovXG4gIHVuem9vbTogZnVuY3Rpb24gdW56b29tKCkge1xuICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcblxuICAgIGlmICgkJC56b29tU2NhbGUpIHtcbiAgICAgIGNvbmZpZy5zdWJjaGFydF9zaG93ID8gJCQuYnJ1c2guZ2V0U2VsZWN0aW9uKCkuY2FsbCgkJC5icnVzaC5tb3ZlLCBudWxsKSA6ICQkLnpvb20udXBkYXRlVHJhbnNmb3JtU2NhbGUoZXh0ZXJuYWxfY29tbW9uanNfZDNfem9vbV9jb21tb25qczJfZDNfem9vbV9hbWRfZDNfem9vbV9yb290X2QzX1tcInpvb21JZGVudGl0eVwiXSksICQkLnVwZGF0ZVpvb20oITApLCAkJC56b29tLnJlc2V0QnRuICYmICQkLnpvb20ucmVzZXRCdG4uc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgIC8vIHJlc2V0IHRyYW5zZm9ybVxuICAgICAgdmFyIGV2ZW50UmVjdHMgPSAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuZXZlbnRSZWN0cykpO1xuICAgICAgT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3pvb21fY29tbW9uanMyX2QzX3pvb21fYW1kX2QzX3pvb21fcm9vdF9kM19bXCJ6b29tVHJhbnNmb3JtXCJdKShldmVudFJlY3RzLm5vZGUoKSkgIT09IGV4dGVybmFsX2NvbW1vbmpzX2QzX3pvb21fY29tbW9uanMyX2QzX3pvb21fYW1kX2QzX3pvb21fcm9vdF9kM19bXCJ6b29tSWRlbnRpdHlcIl0gJiYgJCQuem9vbS50cmFuc2Zvcm0oZXZlbnRSZWN0cywgZXh0ZXJuYWxfY29tbW9uanNfZDNfem9vbV9jb21tb25qczJfZDNfem9vbV9hbWRfZDNfem9vbV9yb290X2QzX1tcInpvb21JZGVudGl0eVwiXSksICQkLnJlZHJhdyh7XG4gICAgICAgIHdpdGhUcmFuc2l0aW9uOiAhMCxcbiAgICAgICAgd2l0aFVwZGF0ZVhEb21haW46ICEwLFxuICAgICAgICB3aXRoVXBkYXRlT3JnWERvbWFpbjogITAsXG4gICAgICAgIHdpdGhZOiBjb25maWcuem9vbV9yZXNjYWxlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYXBpL2FwaS5sb2FkLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuZXh0ZW5kKENoYXJ0X0NoYXJ0LnByb3RvdHlwZSwge1xuICAvKipcbiAgICogTG9hZCBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxuICAgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHRvZ2dsZXMuXG4gICAqIC0gPGI+Tm90ZTo8L2I+XG4gICAqICAgLSB1bmxvYWQgc2hvdWxkIGJlIHVzZWQgaWYgc29tZSBkYXRhIG5lZWRzIHRvIGJlIHVubG9hZGVkIHNpbXVsdGFuZW91c2x5LlxuICAgKiAgICAgSWYgeW91IGNhbGwgdW5sb2FkIEFQSSBzb29uIGFmdGVyL2JlZm9yZSBsb2FkIGluc3RlYWQgb2YgdW5sb2FkIHBhcmFtLCBjaGFydCB3aWxsIG5vdCBiZSByZW5kZXJlZCBwcm9wZXJseSBiZWNhdXNlIG9mIGNhbmNlbCBvZiBhbmltYXRpb24uPGJyPlxuICAgKiAgIC0gZG9uZSB3aWxsIGJlIGNhbGxlZCBhZnRlciBkYXRhIGxvYWRlZCwgYnV0IGl0J3Mgbm90IGFmdGVyIHJlbmRlcmluZy5cbiAgICogICAgIEl0J3MgYmVjYXVzZSByZW5kZXJpbmcgd2lsbCBmaW5pc2ggYWZ0ZXIgc29tZSB0cmFuc2l0aW9uIGFuZCB0aGVyZSBpcyBzb21lIHRpbWUgbGFnIGJldHdlZW4gbG9hZGluZyBhbmQgcmVuZGVyaW5nXG4gICAqIEBtZXRob2QgbG9hZFxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG4gICAqXG4gICAqICAgIHwgS2V5IHwgRGVzY3JpcHRpb24gfFxuICAgKiAgICB8IC0tLSB8IC0tLSB8XG4gICAqICAgIHwgLSB1cmw8YnI+LSBqc29uPGJyPi0gcm93czxicj4tIGNvbHVtbnMgfCBUaGUgZGF0YSB3aWxsIGJlIGxvYWRlZC4gSWYgZGF0YSB0aGF0IGhhcyB0aGUgc2FtZSB0YXJnZXQgaWQgaXMgZ2l2ZW4sIHRoZSBjaGFydCB3aWxsIGJlIHVwZGF0ZWQuIE90aGVyd2lzZSwgbmV3IHRhcmdldCB3aWxsIGJlIGFkZGVkIHxcbiAgICogICAgfCBkYXRhIHwgRGF0YSBvYmplY3RzIHRvIGJlIGxvYWRlZC4gQ2hlY2tvdXQgdGhlIGV4YW1wbGUuIHxcbiAgICogICAgfCBuYW1lcyB8IFNhbWUgYXMgZGF0YS5uYW1lcygpIHxcbiAgICogICAgfCB4cyB8IFNhbWUgYXMgZGF0YS54cyBvcHRpb24gIHxcbiAgICogICAgfCBjbGFzc2VzIHwgVGhlIGNsYXNzZXMgc3BlY2lmaWVkIGJ5IGRhdGEuY2xhc3NlcyB3aWxsIGJlIHVwZGF0ZWQuIGNsYXNzZXMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcbiAgICogICAgfCBjYXRlZ29yaWVzIHwgVGhlIGNhdGVnb3JpZXMgc3BlY2lmaWVkIGJ5IGF4aXMueC5jYXRlZ29yaWVzIG9yIGRhdGEueCB3aWxsIGJlIHVwZGF0ZWQuIGNhdGVnb3JpZXMgbXVzdCBiZSBBcnJheS4gfFxuICAgKiAgICB8IGF4ZXMgfCBUaGUgYXhlcyBzcGVjaWZpZWQgYnkgZGF0YS5heGVzIHdpbGwgYmUgdXBkYXRlZC4gYXhlcyBtdXN0IGJlIE9iamVjdCB0aGF0IGhhcyB0YXJnZXQgaWQgYXMga2V5cy4gfFxuICAgKiAgICB8IGNvbG9ycyB8IFRoZSBjb2xvcnMgc3BlY2lmaWVkIGJ5IGRhdGEuY29sb3JzIHdpbGwgYmUgdXBkYXRlZC4gY29sb3JzIG11c3QgYmUgT2JqZWN0IHRoYXQgaGFzIHRhcmdldCBpZCBhcyBrZXlzLiB8XG4gICAqICAgIHwgaGVhZGVycyB8ICBTZXQgcmVxdWVzdCBoZWFkZXIgaWYgbG9hZGluZyB2aWEgYGRhdGEudXJsYC48YnI+QHNlZSBbZGF0YeKApGhlYWRlcnNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGhlYWRlcnMpIHxcbiAgICogICAgfCBrZXlzIHwgIENob29zZSB3aGljaCBKU09OIG9iamVjdHMga2V5cyBjb3JyZXNwb25kIHRvIGRlc2lyZWQgZGF0YS48YnI+KipOT1RFOioqIE9ubHkgZm9yIEpTT04gb2JqZWN0IGdpdmVuIGFzIGFycmF5Ljxicj5Ac2VlIFtkYXRh4oCka2V5c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0a2V5cykgfFxuICAgKiAgICB8IG1pbWVUeXBlIHwgIFNldCAnanNvbicgaWYgbG9hZGluZyBKU09OIHZpYSB1cmwuPGJyPkBzZWUgW2RhdGHigKRtaW1lVHlwZV0oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0bWltZVR5cGUpIHxcbiAgICogICAgfCAtIHR5cGU8YnI+LSB0eXBlcyB8IFRoZSB0eXBlIG9mIHRhcmdldHMgd2lsbCBiZSB1cGRhdGVkLiB0eXBlIG11c3QgYmUgU3RyaW5nIGFuZCB0eXBlcyBtdXN0IGJlIE9iamVjdC4gfFxuICAgKiAgICB8IHVubG9hZCB8IFNwZWNpZnkgdGhlIGRhdGEgd2lsbCBiZSB1bmxvYWRlZCBiZWZvcmUgbG9hZGluZyBuZXcgZGF0YS4gSWYgdHJ1ZSBnaXZlbiwgYWxsIG9mIGRhdGEgd2lsbCBiZSB1bmxvYWRlZC4gSWYgdGFyZ2V0IGlkcyBnaXZlbiBhcyBTdHJpbmcgb3IgQXJyYXksIHNwZWNpZmllZCB0YXJnZXRzIHdpbGwgYmUgdW5sb2FkZWQuIElmIGFic2VudCBvciBmYWxzZSBnaXZlbiwgdW5sb2FkIHdpbGwgbm90IG9jY3VyLiB8XG4gICAqICAgIHwgZG9uZSB8IFRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQufFxuICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhRnJvbVVSTClcbiAgICogQGV4YW1wbGVcbiAgICogLy8gTG9hZCBkYXRhMSBhbmQgdW5sb2FkIGRhdGEyIGFuZCBkYXRhM1xuICAgKiBjaGFydC5sb2FkKHtcbiAgICogICAgIGNvbHVtbnM6IFtcbiAgICogICAgICAgIFtcImRhdGExXCIsIDEwMCwgMjAwLCAxNTAsIC4uLl0sXG4gICAqICAgICAgICAuLi5cbiAgICogICAgXSxcbiAgICogICAgdW5sb2FkOiBbXCJkYXRhMlwiLCBcImRhdGEzXCJdLFxuICAgKiAgICB1cmw6IFwiLi4uXCIsXG4gICAqICAgIGRvbmU6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiB9KTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gbXlBUEkuanNvblxuICAgKiAvLyB7XG4gICAqIC8vICAgXCJkYXRhMVwiOiBbMjIwLCAyNDAsIDI3MCwgMjUwLCAyODBdLFxuICAgKiAvLyAgIFwiZGF0YTJcIjogWzE4MCwgMTUwLCAzMDAsIDcwLCAxMjBdXG4gICAqIC8vIH1cbiAgICpcbiAgICogY2hhcnQubG9hZCh7XG4gICAqICAgICB1cmw6ICcuL2RhdGEvbXlBUEkuanNvbicsXG4gICAqICAgICBtaW1lVHlwZTogXCJqc29uXCIsXG4gICAqXG4gICAqICAgICAvLyBzZXQgcmVxdWVzdCBoZWFkZXIgaWYgaXMgbmVlZGVkXG4gICAqICAgICBoZWFkZXJzOiB7XG4gICAqICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9qc29uXCJcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqIEBleGFtcGxlXG4gICAqIGNoYXJ0LmxvYWQoe1xuICAgKiAgICAgZGF0YTogW1xuICAgKiAgICAgICAvLyBlcXVpdmFsZW50IGFzOiBjb2x1bW5zOiBbW1wiZGF0YTFcIiwgMzAsIDIwMCwgMTAwXV1cbiAgICogICAgICAge1wiZGF0YTFcIjogMzB9LCB7XCJkYXRhMVwiOiAyMDB9LCB7XCJkYXRhMVwiOiAxMDB9XG4gICAqXG4gICAqICAgICAgIC8vIG9yXG4gICAqICAgICAgIC8vIGVxdWl2YWxlbnQgYXM6IGNvbHVtbnM6IFtbXCJkYXRhMVwiLCAxMCwgMjBdLCBbXCJkYXRhMlwiLCAxMywgMzBdXVxuICAgKiAgICAgICAvLyB7XCJkYXRhMVwiOiAxMCwgXCJkYXRhMlwiOiAxM30sIHtcImRhdGExXCI6IDIwLCBcImRhdGEyXCI6IDMwfX1cbiAgICogICAgIF1cbiAgICogfSk7XG4gICAqIEBleGFtcGxlXG4gICAqIGNoYXJ0LmxvYWQoe1xuICAgKiAgICAganNvbjogW1xuICAgKiAgICAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTEuY29tXCIsIHVwbG9hZDogODAwLCBkb3dubG9hZDogNTAwLCB0b3RhbDogNDAwfSxcbiAgICogICAgIF0sXG4gICAqICAgICBrZXlzOiB7XG4gICAqICAgICAgICAgeDogXCJuYW1lXCIsXG4gICAqICAgICAgICAgdmFsdWU6IFtcInVwbG9hZFwiLCBcImRvd25sb2FkXCJdXG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChhcmdzKSB7XG4gICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgIC8vIHVwZGF0ZSB4cyBpZiBzcGVjaWZpZWRcbiAgICAvLyB1cGRhdGUgbmFtZXMgaWYgZXhpc3RzXG4gICAgLy8gdXBkYXRlIGNsYXNzZXMgaWYgZXhpc3RzXG4gICAgLy8gdXBkYXRlIGF4ZXMgaWYgZXhpc3RzXG4gICAgLy8gdXBkYXRlIGNvbG9ycyBpZiBleGlzdHNcbiAgICBhcmdzLnhzICYmICQkLmFkZFhzKGFyZ3MueHMpLCBcIm5hbWVzXCIgaW4gYXJncyAmJiB0aGlzLmRhdGEubmFtZXMoYXJncy5uYW1lcyksIFwiY2xhc3Nlc1wiIGluIGFyZ3MgJiYgT2JqZWN0LmtleXMoYXJncy5jbGFzc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgY29uZmlnLmRhdGFfY2xhc3Nlc1tpZF0gPSBhcmdzLmNsYXNzZXNbaWRdO1xuICAgIH0pLCBcImNhdGVnb3JpZXNcIiBpbiBhcmdzICYmICQkLmlzQ2F0ZWdvcml6ZWQoKSAmJiAoY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gYXJncy5jYXRlZ29yaWVzKSwgXCJheGVzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmF4ZXMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBjb25maWcuZGF0YV9heGVzW2lkXSA9IGFyZ3MuYXhlc1tpZF07XG4gICAgfSksIFwiY29sb3JzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmNvbG9ycykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGNvbmZpZy5kYXRhX2NvbG9yc1tpZF0gPSBhcmdzLmNvbG9yc1tpZF07XG4gICAgfSksIFwidW5sb2FkXCIgaW4gYXJncyAmJiBhcmdzLnVubG9hZCAhPT0gITEgPyAkJC51bmxvYWQoJCQubWFwVG9UYXJnZXRJZHMoYXJncy51bmxvYWQgPT09ICEwID8gbnVsbCA6IGFyZ3MudW5sb2FkKSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICQkLmxvYWRGcm9tQXJncyhhcmdzKTtcbiAgICB9KSA6ICQkLmxvYWRGcm9tQXJncyhhcmdzKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5sb2FkIGRhdGEgdG8gdGhlIGNoYXJ0Ljxicj48YnI+XG4gICAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgdG9nZ2xlcy5cbiAgICogLSA8Yj5Ob3RlOjwvYj5cbiAgICogSWYgeW91IGNhbGwgbG9hZCBBUEkgc29vbiBhZnRlci9iZWZvcmUgdW5sb2FkLCB1bmxvYWQgcGFyYW0gb2YgbG9hZCBzaG91bGQgYmUgdXNlZC4gT3RoZXJ3aXNlIGNoYXJ0IHdpbGwgbm90IGJlIHJlbmRlcmVkIHByb3Blcmx5IGJlY2F1c2Ugb2YgY2FuY2VsIG9mIGFuaW1hdGlvbi48YnI+XG4gICAqIGBkb25lYCB3aWxsIGJlIGNhbGxlZCBhZnRlciBkYXRhIGxvYWRlZCwgYnV0IGl0J3Mgbm90IGFmdGVyIHJlbmRlcmluZy4gSXQncyBiZWNhdXNlIHJlbmRlcmluZyB3aWxsIGZpbmlzaCBhZnRlciBzb21lIHRyYW5zaXRpb24gYW5kIHRoZXJlIGlzIHNvbWUgdGltZSBsYWcgYmV0d2VlbiBsb2FkaW5nIGFuZCByZW5kZXJpbmcuXG4gICAqIEBtZXRob2QgdW5sb2FkXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAgICogIHwga2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcbiAgICogIHwgLS0tIHwgLS0tIHwgLS0tIHxcbiAgICogIHwgaWRzIHwgU3RyaW5nICZ2ZXJ0OyBBcnJheSB8IFRhcmdldCBpZCBkYXRhIHRvIGJlIHVubG9hZGVkLiBJZiBub3QgZ2l2ZW4sIGFsbCBkYXRhIHdpbGwgYmUgdW5sb2FkZWQuIHxcbiAgICogIHwgZG9uZSB8IEZ1Y3Rpb24gfCBDYWxsYmFjayBhZnRlciBkYXRhIGlzIHVubG9hZGVkLiB8XG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBVbmxvYWQgZGF0YTIgYW5kIGRhdGEzXG4gICAqICBjaGFydC51bmxvYWQoe1xuICAgKiAgICBpZHM6IFtcImRhdGEyXCIsIFwiZGF0YTNcIl0sXG4gICAqICAgIGRvbmU6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAvLyBjYWxsZWQgYWZ0ZXIgdGhlIHVubG9hZGVkXG4gICAqICAgIH1cbiAgICogIH0pO1xuICAgKi9cbiAgdW5sb2FkOiBmdW5jdGlvbiB1bmxvYWQoYXJnc1ZhbHVlKSB7XG4gICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgYXJncyA9IGFyZ3NWYWx1ZSB8fCB7fTtcbiAgICBpc0FycmF5KGFyZ3MpID8gYXJncyA9IHtcbiAgICAgIGlkczogYXJnc1xuICAgIH0gOiBpc1N0cmluZyhhcmdzKSAmJiAoYXJncyA9IHtcbiAgICAgIGlkczogW2FyZ3NdXG4gICAgfSk7XG4gICAgdmFyIGlkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKGFyZ3MuaWRzKTtcbiAgICAkJC51bmxvYWQoaWRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkJC5yZWRyYXcoe1xuICAgICAgICB3aXRoVXBkYXRlT3JnWERvbWFpbjogITAsXG4gICAgICAgIHdpdGhVcGRhdGVYRG9tYWluOiAhMCxcbiAgICAgICAgd2l0aExlZ2VuZDogITBcbiAgICAgIH0pLCAkJC5yZW1vdmVDYWNoZShpZHMpLCBhcmdzLmRvbmUgJiYgYXJncy5kb25lKCk7XG4gICAgfSk7XG4gIH1cbn0pO1xuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZWFzZVwiLFwiY29tbW9uanMyXCI6XCJkMy1lYXNlXCIsXCJhbWRcIjpcImQzLWVhc2VcIixcInJvb3RcIjpcImQzXCJ9XG52YXIgZXh0ZXJuYWxfY29tbW9uanNfZDNfZWFzZV9jb21tb25qczJfZDNfZWFzZV9hbWRfZDNfZWFzZV9yb290X2QzXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9hcGkvYXBpLmZsb3cuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5cblxuXG5cblxuZXh0ZW5kKENoYXJ0X0NoYXJ0LnByb3RvdHlwZSwge1xuICAvKipcbiAgICogRmxvdyBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxuICAgKiBCeSB0aGlzIEFQSSwgeW91IGNhbiBhcHBlbmQgbmV3IGRhdGEgcG9pbnRzIHRvIHRoZSBjaGFydC5cbiAgICogQG1ldGhvZCBmbG93XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cbiAgICpcbiAgICogICAgfCBLZXkgfCBUeXBlIHwgRGVzY3JpcHRpb24gfFxuICAgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8XG4gICAqICAgIHwganNvbiB8IE9iamVjdCB8IERhdGEgYXMgSlNPTiBmb3JtYXQgKEBzZWUgW2RhdGHigKRqc29uXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRqc29uKSkgfFxuICAgKiAgICB8IHJvd3MgfCBBcnJheSB8IERhdGEgaW4gYXJyYXkgYXMgcm93IGZvcm1hdCAoQHNlZSBbZGF0YeKApHJvd3NdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGpzb24pKSB8XG4gICAqICAgIHwgY29sdW1ucyB8IEFycmF5IHwgRGF0YSBpbiBhcnJheSBhcyBjb2x1bW4gZm9ybWF0IChAc2VlIFtkYXRh4oCkY29sdW1uc10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0Y29sdW1ucykpIHxcbiAgICogICAgfCB0byB8IFN0cmluZyB8IFRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIHRvIHRoYXQgcG9pbnQuIElmIG5vdCBnaXZlbiwgdGhlIGxvd2VyIHggZWRnZSB3aWxsIG1vdmUgYnkgdGhlIG51bWJlciBvZiBnaXZlbiBkYXRhIHBvaW50cyB8XG4gICAqICAgIHwgbGVuZ3RoIHwgTnVtYmVyIHwgVGhlIGxvd2VyIHggZWRnZSB3aWxsIG1vdmUgYnkgdGhlIG51bWJlciBvZiB0aGlzIGFyZ3VtZW50IHxcbiAgICogICAgfCBkdXJhdGlvbiB8IE51bWJlciB8IFRoZSBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIHNwZWNpZmllZCB2YWx1ZS4gSWYgbm90IGdpdmVuLCB0cmFuc2l0aW9uLmR1cmF0aW9uIHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHxcbiAgICogICAgfCBkb25lIHwgRnVuY3Rpb24gfCBUaGUgc3BlY2lmaWVkIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gZmxvdyBlbmRzIHxcbiAgICpcbiAgICogLSAqKk5PVEU6KipcbiAgICogICAtIElmIGpzb24sIHJvd3MgYW5kIGNvbHVtbnMgZ2l2ZW4sIHRoZSBkYXRhIHdpbGwgYmUgbG9hZGVkLlxuICAgKiAgIC0gSWYgZGF0YSB0aGF0IGhhcyB0aGUgc2FtZSB0YXJnZXQgaWQgaXMgZ2l2ZW4sIHRoZSBjaGFydCB3aWxsIGJlIGFwcGVuZGVkLlxuICAgKiAgIC0gT3RoZXJ3aXNlLCBuZXcgdGFyZ2V0IHdpbGwgYmUgYWRkZWQuIE9uZSBvZiB0aGVzZSBpcyByZXF1aXJlZCB3aGVuIGNhbGxpbmcuXG4gICAqICAgLSBJZiBqc29uIHNwZWNpZmllZCwga2V5cyBpcyByZXF1aXJlZCBhcyB3ZWxsIGFzIGRhdGEuanNvbi5cbiAgICogXHQgLSBJZiB0YWIgaXNuJ3QgdmlzaWJsZShieSBldmFsdWF0aW5nIGBkb2N1bWVudC5oaWRkZW5gKSwgd2lsbCBub3QgYmUgZXhlY3V0ZWQgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSB3b3JrLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyAyIGRhdGEgcG9pbnRzIHdpbGwgYmUgYXBwcmVuZGVkIHRvIHRoZSB0YWlsIGFuZCBwb3BwZWQgZnJvbSB0aGUgaGVhZC5cbiAgICogLy8gQWZ0ZXIgdGhhdCwgNCBkYXRhIHBvaW50cyB3aWxsIGJlIGFwcGVuZGVkIGFuZCBubyBkYXRhIHBvaW50cyB3aWxsIGJlIHBvcHBvZWQuXG4gICAqIGNoYXJ0LmZsb3coe1xuICAgKiAgY29sdW1uczogW1xuICAgKiAgICBbXCJ4XCIsIFwiMjAxOC0wMS0xMVwiLCBcIjIwMTgtMDEtMjFcIl0sXG4gICAqICAgIFtcImRhdGExXCIsIDUwMCwgMjAwXSxcbiAgICogICAgW1wiZGF0YTJcIiwgMTAwLCAzMDBdLFxuICAgKiAgICBbXCJkYXRhM1wiLCAyMDAsIDEyMF1cbiAgICogIF0sXG4gICAqICB0bzogXCIyMDEzLTAxLTExXCIsXG4gICAqICBkb25lOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgIGNoYXJ0LmZsb3coe1xuICAgKiAgICAgIGNvbHVtbnM6IFtcbiAgICogICAgICAgIFtcInhcIiwgXCIyMDE4LTAyLTExXCIsIFwiMjAxOC0wMi0xMlwiLCBcIjIwMTgtMDItMTNcIiwgXCIyMDE4LTAyLTE0XCJdLFxuICAgKiAgICAgICAgW1wiZGF0YTFcIiwgMjAwLCAzMDAsIDEwMCwgMjUwXSxcbiAgICogICAgICAgIFtcImRhdGEyXCIsIDEwMCwgOTAsIDQwLCAxMjBdLFxuICAgKiAgICAgICAgW1wiZGF0YTNcIiwgMTAwLCAxMDAsIDMwMCwgNTAwXVxuICAgKiAgICAgIF0sXG4gICAqICAgICAgbGVuZ3RoOiAyLFxuICAgICAgKiAgICAgIGR1cmF0aW9uOiAxNTAwXG4gICAqICAgIH0pO1xuICAgKiAgfVxuICAgKiB9KTtcbiAgICovXG4gIGZsb3c6IGZ1bmN0aW9uIGZsb3coYXJncykge1xuICAgIHZhciBkYXRhLFxuICAgICAgICBkb21haW4sXG4gICAgICAgIGRpZmYsXG4gICAgICAgIHRvLFxuICAgICAgICAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgIHRhaWwgPSAwO1xuXG4gICAgaWYgKChhcmdzLmpzb24gfHwgYXJncy5yb3dzIHx8IGFyZ3MuY29sdW1ucykgJiYgKGRhdGEgPSAkJC5jb252ZXJ0RGF0YShhcmdzKSksIGRhdGEgJiYgJCQuaXNUYWJWaXNpYmxlKCkpIHtcbiAgICAgIHZhciBub3Rmb3VuZElkcyA9IFtdLFxuICAgICAgICAgIG9yZ0RhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpLFxuICAgICAgICAgIHRhcmdldHMgPSAkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cyhkYXRhLCAhMCk7XG4gICAgICAkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBmb3VuZCA9ICExLCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIGlmICh0LmlkID09PSB0YXJnZXRzW2ldLmlkKSB7XG4gICAgICAgICAgZm91bmQgPSAhMCwgdC52YWx1ZXNbdC52YWx1ZXMubGVuZ3RoIC0gMV0gJiYgKHRhaWwgPSB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS5pbmRleCArIDEpLCBsZW5ndGggPSB0YXJnZXRzW2ldLnZhbHVlcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBfajMgPSAwOyBfajMgPCBsZW5ndGg7IF9qMysrKSB0YXJnZXRzW2ldLnZhbHVlc1tfajNdLmluZGV4ID0gdGFpbCArIF9qMywgJCQuaXNUaW1lU2VyaWVzKCkgfHwgKHRhcmdldHNbaV0udmFsdWVzW19qM10ueCA9IHRhaWwgKyBfajMpO1xuXG4gICAgICAgICAgdC52YWx1ZXMgPSB0LnZhbHVlcy5jb25jYXQodGFyZ2V0c1tpXS52YWx1ZXMpLCB0YXJnZXRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvdW5kIHx8IG5vdGZvdW5kSWRzLnB1c2godC5pZCk7XG4gICAgICB9KSwgJCQuZGF0YS50YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vdGZvdW5kSWRzLmxlbmd0aDsgX2krKykgaWYgKHQuaWQgPT09IG5vdGZvdW5kSWRzW19pXSkge1xuICAgICAgICAgIHRhaWwgPSB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS5pbmRleCArIDE7XG5cbiAgICAgICAgICBmb3IgKHZhciBfajQgPSAwOyBfajQgPCBsZW5ndGg7IF9qNCsrKSB0LnZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiB0LmlkLFxuICAgICAgICAgICAgaW5kZXg6IHRhaWwgKyBfajQsXG4gICAgICAgICAgICB4OiAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLmdldE90aGVyVGFyZ2V0WCh0YWlsICsgX2o0KSA6IHRhaWwgKyBfajQsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgJCQuZGF0YS50YXJnZXRzLmxlbmd0aCAmJiB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgbWlzc2luZyA9IFtdLCBpID0gJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlc1swXS5pbmRleDsgaSA8IHRhaWw7IGkrKykgbWlzc2luZy5wdXNoKHtcbiAgICAgICAgICBpZDogdC5pZCxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICB4OiAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLmdldE90aGVyVGFyZ2V0WChpKSA6IGksXG4gICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHYuaW5kZXggKz0gdGFpbCwgJCQuaXNUaW1lU2VyaWVzKCkgfHwgKHYueCArPSB0YWlsKTtcbiAgICAgICAgfSksIHQudmFsdWVzID0gbWlzc2luZy5jb25jYXQodC52YWx1ZXMpO1xuICAgICAgfSksICQkLmRhdGEudGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cy5jb25jYXQodGFyZ2V0cyk7XG4gICAgICAvLyBhZGQgcmVtYWluZWRcbiAgICAgIC8vIGNoZWNrIGRhdGEgY291bnQgYmVjYXVzZSBiZWhhdmlvciBuZWVkcyB0byBjaGFuZ2Ugd2hlbiBpdFwicyBvbmx5IG9uZVxuICAgICAgLy8gY29uc3QgZGF0YUNvdW50ID0gJCQuZ2V0TWF4RGF0YUNvdW50KCk7XG4gICAgICB2YXIgYmFzZVRhcmdldCA9ICQkLmRhdGEudGFyZ2V0c1swXSxcbiAgICAgICAgICBiYXNlVmFsdWUgPSBiYXNlVGFyZ2V0LnZhbHVlc1swXTtcbiAgICAgIGlzRGVmaW5lZChhcmdzLnRvKSA/IChsZW5ndGggPSAwLCB0byA9ICQkLmlzVGltZVNlcmllcygpID8gJCQucGFyc2VEYXRlKGFyZ3MudG8pIDogYXJncy50bywgYmFzZVRhcmdldC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICB2LnggPCB0byAmJiBsZW5ndGgrKztcbiAgICAgIH0pKSA6IGlzRGVmaW5lZChhcmdzLmxlbmd0aCkgJiYgKGxlbmd0aCA9IGFyZ3MubGVuZ3RoKSwgb3JnRGF0YUNvdW50ID8gb3JnRGF0YUNvdW50ID09PSAxICYmICQkLmlzVGltZVNlcmllcygpICYmIChkaWZmID0gKGJhc2VUYXJnZXQudmFsdWVzW2Jhc2VUYXJnZXQudmFsdWVzLmxlbmd0aCAtIDFdLnggLSBiYXNlVmFsdWUueCkgLyAyLCBkb21haW4gPSBbbmV3IERhdGUoK2Jhc2VWYWx1ZS54IC0gZGlmZiksIG5ldyBEYXRlKCtiYXNlVmFsdWUueCArIGRpZmYpXSkgOiAoZGlmZiA9ICQkLmlzVGltZVNlcmllcygpID8gYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoID4gMSA/IGJhc2VUYXJnZXQudmFsdWVzW2Jhc2VUYXJnZXQudmFsdWVzLmxlbmd0aCAtIDFdLnggLSBiYXNlVmFsdWUueCA6IGJhc2VWYWx1ZS54IC0gJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpWzBdIDogMSwgZG9tYWluID0gW2Jhc2VWYWx1ZS54IC0gZGlmZiwgYmFzZVZhbHVlLnhdKSwgZG9tYWluICYmICQkLnVwZGF0ZVhEb21haW4obnVsbCwgITAsICEwLCAhMSwgZG9tYWluKSwgJCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpLCAkJC5yZWRyYXcoe1xuICAgICAgICBmbG93OiB7XG4gICAgICAgICAgaW5kZXg6IGJhc2VWYWx1ZS5pbmRleCxcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICBkdXJhdGlvbjogaXNWYWx1ZShhcmdzLmR1cmF0aW9uKSA/IGFyZ3MuZHVyYXRpb24gOiAkJC5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbixcbiAgICAgICAgICBkb25lOiBhcmdzLmRvbmUsXG4gICAgICAgICAgb3JnRGF0YUNvdW50OiBvcmdEYXRhQ291bnRcbiAgICAgICAgfSxcbiAgICAgICAgd2l0aExlZ2VuZDogITAsXG4gICAgICAgIHdpdGhUcmFuc2l0aW9uOiBvcmdEYXRhQ291bnQgPiAxLFxuICAgICAgICB3aXRoVHJpbVhEb21haW46ICExLFxuICAgICAgICB3aXRoVXBkYXRlWEF4aXM6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pLCBleHRlbmQoQ2hhcnRJbnRlcm5hbF9DaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogR2VuZXJhdGUgZmxvd1xuICAgKiBAbWVtYmVyb2YgQ2hhcnRJbnRlcm5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIGdlbmVyYXRlRmxvdzogZnVuY3Rpb24gZ2VuZXJhdGVGbG93KGFyZ3MpIHtcbiAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0cmFuc2xhdGVYLFxuICAgICAgICAgIHRhcmdldHMgPSBhcmdzLnRhcmdldHMsXG4gICAgICAgICAgZmxvdyA9IGFyZ3MuZmxvdyxcbiAgICAgICAgICBfYXJncyRzaGFwZSR0eXBlID0gYXJncy5zaGFwZS50eXBlLFxuICAgICAgICAgIGRyYXdCYXIgPSBfYXJncyRzaGFwZSR0eXBlLmJhcixcbiAgICAgICAgICBkcmF3TGluZSA9IF9hcmdzJHNoYXBlJHR5cGUubGluZSxcbiAgICAgICAgICBkcmF3QXJlYSA9IF9hcmdzJHNoYXBlJHR5cGUuYXJlYSxcbiAgICAgICAgICBfYXJncyRzaGFwZSRwb3MgPSBhcmdzLnNoYXBlLnBvcyxcbiAgICAgICAgICBjeCA9IF9hcmdzJHNoYXBlJHBvcy5jeCxcbiAgICAgICAgICBjeSA9IF9hcmdzJHNoYXBlJHBvcy5jeSxcbiAgICAgICAgICB4Rm9yVGV4dCA9IF9hcmdzJHNoYXBlJHBvcy54Rm9yVGV4dCxcbiAgICAgICAgICB5Rm9yVGV4dCA9IF9hcmdzJHNoYXBlJHBvcy55Rm9yVGV4dCxcbiAgICAgICAgICB4diA9IGFyZ3MueHYsXG4gICAgICAgICAgZHVyYXRpb24gPSBhcmdzLmR1cmF0aW9uLFxuICAgICAgICAgIHNjYWxlWCA9IDEsXG4gICAgICAgICAgZmxvd0luZGV4ID0gZmxvdy5pbmRleCxcbiAgICAgICAgICBmbG93TGVuZ3RoID0gZmxvdy5sZW5ndGgsXG4gICAgICAgICAgZmxvd1N0YXJ0ID0gJCQuZ2V0VmFsdWVPbkluZGV4KCQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMsIGZsb3dJbmRleCksXG4gICAgICAgICAgZmxvd0VuZCA9ICQkLmdldFZhbHVlT25JbmRleCgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLCBmbG93SW5kZXggKyBmbG93TGVuZ3RoKSxcbiAgICAgICAgICBvcmdEb21haW4gPSAkJC54LmRvbWFpbigpLFxuICAgICAgICAgIGR1cmF0aW9uRm9yRmxvdyA9IGZsb3cuZHVyYXRpb24gfHwgZHVyYXRpb24sXG4gICAgICAgICAgZG9uZSA9IGZsb3cuZG9uZSB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICB3YWl0ID0gJCQuZ2VuZXJhdGVXYWl0KCksXG4gICAgICAgICAgeGdyaWQgPSAkJC54Z3JpZCB8fCBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdEFsbFwiXSkoW10pLFxuICAgICAgICAgIHhncmlkTGluZXMgPSAkJC54Z3JpZExpbmVzIHx8IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0QWxsXCJdKShbXSksXG4gICAgICAgICAgbWFpblJlZ2lvbiA9ICQkLm1haW5SZWdpb24gfHwgT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RBbGxcIl0pKFtdKSxcbiAgICAgICAgICBtYWluVGV4dCA9ICQkLm1haW5UZXh0IHx8IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0QWxsXCJdKShbXSksXG4gICAgICAgICAgbWFpbkJhciA9ICQkLm1haW5CYXIgfHwgT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RBbGxcIl0pKFtdKSxcbiAgICAgICAgICBtYWluTGluZSA9ICQkLm1haW5MaW5lIHx8IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0QWxsXCJdKShbXSksXG4gICAgICAgICAgbWFpbkFyZWEgPSAkJC5tYWluQXJlYSB8fCBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdEFsbFwiXSkoW10pLFxuICAgICAgICAgIG1haW5DaXJjbGUgPSAkJC5tYWluQ2lyY2xlIHx8IE9iamVjdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wic2VsZWN0QWxsXCJdKShbXSk7XG5cbiAgICAgICQkLmZsb3dpbmcgPSAhMCwgJCQuZGF0YS50YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZC52YWx1ZXMuc3BsaWNlKDAsIGZsb3dMZW5ndGgpO1xuICAgICAgfSk7XG4gICAgICAvLyB1cGRhdGUgeCBkb21haW4gdG8gZ2VuZXJhdGUgYXhpcyBlbGVtZW50cyBmb3IgZmxvd1xuICAgICAgdmFyIGRvbWFpbiA9ICQkLnVwZGF0ZVhEb21haW4odGFyZ2V0cywgITAsICEwKTsgLy8gdXBkYXRlIGVsZW1lbnRzIHJlbGF0ZWQgdG8geCBzY2FsZVxuXG4gICAgICAkJC51cGRhdGVYR3JpZCAmJiAkJC51cGRhdGVYR3JpZCghMCksIGZsb3cub3JnRGF0YUNvdW50ID8gZmxvdy5vcmdEYXRhQ291bnQgPT09IDEgfHwgKGZsb3dTdGFydCAmJiBmbG93U3RhcnQueCkgPT09IChmbG93RW5kICYmIGZsb3dFbmQueCkgPyB0cmFuc2xhdGVYID0gJCQueChvcmdEb21haW5bMF0pIC0gJCQueChkb21haW5bMF0pIDogJCQuaXNUaW1lU2VyaWVzKCkgPyB0cmFuc2xhdGVYID0gJCQueChvcmdEb21haW5bMF0pIC0gJCQueChkb21haW5bMF0pIDogdHJhbnNsYXRlWCA9ICQkLngoZmxvd1N0YXJ0LngpIC0gJCQueChmbG93RW5kLngpIDogJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcy5sZW5ndGggPT09IDEgPyAkJC5pc1RpbWVTZXJpZXMoKSA/IChmbG93U3RhcnQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcywgMCksIGZsb3dFbmQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcywgJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcy5sZW5ndGggLSAxKSwgdHJhbnNsYXRlWCA9ICQkLngoZmxvd1N0YXJ0LngpIC0gJCQueChmbG93RW5kLngpKSA6IHRyYW5zbGF0ZVggPSBkaWZmRG9tYWluKGRvbWFpbikgLyAyIDogdHJhbnNsYXRlWCA9ICQkLngob3JnRG9tYWluWzBdKSAtICQkLngoZG9tYWluWzBdKSwgc2NhbGVYID0gZGlmZkRvbWFpbihvcmdEb21haW4pIC8gZGlmZkRvbWFpbihkb21haW4pO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh0cmFuc2xhdGVYLCBcIiwwKSBzY2FsZShcIikuY29uY2F0KHNjYWxlWCwgXCIsMSlcIik7XG4gICAgICAkJC5oaWRlR3JpZEZvY3VzKCk7XG4gICAgICB2YXIgZ3QgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfdHJhbnNpdGlvbl9jb21tb25qczJfZDNfdHJhbnNpdGlvbl9hbWRfZDNfdHJhbnNpdGlvbl9yb290X2QzX1tcInRyYW5zaXRpb25cIl0pKCkuZWFzZShleHRlcm5hbF9jb21tb25qc19kM19lYXNlX2NvbW1vbmpzMl9kM19lYXNlX2FtZF9kM19lYXNlX3Jvb3RfZDNfW1wiZWFzZUxpbmVhclwiXSkuZHVyYXRpb24oZHVyYXRpb25Gb3JGbG93KTtcbiAgICAgIHdhaXQuYWRkKFskJC5heGVzLngudHJhbnNpdGlvbihndCkuY2FsbChmdW5jdGlvbiAoZykge1xuICAgICAgICByZXR1cm4gJCQueEF4aXMuc2V0VHJhbnNpdGlvbihndCkuY3JlYXRlKGcpO1xuICAgICAgfSksIG1haW5CYXIudHJhbnNpdGlvbihndCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLCBtYWluTGluZS50cmFuc2l0aW9uKGd0KS5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSksIG1haW5BcmVhLnRyYW5zaXRpb24oZ3QpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSwgbWFpbkNpcmNsZS50cmFuc2l0aW9uKGd0KS5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSksIG1haW5UZXh0LnRyYW5zaXRpb24oZ3QpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSwgbWFpblJlZ2lvbi5maWx0ZXIoJCQuaXNSZWdpb25PblgpLnRyYW5zaXRpb24oZ3QpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSwgeGdyaWQudHJhbnNpdGlvbihndCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLCB4Z3JpZExpbmVzLnRyYW5zaXRpb24oZ3QpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKV0pLCBndC5jYWxsKHdhaXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7IC8vIHJlbW92ZSBmbG93ZWQgZWxlbWVudHNcblxuICAgICAgICBpZiAoZmxvd0xlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIHRhcmdldCA9IHtcbiAgICAgICAgICAgIHNoYXBlczogW10sXG4gICAgICAgICAgICB0ZXh0czogW10sXG4gICAgICAgICAgICBldmVudFJlY3RzOiBbXVxuICAgICAgICAgIH0sIGkgPSAwOyBpIDwgZmxvd0xlbmd0aDsgaSsrKSB0YXJnZXQuc2hhcGVzLnB1c2goXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnNoYXBlLCBcIi1cIikuY29uY2F0KGkpKSwgdGFyZ2V0LnRleHRzLnB1c2goXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnRleHQsIFwiLVwiKS5jb25jYXQoaSkpLCB0YXJnZXQuZXZlbnRSZWN0cy5wdXNoKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5ldmVudFJlY3QsIFwiLVwiKS5jb25jYXQoaSkpO1xuXG4gICAgICAgICAgW1wic2hhcGVzXCIsIFwidGV4dHNcIiwgXCJldmVudFJlY3RzXCJdLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICQkLnN2Zy5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzW3ZdKSkuc2VsZWN0QWxsKHRhcmdldFt2XSkucmVtb3ZlKCk7XG4gICAgICAgICAgfSksICQkLnN2Zy5zZWxlY3QoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnhncmlkKSkucmVtb3ZlKCk7XG4gICAgICAgIH0gLy8gZHJhdyBhZ2FpbiBmb3IgcmVtb3ZpbmcgZmxvd2VkIGVsZW1lbnRzIGFuZCByZXZlcnRpbmcgYXR0clxuXG5cbiAgICAgICAgaWYgKHhncmlkLnNpemUoKSAmJiB4Z3JpZC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpLmF0dHIoJCQueGdyaWRBdHRyKSwgeGdyaWRMaW5lcy5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpLCB4Z3JpZExpbmVzLnNlbGVjdChcImxpbmVcIikuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiB4dikuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/ICQkLndpZHRoIDogeHYpLCB4Z3JpZExpbmVzLnNlbGVjdChcInRleHRcIikuYXR0cihcInhcIiwgaXNSb3RhdGVkID8gJCQud2lkdGggOiAwKS5hdHRyKFwieVwiLCB4diksIG1haW5CYXIuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKS5hdHRyKFwiZFwiLCBkcmF3QmFyKSwgbWFpbkxpbmUuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKS5hdHRyKFwiZFwiLCBkcmF3TGluZSksIG1haW5BcmVhLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCkuYXR0cihcImRcIiwgZHJhd0FyZWEpLCBtYWluQ2lyY2xlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCksICQkLmlzQ2lyY2xlUG9pbnQoKSkgbWFpbkNpcmNsZS5hdHRyKFwiY3hcIiwgY3gpLmF0dHIoXCJjeVwiLCBjeSk7ZWxzZSB7XG4gICAgICAgICAgdmFyIHhGdW5jID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjeChkKSAtIGNvbmZpZy5wb2ludF9yO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHlGdW5jID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjeShkKSAtIGNvbmZpZy5wb2ludF9yO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBtYWluQ2lyY2xlLmF0dHIoXCJ4XCIsIHhGdW5jKS5hdHRyKFwieVwiLCB5RnVuYykuYXR0cihcImN4XCIsIGN4KSAvLyB3aGVuIHBhdHRlcm4gaXMgdXNlZCwgaXQgcG9zc2libHkgY29udGFpbiAnY2lyY2xlJyBhbHNvLlxuICAgICAgICAgIC5hdHRyKFwiY3lcIiwgY3kpO1xuICAgICAgICB9XG4gICAgICAgIG1haW5UZXh0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCkuYXR0cihcInhcIiwgeEZvclRleHQpLmF0dHIoXCJ5XCIsIHlGb3JUZXh0KS5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCAkJC5vcGFjaXR5Rm9yVGV4dC5iaW5kKCQkKSksIG1haW5SZWdpb24uYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKSwgbWFpblJlZ2lvbi5zZWxlY3QoXCJyZWN0XCIpLmZpbHRlcigkJC5pc1JlZ2lvbk9uWCkuYXR0cihcInhcIiwgJCQucmVnaW9uWC5iaW5kKCQkKSkuYXR0cihcIndpZHRoXCIsICQkLnJlZ2lvbldpZHRoLmJpbmQoJCQpKSwgY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgJCQucmVkcmF3RXZlbnRSZWN0KCksIGRvbmUoKSwgJCQuZmxvd2luZyA9ICExO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9hcGkvYXBpLnNlbGVjdGlvbi5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuXG5leHRlbmQoQ2hhcnRfQ2hhcnQucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBHZXQgc2VsZWN0ZWQgZGF0YSBwb2ludHMuPGJyPjxicj5cbiAgICogQnkgdGhpcyBBUEksIHlvdSBjYW4gZ2V0IHNlbGVjdGVkIGRhdGEgcG9pbnRzIGluZm9ybWF0aW9uLiBUbyB1c2UgdGhpcyBBUEksIGRhdGEuc2VsZWN0aW9uLmVuYWJsZWQgbmVlZHMgdG8gYmUgc2V0IHRydWUuXG4gICAqIEBtZXRob2Qgc2VsZWN0ZWRcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3RhcmdldElkXSBZb3UgY2FuIGZpbHRlciB0aGUgcmVzdWx0IGJ5IGdpdmluZyB0YXJnZXQgaWQgdGhhdCB5b3Ugd2FudCB0byBnZXQuIElmIG5vdCBnaXZlbiwgYWxsIG9mIGRhdGEgcG9pbnRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge0FycmF5fSBkYXRhUG9pbnQgQXJyYXkgb2YgdGhlIGRhdGEgcG9pbnRzLjxicj5leC4pIGBbe3g6IDEsIHZhbHVlOiAyMDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAxLCBuYW1lOiBcImRhdGExXCJ9LCAuLi5dYFxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gYWxsIHNlbGVjdGVkIGRhdGEgcG9pbnRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqICBjaGFydC5zZWxlY3RlZCgpO1xuICAgKiAgLy8gLS0+IGV4LikgW3t4OiAxLCB2YWx1ZTogMjAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogMSwgbmFtZTogXCJkYXRhMVwifSwgLi4uIF1cbiAgICpcbiAgICogIC8vIGFsbCBzZWxlY3RlZCBkYXRhIHBvaW50cyBvZiBkYXRhMSB3aWxsIGJlIHJldHVybmVkLlxuICAgKiAgY2hhcnQuc2VsZWN0ZWQoXCJkYXRhMVwiKTtcbiAgICovXG4gIHNlbGVjdGVkOiBmdW5jdGlvbiBzZWxlY3RlZCh0YXJnZXRJZCkge1xuICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgIGRhdGFQb2ludCA9IFtdO1xuICAgIHJldHVybiAkJC5tYWluLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuc2hhcGVzICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpKSkuc2VsZWN0QWxsKFwiLlwiLmNvbmNhdChjb25maWdfY2xhc3Nlcy5zaGFwZSkpLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX2NvbW1vbmpzX2QzX3NlbGVjdGlvbl9jb21tb25qczJfZDNfc2VsZWN0aW9uX2FtZF9kM19zZWxlY3Rpb25fcm9vdF9kM19bXCJzZWxlY3RcIl0pKHRoaXMpLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuU0VMRUNURUQpO1xuICAgIH0pLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkYXRhUG9pbnQucHVzaChkKTtcbiAgICB9KSwgZGF0YVBvaW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgZGF0YSBwb2ludHMgdG8gYmUgc2VsZWN0ZWQuIChgW2RhdGEuc2VsZWN0aW9uLmVuYWJsZWRdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNHNlbGVjdGlvbiUyNUUyJTI1ODAlMjVBNGVuYWJsZWQpIG9wdGlvbiBzaG91bGQgYmUgc2V0IHRydWUgdG8gdXNlIHRoaXMgbWV0aG9kKWBcbiAgICogQG1ldGhvZCBzZWxlY3RcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW2lkc10gaWQgdmFsdWUgdG8gZ2V0IHNlbGVjdGVkLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXNldE90aGVyXSBVbnNlbGVjdCBhbHJlYWR5IHNlbGVjdGVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gc2VsZWN0IGFsbCBkYXRhIHBvaW50c1xuICAgKiAgY2hhcnQuc2VsZWN0KCk7XG4gICAqXG4gICAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGEyJ1xuICAgKiAgY2hhcnQuc2VsZWN0KFwiZGF0YTJcIik7XG4gICAqXG4gICAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGExJyBhbmQgJ2RhdGEyJ1xuICAgKiAgY2hhcnQuc2VsZWN0KFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuICAgKlxuICAgKiAgLy8gc2VsZWN0IGZyb20gJ2RhdGExJywgaW5kaWNlcyAyIGFuZCB1bnNlbGVjdCBvdGhlcnMgc2VsZWN0ZWRcbiAgICogIGNoYXJ0LnNlbGVjdChcImRhdGExXCIsIFsyXSwgdHJ1ZSk7XG4gICAqXG4gICAqICAvLyBzZWxlY3QgZnJvbSAnZGF0YTEnLCBpbmRpY2VzIDAsIDMgYW5kIDVcbiAgICogIGNoYXJ0LnNlbGVjdChcImRhdGExXCIsIFswLCAzLCA1XSk7XG4gICAqL1xuICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChpZHMsIGluZGljZXMsIHJlc2V0T3RoZXIpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgJiYgJCQubWFpbi5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnNoYXBlcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuc2hhcGUpKS5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICB2YXIgc2hhcGUgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhpcyksXG4gICAgICAgICAgaWQgPSBkLmRhdGEgPyBkLmRhdGEuaWQgOiBkLmlkLFxuICAgICAgICAgIHRvZ2dsZSA9ICQkLmdldFRvZ2dsZSh0aGlzLCBkKS5iaW5kKCQkKSxcbiAgICAgICAgICBpc1RhcmdldElkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgIWlkcyB8fCBpZHMuaW5kZXhPZihpZCkgPj0gMCxcbiAgICAgICAgICBpc1RhcmdldEluZGV4ID0gIWluZGljZXMgfHwgaW5kaWNlcy5pbmRleE9mKGkpID49IDAsXG4gICAgICAgICAgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuU0VMRUNURUQpO1xuICAgICAgLy8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxuICAgICAgc2hhcGUuY2xhc3NlZChjb25maWdfY2xhc3Nlcy5saW5lKSB8fCBzaGFwZS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmFyZWEpIHx8IChpc1RhcmdldElkICYmIGlzVGFyZ2V0SW5kZXggPyBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpICYmICFpc1NlbGVjdGVkICYmIHRvZ2dsZSghMCwgc2hhcGUuY2xhc3NlZChjb25maWdfY2xhc3Nlcy5TRUxFQ1RFRCwgITApLCBkLCBpKSA6IGlzRGVmaW5lZChyZXNldE90aGVyKSAmJiByZXNldE90aGVyICYmIGlzU2VsZWN0ZWQgJiYgdG9nZ2xlKCExLCBzaGFwZS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLlNFTEVDVEVELCAhMSksIGQsIGkpKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGRhdGEgcG9pbnRzIHRvIGJlIHVuLXNlbGVjdGVkLlxuICAgKiBAbWV0aG9kIHVuc2VsZWN0XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFtpZHNdIGlkIHZhbHVlIHRvIGJlIHVuc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtpbmRpY2VzXSBUaGUgaW5kZXggYXJyYXkgb2YgZGF0YSBwb2ludHMuIElmIGZhbHN5IHZhbHVlIGdpdmVuLCB3aWxsIHNlbGVjdCBhbGwgZGF0YSBwb2ludHMuXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyB1bnNlbGVjdCBhbGwgZGF0YSBwb2ludHNcbiAgICogIGNoYXJ0LnVuc2VsZWN0KCk7XG4gICAqXG4gICAqICAvLyB1bnNlbGVjdCBhbGwgZnJvbSAnZGF0YTEnXG4gICAqICBjaGFydC51bnNlbGVjdChcImRhdGExXCIpO1xuICAgKlxuICAgKiAgLy8gdW5zZWxlY3QgZnJvbSAnZGF0YTEnLCBpbmRpY2VzIDJcbiAgICogIGNoYXJ0LnVuc2VsZWN0KFwiZGF0YTFcIiwgWzJdKTtcbiAgICovXG4gIHVuc2VsZWN0OiBmdW5jdGlvbiB1bnNlbGVjdChpZHMsIGluZGljZXMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgJiYgJCQubWFpbi5zZWxlY3RBbGwoXCIuXCIuY29uY2F0KGNvbmZpZ19jbGFzc2VzLnNoYXBlcykpLnNlbGVjdEFsbChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMuc2hhcGUpKS5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICB2YXIgc2hhcGUgPSBPYmplY3QoZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcInNlbGVjdFwiXSkodGhpcyksXG4gICAgICAgICAgaWQgPSBkLmRhdGEgPyBkLmRhdGEuaWQgOiBkLmlkLFxuICAgICAgICAgIHRvZ2dsZSA9ICQkLmdldFRvZ2dsZSh0aGlzLCBkKS5iaW5kKCQkKSxcbiAgICAgICAgICBpc1RhcmdldElkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgIWlkcyB8fCBpZHMuaW5kZXhPZihpZCkgPj0gMCxcbiAgICAgICAgICBpc1RhcmdldEluZGV4ID0gIWluZGljZXMgfHwgaW5kaWNlcy5pbmRleE9mKGkpID49IDAsXG4gICAgICAgICAgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoY29uZmlnX2NsYXNzZXMuU0VMRUNURUQpO1xuICAgICAgLy8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxuICAgICAgc2hhcGUuY2xhc3NlZChjb25maWdfY2xhc3Nlcy5saW5lKSB8fCBzaGFwZS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLmFyZWEpIHx8IGlzVGFyZ2V0SWQgJiYgaXNUYXJnZXRJbmRleCAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpICYmIGlzU2VsZWN0ZWQgJiYgdG9nZ2xlKCExLCBzaGFwZS5jbGFzc2VkKGNvbmZpZ19jbGFzc2VzLlNFTEVDVEVELCAhMSksIGQsIGkpO1xuICAgIH0pO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FwaS9hcGkudHJhbnNmb3JtLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIGNoYXJ0LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc0ZvclJlZHJhd1xuICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVRvKHRhcmdldElkcywgdHlwZSwgb3B0aW9uc0ZvclJlZHJhdykge1xuICB2YXIgJCQgPSB0aGlzLFxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnNGb3JSZWRyYXcgfHwge1xuICAgIHdpdGhUcmFuc2l0aW9uRm9yQXhpczogISQkLmhhc0FyY1R5cGUoKVxuICB9O1xuICAvLyB0aGlzIGlzIG5lZWRlZCB3aGVuIHRyYW5zZm9ybWluZyB0byBhcmNcbiAgb3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSA9ICExLCAkJC50cmFuc2l0aW5nID0gITEsICQkLnNldFRhcmdldFR5cGUodGFyZ2V0SWRzLCB0eXBlKSwgJCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpLCAkJC51cGRhdGVBbmRSZWRyYXcob3B0aW9ucyk7XG59XG5cbmV4dGVuZChDaGFydF9DaGFydC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgdHlwZSBvZiB0aGUgY2hhcnQuXG4gICAqIEBtZXRob2QgdHJhbnNmb3JtXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgU3BlY2lmeSB0aGUgdHlwZSB0byBiZSB0cmFuc2Zvcm1lZC4gVGhlIHR5cGVzIGxpc3RlZCBpbiBkYXRhLnR5cGUgY2FuIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHMgU3BlY2lmeSB0YXJnZXRzIHRvIGJlIHRyYW5zZm9ybWVkLiBJZiBub3QgZ2l2ZW4sIGFsbCB0YXJnZXRzIHdpbGwgYmUgdGhlIGNhbmRpZGF0ZS5cbiAgICogQGV4YW1wbGVcbiAgICogIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgYmFyIGNoYXJ0LlxuICAgKiAgY2hhcnQudHJhbnNmb3JtKFwiYmFyXCIpO1xuICAgKlxuICAgKiAgLy8gb25seSBkYXRhMSB3aWxsIGJlIGJhciBjaGFydC5cbiAgICogIGNoYXJ0LnRyYW5zZm9ybShcImJhclwiLCBcImRhdGExXCIpO1xuICAgKlxuICAgKiAgLy8gb25seSBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBiYXIgY2hhcnQuXG4gICAqICBjaGFydC50cmFuc2Zvcm0oXCJiYXJcIiwgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybSh0eXBlLCB0YXJnZXRJZHMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICBvcHRpb25zID0gW1wicGllXCIsIFwiZG9udXRcIl0uaW5kZXhPZih0eXBlKSA+PSAwID8ge1xuICAgICAgd2l0aFRyYW5zZm9ybTogITBcbiAgICB9IDogbnVsbDtcbiAgICB0cmFuc2Zvcm1Uby5iaW5kKCQkKSh0YXJnZXRJZHMsIHR5cGUsIG9wdGlvbnMpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FwaS9hcGkuZ3JvdXAuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5leHRlbmQoQ2hhcnRfQ2hhcnQucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBVcGRhdGUgZ3JvdXBzIGZvciB0aGUgdGFyZ2V0cy5cbiAgICogQG1ldGhvZCBncm91cHNcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge0FycmF5fSBncm91cHMgVGhpcyBhcmd1bWVudCBuZWVkcyB0byBiZSBhbiBBcnJheSB0aGF0IGluY2x1ZGVzIG9uZSBvciBtb3JlIEFycmF5IHRoYXQgaW5jbHVkZXMgdGFyZ2V0IGlkcyB0byBiZSBncm91cGVkLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gR3JvdXBlZCBkYXRhIG5hbWVzIGFycmF5XG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBhIG5ldyBncm91cC5cbiAgICogIGNoYXJ0Lmdyb3VwcyhbXG4gICAqICAgICBbXCJkYXRhMVwiLCBcImRhdGEyXCJdXG4gICAqICBdKTtcbiAgICovXG4gIGdyb3VwczogZnVuY3Rpb24gZ3JvdXBzKF9ncm91cHMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKF9ncm91cHMpID8gY29uZmlnLmRhdGFfZ3JvdXBzIDogKGNvbmZpZy5kYXRhX2dyb3VwcyA9IF9ncm91cHMsICQkLnJlZHJhdygpLCBjb25maWcuZGF0YV9ncm91cHMpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FwaS9hcGkuZ3JpZC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cbi8qKlxuICogVXBkYXRlIHggZ3JpZCBsaW5lcy5cbiAqIEBtZXRob2QgeGdyaWRzXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQHBhcmFtIHtBcnJheX0gZ3JpZHMgWCBncmlkIGxpbmVzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC54LmxpbmVzLlxuICogQGV4YW1wbGVcbiAqICAvLyBTaG93IDIgeCBncmlkIGxpbmVzXG4gKiBjaGFydC54Z3JpZHMoW1xuICogICAge3ZhbHVlOiAxLCB0ZXh0OiBcIkxhYmVsIDFcIn0sXG4gKiAgICB7dmFsdWU6IDQsIHRleHQ6IFwiTGFiZWwgNFwifVxuICogXSk7XG4gKi9cblxudmFyIHhncmlkcyA9IGZ1bmN0aW9uIChncmlkcykge1xuICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICByZXR1cm4gZ3JpZHMgPyAoY29uZmlnLmdyaWRfeF9saW5lcyA9IGdyaWRzLCAkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpLCBjb25maWcuZ3JpZF94X2xpbmVzKSA6IGNvbmZpZy5ncmlkX3hfbGluZXM7XG59O1xuXG5leHRlbmQoeGdyaWRzLCB7XG4gIC8qKlxuICAgKiBBZGQgeCBncmlkIGxpbmVzLjxicj5cbiAgICogVGhpcyBBUEkgYWRkcyBuZXcgeCBncmlkIGxpbmVzIGluc3RlYWQgb2YgcmVwbGFjaW5nIGxpa2UgeGdyaWRzLlxuICAgKiBAbWV0aG9kIHhncmlkc+KApGFkZFxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBncmlkcyBOZXcgeCBncmlkIGxpbmVzIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLngubGluZXMgYW5kIGl0J3MgcG9zc2libGUgdG8gZ2l2ZSBhbiBPYmplY3QgaWYgb25seSBvbmUgbGluZSB3aWxsIGJlIGFkZGVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gQWRkIGEgbmV3IHggZ3JpZCBsaW5lXG4gICAqIGNoYXJ0Lnhncmlkcy5hZGQoXG4gICAqICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cbiAgICogKTtcbiAgICpcbiAgICogLy8gQWRkIG5ldyB4IGdyaWQgbGluZXNcbiAgICogY2hhcnQueGdyaWRzLmFkZChbXG4gICAqICAge3ZhbHVlOiAyLCB0ZXh0OiBcIkxhYmVsIDJcIn0sXG4gICAqICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cbiAgICogXSk7XG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChncmlkcykge1xuICAgIHJldHVybiB0aGlzLnhncmlkcyh0aGlzLmludGVybmFsLmNvbmZpZy5ncmlkX3hfbGluZXMuY29uY2F0KGdyaWRzIHx8IFtdKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSB4IGdyaWQgbGluZXMuPGJyPlxuICAgKiBUaGlzIEFQSSByZW1vdmVzIHggZ3JpZCBsaW5lcy5cbiAgICogQG1ldGhvZCB4Z3JpZHPigKRyZW1vdmVcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgdmFsdWUgb3IgY2xhc3MuIElmIHZhbHVlIGlzIGdpdmVuLCB0aGUgeCBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgeCB2YWx1ZSB3aWxsIGJlIHJlbW92ZWQuIElmIGNsYXNzIGlzIGdpdmVuLCB0aGUgeCBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgY2xhc3Mgd2lsbCBiZSByZW1vdmVkLiBJZiBhcmdzIGlzIG5vdCBnaXZlbiwgYWxsIG9mIHggZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIHggZ3JpZCBsaW5lIG9uIHggPSAyIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBjaGFydC54Z3JpZHMucmVtb3ZlKHt2YWx1ZTogMn0pO1xuICAgKlxuICAgKiAvLyB4IGdyaWQgbGluZXMgdGhhdCBoYXZlICdncmlkLUEnIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBjaGFydC54Z3JpZHMucmVtb3ZlKHtcbiAgICogICBjbGFzczogXCJncmlkLUFcIlxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gYWxsIG9mIHggZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWRcbiAgICogY2hhcnQueGdyaWRzLnJlbW92ZSgpO1xuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUocGFyYW1zKSB7XG4gICAgLy8gVE9ETzogbXVsdGlwbGVcbiAgICB0aGlzLmludGVybmFsLnJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsICEwKTtcbiAgfVxufSk7XG5cbi8qKlxuICogVXBkYXRlIHkgZ3JpZCBsaW5lcy5cbiAqIEBtZXRob2QgeWdyaWRzXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQHBhcmFtIHtBcnJheX0gZ3JpZHMgWSBncmlkIGxpbmVzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC55LmxpbmVzLlxuICogQGV4YW1wbGVcbiAqICAvLyBTaG93IDIgeSBncmlkIGxpbmVzXG4gKiBjaGFydC55Z3JpZHMoW1xuICogICAge3ZhbHVlOiAxMDAsIHRleHQ6IFwiTGFiZWwgMVwifSxcbiAqICAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cbiAqIF0pO1xuICovXG52YXIgeWdyaWRzID0gZnVuY3Rpb24gKGdyaWRzKSB7XG4gIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gIHJldHVybiBncmlkcyA/IChjb25maWcuZ3JpZF95X2xpbmVzID0gZ3JpZHMsICQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCksIGNvbmZpZy5ncmlkX3lfbGluZXMpIDogY29uZmlnLmdyaWRfeV9saW5lcztcbn07XG5cbmV4dGVuZCh5Z3JpZHMsIHtcbiAgLyoqXG4gICAqIEFkZCB5IGdyaWQgbGluZXMuPGJyPlxuICAgKiBUaGlzIEFQSSBhZGRzIG5ldyB5IGdyaWQgbGluZXMgaW5zdGVhZCBvZiByZXBsYWNpbmcgbGlrZSB5Z3JpZHMuXG4gICAqIEBtZXRob2QgeWdyaWRz4oCkYWRkXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGdyaWRzIE5ldyB5IGdyaWQgbGluZXMgd2lsbCBiZSBhZGRlZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGdyaWQueS5saW5lcyBhbmQgaXQncyBwb3NzaWJsZSB0byBnaXZlIGFuIE9iamVjdCBpZiBvbmx5IG9uZSBsaW5lIHdpbGwgYmUgYWRkZWQuXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBBZGQgYSBuZXcgeCBncmlkIGxpbmVcbiAgICogY2hhcnQueWdyaWRzLmFkZChcbiAgICogICB7dmFsdWU6IDQwMCwgdGV4dDogXCJMYWJlbCA0XCJ9XG4gICAqICk7XG4gICAqXG4gICAqIC8vIEFkZCBuZXcgeCBncmlkIGxpbmVzXG4gICAqIGNoYXJ0Lnlncmlkcy5hZGQoW1xuICAgKiAgIHt2YWx1ZTogMjAwLCB0ZXh0OiBcIkxhYmVsIDJcIn0sXG4gICAqICAge3ZhbHVlOiA0MDAsIHRleHQ6IFwiTGFiZWwgNFwifVxuICAgKiBdKTtcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gYWRkKGdyaWRzKSB7XG4gICAgcmV0dXJuIHRoaXMueWdyaWRzKHRoaXMuaW50ZXJuYWwuY29uZmlnLmdyaWRfeV9saW5lcy5jb25jYXQoZ3JpZHMgfHwgW10pKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIHkgZ3JpZCBsaW5lcy48YnI+XG4gICAqIFRoaXMgQVBJIHJlbW92ZXMgeCBncmlkIGxpbmVzLlxuICAgKiBAbWV0aG9kIHlncmlkc+KApHJlbW92ZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB2YWx1ZSBvciBjbGFzcy4gSWYgdmFsdWUgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCB5IHZhbHVlIHdpbGwgYmUgcmVtb3ZlZC4gSWYgY2xhc3MgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgeSBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICogQGV4YW1wbGVcbiAgICogLy8geSBncmlkIGxpbmUgb24geSA9IDIwMCB3aWxsIGJlIHJlbW92ZWRcbiAgICogY2hhcnQueWdyaWRzLnJlbW92ZSh7dmFsdWU6IDIwMH0pO1xuICAgKlxuICAgKiAvLyB5IGdyaWQgbGluZXMgdGhhdCBoYXZlICdncmlkLUEnIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBjaGFydC55Z3JpZHMucmVtb3ZlKHtcbiAgICogICBjbGFzczogXCJncmlkLUFcIlxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gYWxsIG9mIHkgZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWRcbiAgICogY2hhcnQueWdyaWRzLnJlbW92ZSgpO1xuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUocGFyYW1zKSB7XG4gICAgLy8gVE9ETzogbXVsdGlwbGVcbiAgICB0aGlzLmludGVybmFsLnJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsICExKTtcbiAgfVxufSksIGV4dGVuZChDaGFydF9DaGFydC5wcm90b3R5cGUsIHtcbiAgeGdyaWRzOiB4Z3JpZHMsXG4gIHlncmlkczogeWdyaWRzXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FwaS9hcGkucmVnaW9uLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuXG4vKipcbiAqIFVwZGF0ZSByZWdpb25zLlxuICogQG1ldGhvZCByZWdpb25zXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQHBhcmFtIHtBcnJheX0gcmVnaW9ucyBSZWdpb25zIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgcmVnaW9ucy5cbiAqIEByZXR1cm4ge0FycmF5fSByZWdpb25zXG4gKiBAZXhhbXBsZVxuICogLy8gU2hvdyAyIHJlZ2lvbnNcbiAqIGNoYXJ0LnJlZ2lvbnMoW1xuICogICAge2F4aXM6IFwieFwiLCBzdGFydDogNSwgY2xhc3M6IFwicmVnaW9uWFwifSxcbiAqICAgIHtheGlzOiBcInlcIiwgZW5kOiA1MCwgY2xhc3M6IFwicmVnaW9uWVwifVxuICogXSk7XG4gKi9cblxudmFyIGFwaV9yZWdpb25fcmVnaW9ucyA9IGZ1bmN0aW9uIChfcmVnaW9ucykge1xuICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICByZXR1cm4gX3JlZ2lvbnMgPyAoY29uZmlnLnJlZ2lvbnMgPSBfcmVnaW9ucywgJCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKSwgX3JlZ2lvbnMpIDogY29uZmlnLnJlZ2lvbnM7XG59O1xuXG5leHRlbmQoYXBpX3JlZ2lvbl9yZWdpb25zLCB7XG4gIC8qKlxuICAgKiBBZGQgbmV3IHJlZ2lvbi48YnI+PGJyPlxuICAgKiBUaGlzIEFQSSBhZGRzIG5ldyByZWdpb24gaW5zdGVhZCBvZiByZXBsYWNpbmcgbGlrZSByZWdpb25zLlxuICAgKiBAbWV0aG9kIHJlZ2lvbnPigKRhZGRcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gcmVnaW9ucyBOZXcgcmVnaW9uIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyByZWdpb25zIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIHJlZ2lvbiB3aWxsIGJlIGFkZGVkLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gcmVnaW9uc1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBBZGQgYSBuZXcgcmVnaW9uXG4gICAqIGNoYXJ0LnJlZ2lvbnMuYWRkKFxuICAgKiAgICB7YXhpczogXCJ4XCIsIHN0YXJ0OiA1LCBjbGFzczogXCJyZWdpb25YXCJ9XG4gICAqICk7XG4gICAqXG4gICAqIC8vIEFkZCBuZXcgcmVnaW9uc1xuICAgKiBjaGFydC5yZWdpb25zLmFkZChbXG4gICAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn0sXG4gICAqICAgIHtheGlzOiBcInlcIiwgZW5kOiA1MCwgY2xhc3M6IFwicmVnaW9uWVwifVxuICAgKl0pO1xuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiBhZGQocmVnaW9ucykge1xuICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICByZXR1cm4gcmVnaW9ucyA/IChjb25maWcucmVnaW9ucyA9IGNvbmZpZy5yZWdpb25zLmNvbmNhdChyZWdpb25zKSwgJCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKSwgY29uZmlnLnJlZ2lvbnMpIDogY29uZmlnLnJlZ2lvbnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSByZWdpb25zLjxicj48YnI+XG4gICAqIFRoaXMgQVBJIHJlbW92ZXMgcmVnaW9ucy5cbiAgICogQG1ldGhvZCByZWdpb25z4oCkcmVtb3ZlXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlZ2lvbnMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSBjbGFzc2VzLiBJZiBjbGFzc2VzIGlzIGdpdmVuLCB0aGUgcmVnaW9ucyB0aGF0IGhhdmUgb25lIG9mIHRoZSBzcGVjaWZpZWQgY2xhc3NlcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm4ge0FycmF5fSByZWdpb25zIFJlbW92ZWQgcmVnaW9uc1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyByZWdpb25zIHRoYXQgaGF2ZSAncmVnaW9uLUEnIG9yICdyZWdpb24tQicgd2lsbCBiZSByZW1vdmVkLlxuICAgKiBjaGFydC5yZWdpb25zLnJlbW92ZSh7XG4gICAqICAgY2xhc3NlczogW1xuICAgKiAgICAgXCJyZWdpb24tQVwiLCBcInJlZ2lvbi1CXCJcbiAgICogICBdXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIGNoYXJ0LnJlZ2lvbnMucmVtb3ZlKCk7XG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShvcHRpb25zVmFsdWUpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zVmFsdWUgfHwge30sXG4gICAgICAgIGR1cmF0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwiZHVyYXRpb25cIiwgY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pLFxuICAgICAgICBjbGFzc2VzID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwiY2xhc3Nlc1wiLCBbY29uZmlnX2NsYXNzZXMucmVnaW9uXSksXG4gICAgICAgIHJlZ2lvbnMgPSAkJC5tYWluLnNlbGVjdChcIi5cIi5jb25jYXQoY29uZmlnX2NsYXNzZXMucmVnaW9ucykpLnNlbGVjdEFsbChjbGFzc2VzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIFwiLlwiLmNvbmNhdChjKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIChkdXJhdGlvbiA/IHJlZ2lvbnMudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IHJlZ2lvbnMpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIikucmVtb3ZlKCksIHJlZ2lvbnMgPSBjb25maWcucmVnaW9ucywgT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoID8gKHJlZ2lvbnMgPSByZWdpb25zLmZpbHRlcihmdW5jdGlvbiAocmVnaW9uKSB7XG4gICAgICB2YXIgZm91bmQgPSAhMTtcbiAgICAgIHJldHVybiAhcmVnaW9uW1wiY2xhc3NcIl0gfHwgKHJlZ2lvbltcImNsYXNzXCJdLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGNsYXNzZXMuaW5kZXhPZihjKSA+PSAwICYmIChmb3VuZCA9ICEwKTtcbiAgICAgIH0pLCAhZm91bmQpO1xuICAgIH0pLCBjb25maWcucmVnaW9ucyA9IHJlZ2lvbnMpIDogY29uZmlnLnJlZ2lvbnMgPSBbXSwgcmVnaW9ucztcbiAgfVxufSksIGV4dGVuZChDaGFydF9DaGFydC5wcm90b3R5cGUsIHtcbiAgcmVnaW9uczogYXBpX3JlZ2lvbl9yZWdpb25zXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FwaS9hcGkuZGF0YS5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cbi8qKlxuICogR2V0IGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cbiAqIEBtZXRob2QgZGF0YVxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQ2hhcnRcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpcyBBUEkgcmV0dXJucyB0aGUgc3BlY2lmaWVkIHRhcmdldCBkYXRhLiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBnaXZlbiwgYWxsIG9mIGRhdGEgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4ge0FycmF5fSBEYXRhIG9iamVjdHNcbiAqIEBleGFtcGxlXG4gKiAvLyBHZXQgb25seSBkYXRhMSBkYXRhXG4gKiBjaGFydC5kYXRhKFwiZGF0YTFcIik7XG4gKiAvLyAtLT4gW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBBcnJheSg2KX0sIC4uLl1cbiAqXG4gKiAvLyBHZXQgZGF0YTEgYW5kIGRhdGEyIGRhdGFcbiAqIGNoYXJ0LmRhdGEoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG4gKlxuICogLy8gR2V0IGFsbCBkYXRhXG4gKiBjaGFydC5kYXRhKCk7XG4gKi9cblxudmFyIGFwaV9kYXRhX2RhdGEgPSBmdW5jdGlvbiAodGFyZ2V0SWRzKSB7XG4gIHZhciB0YXJnZXRzID0gdGhpcy5pbnRlcm5hbC5kYXRhLnRhcmdldHM7XG5cbiAgaWYgKCFpc1VuZGVmaW5lZCh0YXJnZXRJZHMpKSB7XG4gICAgdmFyIGlkcyA9IGlzQXJyYXkodGFyZ2V0SWRzKSA/IHRhcmdldElkcyA6IFt0YXJnZXRJZHNdO1xuICAgIHJldHVybiB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2ID09PSB0LmlkO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0cztcbn07XG5cbmV4dGVuZChhcGlfZGF0YV9kYXRhLCB7XG4gIC8qKlxuICAgKiBHZXQgZGF0YSBzaG93biBpbiB0aGUgY2hhcnQuXG4gICAqIEBtZXRob2QgZGF0YeKApHNob3duXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzIEFQSSBmaWx0ZXJzIHRoZSBkYXRhIHdpdGggc3BlY2lmaWVkIHRhcmdldCBpZHMuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IGdpdmVuLCBhbGwgc2hvd24gZGF0YSB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gRGF0YSBvYmplY3RzXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdldCBzaG93biBkYXRhIGJ5IGZpbHRlcmluZyB0byBpbmNsdWRlIG9ubHkgZGF0YTEgZGF0YVxuICAgKiBjaGFydC5kYXRhLnNob3duKFwiZGF0YTFcIik7XG4gICAqIC8vIC0tPiBbe2lkOiBcImRhdGExXCIsIGlkX29yZzogXCJkYXRhMVwiLCB2YWx1ZXM6IEFycmF5KDYpfSwgLi4uXVxuICAgKlxuICAgKiAvLyBHZXQgc2hvd24gZGF0YSBieSBmaWx0ZXJpbmcgdG8gaW5jbHVkZSBkYXRhMSBhbmQgZGF0YTIgZGF0YVxuICAgKiBjaGFydC5kYXRhLnNob3duKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuICAgKlxuICAgKiAvLyBHZXQgYWxsIHNob3duIGRhdGFcbiAgICogY2hhcnQuZGF0YS5zaG93bigpO1xuICAgKi9cbiAgc2hvd246IGZ1bmN0aW9uIHNob3duKHRhcmdldElkcykge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsLmZpbHRlclRhcmdldHNUb1Nob3codGhpcy5kYXRhKHRhcmdldElkcykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdmFsdWVzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXG4gICAqIEBtZXRob2QgZGF0YeKApHZhbHVlc1xuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHMgVGhpcyBBUEkgcmV0dXJucyB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB0YXJnZXQuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IGdpdmVuLCBudWxsIHdpbGwgYmUgcmV0cnVuZWRcbiAgICogQHJldHVybiB7QXJyYXl9IERhdGEgdmFsdWVzXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdldCBkYXRhMSB2YWx1ZXNcbiAgICogY2hhcnQuZGF0YS52YWx1ZXMoXCJkYXRhMVwiKTtcbiAgICogLy8gLS0+IFsxMCwgMjAsIDMwLCA0MF1cbiAgICovXG4gIHZhbHVlczogZnVuY3Rpb24gKHRhcmdldElkKSB7XG4gICAgdmFyIGZsYXQgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkKSB8fCBhcmd1bWVudHNbMV0sXG4gICAgICAgIHZhbHVlcyA9IG51bGw7XG5cbiAgICBpZiAodGFyZ2V0SWQpIHtcbiAgICAgIHZhciB0YXJnZXRzID0gdGhpcy5kYXRhKHRhcmdldElkKTtcbiAgICAgIHRhcmdldHMgJiYgaXNBcnJheSh0YXJnZXRzKSAmJiAodmFsdWVzID0gW10sIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgZGF0YVZhbHVlID0gdi52YWx1ZXMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBmbGF0ID8gdmFsdWVzID0gdmFsdWVzLmNvbmNhdChkYXRhVmFsdWUpIDogdmFsdWVzLnB1c2goZGF0YVZhbHVlKTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYW5kIHNldCBuYW1lcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxuICAgKiBAbWV0aG9kIGRhdGHigKRuYW1lc1xuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuYW1lcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbmFtZXMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgbmFtZXMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQ29ycmVzcG9uZGluZyBuYW1lcyBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZSwgaWYgc3BlY2lmaWVkIG5hbWVzIHZhbHVlcy5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gR2V0IGN1cnJlbnQgbmFtZXNcbiAgICogY2hhcnQuZGF0YS5uYW1lcygpO1xuICAgKiAvLyAtLT4ge2RhdGExOiBcInRlc3QxXCIsIGRhdGEyOiBcInRlc3QyXCJ9XG4gICAqXG4gICAqIC8vIFVwZGF0ZSBuYW1lc1xuICAgKiBjaGFydC5kYXRhLm5hbWVzKHtcbiAgICogIGRhdGExOiBcIk5ldyBOYW1lIDFcIixcbiAgICogIGRhdGEyOiBcIk5ldyBOYW1lIDJcIlxuICAgKn0pO1xuICAgKi9cbiAgbmFtZXM6IGZ1bmN0aW9uIG5hbWVzKF9uYW1lcykge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsLmNsZWFyTGVnZW5kSXRlbVRleHRCb3hDYWNoZSgpLCB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwibmFtZXNcIiwgX25hbWVzKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGFuZCBzZXQgY29sb3JzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXG4gICAqIEBtZXRob2QgZGF0YeKApGNvbG9yc1xuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGNvbG9ycyBvZiBkYXRhIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm90IGdpdmVuLCB0aGUgY3VycmVudCBjb2xvcnMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIFtkYXRhLmNvbG9yc10oLi9PcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRjb2xvcnMpLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IENvcnJlc3BvbmRpbmcgZGF0YSBjb2xvciB2YWx1ZSBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gR2V0IGN1cnJlbnQgY29sb3JzXG4gICAqIGNoYXJ0LmRhdGEuY29sb3JzKCk7XG4gICAqIC8vIC0tPiB7ZGF0YTE6IFwiIzAwYzczY1wiLCBkYXRhMjogXCIjZmE3MTcxXCJ9XG4gICAqXG4gICAqIC8vIFVwZGF0ZSBjb2xvcnNcbiAgICogY2hhcnQuZGF0YS5jb2xvcnMoe1xuICAgKiAgZGF0YTE6IFwiI0ZGRkZGRlwiLFxuICAgKiAgZGF0YTI6IFwiIzAwMDAwMFwiXG4gICAqIH0pO1xuICAgKi9cbiAgY29sb3JzOiBmdW5jdGlvbiBjb2xvcnMoX2NvbG9ycykge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiY29sb3JzXCIsIF9jb2xvcnMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYW5kIHNldCBheGVzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXG4gICAqIC0gKipOT1RFOioqIElmIGFsbCBkYXRhIGlzIHJlbGF0ZWQgdG8gb25lIG9mIHRoZSBheGVzLCB0aGUgZG9tYWluIG9mIGF4aXMgd2l0aG91dCByZWxhdGVkIGRhdGEgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgZG9tYWluIGZyb20gdGhlIGF4aXMgd2l0aCByZWxhdGVkIGRhdGFcbiAgICogQG1ldGhvZCBkYXRh4oCkYXhlc1xuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBheGVzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBheGVzIG9mIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZSBjdXJyZW50IGF4ZXMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQ29ycmVzcG9uZGluZyBheGVzIHZhbHVlIGZvciBkYXRhLCBpZiBzcGVjaWZpZWQgYXhlcyB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gR2V0IGN1cnJlbnQgYXhlc1xuICAgKiBjaGFydC5kYXRhLmF4ZXMoKTtcbiAgICogLy8gLS0+IHtkYXRhMTogXCJ5XCJ9XG4gICAqXG4gICAqIC8vIFVwZGF0ZSBheGVzXG4gICAqIGNoYXJ0LmRhdGEuYXhlcyh7XG4gICAqICBkYXRhMTogXCJ5XCIsXG4gICAqICBkYXRhMjogXCJ5MlwiXG4gICAqIH0pO1xuICAgKi9cbiAgYXhlczogZnVuY3Rpb24gYXhlcyhfYXhlcykge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiYXhlc1wiLCBfYXhlcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWluaW11bSBkYXRhIHZhbHVlIGJvdW5kIHRvIHRoZSBjaGFydFxuICAgKiBAbWV0aG9kIGRhdGHigKRtaW5cbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcmV0dXJuIHtBcnJheX0gRGF0YSBvYmplY3RzXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdldCBjdXJyZW50IGF4ZXNcbiAgICogY2hhcnQuZGF0YS5taW4oKTtcbiAgICogLy8gLS0+IFt7eDogMCwgdmFsdWU6IDMwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogMH0sIC4uLl1cbiAgICovXG4gIG1pbjogZnVuY3Rpb24gbWluKCkge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsLmdldE1pbk1heERhdGEoKS5taW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSBkYXRhIHZhbHVlIGJvdW5kIHRvIHRoZSBjaGFydFxuICAgKiBAbWV0aG9kIGRhdGHigKRtYXhcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcmV0dXJuIHtBcnJheX0gRGF0YSBvYmplY3RzXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdldCBjdXJyZW50IGF4ZXNcbiAgICogY2hhcnQuZGF0YS5tYXgoKTtcbiAgICogLy8gLS0+IFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi5dXG4gICAqL1xuICBtYXg6IGZ1bmN0aW9uIG1heCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbC5nZXRNaW5NYXhEYXRhKCkubWF4O1xuICB9XG59KSwgZXh0ZW5kKENoYXJ0X0NoYXJ0LnByb3RvdHlwZSwge1xuICBkYXRhOiBhcGlfZGF0YV9kYXRhXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FwaS9hcGkuY2F0ZWdvcnkuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5leHRlbmQoQ2hhcnRfQ2hhcnQucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBTZXQgc3BlY2lmaWVkIGNhdGVnb3J5IG5hbWUgb24gY2F0ZWdvcnkgYXhpcy5cbiAgICogQG1ldGhvZCBjYXRlZ29yeVxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpIGluZGV4IG9mIGNhdGVnb3J5IHRvIGJlIGNoYW5nZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNhdGVnb3J5IGNhdGVnb3J5IHZhbHVlIHRvIGJlIGNoYW5nZWRcbiAgICogQGV4YW1wbGVcbiAgICogY2hhcnQuY2F0ZWdvcnkoMiwgXCJDYXRlZ29yeSAzXCIpO1xuICAgKi9cbiAgY2F0ZWdvcnk6IGZ1bmN0aW9uIGNhdGVnb3J5KGksIF9jYXRlZ29yeSkge1xuICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgKGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllc1tpXSA9IF9jYXRlZ29yeSwgJCQucmVkcmF3KCkpLCBjb25maWcuYXhpc194X2NhdGVnb3JpZXNbaV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBjYXRlZ29yeSBuYW1lcyBvbiBjYXRlZ29yeSBheGlzLlxuICAgKiBAbWV0aG9kIGNhdGVnb3JpZXNcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge0FycmF5fSBjYXRlZ29yaWVzIFRoaXMgbXVzdCBiZSBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGNhdGVnb3J5IG5hbWVzIGluIHN0cmluZy4gSWYgY2F0ZWdvcnkgbmFtZXMgYXJlIGluY2x1ZGVkIGluIHRoZSBkYXRlIGJ5IGRhdGEueCBvcHRpb24sIHRoaXMgaXMgbm90IHJlcXVpcmVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFydC5jYXRlZ29yaWVzKFtcbiAgICogICAgICBcIkNhdGVnb3J5IDFcIiwgXCJDYXRlZ29yeSAyXCIsIC4uLlxuICAgKiBdKTtcbiAgICovXG4gIGNhdGVnb3JpZXM6IGZ1bmN0aW9uIGNhdGVnb3JpZXMoX2NhdGVnb3JpZXMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gX2NhdGVnb3JpZXMsICQkLnJlZHJhdygpLCBjb25maWcuYXhpc194X2NhdGVnb3JpZXMpIDogY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FwaS9hcGkuY29sb3IuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5leHRlbmQoQ2hhcnRfQ2hhcnQucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbG9yXG4gICAqIEBtZXRob2QgY29sb3JcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgaWQgdG8gZ2V0IHRoZSBjb2xvclxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFydC5jb2xvcihcImRhdGExXCIpO1xuICAgKi9cbiAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWwuY29sb3IoaWQpOyAvLyBtb3JlIHBhdHRlcm5zXG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYXBpL2FwaS54LmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuZXh0ZW5kKENoYXJ0X0NoYXJ0LnByb3RvdHlwZSwge1xuICAvKipcbiAgICogR2V0IGFuZCBzZXQgeCB2YWx1ZXMgZm9yIHRoZSBjaGFydC5cbiAgICogQG1ldGhvZCB4XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtBcnJheX0geCBJZiB4IGlzIGdpdmVuLCB4IHZhbHVlcyBvZiBldmVyeSB0YXJnZXQgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgY3VycmVudCB4IHZhbHVlcyB3aWxsIGJlIHJldHVybmVkIGFzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSB0aGUgdGFyZ2V0IGlkcy5cbiAgICogQHJldHVybiB7T2JqZWN0fSB4c1xuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gR2V0IGN1cnJlbnQgeCB2YWx1ZXNcbiAgICogIGNoYXJ0LngoKTtcbiAgICpcbiAgICogIC8vIFVwZGF0ZSB4IHZhbHVlcyBmb3IgYWxsIHRhcmdldHNcbiAgICogIGNoYXJ0LngoWzEwMCwgMjAwLCAzMDAsIDQwMCwgLi4uXSk7XG4gICAqL1xuICB4OiBmdW5jdGlvbiB4KF94KSB7XG4gICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ3VzdG9tWCgpICYmICQkLmlzQ2F0ZWdvcml6ZWQoKTtcbiAgICByZXR1cm4gaXNBcnJheShfeCkgJiYgKGlzQ2F0ZWdvcml6ZWQgPyAkJC5hcGkuY2F0ZWdvcmllcyhfeCkgOiAoJCQudXBkYXRlVGFyZ2V0WCgkJC5kYXRhLnRhcmdldHMsIF94KSwgJCQucmVkcmF3KHtcbiAgICAgIHdpdGhVcGRhdGVPcmdYRG9tYWluOiAhMCxcbiAgICAgIHdpdGhVcGRhdGVYRG9tYWluOiAhMFxuICAgIH0pKSksIGlzQ2F0ZWdvcml6ZWQgPyAkJC5hcGkuY2F0ZWdvcmllcygpIDogJCQuZGF0YS54cztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGFuZCBzZXQgeCB2YWx1ZXMgZm9yIHRoZSBjaGFydC5cbiAgICogQG1ldGhvZCB4c1xuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHhzIElmIHhzIGlzIGdpdmVuLCBzcGVjaWZpZWQgdGFyZ2V0J3MgeCB2YWx1ZXMgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgY3VycmVudCB4IHZhbHVlcyB3aWxsIGJlIHJldHVybmVkIGFzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSB0aGUgdGFyZ2V0IGlkcy5cbiAgICogQHJldHVybiB7T2JqZWN0fSB4c1xuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gR2V0IGN1cnJlbnQgeCB2YWx1ZXNcbiAgICogIGNoYXJ0LnhzKCk7XG4gICAqXG4gICAqICAvLyBVcGRhdGUgeCB2YWx1ZXMgZm9yIGFsbCB0YXJnZXRzXG4gICAqICBjaGFydC54cyh7XG4gICAqICAgIGRhdGExOiBbMTAsIDIwLCAzMCwgNDAsIC4uLl0sXG4gICAqICAgIGRhdGEyOiBbMTAwLCAyMDAsIDMwMCwgNDAwLCAuLi5dXG4gICAqICB9KTtcbiAgICovXG4gIHhzOiBmdW5jdGlvbiB4cyhfeHMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsO1xuICAgIHJldHVybiBpc09iamVjdChfeHMpICYmICgkJC51cGRhdGVUYXJnZXRYcygkJC5kYXRhLnRhcmdldHMsIF94cyksICQkLnJlZHJhdyh7XG4gICAgICB3aXRoVXBkYXRlT3JnWERvbWFpbjogITAsXG4gICAgICB3aXRoVXBkYXRlWERvbWFpbjogITBcbiAgICB9KSksICQkLmRhdGEueHM7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYXBpL2FwaS5heGlzLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuLyoqXG4gKiBTZXQgdGhlIG1pbi9tYXggdmFsdWVcbiAqIEBwYXJhbSB7Q2hhcnR9ICQkXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBzZXRNaW5NYXggPSBmdW5jdGlvbiAoJCQsIHR5cGUsIHZhbHVlKSB7XG4gIHZhciBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICBheGlzWCA9IFwiYXhpc194X1wiLmNvbmNhdCh0eXBlKSxcbiAgICAgIGF4aXNZID0gXCJheGlzX3lfXCIuY29uY2F0KHR5cGUpLFxuICAgICAgYXhpc1kyID0gXCJheGlzX3kyX1wiLmNvbmNhdCh0eXBlKTtcbiAgcmV0dXJuIGlzRGVmaW5lZCh2YWx1ZSkgJiYgKGlzT2JqZWN0VHlwZSh2YWx1ZSkgPyAoaXNWYWx1ZSh2YWx1ZS54KSAmJiAoY29uZmlnW2F4aXNYXSA9IHZhbHVlLngpLCBpc1ZhbHVlKHZhbHVlLnkpICYmIChjb25maWdbYXhpc1ldID0gdmFsdWUueSksIGlzVmFsdWUodmFsdWUueTIpICYmIChjb25maWdbYXhpc1kyXSA9IHZhbHVlLnkyKSkgOiAoY29uZmlnW2F4aXNZXSA9IHZhbHVlLCBjb25maWdbYXhpc1kyXSA9IHZhbHVlKSwgJCQucmVkcmF3KHtcbiAgICB3aXRoVXBkYXRlT3JnWERvbWFpbjogITAsXG4gICAgd2l0aFVwZGF0ZVhEb21haW46ICEwXG4gIH0pKSwgdW5kZWZpbmVkO1xufSxcbiAgICBhcGlfYXhpc19nZXRNaW5NYXggPSBmdW5jdGlvbiAoJCQsIHR5cGUpIHtcbiAgdmFyIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgcmV0dXJuIHtcbiAgICB4OiBjb25maWdbXCJheGlzX3hfXCIuY29uY2F0KHR5cGUpXSxcbiAgICB5OiBjb25maWdbXCJheGlzX3lfXCIuY29uY2F0KHR5cGUpXSxcbiAgICB5MjogY29uZmlnW1wiYXhpc195Ml9cIi5jb25jYXQodHlwZSldXG4gIH07XG59LFxuICAgIGFwaV9heGlzX2F4aXMgPSBleHRlbmQoZnVuY3Rpb24gKCkge30sIHtcbiAgLyoqXG4gICAqIEdldCBhbmQgc2V0IGF4aXMgbGFiZWxzLlxuICAgKiBAbWV0aG9kIGF4aXPigKRsYWJlbHNcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gbGFiZWxzIHNwZWNpZmllZCBheGlzJyBsYWJlbCB0byBiZSB1cGRhdGVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcbiAgICogY2hhcnQuYXhpcy5sYWJlbHMoe1xuICAgKiAgIHg6IFwiTmV3IFggQXhpcyBMYWJlbFwiLFxuICAgKiAgIHk6IFwiTmV3IFkgQXhpcyBMYWJlbFwiXG4gICAqIH0pO1xuICAgKi9cbiAgbGFiZWxzOiBmdW5jdGlvbiBsYWJlbHMoX2xhYmVscykge1xuICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWw7XG4gICAgYXJndW1lbnRzLmxlbmd0aCAmJiAoT2JqZWN0LmtleXMoX2xhYmVscykuZm9yRWFjaChmdW5jdGlvbiAoYXhpc0lkKSB7XG4gICAgICAkJC5heGlzLnNldExhYmVsVGV4dChheGlzSWQsIF9sYWJlbHNbYXhpc0lkXSk7XG4gICAgfSksICQkLmF4aXMudXBkYXRlTGFiZWxzKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYW5kIHNldCBheGlzIG1pbiB2YWx1ZS5cbiAgICogQG1ldGhvZCBheGlz4oCkbWluXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG1pbiBJZiBtaW4gaXMgZ2l2ZW4sIHNwZWNpZmllZCBheGlzJyBtaW4gdmFsdWUgd2lsbCBiZSB1cGRhdGVkLjxicj5cbiAgICogICAgIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbWluIHZhbHVlcyBzZXQgb24gZ2VuZXJhdGluZyBvcHRpb24gZm9yIGVhY2ggYXhpcyB3aWxsIGJlIHJldHVybmVkLlxuICAgKiAgICAgSWYgbm90IHNldCBhbnkgbWluIHZhbHVlcyBvbiBnZW5lcmF0aW9uLCBpdCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gVXBkYXRlIGF4aXMnIG1pblxuICAgKiBjaGFydC5heGlzLm1pbih7XG4gICAqICAgeDogLTEwLFxuICAgKiAgIHk6IDEwMDAsXG4gICAqICAgeTI6IDEwMFxuICAgKiB9KTtcbiAgICovXG4gIG1pbjogZnVuY3Rpb24gbWluKF9taW4pIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsO1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gc2V0TWluTWF4KCQkLCBcIm1pblwiLCBfbWluKSA6IGFwaV9heGlzX2dldE1pbk1heCgkJCwgXCJtaW5cIik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhbmQgc2V0IGF4aXMgbWF4IHZhbHVlLlxuICAgKiBAbWV0aG9kIGF4aXPigKRtYXhcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gbWF4IElmIG1heCBpcyBnaXZlbiwgc3BlY2lmaWVkIGF4aXMnIG1heCB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQuPGJyPlxuICAgKiAgICAgSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBtYXggdmFsdWVzIHNldCBvbiBnZW5lcmF0aW5nIG9wdGlvbiBmb3IgZWFjaCBheGlzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqICAgICBJZiBub3Qgc2V0IGFueSBtYXggdmFsdWVzIG9uIGdlbmVyYXRpb24sIGl0IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcbiAgICogY2hhcnQuYXhpcy5tYXgoe1xuICAgKiAgICB4OiAxMDAsXG4gICAqICAgIHk6IDEwMDAsXG4gICAqICAgIHkyOiAxMDAwMFxuICAgKiB9KTtcbiAgICovXG4gIG1heDogZnVuY3Rpb24gbWF4KF9tYXgpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsO1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gc2V0TWluTWF4KCQkLCBcIm1heFwiLCBfbWF4KSA6IGFwaV9heGlzX2dldE1pbk1heCgkJCwgXCJtYXhcIik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhbmQgc2V0IGF4aXMgbWluIGFuZCBtYXggdmFsdWUuXG4gICAqIEBtZXRob2QgYXhpc+KApHJhbmdlXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHJhbmdlIElmIHJhbmdlIGlzIGdpdmVuLCBzcGVjaWZpZWQgYXhpcycgbWluIGFuZCBtYXggdmFsdWUgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGN1cnJlbnQgbWluIGFuZCBtYXggdmFsdWVzIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gVXBkYXRlIGF4aXMnIGxhYmVsXG4gICAqIGNoYXJ0LmF4aXMucmFuZ2Uoe1xuICAgKiAgIG1pbjoge1xuICAgKiAgICAgeDogLTEwLFxuICAgKiAgICAgeTogLTEwMDAsXG4gICAqICAgICB5MjogLTEwMDAwXG4gICAqICAgfSxcbiAgICogICBtYXg6IHtcbiAgICogICAgIHg6IDEwMCxcbiAgICogICAgIHk6IDEwMDAsXG4gICAqICAgICB5MjogMTAwMDBcbiAgICogICB9LFxuICAgKiB9KTtcbiAgICovXG4gIHJhbmdlOiBmdW5jdGlvbiByYW5nZShfcmFuZ2UpIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgaXNEZWZpbmVkKF9yYW5nZS5tYXgpICYmIGF4aXMubWF4KF9yYW5nZS5tYXgpLCBpc0RlZmluZWQoX3JhbmdlLm1pbikgJiYgYXhpcy5taW4oX3JhbmdlLm1pbik7ZWxzZSByZXR1cm4ge1xuICAgICAgbWF4OiBheGlzLm1heCgpLFxuICAgICAgbWluOiBheGlzLm1pbigpXG4gICAgfTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KTtcbi8qKlxuICogR2V0IHRoZSBtaW4vbWF4IHZhbHVlXG4gKiBAcGFyYW0ge0NoYXJ0fSAkJFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge3t4LCB5LCB5Mn19XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZXh0ZW5kKENoYXJ0X0NoYXJ0LnByb3RvdHlwZSwge1xuICBheGlzOiBhcGlfYXhpc19heGlzXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FwaS9hcGkubGVnZW5kLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuLyoqXG4gKiBEZWZpbmUgbGVnZW5kXG4gKiBAaWdub3JlXG4gKi9cblxudmFyIGxlZ2VuZCA9IGV4dGVuZChmdW5jdGlvbiAoKSB7fSwge1xuICAvKipcbiAgICogU2hvdyBsZWdlbmQgZm9yIGVhY2ggdGFyZ2V0LlxuICAgKiBAbWV0aG9kIGxlZ2VuZOKApHNob3dcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXG4gICAqIC0gSWYgdGFyZ2V0SWRzIGlzIGdpdmVuLCBzcGVjaWZpZWQgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgc2hvd24uXG4gICAqIC0gSWYgb25seSBvbmUgdGFyZ2V0IGlzIHRoZSBjYW5kaWRhdGUsIFN0cmluZyBjYW4gYmUgcGFzc2VkLlxuICAgKiAtIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgc2hvd24uXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNob3cgbGVnZW5kIGZvciBkYXRhMS5cbiAgICogY2hhcnQubGVnZW5kLnNob3coXCJkYXRhMVwiKTtcbiAgICpcbiAgICogLy8gU2hvdyBsZWdlbmQgZm9yIGRhdGExIGFuZCBkYXRhMi5cbiAgICogY2hhcnQubGVnZW5kLnNob3coW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG4gICAqXG4gICAqIC8vIFNob3cgYWxsIGxlZ2VuZC5cbiAgICogY2hhcnQubGVnZW5kLnNob3coKTtcbiAgICovXG4gIHNob3c6IGZ1bmN0aW9uIHNob3codGFyZ2V0SWRzKSB7XG4gICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbDtcbiAgICAkJC5zaG93TGVnZW5kKCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcykpLCAkJC51cGRhdGVBbmRSZWRyYXcoe1xuICAgICAgd2l0aExlZ2VuZDogITBcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogSGlkZSBsZWdlbmQgZm9yIGVhY2ggdGFyZ2V0LlxuICAgKiBAbWV0aG9kIGxlZ2VuZOKApGhpZGVcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXG4gICAqIC0gSWYgdGFyZ2V0SWRzIGlzIGdpdmVuLCBzcGVjaWZpZWQgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgaGlkZGVuLlxuICAgKiAtIElmIG9ubHkgb25lIHRhcmdldCBpcyB0aGUgY2FuZGlkYXRlLCBTdHJpbmcgY2FuIGJlIHBhc3NlZC5cbiAgICogLSBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIGhpZGRlbi5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gSGlkZSBsZWdlbmQgZm9yIGRhdGExLlxuICAgKiBjaGFydC5sZWdlbmQuaGlkZShcImRhdGExXCIpO1xuICAgKlxuICAgKiAvLyBIaWRlIGxlZ2VuZCBmb3IgZGF0YTEgYW5kIGRhdGEyLlxuICAgKiBjaGFydC5sZWdlbmQuaGlkZShbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcbiAgICpcbiAgICogLy8gSGlkZSBhbGwgbGVnZW5kLlxuICAgKiBjaGFydC5sZWdlbmQuaGlkZSgpO1xuICAgKi9cbiAgaGlkZTogZnVuY3Rpb24gaGlkZSh0YXJnZXRJZHMpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsO1xuICAgICQkLmhpZGVMZWdlbmQoJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKSksICQkLnVwZGF0ZUFuZFJlZHJhdyh7XG4gICAgICB3aXRoTGVnZW5kOiAhMFxuICAgIH0pO1xuICB9XG59KTtcbmV4dGVuZChDaGFydF9DaGFydC5wcm90b3R5cGUsIHtcbiAgbGVnZW5kOiBsZWdlbmRcbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYXBpL2FwaS5jaGFydC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5cblxuZXh0ZW5kKENoYXJ0X0NoYXJ0LnByb3RvdHlwZSwge1xuICAvKipcbiAgICogUmVzaXplIHRoZSBjaGFydC5cbiAgICogQG1ldGhvZCByZXNpemVcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2l6ZSBUaGlzIGFyZ3VtZW50IHNob3VsZCBpbmNsdWRlIHdpZHRoIGFuZCBoZWlnaHQgaW4gcGl4ZWxzLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBSZXNpemUgdG8gNjQweDQ4MFxuICAgKiBjaGFydC5yZXNpemUoe1xuICAgKiAgICB3aWR0aDogNjQwLFxuICAgKiAgICBoZWlnaHQ6IDQ4MFxuICAgKiB9KTtcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKHNpemUpIHtcbiAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgJCQucmVuZGVyZWQgJiYgKGNvbmZpZy5zaXplX3dpZHRoID0gc2l6ZSA/IHNpemUud2lkdGggOiBudWxsLCBjb25maWcuc2l6ZV9oZWlnaHQgPSBzaXplID8gc2l6ZS5oZWlnaHQgOiBudWxsLCB0aGlzLmZsdXNoKCExLCAhMCksICQkLnJlc2l6ZUZ1bmN0aW9uKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZSB0byByZWRyYXcuXG4gICAqIEBtZXRob2QgZmx1c2hcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzb2Z0XSBGb3Igc29mdCByZWRyYXcuXG4gICAqIEBleGFtcGxlXG4gICAqIGNoYXJ0LmZsdXNoKCk7XG4gICAqXG4gICAqIC8vIGZvciBzb2Z0IHJlZHJhd1xuICAgKiBjaGFydC5mbHVzaCh0cnVlKTtcbiAgICovXG4gIGZsdXNoOiBmdW5jdGlvbiBmbHVzaChzb2Z0LCBfaXNGcm9tUmVzaXplKSB7XG4gICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbDtcbiAgICAkJC5yZW5kZXJlZCA/IChfaXNGcm9tUmVzaXplID8gJCQuYnJ1c2ggJiYgJCQuYnJ1c2gudXBkYXRlUmVzaXplKCkgOiAkJC5heGlzICYmICQkLmF4aXMuc2V0T3JpZW50KCksICQkLnpvb21TY2FsZSA9IG51bGwsIHNvZnQgPyAkJC5yZWRyYXcoe1xuICAgICAgd2l0aFRyYW5zZm9ybTogITAsXG4gICAgICB3aXRoVXBkYXRlWERvbWFpbjogITAsXG4gICAgICB3aXRoVXBkYXRlT3JnWERvbWFpbjogITAsXG4gICAgICB3aXRoTGVnZW5kOiAhMFxuICAgIH0pIDogJCQudXBkYXRlQW5kUmVkcmF3KHtcbiAgICAgIHdpdGhMZWdlbmQ6ICEwLFxuICAgICAgd2l0aFRyYW5zaXRpb246ICExLFxuICAgICAgd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06ICExXG4gICAgfSkpIDogJCQuaW5pdFRvUmVuZGVyKCEwKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzZXQgdGhlIGNoYXJ0IG9iamVjdCBhbmQgcmVtb3ZlIGVsZW1lbnQgYW5kIGV2ZW50cyBjb21wbGV0ZWx5LlxuICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFydC5kZXN0cm95KCk7XG4gICAqL1xuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICQkID0gdGhpcy5pbnRlcm5hbDtcblxuICAgIHJldHVybiBub3RFbXB0eSgkJCkgJiYgKCQkLmNhbGxQbHVnaW5Ib29rKFwiJHdpbGxEZXN0cm95XCIpLCAkJC5jaGFydHMuc3BsaWNlKCQkLmNoYXJ0cy5pbmRleE9mKHRoaXMpLCAxKSwgJCQuc3ZnLnNlbGVjdChcIipcIikuaW50ZXJydXB0KCksICQkLmdlbmVyYXRlUmVzaXplLnRpbWVvdXQgJiYgd2luLmNsZWFyVGltZW91dCgkJC5nZW5lcmF0ZVJlc2l6ZS50aW1lb3V0KSwgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgJCQucmVzaXplRnVuY3Rpb24pLCAkJC5zZWxlY3RDaGFydC5jbGFzc2VkKFwiYmJcIiwgITEpLmh0bWwoXCJcIiksIE9iamVjdC5rZXlzKHRoaXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAga2V5ID09PSBcImludGVybmFsXCIgJiYgT2JqZWN0LmtleXMoJCQpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgJCRba10gPSBudWxsO1xuICAgICAgfSksIF90aGlzW2tleV0gPSBudWxsLCBkZWxldGUgX3RoaXNba2V5XTtcbiAgICB9KSksIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgc2luZ2xlIGNvbmZpZyBvcHRpb24gdmFsdWUuXG4gICAqIEBtZXRob2QgY29uZmlnXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG9wdGlvbiBrZXkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSBhY2NlcHRlZCBmb3IgaW5kaWNhdGVkIG9wdGlvbi5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcmVkcmF3XSBTZXQgdG8gcmVkcmF3IHdpdGggdGhlIG5ldyBvcHRpb24gY2hhbmdlcy5cbiAgICogLSAqKk5PVEU6KiogRG9lc24ndCBndWFyYW50ZWUgd29yayBpbiBhbGwgY2lyY3Vtc3RhbmNlcy4gSXQgY2FuIGJlIGFwcGxpZWQgZm9yIGxpbWl0ZWQgb3B0aW9ucyBvbmx5LlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBHZXR0ZXJcbiAgICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIpO1xuICAgKlxuICAgKiAvLyBTZXR0ZXJcbiAgICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIsIDEwMCk7XG4gICAqXG4gICAqIC8vIFNldHRlciAmIHJlZHJhdyB3aXRoIHRoZSBuZXcgb3B0aW9uXG4gICAqIGNoYXJ0LmNvbmZpZyhcImdhdWdlLm1heFwiLCAxMDAsIHRydWUpO1xuICAgKi9cbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcobmFtZSwgdmFsdWUsIHJlZHJhdykge1xuICAgIHZhciByZXMsXG4gICAgICAgICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAga2V5ID0gbmFtZSAmJiBuYW1lLnJlcGxhY2UoL1xcLi9nLCBcIl9cIik7XG4gICAgcmV0dXJuIGtleSBpbiAkJC5jb25maWcgJiYgKGlzRGVmaW5lZCh2YWx1ZSkgPyAoJCQuY29uZmlnW2tleV0gPSB2YWx1ZSwgcmVzID0gdmFsdWUsIHJlZHJhdyAmJiB0aGlzLmZsdXNoKCkpIDogcmVzID0gJCQuY29uZmlnW2tleV0pLCByZXM7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYXBpL2FwaS50b29sdGlwLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuLyoqXG4gKiBEZWZpbmUgdG9vbHRpcFxuICogQGlnbm9yZVxuICovXG5cbnZhciBhcGlfdG9vbHRpcF90b29sdGlwID0gZXh0ZW5kKGZ1bmN0aW9uICgpIHt9LCB7XG4gIC8qKlxuICAgKiBTaG93IHRvb2x0aXBcbiAgICogQG1ldGhvZCB0b29sdGlw4oCkc2hvd1xuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG4gICAqXG4gICAqICAgIHwgS2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcbiAgICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfFxuICAgKiAgICB8IGluZGV4IHwgTnVtYmVyIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IGluZGV4IHxcbiAgICogICAgfCB4IHwgTnVtYmVyICZ2ZXJ0OyBEYXRlIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IHggQXhpcyBpbmRleCB8XG4gICAqICAgIHwgbW91c2UgfCBBcnJheSB8IERldGVybWluZSB4IGFuZCB5IGNvb3JkaW5hdGUgdmFsdWUgcmVsYXRpdmUgdGhlIHRhcmdldGVkICcuYmItZXZlbnQtcmVjdCcgeCBBeGlzLjxicj5JdCBzaG91bGQgYmUgdXNlZCBhbG9uZyB3aXRoIGBkYXRhYCwgYGluZGV4YCBvciBgeGAgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHNldCBhcyBgWzAsMF1gIHxcbiAgICogICAgfCBkYXRhIHwgT2JqZWN0IHwgV2hlbiBbZGF0YS54c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0eHMpIG9wdGlvbiBpcyB1c2VkIG9yIFt0b29sdGlwLmdyb3VwZWRdKE9wdGlvbnMuaHRtbCMudG9vbHRpcCkgc2V0IHRvICdmYWxzZScsIGBzaG91bGQgYmUgdXNlZCBnaXZpbmcgdGhpcyBwYXJhbWAuPGJyPjxicj4qKktleToqKjxicj4tIHgge051bWJlciAmdmVyYmFyOyBEYXRlfTogeCBBeGlzIHZhbHVlPGJyPi0gaW5kZXgge051bWJlcn06IHggQXhpcyBpbmRleCAodXNlbGVzcyBmb3IgZGF0YS54cyk8YnI+LSBpZCB7U3RyaW5nfTogZGF0YSBpZDxicj4tIHZhbHVlIHtOdW1iZXJ9OiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBmb3IgdG9vbHRpcC4gfFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gc2hvdyB0aGUgMm5kIHggQXhpcyBjb29yZGluYXRlIHRvb2x0aXBcbiAgICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG4gICAqICAgIGluZGV4OiAxXG4gICAqICB9KTtcbiAgICpcbiAgICogIC8vIHNob3cgdG9vbHRpcCBmb3IgdGhlIDNyZCB4IEF4aXMgaW4geDo1MCBhbmQgeToxMDAgY29vcmRpbmF0ZSBvZiAnLmJiLWV2ZW50LXJlY3QnIG9mIHRoZSB4IEF4aXMuXG4gICAqICBjaGFydC50b29sdGlwLnNob3coe1xuICAgKiAgICB4OiAyLFxuICAgKiAgICBtb3VzZTogWzUwLCAxMDBdXG4gICAqICB9KTtcbiAgICpcbiAgICogIC8vIHNob3cgdG9vbHRpcCBmb3IgdGltZXNlcmllcyB4IGF4aXNcbiAgICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG4gICAqICAgIHg6IG5ldyBEYXRlKFwiMjAxOC0wMS0wMiAwMDowMFwiKVxuICAgKiAgfSk7XG4gICAqXG4gICAqICAvLyB3aGVuIGRhdGEueHMgaXMgdXNlZFxuICAgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcbiAgICogICAgZGF0YToge1xuICAgKiAgICAgICAgeDogMywgIC8vIHggQXhpcyB2YWx1ZVxuICAgKiAgICAgICAgaWQ6IFwiZGF0YTFcIiwgIC8vIGRhdGEgaWRcbiAgICogICAgICAgIHZhbHVlOiA1MDAgIC8vIGRhdGEgdmFsdWVcbiAgICogICAgfVxuICAgKiAgfSk7XG4gICAqXG4gICAqICAvLyB3aGVuIGRhdGEueHMgaXNuJ3QgdXNlZCwgYnV0IHRvb2x0aXAuZ3JvdXBlZD1mYWxzZSBpcyBzZXRcbiAgICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG4gICAqICAgIGRhdGE6IHtcbiAgICogICAgICAgIGluZGV4OiAzLCAgLy8gb3IgJ3gnIGtleSB2YWx1ZVxuICAgKiAgICAgICAgaWQ6IFwiZGF0YTFcIiwgIC8vIGRhdGEgaWRcbiAgICogICAgICAgIHZhbHVlOiA1MDAgIC8vIGRhdGEgdmFsdWVcbiAgICogICAgfVxuICAgKiAgfSk7XG4gICAqL1xuICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgIHZhciBpbmRleCxcbiAgICAgICAgbW91c2UsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cbiAgICAvLyBkZXRlcm1pbmUgZm9jdXMgZGF0YVxuICAgIGlmIChhcmdzLm1vdXNlICYmIChtb3VzZSA9IGFyZ3MubW91c2UpLCBhcmdzLmRhdGEpIHtcbiAgICAgIHZhciB5ID0gJCQuZ2V0WVNjYWxlKGFyZ3MuZGF0YS5pZCkoYXJncy5kYXRhLnZhbHVlKTtcbiAgICAgICQkLmlzTXVsdGlwbGVYKCkgPyBtb3VzZSA9IFskJC54KGFyZ3MuZGF0YS54KSwgeV0gOiAoISQkLmNvbmZpZy50b29sdGlwX2dyb3VwZWQgJiYgKG1vdXNlID0gWzAsIHldKSwgaW5kZXggPSBpc1ZhbHVlKGFyZ3MuZGF0YS5pbmRleCkgPyBhcmdzLmRhdGEuaW5kZXggOiAkJC5nZXRJbmRleEJ5WChhcmdzLmRhdGEueCkpO1xuICAgIH0gZWxzZSBpc0RlZmluZWQoYXJncy54KSA/IGluZGV4ID0gJCQuZ2V0SW5kZXhCeVgoYXJncy54KSA6IGlzRGVmaW5lZChhcmdzLmluZGV4KSAmJiAoaW5kZXggPSBhcmdzLmluZGV4KTsgLy8gZW11bGF0ZSBldmVudHMgdG8gc2hvd1xuXG5cbiAgICAoJCQuaW5wdXRUeXBlID09PSBcIm1vdXNlXCIgPyBbXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW1vdmVcIl0gOiBbXCJ0b3VjaHN0YXJ0XCJdKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICQkLmRpc3BhdGNoRXZlbnQoZXZlbnROYW1lLCBpbmRleCwgbW91c2UpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIaWRlIHRvb2x0aXBcbiAgICogQG1ldGhvZCB0b29sdGlw4oCkaGlkZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIENoYXJ0XG4gICAqL1xuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWw7IC8vIHJlc2V0IGxhc3QgdG91Y2ggcG9pbnQgaW5kZXhcblxuICAgICQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiICYmICQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goKSwgJCQuaGlkZVRvb2x0aXAoITApLCAkJC5oaWRlR3JpZEZvY3VzKCksICQkLnVuZXhwYW5kQ2lyY2xlcygpLCAkJC51bmV4cGFuZEJhcnMoKTtcbiAgfVxufSk7XG5leHRlbmQoQ2hhcnRfQ2hhcnQucHJvdG90eXBlLCB7XG4gIHRvb2x0aXA6IGFwaV90b29sdGlwX3Rvb2x0aXBcbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYXBpL2FwaS5leHBvcnQuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5cblxuLyoqXG4gKiBFbmNvZGUgdG8gYmFzZTY0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9BUEkvV2luZG93QmFzZTY0L0Jhc2U2NF9lbmNvZGluZ19hbmRfZGVjb2RpbmdcbiAqL1xuXG52YXIgYjY0RW5jb2RlVW5pY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIGJ0b2EoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgZnVuY3Rpb24gKG1hdGNoLCBwKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXCIweFwiLmNvbmNhdChwKSk7XG4gIH0pKTtcbn0sXG4gICAgbm9kZVRvU3ZnRGF0YVVybCA9IGZ1bmN0aW9uIChub2RlLCBzaXplKSB7XG4gIHZhciBzZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKSxcbiAgICAgIGNsb25lID0gbm9kZS5jbG9uZU5vZGUoITApLFxuICAgICAgY3NzVGV4dCA9IGdldENzc1J1bGVzKHRvQXJyYXkoYnJvd3Nlcl9kb2Muc3R5bGVTaGVldHMpKS5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gci5jc3NUZXh0O1xuICB9KS5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gci5jc3NUZXh0O1xuICB9KTtcbiAgY2xvbmUuc2V0QXR0cmlidXRlKFwieG1sbnNcIiwgZXh0ZXJuYWxfY29tbW9uanNfZDNfc2VsZWN0aW9uX2NvbW1vbmpzMl9kM19zZWxlY3Rpb25fYW1kX2QzX3NlbGVjdGlvbl9yb290X2QzX1tcIm5hbWVzcGFjZXNcIl0ueGh0bWwpO1xuICB2YXIgbm9kZVhtbCA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoY2xvbmUpLFxuICAgICAgc3R5bGUgPSBicm93c2VyX2RvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7IC8vIGVzY2FwZSBjc3MgZm9yIFhNTFxuXG4gIHN0eWxlLmFwcGVuZENoaWxkKGJyb3dzZXJfZG9jLmNyZWF0ZVRleHROb2RlKGNzc1RleHQuam9pbihcIlxcblwiKSkpO1xuICB2YXIgc3R5bGVYbWwgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHN0eWxlKSxcbiAgICAgIGRhdGFTdHIgPSBcIjxzdmcgeG1sbnM9XFxcIlwiLmNvbmNhdChleHRlcm5hbF9jb21tb25qc19kM19zZWxlY3Rpb25fY29tbW9uanMyX2QzX3NlbGVjdGlvbl9hbWRfZDNfc2VsZWN0aW9uX3Jvb3RfZDNfW1wibmFtZXNwYWNlc1wiXS5zdmcsIFwiXFxcIiB3aWR0aD1cXFwiXCIpLmNvbmNhdChzaXplLndpZHRoLCBcIlxcXCIgaGVpZ2h0PVxcXCJcIikuY29uY2F0KHNpemUuaGVpZ2h0LCBcIlxcXCI+XFxuXFx0XFx0XFx0PGZvcmVpZ25PYmplY3Qgd2lkdGg9XFxcIjEwMCVcXFwiIGhlaWdodD1cXFwiMTAwJVxcXCI+XFxuXFx0XFx0XFx0XFx0XCIpLmNvbmNhdChzdHlsZVhtbCwgXCJcXG5cXHRcXHRcXHRcXHRcIikuY29uY2F0KG5vZGVYbWwucmVwbGFjZSgvKHVybFxcKClbXiNdKy9nLCBcIiQxXCIpLCBcIlxcblxcdFxcdFxcdDwvZm9yZWlnbk9iamVjdD48L3N2Zz5cIikucmVwbGFjZShcIi9cXG4vZ1wiLCBcIiUwQVwiKTsgLy8gZm9yZWlnbk9iamVjdCBub3Qgc3VwcG9ydGVkIGluIElFMTEgYW5kIGJlbG93XG4gIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4MzQ2NzUodj12cy44NSkuYXNweFxuXG4gIHJldHVybiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsXCIuY29uY2F0KGI2NEVuY29kZVVuaWNvZGUoZGF0YVN0cikpO1xufTtcbi8qKlxuICogQ29udmVydCBzdmcgbm9kZSB0byBkYXRhIHVybFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbmV4dGVuZChDaGFydF9DaGFydC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEV4cG9ydCBjaGFydCBhcyBhbiBpbWFnZS5cbiAgICogLSAqKk5PVEU6KipcbiAgICogICAtIElFMTEgYW5kIGJlbG93IG5vdCB3b3JrIHByb3Blcmx5IGR1ZSB0byB0aGUgbGFjayBvZiB0aGUgZmVhdHVyZSg8YSBocmVmPVwiaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oaDgzNDY3NSh2PXZzLjg1KS5hc3B4XCI+Zm9yZWlnbk9iamVjdDwvYT4pIHN1cHBvcnRcbiAgICogICAtIFRoZSBiYXNpYyBDU1MgZmlsZShleC4gYmlsbGJvYXJkLmNzcykgc2hvdWxkIGJlIGF0IHNhbWUgZG9tYWluIGFzIEFQSSBjYWxsIGNvbnRleHQgdG8gZ2V0IGNvcnJlY3Qgc3R5bGVkIGV4cG9ydCBpbWFnZS5cbiAgICogQG1ldGhvZCBleHBvcnRcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBDaGFydFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW21pbWVUeXBlPWltYWdlL3BuZ10gVGhlIGRlc2lyZWQgb3V0cHV0IGltYWdlIGZvcm1hdC4gKGV4LiAnaW1hZ2UvcG5nJyBmb3IgcG5nLCAnaW1hZ2UvanBlZycgZm9yIGpwZWcgZm9ybWF0KVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gZXhwb3J0IGlzIHJlYWR5LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGRhdGFVUklcbiAgICogQGV4YW1wbGVcbiAgICogIGNoYXJ0LmV4cG9ydCgpO1xuICAgKiAgLy8gLS0+IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4uLi5cIlxuICAgKlxuICAgKiAgLy8gSW5pdGlhbGl6ZSB0aGUgZG93bmxvYWQgYXV0b21hdGljYWxseVxuICAgKiAgY2hhcnQuZXhwb3J0KFwiaW1hZ2UvcG5nXCIsIGRhdGFVcmwgPT4ge1xuICAgKiAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgKlxuICAgKiAgICAgbGluay5kb3dubG9hZCA9IGAke0RhdGUubm93KCl9LnBuZ2A7XG4gICAqICAgICBsaW5rLmhyZWYgPSBkYXRhVXJsO1xuICAgKiAgICAgbGluay5pbm5lckhUTUwgPSBcIkRvd25sb2FkIGNoYXJ0IGFzIGltYWdlXCI7XG4gICAqXG4gICAqICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xuICAgKiAgfSk7XG4gICAqL1xuICBcImV4cG9ydFwiOiBmdW5jdGlvbiBfZXhwb3J0KG1pbWVUeXBlLCBjYWxsYmFjaykge1xuICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgIHNpemUgPSB7XG4gICAgICB3aWR0aDogJCQuY3VycmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiAkJC5jdXJyZW50SGVpZ2h0XG4gICAgfSxcbiAgICAgICAgc3ZnRGF0YVVybCA9IG5vZGVUb1N2Z0RhdGFVcmwodGhpcy5lbGVtZW50LCBzaXplKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1nLmNyb3Nzc09yaWdpbiA9IFwiQW5vbnltb3VzXCIsIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBicm93c2VyX2RvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gc2l6ZS53aWR0aCwgY2FudmFzLmhlaWdodCA9IHNpemUuaGVpZ2h0LCBjdHguZHJhd0ltYWdlKGltZywgMCwgMCksIGNhbGxiYWNrKGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUpKTtcbiAgICAgIH0sIGltZy5zcmMgPSBzdmdEYXRhVXJsO1xuICAgIH1cblxuICAgIHJldHVybiBzdmdEYXRhVXJsO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIF9kZWZhdWx0cyA9IHt9LFxuICAgIGJiID0ge1xuICAvKipcbiAgICogVmVyc2lvbiBpbmZvcm1hdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gdmVyc2lvbiB2ZXJzaW9uXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGJiLnZlcnNpb247ICAvLyBcIjEuMC4wXCJcbiAgICogQG1lbWJlcm9mIGJiXG4gICAqL1xuICB2ZXJzaW9uOiBcIjEuMTIuMTFcIixcblxuICAvKipcbiAgICogR2VuZXJhdGUgY2hhcnRcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICogQG1lbWJlcm9mIGJiXG4gICAqIEByZXR1cm4ge0NoYXJ0fVxuICAgKiBAc2VlIHtAbGluayBPcHRpb25zfSBmb3IgZGlmZmVyZW50IGdlbmVyYXRpb24gb3B0aW9uc1xuICAgKiBAc2VlIHtAbGluayBDaGFydH0gZm9yIGRpZmZlcmVudCBtZXRob2RzIEFQSVxuICAgKiBAZXhhbXBsZVxuICAgKiAgPCEtLSBjaGFydCBob2xkZXIgLS0+XG4gICAqIDxkaXYgaWQ9XCJMaW5lQ2hhcnRcIj48L2Rpdj5cbiAgICogQGV4YW1wbGVcbiAgICogICAvLyBnZW5lcmF0ZSBjaGFydCB3aXRoIG9wdGlvbnNcbiAgICogIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcbiAgICogICAgICBcImJpbmR0b1wiOiBcIiNMaW5lQ2hhcnRcIlxuICAgKiAgICAgIFwiZGF0YVwiOiB7XG4gICAqICAgICAgICAgIFwiY29sdW1uc1wiOiBbXG4gICAqICAgICAgICAgICAgICBbXCJkYXRhMVwiLCAzMCwgMjAwLCAxMDAsIDQwMCwgMTUwLCAyNTBdLFxuICAgKiAgICAgICAgICAgICAgW1wiZGF0YTJcIiwgNTAsIDIwLCAxMCwgNDAsIDE1LCAyNV1cbiAgICogICAgICAgICAgIF1cbiAgICogICAgICB9XG4gICAqICB9KTtcbiAgICpcbiAgICogIC8vIGNhbGwgc29tZSBBUElcbiAgICogIC8vIGV4KSBnZXQgdGhlIGRhdGEgb2YgJ2RhdGExJ1xuICAgKiAgY2hhcnQuZGF0YShcImRhdGExXCIpO1xuICAgKi9cbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKGNvbmZpZykge1xuICAgIHZhciBvcHRpb25zID0gbWVyZ2VPYmooe30sIF9kZWZhdWx0cywgY29uZmlnKSxcbiAgICAgICAgaW5zdCA9IG5ldyBDaGFydF9DaGFydChvcHRpb25zKTtcbiAgICByZXR1cm4gaW5zdC5pbnRlcm5hbC5jaGFydHMgPSB0aGlzLmluc3RhbmNlLCB0aGlzLmluc3RhbmNlLnB1c2goaW5zdCksIGluc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBvciBnZXQgZ2xvYmFsIGRlZmF1bHQgb3B0aW9ucy5cbiAgICogLSAqKk5PVEU6KipcbiAgICogICAtIFRoZSBvcHRpb25zIHZhbHVlcyBzZXR0aW5ncyBhcmUgdmFsaWQgd2l0aGluIHBhZ2UgY29udGV4dCBvbmx5LlxuICAgKiAgIC0gSWYgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzLCB3aWxsIG92ZXJyaWRlIHRoZSBsYXN0IHZhbHVlLlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgKiBAbWVtYmVyb2YgYmJcbiAgICogQHJldHVybiB7T3B0aW9uc31cbiAgICogQHNlZSB7QGxpbmsgT3B0aW9uc31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gU2V0IHNhbWUgb3B0aW9uIHZhbHVlIGFzIGZvciBgLmdlbmVyYXRlKClgXG4gICAqIGJiLmRlZmF1bHRzKHtcbiAgICogICBkYXRhOiB7XG4gICAqICAgICB0eXBlOiBcImJhclwiXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogYmIuZGVmYXVsdHMoKTsgIC8vIHtkYXRhOnt0eXBlOiBcImJhclwifX1cbiAgICpcbiAgICogLy8gZGF0YS50eXBlIGRlZmF1bHRzIHRvICdiYXInXG4gICAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xuICAgKi9cbiAgZGVmYXVsdHM6IGZ1bmN0aW9uIGRlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob3B0aW9ucykgJiYgKF9kZWZhdWx0cyA9IG9wdGlvbnMpLCBfZGVmYXVsdHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2UgY3JlYXRlZFxuICAgKiBAcHJvcGVydHkge0FycmF5fSBpbnN0YW5jZSBpbnN0YW5jZSBhcnJheVxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gZ2VuZXJhdGUgY2hhcnRzXG4gICAqICB2YXIgY2hhcnQxID0gYmIuZ2VuZXJhdGUoLi4uKTtcbiAgICogIHZhciBjaGFydDIgPSBiYi5nZW5lcmF0ZSguLi4pO1xuICAgKlxuICAgKiAgYmIuaW5zdGFuY2U7ICAvLyBbIGNoYXJ0MSwgY2hhcnQyLCAuLi4gXVxuICAgKiBAbWVtYmVyb2YgYmJcbiAgICovXG4gIGluc3RhbmNlOiBbXSxcblxuICAvKipcbiAgICogTmFtZXNwYWNlIGZvciBwbHVnaW5zXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwbHVnaW4gcGx1Z2luIG5hbWVzcGFjZVxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gU3RhbmZvcmQgZGlhZ3JhbSBwbHVnaW5cbiAgICogIGJiLnBsdWdpbi5zdGFuZm9yZDtcbiAgICogQG1lbWJlcm9mIGJiXG4gICAqL1xuICBwbHVnaW46IHt9LFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBjaGFydCBvYmplY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoYXJ0OiB7XG4gICAgZm46IENoYXJ0X0NoYXJ0LnByb3RvdHlwZSxcbiAgICBpbnRlcm5hbDoge1xuICAgICAgZm46IENoYXJ0SW50ZXJuYWxfQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsXG4gICAgICBheGlzOiB7XG4gICAgICAgIGZuOiBBeGlzX0F4aXMucHJvdG90eXBlXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBAbmFtZXNwYWNlIGJiXG4gKiBAdmVyc2lvbiAxLjEyLjExXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb3JlID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoYmIpO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbGxib2FyZC5qcy5tYXAiLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiFcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXFxyXFxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxyXFxuICogXFxyXFxuICogYmlsbGJvYXJkLmpzLCBKYXZhU2NyaXB0IGNoYXJ0IGxpYnJhcnlcXHJcXG4gKiBodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvXFxyXFxuICogXFxyXFxuICogQHZlcnNpb24gMS4xMi4xMVxcbiAqL1xcbi8qLS0gQ2hhcnQgLS0qL1xcbi5iYiBzdmcge1xcbiAgZm9udDogMTBweCBzYW5zLXNlcmlmO1xcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApOyB9XFxuXFxuLmJiIHBhdGgsIC5iYiBsaW5lIHtcXG4gIGZpbGw6IG5vbmU7XFxuICBzdHJva2U6ICMwMDA7IH1cXG5cXG4uYmIgdGV4dCwgLmJiIC5iYi1idXR0b24ge1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbi5iYi1sZWdlbmQtaXRlbS10aWxlLFxcbi5iYi14Z3JpZC1mb2N1cyxcXG4uYmIteWdyaWQtZm9jdXMsXFxuLmJiLXlncmlkLFxcbi5iYi1ldmVudC1yZWN0LFxcbi5iYi1iYXJzIHBhdGgge1xcbiAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyAuYmItZ2F1Z2UtdmFsdWUge1xcbiAgZmlsbDogIzAwMDsgfVxcblxcbi5iYi1jaGFydC1hcmMgcGF0aCB7XFxuICBzdHJva2U6ICNmZmY7IH1cXG5cXG4uYmItY2hhcnQtYXJjIHJlY3Qge1xcbiAgc3Ryb2tlOiAjZmZmO1xcbiAgc3Ryb2tlLXdpZHRoOiAxOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyB0ZXh0IHtcXG4gIGZpbGw6ICNmZmY7XFxuICBmb250LXNpemU6IDEzcHg7IH1cXG5cXG4vKi0tIEF4aXMgLS0qL1xcbi5iYi1heGlzIHtcXG4gIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlczsgfVxcblxcbi8qLS0gR3JpZCAtLSovXFxuLmJiLWdyaWQgbGluZSB7XFxuICBzdHJva2U6ICNhYWE7IH1cXG5cXG4uYmItZ3JpZCB0ZXh0IHtcXG4gIGZpbGw6ICNhYWE7IH1cXG5cXG4uYmIteGdyaWQsIC5iYi15Z3JpZCB7XFxuICBzdHJva2UtZGFzaGFycmF5OiAzIDM7IH1cXG5cXG4vKi0tIFRleHQgb24gQ2hhcnQgLS0qL1xcbi5iYi10ZXh0LmJiLWVtcHR5IHtcXG4gIGZpbGw6ICM4MDgwODA7XFxuICBmb250LXNpemU6IDJlbTsgfVxcblxcbi8qLS0gTGluZSAtLSovXFxuLmJiLWxpbmUge1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7IH1cXG5cXG4vKi0tIFBvaW50IC0tKi9cXG4uYmItY2lyY2xlLl9leHBhbmRlZF8ge1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7XFxuICBzdHJva2U6IHdoaXRlOyB9XFxuXFxuLmJiLXNlbGVjdGVkLWNpcmNsZSB7XFxuICBmaWxsOiB3aGl0ZTtcXG4gIHN0cm9rZS13aWR0aDogMnB4OyB9XFxuXFxuLyotLSBCYXIgLS0qL1xcbi5iYi1iYXIge1xcbiAgc3Ryb2tlLXdpZHRoOiAwOyB9XFxuICAuYmItYmFyLl9leHBhbmRlZF8ge1xcbiAgICBmaWxsLW9wYWNpdHk6IDAuNzU7IH1cXG5cXG4vKi0tIEZvY3VzIC0tKi9cXG4uYmItdGFyZ2V0LmJiLWZvY3VzZWQge1xcbiAgb3BhY2l0eTogMTsgfVxcblxcbi5iYi10YXJnZXQuYmItZm9jdXNlZCBwYXRoLmJiLWxpbmUsIC5iYi10YXJnZXQuYmItZm9jdXNlZCBwYXRoLmJiLXN0ZXAge1xcbiAgc3Ryb2tlLXdpZHRoOiAycHg7IH1cXG5cXG4uYmItdGFyZ2V0LmJiLWRlZm9jdXNlZCB7XFxuICBvcGFjaXR5OiAwLjMgIWltcG9ydGFudDsgfVxcbiAgLmJiLXRhcmdldC5iYi1kZWZvY3VzZWQgLnRleHQtb3ZlcmxhcHBpbmcge1xcbiAgICBvcGFjaXR5OiAuMDUgIWltcG9ydGFudDsgfVxcblxcbi8qLS0gUmVnaW9uIC0tKi9cXG4uYmItcmVnaW9uIHtcXG4gIGZpbGw6IHN0ZWVsYmx1ZTtcXG4gIGZpbGwtb3BhY2l0eTogLjE7IH1cXG5cXG4vKi0tIFpvb20gcmVnaW9uIC0tKi9cXG4uYmItem9vbS1icnVzaCB7XFxuICBmaWxsLW9wYWNpdHk6IC4xOyB9XFxuXFxuLyotLSBCcnVzaCAtLSovXFxuLmJiLWJydXNoIC5leHRlbnQge1xcbiAgZmlsbC1vcGFjaXR5OiAuMTsgfVxcblxcbi8qLS0gU2VsZWN0IC0gRHJhZyAtLSovXFxuLyotLSBMZWdlbmQgLS0qL1xcbi5iYi1sZWdlbmQtaXRlbSB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbi5iYi1sZWdlbmQtaXRlbS1oaWRkZW4ge1xcbiAgb3BhY2l0eTogMC4xNTsgfVxcblxcbi5iYi1sZWdlbmQtYmFja2dyb3VuZCB7XFxuICBvcGFjaXR5OiAwLjc1O1xcbiAgZmlsbDogd2hpdGU7XFxuICBzdHJva2U6IGxpZ2h0Z3JheTtcXG4gIHN0cm9rZS13aWR0aDogMTsgfVxcblxcbi8qLS0gVGl0bGUgLS0qL1xcbi5iYi10aXRsZSB7XFxuICBmb250OiAxNHB4IHNhbnMtc2VyaWY7IH1cXG5cXG4vKi0tIFRvb2x0aXAgLS0qL1xcbi5iYi10b29sdGlwLWNvbnRhaW5lciB7XFxuICB6LWluZGV4OiAxMDtcXG4gIHVzZXItc2VsZWN0OiBub25lOyB9XFxuXFxuLmJiLXRvb2x0aXAge1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gIGJvcmRlci1zcGFjaW5nOiAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGVtcHR5LWNlbGxzOiBzaG93O1xcbiAgb3BhY2l0eTogMC45O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiA3cHggN3B4IDEycHggLTlweCAjNzc3Nzc3O1xcbiAgLW1vei1ib3gtc2hhZG93OiA3cHggN3B4IDEycHggLTlweCAjNzc3Nzc3O1xcbiAgYm94LXNoYWRvdzogN3B4IDdweCAxMnB4IC05cHggIzc3Nzc3NzsgfVxcbiAgLmJiLXRvb2x0aXAgdHIge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjQ0NDOyB9XFxuICAuYmItdG9vbHRpcCB0aCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNhYWE7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgcGFkZGluZzogMnB4IDVweDtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgY29sb3I6ICNGRkY7IH1cXG4gIC5iYi10b29sdGlwIHRkIHtcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcbiAgICBwYWRkaW5nOiAzcHggNnB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBib3JkZXItbGVmdDogMXB4IGRvdHRlZCAjOTk5OyB9XFxuICAgIC5iYi10b29sdGlwIHRkID4gc3BhbiwgLmJiLXRvb2x0aXAgdGQgPiBzdmcge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICB3aWR0aDogMTBweDtcXG4gICAgICBoZWlnaHQ6IDEwcHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA2cHg7IH1cXG4gIC5iYi10b29sdGlwLnZhbHVlIHtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG5cXG4vKi0tIEFyZWEgLS0qL1xcbi5iYi1hcmVhIHtcXG4gIHN0cm9rZS13aWR0aDogMDtcXG4gIG9wYWNpdHk6IDAuMjsgfVxcblxcbi8qLS0gQXJjIC0tKi9cXG4uYmItY2hhcnQtYXJjcy10aXRsZSB7XFxuICBkb21pbmFudC1iYXNlbGluZTogbWlkZGxlO1xcbiAgZm9udC1zaXplOiAxLjNlbTsgfVxcblxcbi5iYi1jaGFydC1hcmNzLWdhdWdlLXRpdGxlIHtcXG4gIGRvbWluYW50LWJhc2VsaW5lOiBtaWRkbGU7XFxuICBmb250LXNpemU6IDIuN2VtOyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtYmFja2dyb3VuZCB7XFxuICBmaWxsOiAjZTBlMGUwO1xcbiAgc3Ryb2tlOiAjZmZmOyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdW5pdCB7XFxuICBmaWxsOiAjMDAwO1xcbiAgZm9udC1zaXplOiAxNnB4OyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWF4IHtcXG4gIGZpbGw6ICM3Nzc7IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1nYXVnZS1taW4ge1xcbiAgZmlsbDogIzc3NzsgfVxcblxcbi8qLS0gUmFkYXIgLS0qL1xcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWxldmVscyBwb2x5Z29uIHtcXG4gIGZpbGw6IG5vbmU7XFxuICBzdHJva2U6ICM4NDgyODI7XFxuICBzdHJva2Utd2lkdGg6IC41cHg7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1sZXZlbHMgdGV4dCB7XFxuICBmaWxsOiAjODQ4MjgyOyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItYXhpcyBsaW5lIHtcXG4gIHN0cm9rZTogIzg0ODI4MjtcXG4gIHN0cm9rZS13aWR0aDogLjVweDsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWF4aXMgdGV4dCB7XFxuICBmb250LXNpemU6IDEuMTVlbTtcXG4gIGN1cnNvcjogZGVmYXVsdDsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLXNoYXBlcyBwb2x5Z29uIHtcXG4gIGZpbGwtb3BhY2l0eTogLjI7XFxuICBzdHJva2Utd2lkdGg6IDFweDsgfVxcblxcbi8qLS0gQnV0dG9uIC0tKi9cXG4uYmItYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMTBweDtcXG4gIHJpZ2h0OiAxMHB4OyB9XFxuICAuYmItYnV0dG9uIC5iYi16b29tLXJlc2V0IHtcXG4gICAgZm9udC1zaXplOiAxMXB4O1xcbiAgICBib3JkZXI6IHNvbGlkIDFweCAjY2NjO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBwYWRkaW5nOiA1cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgY3Vyc29yOiBwb2ludGVyOyB9XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59IiwidmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG5leHBvcnQgdmFyIHNsaWNlID0gYXJyYXkuc2xpY2U7XG5leHBvcnQgdmFyIG1hcCA9IGFycmF5Lm1hcDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcbmltcG9ydCBiaXNlY3RvciBmcm9tIFwiLi9iaXNlY3RvclwiO1xuXG52YXIgYXNjZW5kaW5nQmlzZWN0ID0gYmlzZWN0b3IoYXNjZW5kaW5nKTtcbmV4cG9ydCB2YXIgYmlzZWN0UmlnaHQgPSBhc2NlbmRpbmdCaXNlY3QucmlnaHQ7XG5leHBvcnQgdmFyIGJpc2VjdExlZnQgPSBhc2NlbmRpbmdCaXNlY3QubGVmdDtcbmV4cG9ydCBkZWZhdWx0IGJpc2VjdFJpZ2h0O1xuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpIGNvbXBhcmUgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGNvbXBhcmUpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG87XG4gICAgfSxcbiAgICByaWdodDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkO1xuICAgICAgICBlbHNlIGxvID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsbztcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZ0NvbXBhcmF0b3IoZikge1xuICByZXR1cm4gZnVuY3Rpb24oZCwgeCkge1xuICAgIHJldHVybiBhc2NlbmRpbmcoZihkKSwgeCk7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCB7cGFpcn0gZnJvbSBcIi4vcGFpcnNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzMCwgdmFsdWVzMSwgcmVkdWNlKSB7XG4gIHZhciBuMCA9IHZhbHVlczAubGVuZ3RoLFxuICAgICAgbjEgPSB2YWx1ZXMxLmxlbmd0aCxcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShuMCAqIG4xKSxcbiAgICAgIGkwLFxuICAgICAgaTEsXG4gICAgICBpLFxuICAgICAgdmFsdWUwO1xuXG4gIGlmIChyZWR1Y2UgPT0gbnVsbCkgcmVkdWNlID0gcGFpcjtcblxuICBmb3IgKGkwID0gaSA9IDA7IGkwIDwgbjA7ICsraTApIHtcbiAgICBmb3IgKHZhbHVlMCA9IHZhbHVlczBbaTBdLCBpMSA9IDA7IGkxIDwgbjE7ICsraTEsICsraSkge1xuICAgICAgdmFsdWVzW2ldID0gcmVkdWNlKHZhbHVlMCwgdmFsdWVzMVtpMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbn1cbiIsImltcG9ydCB2YXJpYW5jZSBmcm9tIFwiLi92YXJpYW5jZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcnJheSwgZikge1xuICB2YXIgdiA9IHZhcmlhbmNlKGFycmF5LCBmKTtcbiAgcmV0dXJuIHYgPyBNYXRoLnNxcnQodikgOiB2O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgbWluLFxuICAgICAgbWF4O1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG4iLCJpbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IGJpc2VjdCBmcm9tIFwiLi9iaXNlY3RcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IGV4dGVudCBmcm9tIFwiLi9leHRlbnRcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuaW1wb3J0IHJhbmdlIGZyb20gXCIuL3JhbmdlXCI7XG5pbXBvcnQge3RpY2tTdGVwfSBmcm9tIFwiLi90aWNrc1wiO1xuaW1wb3J0IHN0dXJnZXMgZnJvbSBcIi4vdGhyZXNob2xkL3N0dXJnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgZG9tYWluID0gZXh0ZW50LFxuICAgICAgdGhyZXNob2xkID0gc3R1cmdlcztcblxuICBmdW5jdGlvbiBoaXN0b2dyYW0oZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIHgsXG4gICAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShuKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHZhbHVlKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIH1cblxuICAgIHZhciB4eiA9IGRvbWFpbih2YWx1ZXMpLFxuICAgICAgICB4MCA9IHh6WzBdLFxuICAgICAgICB4MSA9IHh6WzFdLFxuICAgICAgICB0eiA9IHRocmVzaG9sZCh2YWx1ZXMsIHgwLCB4MSk7XG5cbiAgICAvLyBDb252ZXJ0IG51bWJlciBvZiB0aHJlc2hvbGRzIGludG8gdW5pZm9ybSB0aHJlc2hvbGRzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eikpIHtcbiAgICAgIHR6ID0gdGlja1N0ZXAoeDAsIHgxLCB0eik7XG4gICAgICB0eiA9IHJhbmdlKE1hdGguY2VpbCh4MCAvIHR6KSAqIHR6LCB4MSwgdHopOyAvLyBleGNsdXNpdmVcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYW55IHRocmVzaG9sZHMgb3V0c2lkZSB0aGUgZG9tYWluLlxuICAgIHZhciBtID0gdHoubGVuZ3RoO1xuICAgIHdoaWxlICh0elswXSA8PSB4MCkgdHouc2hpZnQoKSwgLS1tO1xuICAgIHdoaWxlICh0elttIC0gMV0gPiB4MSkgdHoucG9wKCksIC0tbTtcblxuICAgIHZhciBiaW5zID0gbmV3IEFycmF5KG0gKyAxKSxcbiAgICAgICAgYmluO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBiaW5zLlxuICAgIGZvciAoaSA9IDA7IGkgPD0gbTsgKytpKSB7XG4gICAgICBiaW4gPSBiaW5zW2ldID0gW107XG4gICAgICBiaW4ueDAgPSBpID4gMCA/IHR6W2kgLSAxXSA6IHgwO1xuICAgICAgYmluLngxID0gaSA8IG0gPyB0eltpXSA6IHgxO1xuICAgIH1cblxuICAgIC8vIEFzc2lnbiBkYXRhIHRvIGJpbnMgYnkgdmFsdWUsIGlnbm9yaW5nIGFueSBvdXRzaWRlIHRoZSBkb21haW4uXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgeCA9IHZhbHVlc1tpXTtcbiAgICAgIGlmICh4MCA8PSB4ICYmIHggPD0geDEpIHtcbiAgICAgICAgYmluc1tiaXNlY3QodHosIHgsIDAsIG0pXS5wdXNoKGRhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiaW5zO1xuICB9XG5cbiAgaGlzdG9ncmFtLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHZhbHVlO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbX1swXSwgX1sxXV0pLCBoaXN0b2dyYW0pIDogZG9tYWluO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS50aHJlc2hvbGRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgcmV0dXJuIGhpc3RvZ3JhbTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgYmlzZWN0LCBiaXNlY3RSaWdodCwgYmlzZWN0TGVmdH0gZnJvbSBcIi4vYmlzZWN0XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYXNjZW5kaW5nfSBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBiaXNlY3Rvcn0gZnJvbSBcIi4vYmlzZWN0b3JcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjcm9zc30gZnJvbSBcIi4vY3Jvc3NcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkZXNjZW5kaW5nfSBmcm9tIFwiLi9kZXNjZW5kaW5nXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZGV2aWF0aW9ufSBmcm9tIFwiLi9kZXZpYXRpb25cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHRlbnR9IGZyb20gXCIuL2V4dGVudFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGhpc3RvZ3JhbX0gZnJvbSBcIi4vaGlzdG9ncmFtXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdGhyZXNob2xkRnJlZWRtYW5EaWFjb25pc30gZnJvbSBcIi4vdGhyZXNob2xkL2ZyZWVkbWFuRGlhY29uaXNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0aHJlc2hvbGRTY290dH0gZnJvbSBcIi4vdGhyZXNob2xkL3Njb3R0XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdGhyZXNob2xkU3R1cmdlc30gZnJvbSBcIi4vdGhyZXNob2xkL3N0dXJnZXNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtYXh9IGZyb20gXCIuL21heFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lYW59IGZyb20gXCIuL21lYW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZWRpYW59IGZyb20gXCIuL21lZGlhblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lcmdlfSBmcm9tIFwiLi9tZXJnZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1pbn0gZnJvbSBcIi4vbWluXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcGFpcnN9IGZyb20gXCIuL3BhaXJzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcGVybXV0ZX0gZnJvbSBcIi4vcGVybXV0ZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHF1YW50aWxlfSBmcm9tIFwiLi9xdWFudGlsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHJhbmdlfSBmcm9tIFwiLi9yYW5nZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNjYW59IGZyb20gXCIuL3NjYW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzaHVmZmxlfSBmcm9tIFwiLi9zaHVmZmxlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3VtfSBmcm9tIFwiLi9zdW1cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0aWNrcywgdGlja0luY3JlbWVudCwgdGlja1N0ZXB9IGZyb20gXCIuL3RpY2tzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJhbnNwb3NlfSBmcm9tIFwiLi90cmFuc3Bvc2VcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB2YXJpYW5jZX0gZnJvbSBcIi4vdmFyaWFuY2VcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB6aXB9IGZyb20gXCIuL3ppcFwiO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgbWF4O1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1heDtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtID0gbixcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgc3VtID0gMDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHN1bSArPSB2YWx1ZTtcbiAgICAgIGVsc2UgLS1tO1xuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHN1bSArPSB2YWx1ZTtcbiAgICAgIGVsc2UgLS1tO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtKSByZXR1cm4gc3VtIC8gbTtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuaW1wb3J0IHF1YW50aWxlIGZyb20gXCIuL3F1YW50aWxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG51bWJlcnMgPSBbXTtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHtcbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1YW50aWxlKG51bWJlcnMuc29ydChhc2NlbmRpbmcpLCAwLjUpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXlzKSB7XG4gIHZhciBuID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgIG0sXG4gICAgICBpID0gLTEsXG4gICAgICBqID0gMCxcbiAgICAgIG1lcmdlZCxcbiAgICAgIGFycmF5O1xuXG4gIHdoaWxlICgrK2kgPCBuKSBqICs9IGFycmF5c1tpXS5sZW5ndGg7XG4gIG1lcmdlZCA9IG5ldyBBcnJheShqKTtcblxuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICBhcnJheSA9IGFycmF5c1tuXTtcbiAgICBtID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlICgtLW0gPj0gMCkge1xuICAgICAgbWVyZ2VkWy0tal0gPSBhcnJheVttXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWVyZ2VkO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgbWluO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIG1pbiA+IHZhbHVlKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiBtaW4gPiB2YWx1ZSkge1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPT09IG51bGwgPyBOYU4gOiAreDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gIGlmIChmID09IG51bGwpIGYgPSBwYWlyO1xuICB2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGggLSAxLCBwID0gYXJyYXlbMF0sIHBhaXJzID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICB3aGlsZSAoaSA8IG4pIHBhaXJzW2ldID0gZihwLCBwID0gYXJyYXlbKytpXSk7XG4gIHJldHVybiBwYWlycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhaXIoYSwgYikge1xuICByZXR1cm4gW2EsIGJdO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgdmFyIGkgPSBpbmRleGVzLmxlbmd0aCwgcGVybXV0ZXMgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHBlcm11dGVzW2ldID0gYXJyYXlbaW5kZXhlc1tpXV07XG4gIHJldHVybiBwZXJtdXRlcztcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgcCwgdmFsdWVvZikge1xuICBpZiAodmFsdWVvZiA9PSBudWxsKSB2YWx1ZW9mID0gbnVtYmVyO1xuICBpZiAoIShuID0gdmFsdWVzLmxlbmd0aCkpIHJldHVybjtcbiAgaWYgKChwID0gK3ApIDw9IDAgfHwgbiA8IDIpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbMF0sIDAsIHZhbHVlcyk7XG4gIGlmIChwID49IDEpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbbiAtIDFdLCBuIC0gMSwgdmFsdWVzKTtcbiAgdmFyIG4sXG4gICAgICBpID0gKG4gLSAxKSAqIHAsXG4gICAgICBpMCA9IE1hdGguZmxvb3IoaSksXG4gICAgICB2YWx1ZTAgPSArdmFsdWVvZih2YWx1ZXNbaTBdLCBpMCwgdmFsdWVzKSxcbiAgICAgIHZhbHVlMSA9ICt2YWx1ZW9mKHZhbHVlc1tpMCArIDFdLCBpMCArIDEsIHZhbHVlcyk7XG4gIHJldHVybiB2YWx1ZTAgKyAodmFsdWUxIC0gdmFsdWUwKSAqIChpIC0gaTApO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgc3RhcnQgPSArc3RhcnQsIHN0b3AgPSArc3RvcCwgc3RlcCA9IChuID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHN0b3AgPSBzdGFydCwgc3RhcnQgPSAwLCAxKSA6IG4gPCAzID8gMSA6ICtzdGVwO1xuXG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCxcbiAgICAgIHJhbmdlID0gbmV3IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmFuZ2VbaV0gPSBzdGFydCArIGkgKiBzdGVwO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCBjb21wYXJlKSB7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICB2YXIgbixcbiAgICAgIGkgPSAwLFxuICAgICAgaiA9IDAsXG4gICAgICB4aSxcbiAgICAgIHhqID0gdmFsdWVzW2pdO1xuXG4gIGlmIChjb21wYXJlID09IG51bGwpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBpZiAoY29tcGFyZSh4aSA9IHZhbHVlc1tpXSwgeGopIDwgMCB8fCBjb21wYXJlKHhqLCB4aikgIT09IDApIHtcbiAgICAgIHhqID0geGksIGogPSBpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wYXJlKHhqLCB4aikgPT09IDApIHJldHVybiBqO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXksIGkwLCBpMSkge1xuICB2YXIgbSA9IChpMSA9PSBudWxsID8gYXJyYXkubGVuZ3RoIDogaTEpIC0gKGkwID0gaTAgPT0gbnVsbCA/IDAgOiAraTApLFxuICAgICAgdCxcbiAgICAgIGk7XG5cbiAgd2hpbGUgKG0pIHtcbiAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgdCA9IGFycmF5W20gKyBpMF07XG4gICAgYXJyYXlbbSArIGkwXSA9IGFycmF5W2kgKyBpMF07XG4gICAgYXJyYXlbaSArIGkwXSA9IHQ7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBzdW0gPSAwO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlc1tpXSkgc3VtICs9IHZhbHVlOyAvLyBOb3RlOiB6ZXJvIGFuZCBudWxsIGFyZSBlcXVpdmFsZW50LlxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpIHN1bSArPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VtO1xufVxuIiwiaW1wb3J0IHttYXB9IGZyb20gXCIuLi9hcnJheVwiO1xuaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi4vYXNjZW5kaW5nXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuLi9udW1iZXJcIjtcbmltcG9ydCBxdWFudGlsZSBmcm9tIFwiLi4vcXVhbnRpbGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCBtaW4sIG1heCkge1xuICB2YWx1ZXMgPSBtYXAuY2FsbCh2YWx1ZXMsIG51bWJlcikuc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDIgKiAocXVhbnRpbGUodmFsdWVzLCAwLjc1KSAtIHF1YW50aWxlKHZhbHVlcywgMC4yNSkpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xufVxuIiwiaW1wb3J0IGRldmlhdGlvbiBmcm9tIFwiLi4vZGV2aWF0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguY2VpbCgobWF4IC0gbWluKSAvICgzLjUgKiBkZXZpYXRpb24odmFsdWVzKSAqIE1hdGgucG93KHZhbHVlcy5sZW5ndGgsIC0xIC8gMykpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlcy5sZW5ndGgpIC8gTWF0aC5MTjIpICsgMTtcbn1cbiIsInZhciBlMTAgPSBNYXRoLnNxcnQoNTApLFxuICAgIGU1ID0gTWF0aC5zcXJ0KDEwKSxcbiAgICBlMiA9IE1hdGguc3FydCgyKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciByZXZlcnNlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbixcbiAgICAgIHRpY2tzLFxuICAgICAgc3RlcDtcblxuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgaWYgKHN0YXJ0ID09PSBzdG9wICYmIGNvdW50ID4gMCkgcmV0dXJuIFtzdGFydF07XG4gIGlmIChyZXZlcnNlID0gc3RvcCA8IHN0YXJ0KSBuID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IG47XG4gIGlmICgoc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSkgPT09IDAgfHwgIWlzRmluaXRlKHN0ZXApKSByZXR1cm4gW107XG5cbiAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKTtcbiAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wIC8gc3RlcCk7XG4gICAgdGlja3MgPSBuZXcgQXJyYXkobiA9IE1hdGguY2VpbChzdG9wIC0gc3RhcnQgKyAxKSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRpY2tzW2ldID0gKHN0YXJ0ICsgaSkgKiBzdGVwO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAqIHN0ZXApO1xuICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAqIHN0ZXApO1xuICAgIHRpY2tzID0gbmV3IEFycmF5KG4gPSBNYXRoLmNlaWwoc3RhcnQgLSBzdG9wICsgMSkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChzdGFydCAtIGkpIC8gc3RlcDtcbiAgfVxuXG4gIGlmIChyZXZlcnNlKSB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwKSAvIE1hdGguTE4xMCksXG4gICAgICBlcnJvciA9IHN0ZXAgLyBNYXRoLnBvdygxMCwgcG93ZXIpO1xuICByZXR1cm4gcG93ZXIgPj0gMFxuICAgICAgPyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKSAqIE1hdGgucG93KDEwLCBwb3dlcilcbiAgICAgIDogLU1hdGgucG93KDEwLCAtcG93ZXIpIC8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAwID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHN0ZXAxID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcDApIC8gTWF0aC5MTjEwKSksXG4gICAgICBlcnJvciA9IHN0ZXAwIC8gc3RlcDE7XG4gIGlmIChlcnJvciA+PSBlMTApIHN0ZXAxICo9IDEwO1xuICBlbHNlIGlmIChlcnJvciA+PSBlNSkgc3RlcDEgKj0gNTtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTIpIHN0ZXAxICo9IDI7XG4gIHJldHVybiBzdG9wIDwgc3RhcnQgPyAtc3RlcDEgOiBzdGVwMTtcbn1cbiIsImltcG9ydCBtaW4gZnJvbSBcIi4vbWluXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdHJpeCkge1xuICBpZiAoIShuID0gbWF0cml4Lmxlbmd0aCkpIHJldHVybiBbXTtcbiAgZm9yICh2YXIgaSA9IC0xLCBtID0gbWluKG1hdHJpeCwgbGVuZ3RoKSwgdHJhbnNwb3NlID0gbmV3IEFycmF5KG0pOyArK2kgPCBtOykge1xuICAgIGZvciAodmFyIGogPSAtMSwgbiwgcm93ID0gdHJhbnNwb3NlW2ldID0gbmV3IEFycmF5KG4pOyArK2ogPCBuOykge1xuICAgICAgcm93W2pdID0gbWF0cml4W2pdW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhbnNwb3NlO1xufVxuXG5mdW5jdGlvbiBsZW5ndGgoZCkge1xuICByZXR1cm4gZC5sZW5ndGg7XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgbSA9IDAsXG4gICAgICBpID0gLTEsXG4gICAgICBtZWFuID0gMCxcbiAgICAgIHZhbHVlLFxuICAgICAgZGVsdGEsXG4gICAgICBzdW0gPSAwO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZXNbaV0pKSkge1xuICAgICAgICBkZWx0YSA9IHZhbHVlIC0gbWVhbjtcbiAgICAgICAgbWVhbiArPSBkZWx0YSAvICsrbTtcbiAgICAgICAgc3VtICs9IGRlbHRhICogKHZhbHVlIC0gbWVhbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpKSkge1xuICAgICAgICBkZWx0YSA9IHZhbHVlIC0gbWVhbjtcbiAgICAgICAgbWVhbiArPSBkZWx0YSAvICsrbTtcbiAgICAgICAgc3VtICs9IGRlbHRhICogKHZhbHVlIC0gbWVhbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG0gPiAxKSByZXR1cm4gc3VtIC8gKG0gLSAxKTtcbn1cbiIsImltcG9ydCB0cmFuc3Bvc2UgZnJvbSBcIi4vdHJhbnNwb3NlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdHJhbnNwb3NlKGFyZ3VtZW50cyk7XG59XG4iLCJleHBvcnQgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuIiwiaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuXG52YXIgdG9wID0gMSxcbiAgICByaWdodCA9IDIsXG4gICAgYm90dG9tID0gMyxcbiAgICBsZWZ0ID0gNCxcbiAgICBlcHNpbG9uID0gMWUtNjtcblxuZnVuY3Rpb24gdHJhbnNsYXRlWCh4KSB7XG4gIHJldHVybiBcInRyYW5zbGF0ZShcIiArICh4ICsgMC41KSArIFwiLDApXCI7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVkoeSkge1xuICByZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIiArICh5ICsgMC41KSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBudW1iZXIoc2NhbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gK3NjYWxlKGQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjZW50ZXIoc2NhbGUpIHtcbiAgdmFyIG9mZnNldCA9IE1hdGgubWF4KDAsIHNjYWxlLmJhbmR3aWR0aCgpIC0gMSkgLyAyOyAvLyBBZGp1c3QgZm9yIDAuNXB4IG9mZnNldC5cbiAgaWYgKHNjYWxlLnJvdW5kKCkpIG9mZnNldCA9IE1hdGgucm91bmQob2Zmc2V0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gK3NjYWxlKGQpICsgb2Zmc2V0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBlbnRlcmluZygpIHtcbiAgcmV0dXJuICF0aGlzLl9fYXhpcztcbn1cblxuZnVuY3Rpb24gYXhpcyhvcmllbnQsIHNjYWxlKSB7XG4gIHZhciB0aWNrQXJndW1lbnRzID0gW10sXG4gICAgICB0aWNrVmFsdWVzID0gbnVsbCxcbiAgICAgIHRpY2tGb3JtYXQgPSBudWxsLFxuICAgICAgdGlja1NpemVJbm5lciA9IDYsXG4gICAgICB0aWNrU2l6ZU91dGVyID0gNixcbiAgICAgIHRpY2tQYWRkaW5nID0gMyxcbiAgICAgIGsgPSBvcmllbnQgPT09IHRvcCB8fCBvcmllbnQgPT09IGxlZnQgPyAtMSA6IDEsXG4gICAgICB4ID0gb3JpZW50ID09PSBsZWZ0IHx8IG9yaWVudCA9PT0gcmlnaHQgPyBcInhcIiA6IFwieVwiLFxuICAgICAgdHJhbnNmb3JtID0gb3JpZW50ID09PSB0b3AgfHwgb3JpZW50ID09PSBib3R0b20gPyB0cmFuc2xhdGVYIDogdHJhbnNsYXRlWTtcblxuICBmdW5jdGlvbiBheGlzKGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWVzID0gdGlja1ZhbHVlcyA9PSBudWxsID8gKHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogc2NhbGUuZG9tYWluKCkpIDogdGlja1ZhbHVlcyxcbiAgICAgICAgZm9ybWF0ID0gdGlja0Zvcm1hdCA9PSBudWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IGlkZW50aXR5KSA6IHRpY2tGb3JtYXQsXG4gICAgICAgIHNwYWNpbmcgPSBNYXRoLm1heCh0aWNrU2l6ZUlubmVyLCAwKSArIHRpY2tQYWRkaW5nLFxuICAgICAgICByYW5nZSA9IHNjYWxlLnJhbmdlKCksXG4gICAgICAgIHJhbmdlMCA9ICtyYW5nZVswXSArIDAuNSxcbiAgICAgICAgcmFuZ2UxID0gK3JhbmdlW3JhbmdlLmxlbmd0aCAtIDFdICsgMC41LFxuICAgICAgICBwb3NpdGlvbiA9IChzY2FsZS5iYW5kd2lkdGggPyBjZW50ZXIgOiBudW1iZXIpKHNjYWxlLmNvcHkoKSksXG4gICAgICAgIHNlbGVjdGlvbiA9IGNvbnRleHQuc2VsZWN0aW9uID8gY29udGV4dC5zZWxlY3Rpb24oKSA6IGNvbnRleHQsXG4gICAgICAgIHBhdGggPSBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFtudWxsXSksXG4gICAgICAgIHRpY2sgPSBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLnRpY2tcIikuZGF0YSh2YWx1ZXMsIHNjYWxlKS5vcmRlcigpLFxuICAgICAgICB0aWNrRXhpdCA9IHRpY2suZXhpdCgpLFxuICAgICAgICB0aWNrRW50ZXIgPSB0aWNrLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0aWNrXCIpLFxuICAgICAgICBsaW5lID0gdGljay5zZWxlY3QoXCJsaW5lXCIpLFxuICAgICAgICB0ZXh0ID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpO1xuXG4gICAgcGF0aCA9IHBhdGgubWVyZ2UocGF0aC5lbnRlcigpLmluc2VydChcInBhdGhcIiwgXCIudGlja1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZG9tYWluXCIpXG4gICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpKTtcblxuICAgIHRpY2sgPSB0aWNrLm1lcmdlKHRpY2tFbnRlcik7XG5cbiAgICBsaW5lID0gbGluZS5tZXJnZSh0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImN1cnJlbnRDb2xvclwiKVxuICAgICAgICAuYXR0cih4ICsgXCIyXCIsIGsgKiB0aWNrU2l6ZUlubmVyKSk7XG5cbiAgICB0ZXh0ID0gdGV4dC5tZXJnZSh0aWNrRW50ZXIuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJjdXJyZW50Q29sb3JcIilcbiAgICAgICAgLmF0dHIoeCwgayAqIHNwYWNpbmcpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgb3JpZW50ID09PSB0b3AgPyBcIjBlbVwiIDogb3JpZW50ID09PSBib3R0b20gPyBcIjAuNzFlbVwiIDogXCIwLjMyZW1cIikpO1xuXG4gICAgaWYgKGNvbnRleHQgIT09IHNlbGVjdGlvbikge1xuICAgICAgcGF0aCA9IHBhdGgudHJhbnNpdGlvbihjb250ZXh0KTtcbiAgICAgIHRpY2sgPSB0aWNrLnRyYW5zaXRpb24oY29udGV4dCk7XG4gICAgICBsaW5lID0gbGluZS50cmFuc2l0aW9uKGNvbnRleHQpO1xuICAgICAgdGV4dCA9IHRleHQudHJhbnNpdGlvbihjb250ZXh0KTtcblxuICAgICAgdGlja0V4aXQgPSB0aWNrRXhpdC50cmFuc2l0aW9uKGNvbnRleHQpXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsIGVwc2lsb24pXG4gICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gaXNGaW5pdGUoZCA9IHBvc2l0aW9uKGQpKSA/IHRyYW5zZm9ybShkKSA6IHRoaXMuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpOyB9KTtcblxuICAgICAgdGlja0VudGVyXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsIGVwc2lsb24pXG4gICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyB2YXIgcCA9IHRoaXMucGFyZW50Tm9kZS5fX2F4aXM7IHJldHVybiB0cmFuc2Zvcm0ocCAmJiBpc0Zpbml0ZShwID0gcChkKSkgPyBwIDogcG9zaXRpb24oZCkpOyB9KTtcbiAgICB9XG5cbiAgICB0aWNrRXhpdC5yZW1vdmUoKTtcblxuICAgIHBhdGhcbiAgICAgICAgLmF0dHIoXCJkXCIsIG9yaWVudCA9PT0gbGVmdCB8fCBvcmllbnQgPT0gcmlnaHRcbiAgICAgICAgICAgID8gKHRpY2tTaXplT3V0ZXIgPyBcIk1cIiArIGsgKiB0aWNrU2l6ZU91dGVyICsgXCIsXCIgKyByYW5nZTAgKyBcIkgwLjVWXCIgKyByYW5nZTEgKyBcIkhcIiArIGsgKiB0aWNrU2l6ZU91dGVyIDogXCJNMC41LFwiICsgcmFuZ2UwICsgXCJWXCIgKyByYW5nZTEpXG4gICAgICAgICAgICA6ICh0aWNrU2l6ZU91dGVyID8gXCJNXCIgKyByYW5nZTAgKyBcIixcIiArIGsgKiB0aWNrU2l6ZU91dGVyICsgXCJWMC41SFwiICsgcmFuZ2UxICsgXCJWXCIgKyBrICogdGlja1NpemVPdXRlciA6IFwiTVwiICsgcmFuZ2UwICsgXCIsMC41SFwiICsgcmFuZ2UxKSk7XG5cbiAgICB0aWNrXG4gICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiB0cmFuc2Zvcm0ocG9zaXRpb24oZCkpOyB9KTtcblxuICAgIGxpbmVcbiAgICAgICAgLmF0dHIoeCArIFwiMlwiLCBrICogdGlja1NpemVJbm5lcik7XG5cbiAgICB0ZXh0XG4gICAgICAgIC5hdHRyKHgsIGsgKiBzcGFjaW5nKVxuICAgICAgICAudGV4dChmb3JtYXQpO1xuXG4gICAgc2VsZWN0aW9uLmZpbHRlcihlbnRlcmluZylcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAuYXR0cihcImZvbnQtc2l6ZVwiLCAxMClcbiAgICAgICAgLmF0dHIoXCJmb250LWZhbWlseVwiLCBcInNhbnMtc2VyaWZcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBvcmllbnQgPT09IHJpZ2h0ID8gXCJzdGFydFwiIDogb3JpZW50ID09PSBsZWZ0ID8gXCJlbmRcIiA6IFwibWlkZGxlXCIpO1xuXG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkgeyB0aGlzLl9fYXhpcyA9IHBvc2l0aW9uOyB9KTtcbiAgfVxuXG4gIGF4aXMuc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGUgPSBfLCBheGlzKSA6IHNjYWxlO1xuICB9O1xuXG4gIGF4aXMudGlja3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGlja0FyZ3VtZW50cyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSwgYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tBcmd1bWVudHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja0FyZ3VtZW50cyA9IF8gPT0gbnVsbCA/IFtdIDogc2xpY2UuY2FsbChfKSwgYXhpcykgOiB0aWNrQXJndW1lbnRzLnNsaWNlKCk7XG4gIH07XG5cbiAgYXhpcy50aWNrVmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tWYWx1ZXMgPSBfID09IG51bGwgPyBudWxsIDogc2xpY2UuY2FsbChfKSwgYXhpcykgOiB0aWNrVmFsdWVzICYmIHRpY2tWYWx1ZXMuc2xpY2UoKTtcbiAgfTtcblxuICBheGlzLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja0Zvcm1hdCA9IF8sIGF4aXMpIDogdGlja0Zvcm1hdDtcbiAgfTtcblxuICBheGlzLnRpY2tTaXplID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplSW5uZXIgPSB0aWNrU2l6ZU91dGVyID0gK18sIGF4aXMpIDogdGlja1NpemVJbm5lcjtcbiAgfTtcblxuICBheGlzLnRpY2tTaXplSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1NpemVJbm5lciA9ICtfLCBheGlzKSA6IHRpY2tTaXplSW5uZXI7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZU91dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplT3V0ZXIgPSArXywgYXhpcykgOiB0aWNrU2l6ZU91dGVyO1xuICB9O1xuXG4gIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1BhZGRpbmcgPSArXywgYXhpcykgOiB0aWNrUGFkZGluZztcbiAgfTtcblxuICByZXR1cm4gYXhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF4aXNUb3Aoc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXModG9wLCBzY2FsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheGlzUmlnaHQoc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXMocmlnaHQsIHNjYWxlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF4aXNCb3R0b20oc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXMoYm90dG9tLCBzY2FsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheGlzTGVmdChzY2FsZSkge1xuICByZXR1cm4gYXhpcyhsZWZ0LCBzY2FsZSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiZXhwb3J0IHtcbiAgYXhpc1RvcCxcbiAgYXhpc1JpZ2h0LFxuICBheGlzQm90dG9tLFxuICBheGlzTGVmdFxufSBmcm9tIFwiLi9heGlzXCI7XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7ZHJhZ0Rpc2FibGUsIGRyYWdFbmFibGV9IGZyb20gXCJkMy1kcmFnXCI7XG5pbXBvcnQge2ludGVycG9sYXRlfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7Y3VzdG9tRXZlbnQsIGV2ZW50LCB0b3VjaCwgbW91c2UsIHNlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtpbnRlcnJ1cHR9IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBCcnVzaEV2ZW50IGZyb20gXCIuL2V2ZW50LmpzXCI7XG5pbXBvcnQgbm9ldmVudCwge25vcHJvcGFnYXRpb259IGZyb20gXCIuL25vZXZlbnQuanNcIjtcblxudmFyIE1PREVfRFJBRyA9IHtuYW1lOiBcImRyYWdcIn0sXG4gICAgTU9ERV9TUEFDRSA9IHtuYW1lOiBcInNwYWNlXCJ9LFxuICAgIE1PREVfSEFORExFID0ge25hbWU6IFwiaGFuZGxlXCJ9LFxuICAgIE1PREVfQ0VOVEVSID0ge25hbWU6IFwiY2VudGVyXCJ9O1xuXG5mdW5jdGlvbiBudW1iZXIxKGUpIHtcbiAgcmV0dXJuIFsrZVswXSwgK2VbMV1dO1xufVxuXG5mdW5jdGlvbiBudW1iZXIyKGUpIHtcbiAgcmV0dXJuIFtudW1iZXIxKGVbMF0pLCBudW1iZXIxKGVbMV0pXTtcbn1cblxuZnVuY3Rpb24gdG91Y2hlcihpZGVudGlmaWVyKSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICByZXR1cm4gdG91Y2godGFyZ2V0LCBldmVudC50b3VjaGVzLCBpZGVudGlmaWVyKTtcbiAgfTtcbn1cblxudmFyIFggPSB7XG4gIG5hbWU6IFwieFwiLFxuICBoYW5kbGVzOiBbXCJ3XCIsIFwiZVwiXS5tYXAodHlwZSksXG4gIGlucHV0OiBmdW5jdGlvbih4LCBlKSB7IHJldHVybiB4ID09IG51bGwgPyBudWxsIDogW1sreFswXSwgZVswXVsxXV0sIFsreFsxXSwgZVsxXVsxXV1dOyB9LFxuICBvdXRwdXQ6IGZ1bmN0aW9uKHh5KSB7IHJldHVybiB4eSAmJiBbeHlbMF1bMF0sIHh5WzFdWzBdXTsgfVxufTtcblxudmFyIFkgPSB7XG4gIG5hbWU6IFwieVwiLFxuICBoYW5kbGVzOiBbXCJuXCIsIFwic1wiXS5tYXAodHlwZSksXG4gIGlucHV0OiBmdW5jdGlvbih5LCBlKSB7IHJldHVybiB5ID09IG51bGwgPyBudWxsIDogW1tlWzBdWzBdLCAreVswXV0sIFtlWzFdWzBdLCAreVsxXV1dOyB9LFxuICBvdXRwdXQ6IGZ1bmN0aW9uKHh5KSB7IHJldHVybiB4eSAmJiBbeHlbMF1bMV0sIHh5WzFdWzFdXTsgfVxufTtcblxudmFyIFhZID0ge1xuICBuYW1lOiBcInh5XCIsXG4gIGhhbmRsZXM6IFtcIm5cIiwgXCJ3XCIsIFwiZVwiLCBcInNcIiwgXCJud1wiLCBcIm5lXCIsIFwic3dcIiwgXCJzZVwiXS5tYXAodHlwZSksXG4gIGlucHV0OiBmdW5jdGlvbih4eSkgeyByZXR1cm4geHkgPT0gbnVsbCA/IG51bGwgOiBudW1iZXIyKHh5KTsgfSxcbiAgb3V0cHV0OiBmdW5jdGlvbih4eSkgeyByZXR1cm4geHk7IH1cbn07XG5cbnZhciBjdXJzb3JzID0ge1xuICBvdmVybGF5OiBcImNyb3NzaGFpclwiLFxuICBzZWxlY3Rpb246IFwibW92ZVwiLFxuICBuOiBcIm5zLXJlc2l6ZVwiLFxuICBlOiBcImV3LXJlc2l6ZVwiLFxuICBzOiBcIm5zLXJlc2l6ZVwiLFxuICB3OiBcImV3LXJlc2l6ZVwiLFxuICBudzogXCJud3NlLXJlc2l6ZVwiLFxuICBuZTogXCJuZXN3LXJlc2l6ZVwiLFxuICBzZTogXCJud3NlLXJlc2l6ZVwiLFxuICBzdzogXCJuZXN3LXJlc2l6ZVwiXG59O1xuXG52YXIgZmxpcFggPSB7XG4gIGU6IFwid1wiLFxuICB3OiBcImVcIixcbiAgbnc6IFwibmVcIixcbiAgbmU6IFwibndcIixcbiAgc2U6IFwic3dcIixcbiAgc3c6IFwic2VcIlxufTtcblxudmFyIGZsaXBZID0ge1xuICBuOiBcInNcIixcbiAgczogXCJuXCIsXG4gIG53OiBcInN3XCIsXG4gIG5lOiBcInNlXCIsXG4gIHNlOiBcIm5lXCIsXG4gIHN3OiBcIm53XCJcbn07XG5cbnZhciBzaWduc1ggPSB7XG4gIG92ZXJsYXk6ICsxLFxuICBzZWxlY3Rpb246ICsxLFxuICBuOiBudWxsLFxuICBlOiArMSxcbiAgczogbnVsbCxcbiAgdzogLTEsXG4gIG53OiAtMSxcbiAgbmU6ICsxLFxuICBzZTogKzEsXG4gIHN3OiAtMVxufTtcblxudmFyIHNpZ25zWSA9IHtcbiAgb3ZlcmxheTogKzEsXG4gIHNlbGVjdGlvbjogKzEsXG4gIG46IC0xLFxuICBlOiBudWxsLFxuICBzOiArMSxcbiAgdzogbnVsbCxcbiAgbnc6IC0xLFxuICBuZTogLTEsXG4gIHNlOiArMSxcbiAgc3c6ICsxXG59O1xuXG5mdW5jdGlvbiB0eXBlKHQpIHtcbiAgcmV0dXJuIHt0eXBlOiB0fTtcbn1cblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKCkge1xuICByZXR1cm4gIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIHN2ZyA9IHRoaXMub3duZXJTVkdFbGVtZW50IHx8IHRoaXM7XG4gIGlmIChzdmcuaGFzQXR0cmlidXRlKFwidmlld0JveFwiKSkge1xuICAgIHN2ZyA9IHN2Zy52aWV3Qm94LmJhc2VWYWw7XG4gICAgcmV0dXJuIFtbc3ZnLngsIHN2Zy55XSwgW3N2Zy54ICsgc3ZnLndpZHRoLCBzdmcueSArIHN2Zy5oZWlnaHRdXTtcbiAgfVxuICByZXR1cm4gW1swLCAwXSwgW3N2Zy53aWR0aC5iYXNlVmFsLnZhbHVlLCBzdmcuaGVpZ2h0LmJhc2VWYWwudmFsdWVdXTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzKTtcbn1cblxuLy8gTGlrZSBkMy5sb2NhbCwgYnV0IHdpdGggdGhlIG5hbWUg4oCcX19icnVzaOKAnSByYXRoZXIgdGhhbiBhdXRvLWdlbmVyYXRlZC5cbmZ1bmN0aW9uIGxvY2FsKG5vZGUpIHtcbiAgd2hpbGUgKCFub2RlLl9fYnJ1c2gpIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm47XG4gIHJldHVybiBub2RlLl9fYnJ1c2g7XG59XG5cbmZ1bmN0aW9uIGVtcHR5KGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzBdWzBdID09PSBleHRlbnRbMV1bMF1cbiAgICAgIHx8IGV4dGVudFswXVsxXSA9PT0gZXh0ZW50WzFdWzFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnJ1c2hTZWxlY3Rpb24obm9kZSkge1xuICB2YXIgc3RhdGUgPSBub2RlLl9fYnJ1c2g7XG4gIHJldHVybiBzdGF0ZSA/IHN0YXRlLmRpbS5vdXRwdXQoc3RhdGUuc2VsZWN0aW9uKSA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicnVzaFgoKSB7XG4gIHJldHVybiBicnVzaChYKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJydXNoWSgpIHtcbiAgcmV0dXJuIGJydXNoKFkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGJydXNoKFhZKTtcbn1cblxuZnVuY3Rpb24gYnJ1c2goZGltKSB7XG4gIHZhciBleHRlbnQgPSBkZWZhdWx0RXh0ZW50LFxuICAgICAgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIHRvdWNoYWJsZSA9IGRlZmF1bHRUb3VjaGFibGUsXG4gICAgICBrZXlzID0gdHJ1ZSxcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJicnVzaFwiLCBcImVuZFwiKSxcbiAgICAgIGhhbmRsZVNpemUgPSA2LFxuICAgICAgdG91Y2hlbmRpbmc7XG5cbiAgZnVuY3Rpb24gYnJ1c2goZ3JvdXApIHtcbiAgICB2YXIgb3ZlcmxheSA9IGdyb3VwXG4gICAgICAgIC5wcm9wZXJ0eShcIl9fYnJ1c2hcIiwgaW5pdGlhbGl6ZSlcbiAgICAgIC5zZWxlY3RBbGwoXCIub3ZlcmxheVwiKVxuICAgICAgLmRhdGEoW3R5cGUoXCJvdmVybGF5XCIpXSk7XG5cbiAgICBvdmVybGF5LmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwib3ZlcmxheVwiKVxuICAgICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpXG4gICAgICAgIC5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMub3ZlcmxheSlcbiAgICAgIC5tZXJnZShvdmVybGF5KVxuICAgICAgICAuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZXh0ZW50ID0gbG9jYWwodGhpcykuZXh0ZW50O1xuICAgICAgICAgIHNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAuYXR0cihcInhcIiwgZXh0ZW50WzBdWzBdKVxuICAgICAgICAgICAgICAuYXR0cihcInlcIiwgZXh0ZW50WzBdWzFdKVxuICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZXh0ZW50WzFdWzFdIC0gZXh0ZW50WzBdWzFdKTtcbiAgICAgICAgfSk7XG5cbiAgICBncm91cC5zZWxlY3RBbGwoXCIuc2VsZWN0aW9uXCIpXG4gICAgICAuZGF0YShbdHlwZShcInNlbGVjdGlvblwiKV0pXG4gICAgICAuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzZWxlY3Rpb25cIilcbiAgICAgICAgLmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29ycy5zZWxlY3Rpb24pXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIiM3NzdcIilcbiAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMC4zKVxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcIiNmZmZcIilcbiAgICAgICAgLmF0dHIoXCJzaGFwZS1yZW5kZXJpbmdcIiwgXCJjcmlzcEVkZ2VzXCIpO1xuXG4gICAgdmFyIGhhbmRsZSA9IGdyb3VwLnNlbGVjdEFsbChcIi5oYW5kbGVcIilcbiAgICAgIC5kYXRhKGRpbS5oYW5kbGVzLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGU7IH0pO1xuXG4gICAgaGFuZGxlLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIGhhbmRsZS5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcImhhbmRsZSBoYW5kbGUtLVwiICsgZC50eXBlOyB9KVxuICAgICAgICAuYXR0cihcImN1cnNvclwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBjdXJzb3JzW2QudHlwZV07IH0pO1xuXG4gICAgZ3JvdXBcbiAgICAgICAgLmVhY2gocmVkcmF3KVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpXG4gICAgICAgIC5hdHRyKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIilcbiAgICAgICAgLm9uKFwibW91c2Vkb3duLmJydXNoXCIsIHN0YXJ0ZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC5icnVzaFwiLCBzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuYnJ1c2hcIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuYnJ1c2ggdG91Y2hjYW5jZWwuYnJ1c2hcIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgYnJ1c2gubW92ZSA9IGZ1bmN0aW9uKGdyb3VwLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoZ3JvdXAuc2VsZWN0aW9uKSB7XG4gICAgICBncm91cFxuICAgICAgICAgIC5vbihcInN0YXJ0LmJydXNoXCIsIGZ1bmN0aW9uKCkgeyBlbWl0dGVyKHRoaXMsIGFyZ3VtZW50cykuYmVmb3Jlc3RhcnQoKS5zdGFydCgpOyB9KVxuICAgICAgICAgIC5vbihcImludGVycnVwdC5icnVzaCBlbmQuYnJ1c2hcIiwgZnVuY3Rpb24oKSB7IGVtaXR0ZXIodGhpcywgYXJndW1lbnRzKS5lbmQoKTsgfSlcbiAgICAgICAgICAudHdlZW4oXCJicnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHRoYXQuX19icnVzaCxcbiAgICAgICAgICAgICAgICBlbWl0ID0gZW1pdHRlcih0aGF0LCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjAgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uMSA9IGRpbS5pbnB1dCh0eXBlb2Ygc2VsZWN0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHNlbGVjdGlvbiwgc3RhdGUuZXh0ZW50KSxcbiAgICAgICAgICAgICAgICBpID0gaW50ZXJwb2xhdGUoc2VsZWN0aW9uMCwgc2VsZWN0aW9uMSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHR3ZWVuKHQpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc2VsZWN0aW9uID0gdCA9PT0gMSAmJiBzZWxlY3Rpb24xID09PSBudWxsID8gbnVsbCA6IGkodCk7XG4gICAgICAgICAgICAgIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgICAgICAgICAgICBlbWl0LmJydXNoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24wICE9PSBudWxsICYmIHNlbGVjdGlvbjEgIT09IG51bGwgPyB0d2VlbiA6IHR3ZWVuKDEpO1xuICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cFxuICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgc3RhdGUgPSB0aGF0Ll9fYnJ1c2gsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uMSA9IGRpbS5pbnB1dCh0eXBlb2Ygc2VsZWN0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3Rpb24uYXBwbHkodGhhdCwgYXJncykgOiBzZWxlY3Rpb24sIHN0YXRlLmV4dGVudCksXG4gICAgICAgICAgICAgICAgZW1pdCA9IGVtaXR0ZXIodGhhdCwgYXJncykuYmVmb3Jlc3RhcnQoKTtcblxuICAgICAgICAgICAgaW50ZXJydXB0KHRoYXQpO1xuICAgICAgICAgICAgc3RhdGUuc2VsZWN0aW9uID0gc2VsZWN0aW9uMSA9PT0gbnVsbCA/IG51bGwgOiBzZWxlY3Rpb24xO1xuICAgICAgICAgICAgcmVkcmF3LmNhbGwodGhhdCk7XG4gICAgICAgICAgICBlbWl0LnN0YXJ0KCkuYnJ1c2goKS5lbmQoKTtcbiAgICAgICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgYnJ1c2guY2xlYXIgPSBmdW5jdGlvbihncm91cCkge1xuICAgIGJydXNoLm1vdmUoZ3JvdXAsIG51bGwpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICB2YXIgZ3JvdXAgPSBzZWxlY3QodGhpcyksXG4gICAgICAgIHNlbGVjdGlvbiA9IGxvY2FsKHRoaXMpLnNlbGVjdGlvbjtcblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIGdyb3VwLnNlbGVjdEFsbChcIi5zZWxlY3Rpb25cIilcbiAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIHNlbGVjdGlvblswXVswXSlcbiAgICAgICAgICAuYXR0cihcInlcIiwgc2VsZWN0aW9uWzBdWzFdKVxuICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgc2VsZWN0aW9uWzFdWzBdIC0gc2VsZWN0aW9uWzBdWzBdKVxuICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHNlbGVjdGlvblsxXVsxXSAtIHNlbGVjdGlvblswXVsxXSk7XG5cbiAgICAgIGdyb3VwLnNlbGVjdEFsbChcIi5oYW5kbGVcIilcbiAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudHlwZVtkLnR5cGUubGVuZ3RoIC0gMV0gPT09IFwiZVwiID8gc2VsZWN0aW9uWzFdWzBdIC0gaGFuZGxlU2l6ZSAvIDIgOiBzZWxlY3Rpb25bMF1bMF0gLSBoYW5kbGVTaXplIC8gMjsgfSlcbiAgICAgICAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlWzBdID09PSBcInNcIiA/IHNlbGVjdGlvblsxXVsxXSAtIGhhbmRsZVNpemUgLyAyIDogc2VsZWN0aW9uWzBdWzFdIC0gaGFuZGxlU2l6ZSAvIDI7IH0pXG4gICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGUgPT09IFwiblwiIHx8IGQudHlwZSA9PT0gXCJzXCIgPyBzZWxlY3Rpb25bMV1bMF0gLSBzZWxlY3Rpb25bMF1bMF0gKyBoYW5kbGVTaXplIDogaGFuZGxlU2l6ZTsgfSlcbiAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGUgPT09IFwiZVwiIHx8IGQudHlwZSA9PT0gXCJ3XCIgPyBzZWxlY3Rpb25bMV1bMV0gLSBzZWxlY3Rpb25bMF1bMV0gKyBoYW5kbGVTaXplIDogaGFuZGxlU2l6ZTsgfSk7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICBncm91cC5zZWxlY3RBbGwoXCIuc2VsZWN0aW9uLC5oYW5kbGVcIilcbiAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxuICAgICAgICAgIC5hdHRyKFwieFwiLCBudWxsKVxuICAgICAgICAgIC5hdHRyKFwieVwiLCBudWxsKVxuICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgbnVsbClcbiAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0dGVyKHRoYXQsIGFyZ3MsIGNsZWFuKSB7XG4gICAgcmV0dXJuICghY2xlYW4gJiYgdGhhdC5fX2JydXNoLmVtaXR0ZXIpIHx8IG5ldyBFbWl0dGVyKHRoYXQsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gRW1pdHRlcih0aGF0LCBhcmdzKSB7XG4gICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuc3RhdGUgPSB0aGF0Ll9fYnJ1c2g7XG4gICAgdGhpcy5hY3RpdmUgPSAwO1xuICB9XG5cbiAgRW1pdHRlci5wcm90b3R5cGUgPSB7XG4gICAgYmVmb3Jlc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHRoaXMuc3RhdGUuZW1pdHRlciA9IHRoaXMsIHRoaXMuc3RhcnRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zdGFydGluZykgdGhpcy5zdGFydGluZyA9IGZhbHNlLCB0aGlzLmVtaXQoXCJzdGFydFwiKTtcbiAgICAgIGVsc2UgdGhpcy5lbWl0KFwiYnJ1c2hcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGJydXNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdChcImJydXNoXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGhpcy5hY3RpdmUgPT09IDApIGRlbGV0ZSB0aGlzLnN0YXRlLmVtaXR0ZXIsIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgY3VzdG9tRXZlbnQobmV3IEJydXNoRXZlbnQoYnJ1c2gsIHR5cGUsIGRpbS5vdXRwdXQodGhpcy5zdGF0ZS5zZWxlY3Rpb24pKSwgbGlzdGVuZXJzLmFwcGx5LCBsaXN0ZW5lcnMsIFt0eXBlLCB0aGlzLnRoYXQsIHRoaXMuYXJnc10pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBzdGFydGVkKCkge1xuICAgIGlmICh0b3VjaGVuZGluZyAmJiAhZXZlbnQudG91Y2hlcykgcmV0dXJuO1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcblxuICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgdHlwZSA9IGV2ZW50LnRhcmdldC5fX2RhdGFfXy50eXBlLFxuICAgICAgICBtb2RlID0gKGtleXMgJiYgZXZlbnQubWV0YUtleSA/IHR5cGUgPSBcIm92ZXJsYXlcIiA6IHR5cGUpID09PSBcInNlbGVjdGlvblwiID8gTU9ERV9EUkFHIDogKGtleXMgJiYgZXZlbnQuYWx0S2V5ID8gTU9ERV9DRU5URVIgOiBNT0RFX0hBTkRMRSksXG4gICAgICAgIHNpZ25YID0gZGltID09PSBZID8gbnVsbCA6IHNpZ25zWFt0eXBlXSxcbiAgICAgICAgc2lnblkgPSBkaW0gPT09IFggPyBudWxsIDogc2lnbnNZW3R5cGVdLFxuICAgICAgICBzdGF0ZSA9IGxvY2FsKHRoYXQpLFxuICAgICAgICBleHRlbnQgPSBzdGF0ZS5leHRlbnQsXG4gICAgICAgIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgVyA9IGV4dGVudFswXVswXSwgdzAsIHcxLFxuICAgICAgICBOID0gZXh0ZW50WzBdWzFdLCBuMCwgbjEsXG4gICAgICAgIEUgPSBleHRlbnRbMV1bMF0sIGUwLCBlMSxcbiAgICAgICAgUyA9IGV4dGVudFsxXVsxXSwgczAsIHMxLFxuICAgICAgICBkeCA9IDAsXG4gICAgICAgIGR5ID0gMCxcbiAgICAgICAgbW92aW5nLFxuICAgICAgICBzaGlmdGluZyA9IHNpZ25YICYmIHNpZ25ZICYmIGtleXMgJiYgZXZlbnQuc2hpZnRLZXksXG4gICAgICAgIGxvY2tYLFxuICAgICAgICBsb2NrWSxcbiAgICAgICAgcG9pbnRlciA9IGV2ZW50LnRvdWNoZXMgPyB0b3VjaGVyKGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXIpIDogbW91c2UsXG4gICAgICAgIHBvaW50MCA9IHBvaW50ZXIodGhhdCksXG4gICAgICAgIHBvaW50ID0gcG9pbnQwLFxuICAgICAgICBlbWl0ID0gZW1pdHRlcih0aGF0LCBhcmd1bWVudHMsIHRydWUpLmJlZm9yZXN0YXJ0KCk7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJvdmVybGF5XCIpIHtcbiAgICAgIGlmIChzZWxlY3Rpb24pIG1vdmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5zZWxlY3Rpb24gPSBzZWxlY3Rpb24gPSBbXG4gICAgICAgIFt3MCA9IGRpbSA9PT0gWSA/IFcgOiBwb2ludDBbMF0sIG4wID0gZGltID09PSBYID8gTiA6IHBvaW50MFsxXV0sXG4gICAgICAgIFtlMCA9IGRpbSA9PT0gWSA/IEUgOiB3MCwgczAgPSBkaW0gPT09IFggPyBTIDogbjBdXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB3MCA9IHNlbGVjdGlvblswXVswXTtcbiAgICAgIG4wID0gc2VsZWN0aW9uWzBdWzFdO1xuICAgICAgZTAgPSBzZWxlY3Rpb25bMV1bMF07XG4gICAgICBzMCA9IHNlbGVjdGlvblsxXVsxXTtcbiAgICB9XG5cbiAgICB3MSA9IHcwO1xuICAgIG4xID0gbjA7XG4gICAgZTEgPSBlMDtcbiAgICBzMSA9IHMwO1xuXG4gICAgdmFyIGdyb3VwID0gc2VsZWN0KHRoYXQpXG4gICAgICAgIC5hdHRyKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuXG4gICAgdmFyIG92ZXJsYXkgPSBncm91cC5zZWxlY3RBbGwoXCIub3ZlcmxheVwiKVxuICAgICAgICAuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzW3R5cGVdKTtcblxuICAgIGlmIChldmVudC50b3VjaGVzKSB7XG4gICAgICBlbWl0Lm1vdmVkID0gbW92ZWQ7XG4gICAgICBlbWl0LmVuZGVkID0gZW5kZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gc2VsZWN0KGV2ZW50LnZpZXcpXG4gICAgICAgICAgLm9uKFwibW91c2Vtb3ZlLmJydXNoXCIsIG1vdmVkLCB0cnVlKVxuICAgICAgICAgIC5vbihcIm1vdXNldXAuYnJ1c2hcIiwgZW5kZWQsIHRydWUpO1xuICAgICAgaWYgKGtleXMpIHZpZXdcbiAgICAgICAgICAub24oXCJrZXlkb3duLmJydXNoXCIsIGtleWRvd25lZCwgdHJ1ZSlcbiAgICAgICAgICAub24oXCJrZXl1cC5icnVzaFwiLCBrZXl1cHBlZCwgdHJ1ZSlcblxuICAgICAgZHJhZ0Rpc2FibGUoZXZlbnQudmlldyk7XG4gICAgfVxuXG4gICAgbm9wcm9wYWdhdGlvbigpO1xuICAgIGludGVycnVwdCh0aGF0KTtcbiAgICByZWRyYXcuY2FsbCh0aGF0KTtcbiAgICBlbWl0LnN0YXJ0KCk7XG5cbiAgICBmdW5jdGlvbiBtb3ZlZCgpIHtcbiAgICAgIHZhciBwb2ludDEgPSBwb2ludGVyKHRoYXQpO1xuICAgICAgaWYgKHNoaWZ0aW5nICYmICFsb2NrWCAmJiAhbG9ja1kpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHBvaW50MVswXSAtIHBvaW50WzBdKSA+IE1hdGguYWJzKHBvaW50MVsxXSAtIHBvaW50WzFdKSkgbG9ja1kgPSB0cnVlO1xuICAgICAgICBlbHNlIGxvY2tYID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBvaW50ID0gcG9pbnQxO1xuICAgICAgbW92aW5nID0gdHJ1ZTtcbiAgICAgIG5vZXZlbnQoKTtcbiAgICAgIG1vdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3ZlKCkge1xuICAgICAgdmFyIHQ7XG5cbiAgICAgIGR4ID0gcG9pbnRbMF0gLSBwb2ludDBbMF07XG4gICAgICBkeSA9IHBvaW50WzFdIC0gcG9pbnQwWzFdO1xuXG4gICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSBNT0RFX1NQQUNFOlxuICAgICAgICBjYXNlIE1PREVfRFJBRzoge1xuICAgICAgICAgIGlmIChzaWduWCkgZHggPSBNYXRoLm1heChXIC0gdzAsIE1hdGgubWluKEUgLSBlMCwgZHgpKSwgdzEgPSB3MCArIGR4LCBlMSA9IGUwICsgZHg7XG4gICAgICAgICAgaWYgKHNpZ25ZKSBkeSA9IE1hdGgubWF4KE4gLSBuMCwgTWF0aC5taW4oUyAtIHMwLCBkeSkpLCBuMSA9IG4wICsgZHksIHMxID0gczAgKyBkeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1PREVfSEFORExFOiB7XG4gICAgICAgICAgaWYgKHNpZ25YIDwgMCkgZHggPSBNYXRoLm1heChXIC0gdzAsIE1hdGgubWluKEUgLSB3MCwgZHgpKSwgdzEgPSB3MCArIGR4LCBlMSA9IGUwO1xuICAgICAgICAgIGVsc2UgaWYgKHNpZ25YID4gMCkgZHggPSBNYXRoLm1heChXIC0gZTAsIE1hdGgubWluKEUgLSBlMCwgZHgpKSwgdzEgPSB3MCwgZTEgPSBlMCArIGR4O1xuICAgICAgICAgIGlmIChzaWduWSA8IDApIGR5ID0gTWF0aC5tYXgoTiAtIG4wLCBNYXRoLm1pbihTIC0gbjAsIGR5KSksIG4xID0gbjAgKyBkeSwgczEgPSBzMDtcbiAgICAgICAgICBlbHNlIGlmIChzaWduWSA+IDApIGR5ID0gTWF0aC5tYXgoTiAtIHMwLCBNYXRoLm1pbihTIC0gczAsIGR5KSksIG4xID0gbjAsIHMxID0gczAgKyBkeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1PREVfQ0VOVEVSOiB7XG4gICAgICAgICAgaWYgKHNpZ25YKSB3MSA9IE1hdGgubWF4KFcsIE1hdGgubWluKEUsIHcwIC0gZHggKiBzaWduWCkpLCBlMSA9IE1hdGgubWF4KFcsIE1hdGgubWluKEUsIGUwICsgZHggKiBzaWduWCkpO1xuICAgICAgICAgIGlmIChzaWduWSkgbjEgPSBNYXRoLm1heChOLCBNYXRoLm1pbihTLCBuMCAtIGR5ICogc2lnblkpKSwgczEgPSBNYXRoLm1heChOLCBNYXRoLm1pbihTLCBzMCArIGR5ICogc2lnblkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZTEgPCB3MSkge1xuICAgICAgICBzaWduWCAqPSAtMTtcbiAgICAgICAgdCA9IHcwLCB3MCA9IGUwLCBlMCA9IHQ7XG4gICAgICAgIHQgPSB3MSwgdzEgPSBlMSwgZTEgPSB0O1xuICAgICAgICBpZiAodHlwZSBpbiBmbGlwWCkgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnNbdHlwZSA9IGZsaXBYW3R5cGVdXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzMSA8IG4xKSB7XG4gICAgICAgIHNpZ25ZICo9IC0xO1xuICAgICAgICB0ID0gbjAsIG4wID0gczAsIHMwID0gdDtcbiAgICAgICAgdCA9IG4xLCBuMSA9IHMxLCBzMSA9IHQ7XG4gICAgICAgIGlmICh0eXBlIGluIGZsaXBZKSBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29yc1t0eXBlID0gZmxpcFlbdHlwZV1dKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbikgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uOyAvLyBNYXkgYmUgc2V0IGJ5IGJydXNoLm1vdmUhXG4gICAgICBpZiAobG9ja1gpIHcxID0gc2VsZWN0aW9uWzBdWzBdLCBlMSA9IHNlbGVjdGlvblsxXVswXTtcbiAgICAgIGlmIChsb2NrWSkgbjEgPSBzZWxlY3Rpb25bMF1bMV0sIHMxID0gc2VsZWN0aW9uWzFdWzFdO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uWzBdWzBdICE9PSB3MVxuICAgICAgICAgIHx8IHNlbGVjdGlvblswXVsxXSAhPT0gbjFcbiAgICAgICAgICB8fCBzZWxlY3Rpb25bMV1bMF0gIT09IGUxXG4gICAgICAgICAgfHwgc2VsZWN0aW9uWzFdWzFdICE9PSBzMSkge1xuICAgICAgICBzdGF0ZS5zZWxlY3Rpb24gPSBbW3cxLCBuMV0sIFtlMSwgczFdXTtcbiAgICAgICAgcmVkcmF3LmNhbGwodGhhdCk7XG4gICAgICAgIGVtaXQuYnJ1c2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRlZCgpIHtcbiAgICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChldmVudC50b3VjaGVzKSB7XG4gICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCA1MDApOyAvLyBHaG9zdCBjbGlja3MgYXJlIGRlbGF5ZWQhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmFnRW5hYmxlKGV2ZW50LnZpZXcsIG1vdmluZyk7XG4gICAgICAgIHZpZXcub24oXCJrZXlkb3duLmJydXNoIGtleXVwLmJydXNoIG1vdXNlbW92ZS5icnVzaCBtb3VzZXVwLmJydXNoXCIsIG51bGwpO1xuICAgICAgfVxuICAgICAgZ3JvdXAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpO1xuICAgICAgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMub3ZlcmxheSk7XG4gICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uKSBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247IC8vIE1heSBiZSBzZXQgYnkgYnJ1c2gubW92ZSAob24gc3RhcnQpIVxuICAgICAgaWYgKGVtcHR5KHNlbGVjdGlvbikpIHN0YXRlLnNlbGVjdGlvbiA9IG51bGwsIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgICAgZW1pdC5lbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXlkb3duZWQoKSB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAxNjogeyAvLyBTSElGVFxuICAgICAgICAgIHNoaWZ0aW5nID0gc2lnblggJiYgc2lnblk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxODogeyAvLyBBTFRcbiAgICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9IQU5ETEUpIHtcbiAgICAgICAgICAgIGlmIChzaWduWCkgZTAgPSBlMSAtIGR4ICogc2lnblgsIHcwID0gdzEgKyBkeCAqIHNpZ25YO1xuICAgICAgICAgICAgaWYgKHNpZ25ZKSBzMCA9IHMxIC0gZHkgKiBzaWduWSwgbjAgPSBuMSArIGR5ICogc2lnblk7XG4gICAgICAgICAgICBtb2RlID0gTU9ERV9DRU5URVI7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzI6IHsgLy8gU1BBQ0U7IHRha2VzIHByaW9yaXR5IG92ZXIgQUxUXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEFORExFIHx8IG1vZGUgPT09IE1PREVfQ0VOVEVSKSB7XG4gICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxIC0gZHg7IGVsc2UgaWYgKHNpZ25YID4gMCkgdzAgPSB3MSAtIGR4O1xuICAgICAgICAgICAgaWYgKHNpZ25ZIDwgMCkgczAgPSBzMSAtIGR5OyBlbHNlIGlmIChzaWduWSA+IDApIG4wID0gbjEgLSBkeTtcbiAgICAgICAgICAgIG1vZGUgPSBNT0RFX1NQQUNFO1xuICAgICAgICAgICAgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIG1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9ldmVudCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleXVwcGVkKCkge1xuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgMTY6IHsgLy8gU0hJRlRcbiAgICAgICAgICBpZiAoc2hpZnRpbmcpIHtcbiAgICAgICAgICAgIGxvY2tYID0gbG9ja1kgPSBzaGlmdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE4OiB7IC8vIEFMVFxuICAgICAgICAgIGlmIChtb2RlID09PSBNT0RFX0NFTlRFUikge1xuICAgICAgICAgICAgaWYgKHNpZ25YIDwgMCkgZTAgPSBlMTsgZWxzZSBpZiAoc2lnblggPiAwKSB3MCA9IHcxO1xuICAgICAgICAgICAgaWYgKHNpZ25ZIDwgMCkgczAgPSBzMTsgZWxzZSBpZiAoc2lnblkgPiAwKSBuMCA9IG4xO1xuICAgICAgICAgICAgbW9kZSA9IE1PREVfSEFORExFO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMyOiB7IC8vIFNQQUNFXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfU1BBQ0UpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgaWYgKHNpZ25YKSBlMCA9IGUxIC0gZHggKiBzaWduWCwgdzAgPSB3MSArIGR4ICogc2lnblg7XG4gICAgICAgICAgICAgIGlmIChzaWduWSkgczAgPSBzMSAtIGR5ICogc2lnblksIG4wID0gbjEgKyBkeSAqIHNpZ25ZO1xuICAgICAgICAgICAgICBtb2RlID0gTU9ERV9DRU5URVI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxOyBlbHNlIGlmIChzaWduWCA+IDApIHcwID0gdzE7XG4gICAgICAgICAgICAgIGlmIChzaWduWSA8IDApIHMwID0gczE7IGVsc2UgaWYgKHNpZ25ZID4gMCkgbjAgPSBuMTtcbiAgICAgICAgICAgICAgbW9kZSA9IE1PREVfSEFORExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnNbdHlwZV0pO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiByZXR1cm47XG4gICAgICB9XG4gICAgICBub2V2ZW50KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2htb3ZlZCgpIHtcbiAgICBlbWl0dGVyKHRoaXMsIGFyZ3VtZW50cykubW92ZWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoKSB7XG4gICAgZW1pdHRlcih0aGlzLCBhcmd1bWVudHMpLmVuZGVkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX19icnVzaCB8fCB7c2VsZWN0aW9uOiBudWxsfTtcbiAgICBzdGF0ZS5leHRlbnQgPSBudW1iZXIyKGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBzdGF0ZS5kaW0gPSBkaW07XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgYnJ1c2guZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQobnVtYmVyMihfKSksIGJydXNoKSA6IGV4dGVudDtcbiAgfTtcblxuICBicnVzaC5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBicnVzaCkgOiBmaWx0ZXI7XG4gIH07XG5cbiAgYnJ1c2gudG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgYnJ1c2gpIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIGJydXNoLmhhbmRsZVNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaGFuZGxlU2l6ZSA9ICtfLCBicnVzaCkgOiBoYW5kbGVTaXplO1xuICB9O1xuXG4gIGJydXNoLmtleU1vZGlmaWVycyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrZXlzID0gISFfLCBicnVzaCkgOiBrZXlzO1xuICB9O1xuXG4gIGJydXNoLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IGJydXNoIDogdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIGJydXNoO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIHNlbGVjdGlvbikge1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG59XG4iLCJleHBvcnQge1xuICBkZWZhdWx0IGFzIGJydXNoLFxuICBicnVzaFgsXG4gIGJydXNoWSxcbiAgYnJ1c2hTZWxlY3Rpb25cbn0gZnJvbSBcIi4vYnJ1c2guanNcIjtcbiIsImltcG9ydCB7ZXZlbnR9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oKSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXApIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG1hcCkgZW50cmllcy5wdXNoKHtrZXk6IGtleSwgdmFsdWU6IG1hcFtrZXldfSk7XG4gIHJldHVybiBlbnRyaWVzO1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIG5lc3R9IGZyb20gXCIuL25lc3RcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZXR9IGZyb20gXCIuL3NldFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1hcH0gZnJvbSBcIi4vbWFwXCI7XG5leHBvcnQge2RlZmF1bHQgYXMga2V5c30gZnJvbSBcIi4va2V5c1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZhbHVlc30gZnJvbSBcIi4vdmFsdWVzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZW50cmllc30gZnJvbSBcIi4vZW50cmllc1wiO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWFwKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBtYXApIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbiIsImV4cG9ydCB2YXIgcHJlZml4ID0gXCIkXCI7XG5cbmZ1bmN0aW9uIE1hcCgpIHt9XG5cbk1hcC5wcm90b3R5cGUgPSBtYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTWFwLFxuICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiAocHJlZml4ICsga2V5KSBpbiB0aGlzO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzW3ByZWZpeCArIGtleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNbcHJlZml4ICsga2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBwcm9wZXJ0eSA9IHByZWZpeCArIGtleTtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiBkZWxldGUgdGhpc1twcm9wZXJ0eV07XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xuICB9LFxuICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBrZXlzLnB1c2gocHJvcGVydHkuc2xpY2UoMSkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9LFxuICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgdmFsdWVzLnB1c2godGhpc1twcm9wZXJ0eV0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0sXG4gIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGVudHJpZXMucHVzaCh7a2V5OiBwcm9wZXJ0eS5zbGljZSgxKSwgdmFsdWU6IHRoaXNbcHJvcGVydHldfSk7XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgKytzaXplO1xuICAgIHJldHVybiBzaXplO1xuICB9LFxuICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZWFjaDogZnVuY3Rpb24oZikge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBmKHRoaXNbcHJvcGVydHldLCBwcm9wZXJ0eS5zbGljZSgxKSwgdGhpcyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1hcChvYmplY3QsIGYpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXA7XG5cbiAgLy8gQ29weSBjb25zdHJ1Y3Rvci5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcCkgb2JqZWN0LmVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkgeyBtYXAuc2V0KGtleSwgdmFsdWUpOyB9KTtcblxuICAvLyBJbmRleCBhcnJheSBieSBudW1lcmljIGluZGV4IG9yIHNwZWNpZmllZCBrZXkgZnVuY3Rpb24uXG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBvYmplY3QubGVuZ3RoLFxuICAgICAgICBvO1xuXG4gICAgaWYgKGYgPT0gbnVsbCkgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoaSwgb2JqZWN0W2ldKTtcbiAgICBlbHNlIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGYobyA9IG9iamVjdFtpXSwgaSwgb2JqZWN0KSwgbyk7XG4gIH1cblxuICAvLyBDb252ZXJ0IG9iamVjdCB0byBtYXAuXG4gIGVsc2UgaWYgKG9iamVjdCkgZm9yICh2YXIga2V5IGluIG9iamVjdCkgbWFwLnNldChrZXksIG9iamVjdFtrZXldKTtcblxuICByZXR1cm4gbWFwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXA7XG4iLCJpbXBvcnQgbWFwIGZyb20gXCIuL21hcFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGtleXMgPSBbXSxcbiAgICAgIHNvcnRLZXlzID0gW10sXG4gICAgICBzb3J0VmFsdWVzLFxuICAgICAgcm9sbHVwLFxuICAgICAgbmVzdDtcblxuICBmdW5jdGlvbiBhcHBseShhcnJheSwgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSB7XG4gICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSB7XG4gICAgICBpZiAoc29ydFZhbHVlcyAhPSBudWxsKSBhcnJheS5zb3J0KHNvcnRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIHJvbGx1cCAhPSBudWxsID8gcm9sbHVwKGFycmF5KSA6IGFycmF5O1xuICAgIH1cblxuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGtleSA9IGtleXNbZGVwdGgrK10sXG4gICAgICAgIGtleVZhbHVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdmFsdWVzQnlLZXkgPSBtYXAoKSxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICByZXN1bHQgPSBjcmVhdGVSZXN1bHQoKTtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWVzID0gdmFsdWVzQnlLZXkuZ2V0KGtleVZhbHVlID0ga2V5KHZhbHVlID0gYXJyYXlbaV0pICsgXCJcIikpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzQnlLZXkuc2V0KGtleVZhbHVlLCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWx1ZXNCeUtleS5lYWNoKGZ1bmN0aW9uKHZhbHVlcywga2V5KSB7XG4gICAgICBzZXRSZXN1bHQocmVzdWx0LCBrZXksIGFwcGx5KHZhbHVlcywgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZW50cmllcyhtYXAsIGRlcHRoKSB7XG4gICAgaWYgKCsrZGVwdGggPiBrZXlzLmxlbmd0aCkgcmV0dXJuIG1hcDtcbiAgICB2YXIgYXJyYXksIHNvcnRLZXkgPSBzb3J0S2V5c1tkZXB0aCAtIDFdO1xuICAgIGlmIChyb2xsdXAgIT0gbnVsbCAmJiBkZXB0aCA+PSBrZXlzLmxlbmd0aCkgYXJyYXkgPSBtYXAuZW50cmllcygpO1xuICAgIGVsc2UgYXJyYXkgPSBbXSwgbWFwLmVhY2goZnVuY3Rpb24odiwgaykgeyBhcnJheS5wdXNoKHtrZXk6IGssIHZhbHVlczogZW50cmllcyh2LCBkZXB0aCl9KTsgfSk7XG4gICAgcmV0dXJuIHNvcnRLZXkgIT0gbnVsbCA/IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc29ydEtleShhLmtleSwgYi5rZXkpOyB9KSA6IGFycmF5O1xuICB9XG5cbiAgcmV0dXJuIG5lc3QgPSB7XG4gICAgb2JqZWN0OiBmdW5jdGlvbihhcnJheSkgeyByZXR1cm4gYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU9iamVjdCwgc2V0T2JqZWN0KTsgfSxcbiAgICBtYXA6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlTWFwLCBzZXRNYXApOyB9LFxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBlbnRyaWVzKGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCksIDApOyB9LFxuICAgIGtleTogZnVuY3Rpb24oZCkgeyBrZXlzLnB1c2goZCk7IHJldHVybiBuZXN0OyB9LFxuICAgIHNvcnRLZXlzOiBmdW5jdGlvbihvcmRlcikgeyBzb3J0S2V5c1trZXlzLmxlbmd0aCAtIDFdID0gb3JkZXI7IHJldHVybiBuZXN0OyB9LFxuICAgIHNvcnRWYWx1ZXM6IGZ1bmN0aW9uKG9yZGVyKSB7IHNvcnRWYWx1ZXMgPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgcm9sbHVwOiBmdW5jdGlvbihmKSB7IHJvbGx1cCA9IGY7IHJldHVybiBuZXN0OyB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdCgpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBzZXRPYmplY3Qob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcCgpIHtcbiAgcmV0dXJuIG1hcCgpO1xufVxuXG5mdW5jdGlvbiBzZXRNYXAobWFwLCBrZXksIHZhbHVlKSB7XG4gIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG59XG4iLCJpbXBvcnQge2RlZmF1bHQgYXMgbWFwLCBwcmVmaXh9IGZyb20gXCIuL21hcFwiO1xuXG5mdW5jdGlvbiBTZXQoKSB7fVxuXG52YXIgcHJvdG8gPSBtYXAucHJvdG90eXBlO1xuXG5TZXQucHJvdG90eXBlID0gc2V0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNldCxcbiAgaGFzOiBwcm90by5oYXMsXG4gIGFkZDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YWx1ZSArPSBcIlwiO1xuICAgIHRoaXNbcHJlZml4ICsgdmFsdWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogcHJvdG8ucmVtb3ZlLFxuICBjbGVhcjogcHJvdG8uY2xlYXIsXG4gIHZhbHVlczogcHJvdG8ua2V5cyxcbiAgc2l6ZTogcHJvdG8uc2l6ZSxcbiAgZW1wdHk6IHByb3RvLmVtcHR5LFxuICBlYWNoOiBwcm90by5lYWNoXG59O1xuXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBmKSB7XG4gIHZhciBzZXQgPSBuZXcgU2V0O1xuXG4gIC8vIENvcHkgY29uc3RydWN0b3IuXG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTZXQpIG9iamVjdC5lYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IHNldC5hZGQodmFsdWUpOyB9KTtcblxuICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpdOKAmXMgYW4gYXJyYXkuXG4gIGVsc2UgaWYgKG9iamVjdCkge1xuICAgIHZhciBpID0gLTEsIG4gPSBvYmplY3QubGVuZ3RoO1xuICAgIGlmIChmID09IG51bGwpIHdoaWxlICgrK2kgPCBuKSBzZXQuYWRkKG9iamVjdFtpXSk7XG4gICAgZWxzZSB3aGlsZSAoKytpIDwgbikgc2V0LmFkZChmKG9iamVjdFtpXSwgaSwgb2JqZWN0KSk7XG4gIH1cblxuICByZXR1cm4gc2V0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXQ7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXApIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSB2YWx1ZXMucHVzaChtYXBba2V5XSk7XG4gIHJldHVybiB2YWx1ZXM7XG59XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENvbG9yKCkge31cblxuZXhwb3J0IHZhciBkYXJrZXIgPSAwLjc7XG5leHBvcnQgdmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxudmFyIHJlSSA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiLFxuICAgIHJlTiA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCIsXG4gICAgcmVQID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCIsXG4gICAgcmVIZXggPSAvXiMoWzAtOWEtZl17Myw4fSkkLyxcbiAgICByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVJLCByZUksIHJlSV0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYlBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYmFJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZUksIHJlSSwgcmVJLCByZU5dICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbGFcXFxcKFwiICsgW3JlTiwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKTtcblxudmFyIG5hbWVkID0ge1xuICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICBhcXVhOiAweDAwZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXG4gIGF6dXJlOiAweGYwZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjLFxuICBiaXNxdWU6IDB4ZmZlNGM0LFxuICBibGFjazogMHgwMDAwMDAsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgYmx1ZTogMHgwMDAwZmYsXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICBicm93bjogMHhhNTJhMmEsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODcsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxuICBjb3JhbDogMHhmZjdmNTAsXG4gIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgY29ybnNpbGs6IDB4ZmZmOGRjLFxuICBjcmltc29uOiAweGRjMTQzYyxcbiAgY3lhbjogMHgwMGZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YixcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxuICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgZGFya2dyYXk6IDB4YTlhOWE5LFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICBkYXJrZ3JleTogMHhhOWE5YTksXG4gIGRhcmtraGFraTogMHhiZGI3NmIsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxuICBkZWVwcGluazogMHhmZjE0OTMsXG4gIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjksXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxuICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgZ29sZDogMHhmZmQ3MDAsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gIGdyYXk6IDB4ODA4MDgwLFxuICBncmVlbjogMHgwMDgwMDAsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgZ3JleTogMHg4MDgwODAsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMCxcbiAgaG90cGluazogMHhmZjY5YjQsXG4gIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gIGluZGlnbzogMHg0YjAwODIsXG4gIGl2b3J5OiAweGZmZmZmMCxcbiAga2hha2k6IDB4ZjBlNjhjLFxuICBsYXZlbmRlcjogMHhlNmU2ZmEsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgbGlnaHRjeWFuOiAweGUwZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MCxcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxuICBsaW1lOiAweDAwZmYwMCxcbiAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgbGluZW46IDB4ZmFmMGU2LFxuICBtYWdlbnRhOiAweGZmMDBmZixcbiAgbWFyb29uOiAweDgwMDAwMCxcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgbW9jY2FzaW46IDB4ZmZlNGI1LFxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gIG5hdnk6IDB4MDAwMDgwLFxuICBvbGRsYWNlOiAweGZkZjVlNixcbiAgb2xpdmU6IDB4ODA4MDAwLFxuICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICBvcmFuZ2U6IDB4ZmZhNTAwLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgcGVydTogMHhjZDg1M2YsXG4gIHBpbms6IDB4ZmZjMGNiLFxuICBwbHVtOiAweGRkYTBkZCxcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXG4gIHB1cnBsZTogMHg4MDAwODAsXG4gIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICByZWQ6IDB4ZmYwMDAwLFxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXG4gIHNhbG1vbjogMHhmYTgwNzIsXG4gIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICBzZWFncmVlbjogMHgyZThiNTcsXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgc2llbm5hOiAweGEwNTIyZCxcbiAgc2lsdmVyOiAweGMwYzBjMCxcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTAsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gIHNub3c6IDB4ZmZmYWZhLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gIHRhbjogMHhkMmI0OGMsXG4gIHRlYWw6IDB4MDA4MDgwLFxuICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgdG9tYXRvOiAweGZmNjM0NyxcbiAgdHVycXVvaXNlOiAweDQwZTBkMCxcbiAgdmlvbGV0OiAweGVlODJlZSxcbiAgd2hlYXQ6IDB4ZjVkZWIzLFxuICB3aGl0ZTogMHhmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcbn07XG5cbmRlZmluZShDb2xvciwgY29sb3IsIHtcbiAgY29weTogZnVuY3Rpb24oY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcywgY2hhbm5lbHMpO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKTtcbiAgfSxcbiAgaGV4OiBjb2xvcl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogY29sb3JfZm9ybWF0SGV4LFxuICBmb3JtYXRIc2w6IGNvbG9yX2Zvcm1hdEhzbCxcbiAgZm9ybWF0UmdiOiBjb2xvcl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiBjb2xvcl9mb3JtYXRSZ2Jcbn0pO1xuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIc2woKSB7XG4gIHJldHVybiBoc2xDb252ZXJ0KHRoaXMpLmZvcm1hdEhzbCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRSZ2IoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdFJnYigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG0sIGw7XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXguZXhlYyhmb3JtYXQpKSA/IChsID0gbVsxXS5sZW5ndGgsIG0gPSBwYXJzZUludChtWzFdLCAxNiksIGwgPT09IDYgPyByZ2JuKG0pIC8vICNmZjAwMDBcbiAgICAgIDogbCA9PT0gMyA/IG5ldyBSZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSwgMSkgLy8gI2YwMFxuICAgICAgOiBsID09PSA4ID8gcmdiYShtID4+IDI0ICYgMHhmZiwgbSA+PiAxNiAmIDB4ZmYsIG0gPj4gOCAmIDB4ZmYsIChtICYgMHhmZikgLyAweGZmKSAvLyAjZmYwMDAwMDBcbiAgICAgIDogbCA9PT0gNCA/IHJnYmEoKG0gPj4gMTIgJiAweGYpIHwgKG0gPj4gOCAmIDB4ZjApLCAobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSkgLyAweGZmKSAvLyAjZjAwMFxuICAgICAgOiBudWxsKSAvLyBpbnZhbGlkIGhleFxuICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdLCBtWzJdLCBtWzNdLCAxKSAvLyByZ2IoMjU1LCAwLCAwKVxuICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxuICAgICAgOiAobSA9IHJlUmdiYUludGVnZXIuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSwgbVsyXSwgbVszXSwgbVs0XSkgLy8gcmdiYSgyNTUsIDAsIDAsIDEpXG4gICAgICA6IChtID0gcmVSZ2JhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCBtWzRdKSAvLyByZ2IoMTAwJSwgMCUsIDAlLCAxKVxuICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcbiAgICAgIDogKG0gPSByZUhzbGFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIG1bNF0pIC8vIGhzbGEoMTIwLCA1MCUsIDUwJSwgMSlcbiAgICAgIDogbmFtZWQuaGFzT3duUHJvcGVydHkoZm9ybWF0KSA/IHJnYm4obmFtZWRbZm9ybWF0XSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApXG4gICAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJnYm4obikge1xuICByZXR1cm4gbmV3IFJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYsIDEpO1xufVxuXG5mdW5jdGlvbiByZ2JhKHIsIGcsIGIsIGEpIHtcbiAgaWYgKGEgPD0gMCkgciA9IGcgPSBiID0gTmFOO1xuICByZXR1cm4gbmV3IFJnYihyLCBnLCBiLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYkNvbnZlcnQobykge1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBSZ2I7XG4gIG8gPSBvLnJnYigpO1xuICByZXR1cm4gbmV3IFJnYihvLnIsIG8uZywgby5iLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICB0aGlzLnIgPSArcjtcbiAgdGhpcy5nID0gK2c7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKFJnYiwgcmdiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoLTAuNSA8PSB0aGlzLnIgJiYgdGhpcy5yIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuZyAmJiB0aGlzLmcgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5iICYmIHRoaXMuYiA8IDI1NS41KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBoZXg6IHJnYl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogcmdiX2Zvcm1hdEhleCxcbiAgZm9ybWF0UmdiOiByZ2JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogcmdiX2Zvcm1hdFJnYlxufSkpO1xuXG5mdW5jdGlvbiByZ2JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gXCIjXCIgKyBoZXgodGhpcy5yKSArIGhleCh0aGlzLmcpICsgaGV4KHRoaXMuYik7XG59XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRSZ2IoKSB7XG4gIHZhciBhID0gdGhpcy5vcGFjaXR5OyBhID0gaXNOYU4oYSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYSkpO1xuICByZXR1cm4gKGEgPT09IDEgPyBcInJnYihcIiA6IFwicmdiYShcIilcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMucikgfHwgMCkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmcpIHx8IDApKSArIFwiLCBcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5iKSB8fCAwKSlcbiAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG59XG5cbmZ1bmN0aW9uIGhleCh2YWx1ZSkge1xuICB2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh2YWx1ZSkgfHwgMCkpO1xuICByZXR1cm4gKHZhbHVlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgdmFsdWUudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBoc2xhKGgsIHMsIGwsIGEpIHtcbiAgaWYgKGEgPD0gMCkgaCA9IHMgPSBsID0gTmFOO1xuICBlbHNlIGlmIChsIDw9IDAgfHwgbCA+PSAxKSBoID0gcyA9IE5hTjtcbiAgZWxzZSBpZiAocyA8PSAwKSBoID0gTmFOO1xuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG5ldyBIc2woby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgSHNsO1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG87XG4gIG8gPSBvLnJnYigpO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGggPSBOYU4sXG4gICAgICBzID0gbWF4IC0gbWluLFxuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKHMpIHtcbiAgICBpZiAociA9PT0gbWF4KSBoID0gKGcgLSBiKSAvIHMgKyAoZyA8IGIpICogNjtcbiAgICBlbHNlIGlmIChnID09PSBtYXgpIGggPSAoYiAtIHIpIC8gcyArIDI7XG4gICAgZWxzZSBoID0gKHIgLSBnKSAvIHMgKyA0O1xuICAgIHMgLz0gbCA8IDAuNSA/IG1heCArIG1pbiA6IDIgLSBtYXggLSBtaW47XG4gICAgaCAqPSA2MDtcbiAgfSBlbHNlIHtcbiAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgfVxuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoc2xDb252ZXJ0KGgpIDogbmV3IEhzbChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSHNsLCBoc2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSB0aGlzLmggJSAzNjAgKyAodGhpcy5oIDwgMCkgKiAzNjAsXG4gICAgICAgIHMgPSBpc05hTihoKSB8fCBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyxcbiAgICAgICAgbCA9IHRoaXMubCxcbiAgICAgICAgbTIgPSBsICsgKGwgPCAwLjUgPyBsIDogMSAtIGwpICogcyxcbiAgICAgICAgbTEgPSAyICogbCAtIG0yO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoIDwgMTIwID8gaCArIDI0MCA6IGggLSAxMjAsIG0xLCBtMiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGZvcm1hdEhzbDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gICAgcmV0dXJuIChhID09PSAxID8gXCJoc2woXCIgOiBcImhzbGEoXCIpXG4gICAgICAgICsgKHRoaXMuaCB8fCAwKSArIFwiLCBcIlxuICAgICAgICArICh0aGlzLnMgfHwgMCkgKiAxMDAgKyBcIiUsIFwiXG4gICAgICAgICsgKHRoaXMubCB8fCAwKSAqIDEwMCArIFwiJVwiXG4gICAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG4gIH1cbn0pKTtcblxuLyogRnJvbSBGdkQgMTMuMzcsIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgMyAqL1xuZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxuICAgICAgOiBoIDwgMTgwID8gbTJcbiAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgIDogbTEpICogMjU1O1xufVxuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5pbXBvcnQge0NvbG9yLCByZ2JDb252ZXJ0LCBSZ2IsIGRhcmtlciwgYnJpZ2h0ZXJ9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5pbXBvcnQge2RlZzJyYWQsIHJhZDJkZWd9IGZyb20gXCIuL21hdGguanNcIjtcblxudmFyIEEgPSAtMC4xNDg2MSxcbiAgICBCID0gKzEuNzgyNzcsXG4gICAgQyA9IC0wLjI5MjI3LFxuICAgIEQgPSAtMC45MDY0OSxcbiAgICBFID0gKzEuOTcyOTQsXG4gICAgRUQgPSBFICogRCxcbiAgICBFQiA9IEUgKiBCLFxuICAgIEJDX0RBID0gQiAqIEMgLSBEICogQTtcblxuZnVuY3Rpb24gY3ViZWhlbGl4Q29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgQ3ViZWhlbGl4KSByZXR1cm4gbmV3IEN1YmVoZWxpeChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBsID0gKEJDX0RBICogYiArIEVEICogciAtIEVCICogZykgLyAoQkNfREEgKyBFRCAtIEVCKSxcbiAgICAgIGJsID0gYiAtIGwsXG4gICAgICBrID0gKEUgKiAoZyAtIGwpIC0gQyAqIGJsKSAvIEQsXG4gICAgICBzID0gTWF0aC5zcXJ0KGsgKiBrICsgYmwgKiBibCkgLyAoRSAqIGwgKiAoMSAtIGwpKSwgLy8gTmFOIGlmIGw9MCBvciBsPTFcbiAgICAgIGggPSBzID8gTWF0aC5hdGFuMihrLCBibCkgKiByYWQyZGVnIC0gMTIwIDogTmFOO1xuICByZXR1cm4gbmV3IEN1YmVoZWxpeChoIDwgMCA/IGggKyAzNjAgOiBoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGN1YmVoZWxpeENvbnZlcnQoaCkgOiBuZXcgQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoQ3ViZWhlbGl4LCBjdWJlaGVsaXgsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSBpc05hTih0aGlzLmgpID8gMCA6ICh0aGlzLmggKyAxMjApICogZGVnMnJhZCxcbiAgICAgICAgbCA9ICt0aGlzLmwsXG4gICAgICAgIGEgPSBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyAqIGwgKiAoMSAtIGwpLFxuICAgICAgICBjb3NoID0gTWF0aC5jb3MoaCksXG4gICAgICAgIHNpbmggPSBNYXRoLnNpbihoKTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIDI1NSAqIChsICsgYSAqIChBICogY29zaCArIEIgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoQyAqIGNvc2ggKyBEICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEUgKiBjb3NoKSksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIGRlZmluaXRpb24pIHtcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSBwcm90b3R5cGVba2V5XSA9IGRlZmluaXRpb25ba2V5XTtcbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBjb2xvciwgcmdiLCBoc2x9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbGFiLCBoY2wsIGxjaCwgZ3JheX0gZnJvbSBcIi4vbGFiLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3ViZWhlbGl4fSBmcm9tIFwiLi9jdWJlaGVsaXguanNcIjtcbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuaW1wb3J0IHtDb2xvciwgcmdiQ29udmVydCwgUmdifSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuaW1wb3J0IHtkZWcycmFkLCByYWQyZGVnfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbi8vIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AbWJvc3RvY2svbGFiLWFuZC1yZ2JcbnZhciBLID0gMTgsXG4gICAgWG4gPSAwLjk2NDIyLFxuICAgIFluID0gMSxcbiAgICBabiA9IDAuODI1MjEsXG4gICAgdDAgPSA0IC8gMjksXG4gICAgdDEgPSA2IC8gMjksXG4gICAgdDIgPSAzICogdDEgKiB0MSxcbiAgICB0MyA9IHQxICogdDEgKiB0MTtcblxuZnVuY3Rpb24gbGFiQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgTGFiKSByZXR1cm4gbmV3IExhYihvLmwsIG8uYSwgby5iLCBvLm9wYWNpdHkpO1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIGhjbDJsYWIobyk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSByZ2IybHJnYihvLnIpLFxuICAgICAgZyA9IHJnYjJscmdiKG8uZyksXG4gICAgICBiID0gcmdiMmxyZ2Ioby5iKSxcbiAgICAgIHkgPSB4eXoybGFiKCgwLjIyMjUwNDUgKiByICsgMC43MTY4Nzg2ICogZyArIDAuMDYwNjE2OSAqIGIpIC8gWW4pLCB4LCB6O1xuICBpZiAociA9PT0gZyAmJiBnID09PSBiKSB4ID0geiA9IHk7IGVsc2Uge1xuICAgIHggPSB4eXoybGFiKCgwLjQzNjA3NDcgKiByICsgMC4zODUwNjQ5ICogZyArIDAuMTQzMDgwNCAqIGIpIC8gWG4pO1xuICAgIHogPSB4eXoybGFiKCgwLjAxMzkzMjIgKiByICsgMC4wOTcxMDQ1ICogZyArIDAuNzE0MTczMyAqIGIpIC8gWm4pO1xuICB9XG4gIHJldHVybiBuZXcgTGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXkobCwgb3BhY2l0eSkge1xuICByZXR1cm4gbmV3IExhYihsLCAwLCAwLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gbGFiQ29udmVydChsKSA6IG5ldyBMYWIobCwgYSwgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMuYSA9ICthO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShMYWIsIGxhYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHkgPSAodGhpcy5sICsgMTYpIC8gMTE2LFxuICAgICAgICB4ID0gaXNOYU4odGhpcy5hKSA/IHkgOiB5ICsgdGhpcy5hIC8gNTAwLFxuICAgICAgICB6ID0gaXNOYU4odGhpcy5iKSA/IHkgOiB5IC0gdGhpcy5iIC8gMjAwO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgbHJnYjJyZ2IoIDMuMTMzODU2MSAqIHggLSAxLjYxNjg2NjcgKiB5IC0gMC40OTA2MTQ2ICogeiksXG4gICAgICBscmdiMnJnYigtMC45Nzg3Njg0ICogeCArIDEuOTE2MTQxNSAqIHkgKyAwLjAzMzQ1NDAgKiB6KSxcbiAgICAgIGxyZ2IycmdiKCAwLjA3MTk0NTMgKiB4IC0gMC4yMjg5OTE0ICogeSArIDEuNDA1MjQyNyAqIHopLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG59XG5cbmZ1bmN0aW9uIGxyZ2IycmdiKHgpIHtcbiAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5cbmZ1bmN0aW9uIHJnYjJscmdiKHgpIHtcbiAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIGhjbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIG5ldyBIY2woby5oLCBvLmMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIExhYikpIG8gPSBsYWJDb252ZXJ0KG8pO1xuICBpZiAoby5hID09PSAwICYmIG8uYiA9PT0gMCkgcmV0dXJuIG5ldyBIY2woTmFOLCAwIDwgby5sICYmIG8ubCA8IDEwMCA/IDAgOiBOYU4sIG8ubCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBNYXRoLmF0YW4yKG8uYiwgby5hKSAqIHJhZDJkZWc7XG4gIHJldHVybiBuZXcgSGNsKGggPCAwID8gaCArIDM2MCA6IGgsIE1hdGguc3FydChvLmEgKiBvLmEgKyBvLmIgKiBvLmIpLCBvLmwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsY2gobCwgYywgaCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQobCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChoKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMuYyA9ICtjO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmZ1bmN0aW9uIGhjbDJsYWIobykge1xuICBpZiAoaXNOYU4oby5oKSkgcmV0dXJuIG5ldyBMYWIoby5sLCAwLCAwLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IG8uaCAqIGRlZzJyYWQ7XG4gIHJldHVybiBuZXcgTGFiKG8ubCwgTWF0aC5jb3MoaCkgKiBvLmMsIE1hdGguc2luKGgpICogby5jLCBvLm9wYWNpdHkpO1xufVxuXG5kZWZpbmUoSGNsLCBoY2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBoY2wybGFiKHRoaXMpLnJnYigpO1xuICB9XG59KSk7XG4iLCJleHBvcnQgdmFyIGRlZzJyYWQgPSBNYXRoLlBJIC8gMTgwO1xuZXhwb3J0IHZhciByYWQyZGVnID0gMTgwIC8gTWF0aC5QSTtcbiIsInZhciBub29wID0ge3ZhbHVlOiBmdW5jdGlvbigpIHt9fTtcblxuZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEodCA9IGFyZ3VtZW50c1tpXSArIFwiXCIpIHx8ICh0IGluIF8pIHx8IC9bXFxzLl0vLnRlc3QodCkpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0KTtcbiAgICBfW3RdID0gW107XG4gIH1cbiAgcmV0dXJuIG5ldyBEaXNwYXRjaChfKTtcbn1cblxuZnVuY3Rpb24gRGlzcGF0Y2goXykge1xuICB0aGlzLl8gPSBfO1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMsIHR5cGVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICBpZiAodCAmJiAhdHlwZXMuaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuRGlzcGF0Y2gucHJvdG90eXBlID0gZGlzcGF0Y2gucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGF0Y2gsXG4gIG9uOiBmdW5jdGlvbih0eXBlbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgXyA9IHRoaXMuXyxcbiAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXG4gICAgICAgIHQsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IFQubGVuZ3RoO1xuXG4gICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHRoZSBjYWxsYmFjayBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSAmJiAodCA9IGdldChfW3RdLCB0eXBlbmFtZS5uYW1lKSkpIHJldHVybiB0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGEgdHlwZSB3YXMgc3BlY2lmaWVkLCBzZXQgdGhlIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29weSA9IHt9LCBfID0gdGhpcy5fO1xuICAgIGZvciAodmFyIHQgaW4gXykgY29weVt0XSA9IF9bdF0uc2xpY2UoKTtcbiAgICByZXR1cm4gbmV3IERpc3BhdGNoKGNvcHkpO1xuICB9LFxuICBjYWxsOiBmdW5jdGlvbih0eXBlLCB0aGF0KSB7XG4gICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24odHlwZSwgdGhhdCwgYXJncykge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh2YXIgdCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0KHR5cGUsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aCwgYzsgaSA8IG47ICsraSkge1xuICAgIGlmICgoYyA9IHR5cGVbaV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQodHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICh0eXBlW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHR5cGVbaV0gPSBub29wLCB0eXBlID0gdHlwZS5zbGljZSgwLCBpKS5jb25jYXQodHlwZS5zbGljZShpICsgMSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB0eXBlLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiBjYWxsYmFja30pO1xuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGlzcGF0Y2g7XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgZGlzcGF0Y2h9IGZyb20gXCIuL2Rpc3BhdGNoLmpzXCI7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHtldmVudCwgY3VzdG9tRXZlbnQsIHNlbGVjdCwgbW91c2UsIHRvdWNofSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgbm9kcmFnLCB7eWVzZHJhZ30gZnJvbSBcIi4vbm9kcmFnLmpzXCI7XG5pbXBvcnQgbm9ldmVudCwge25vcHJvcGFnYXRpb259IGZyb20gXCIuL25vZXZlbnQuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IERyYWdFdmVudCBmcm9tIFwiLi9ldmVudC5qc1wiO1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoKSB7XG4gIHJldHVybiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYnV0dG9uO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udGFpbmVyKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U3ViamVjdChkKSB7XG4gIHJldHVybiBkID09IG51bGwgPyB7eDogZXZlbnQueCwgeTogZXZlbnQueX0gOiBkO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VG91Y2hhYmxlKCkge1xuICByZXR1cm4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IChcIm9udG91Y2hzdGFydFwiIGluIHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICBjb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyLFxuICAgICAgc3ViamVjdCA9IGRlZmF1bHRTdWJqZWN0LFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIGdlc3R1cmVzID0ge30sXG4gICAgICBsaXN0ZW5lcnMgPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiZHJhZ1wiLCBcImVuZFwiKSxcbiAgICAgIGFjdGl2ZSA9IDAsXG4gICAgICBtb3VzZWRvd254LFxuICAgICAgbW91c2Vkb3dueSxcbiAgICAgIG1vdXNlbW92aW5nLFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDA7XG5cbiAgZnVuY3Rpb24gZHJhZyhzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLm9uKFwibW91c2Vkb3duLmRyYWdcIiwgbW91c2Vkb3duZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLmRyYWdcIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuZHJhZyB0b3VjaGNhbmNlbC5kcmFnXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKCkge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZ2VzdHVyZSA9IGJlZm9yZXN0YXJ0KFwibW91c2VcIiwgY29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIG1vdXNlLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghZ2VzdHVyZSkgcmV0dXJuO1xuICAgIHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC5kcmFnXCIsIG1vdXNldXBwZWQsIHRydWUpO1xuICAgIG5vZHJhZyhldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgbW91c2Vtb3ZpbmcgPSBmYWxzZTtcbiAgICBtb3VzZWRvd254ID0gZXZlbnQuY2xpZW50WDtcbiAgICBtb3VzZWRvd255ID0gZXZlbnQuY2xpZW50WTtcbiAgICBnZXN0dXJlKFwic3RhcnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZW1vdmVkKCkge1xuICAgIG5vZXZlbnQoKTtcbiAgICBpZiAoIW1vdXNlbW92aW5nKSB7XG4gICAgICB2YXIgZHggPSBldmVudC5jbGllbnRYIC0gbW91c2Vkb3dueCwgZHkgPSBldmVudC5jbGllbnRZIC0gbW91c2Vkb3dueTtcbiAgICAgIG1vdXNlbW92aW5nID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICB9XG4gICAgZ2VzdHVyZXMubW91c2UoXCJkcmFnXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V1cHBlZCgpIHtcbiAgICBzZWxlY3QoZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuZHJhZyBtb3VzZXVwLmRyYWdcIiwgbnVsbCk7XG4gICAgeWVzZHJhZyhldmVudC52aWV3LCBtb3VzZW1vdmluZyk7XG4gICAgbm9ldmVudCgpO1xuICAgIGdlc3R1cmVzLm1vdXNlKFwiZW5kXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBjID0gY29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gYmVmb3Jlc3RhcnQodG91Y2hlc1tpXS5pZGVudGlmaWVyLCBjLCB0b3VjaCwgdGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKCkge1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBub2V2ZW50KCk7XG4gICAgICAgIGdlc3R1cmUoXCJkcmFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoKSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCA1MDApOyAvLyBHaG9zdCBjbGlja3MgYXJlIGRlbGF5ZWQhXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICAgICAgZ2VzdHVyZShcImVuZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZWZvcmVzdGFydChpZCwgY29udGFpbmVyLCBwb2ludCwgdGhhdCwgYXJncykge1xuICAgIHZhciBwID0gcG9pbnQoY29udGFpbmVyLCBpZCksIHMsIGR4LCBkeSxcbiAgICAgICAgc3VibGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvcHkoKTtcblxuICAgIGlmICghY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCBcImJlZm9yZXN0YXJ0XCIsIHMsIGlkLCBhY3RpdmUsIHBbMF0sIHBbMV0sIDAsIDAsIHN1Ymxpc3RlbmVycyksIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKChldmVudC5zdWJqZWN0ID0gcyA9IHN1YmplY3QuYXBwbHkodGhhdCwgYXJncykpID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIGR4ID0gcy54IC0gcFswXSB8fCAwO1xuICAgICAgZHkgPSBzLnkgLSBwWzFdIHx8IDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KSkgcmV0dXJuO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdlc3R1cmUodHlwZSkge1xuICAgICAgdmFyIHAwID0gcCwgbjtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RhcnRcIjogZ2VzdHVyZXNbaWRdID0gZ2VzdHVyZSwgbiA9IGFjdGl2ZSsrOyBicmVhaztcbiAgICAgICAgY2FzZSBcImVuZFwiOiBkZWxldGUgZ2VzdHVyZXNbaWRdLCAtLWFjdGl2ZTsgLy8gbm9icmVha1xuICAgICAgICBjYXNlIFwiZHJhZ1wiOiBwID0gcG9pbnQoY29udGFpbmVyLCBpZCksIG4gPSBhY3RpdmU7IGJyZWFrO1xuICAgICAgfVxuICAgICAgY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCB0eXBlLCBzLCBpZCwgbiwgcFswXSArIGR4LCBwWzFdICsgZHksIHBbMF0gLSBwMFswXSwgcFsxXSAtIHAwWzFdLCBzdWJsaXN0ZW5lcnMpLCBzdWJsaXN0ZW5lcnMuYXBwbHksIHN1Ymxpc3RlbmVycywgW3R5cGUsIHRoYXQsIGFyZ3NdKTtcbiAgICB9O1xuICB9XG5cbiAgZHJhZy5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBkcmFnKSA6IGZpbHRlcjtcbiAgfTtcblxuICBkcmFnLmNvbnRhaW5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250YWluZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBkcmFnKSA6IGNvbnRhaW5lcjtcbiAgfTtcblxuICBkcmFnLnN1YmplY3QgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3ViamVjdCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogc3ViamVjdDtcbiAgfTtcblxuICBkcmFnLnRvdWNoYWJsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0b3VjaGFibGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIGRyYWcub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gZHJhZyA6IHZhbHVlO1xuICB9O1xuXG4gIGRyYWcuY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgZHJhZykgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHJldHVybiBkcmFnO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRHJhZ0V2ZW50KHRhcmdldCwgdHlwZSwgc3ViamVjdCwgaWQsIGFjdGl2ZSwgeCwgeSwgZHgsIGR5LCBkaXNwYXRjaCkge1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgdGhpcy5pZGVudGlmaWVyID0gaWQ7XG4gIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLmR4ID0gZHg7XG4gIHRoaXMuZHkgPSBkeTtcbiAgdGhpcy5fID0gZGlzcGF0Y2g7XG59XG5cbkRyYWdFdmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy5fLm9uLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHZhbHVlID09PSB0aGlzLl8gPyB0aGlzIDogdmFsdWU7XG59O1xuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGRyYWd9IGZyb20gXCIuL2RyYWcuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkcmFnRGlzYWJsZSwgeWVzZHJhZyBhcyBkcmFnRW5hYmxlfSBmcm9tIFwiLi9ub2RyYWcuanNcIjtcbiIsImltcG9ydCB7c2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgbm9ldmVudCBmcm9tIFwiLi9ub2V2ZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZpZXcpIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG5vZXZlbnQsIHRydWUpO1xuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fX25vc2VsZWN0ID0gcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0O1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IFwibm9uZVwiO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5ZXNkcmFnKHZpZXcsIG5vY2xpY2spIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG51bGwpO1xuICBpZiAobm9jbGljaykge1xuICAgIHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBudWxsKTsgfSwgMCk7XG4gIH1cbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IHJvb3QuX19ub3NlbGVjdDtcbiAgICBkZWxldGUgcm9vdC5fX25vc2VsZWN0O1xuICB9XG59XG4iLCJpbXBvcnQge2V2ZW50fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3Byb3BhZ2F0aW9uKCkge1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b1R5cGUob2JqZWN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XS50cmltKCksIG51bWJlciwgbTtcbiAgICBpZiAoIXZhbHVlKSB2YWx1ZSA9IG51bGw7XG4gICAgZWxzZSBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB2YWx1ZSA9IHRydWU7XG4gICAgZWxzZSBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikgdmFsdWUgPSBmYWxzZTtcbiAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJOYU5cIikgdmFsdWUgPSBOYU47XG4gICAgZWxzZSBpZiAoIWlzTmFOKG51bWJlciA9ICt2YWx1ZSkpIHZhbHVlID0gbnVtYmVyO1xuICAgIGVsc2UgaWYgKG0gPSB2YWx1ZS5tYXRjaCgvXihbLStdXFxkezJ9KT9cXGR7NH0oLVxcZHsyfSgtXFxkezJ9KT8pPyhUXFxkezJ9OlxcZHsyfSg6XFxkezJ9KFxcLlxcZHszfSk/KT8oWnxbLStdXFxkezJ9OlxcZHsyfSk/KT8kLykpIHtcbiAgICAgIGlmIChmaXh0eiAmJiAhIW1bNF0gJiYgIW1bN10pIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvLS9nLCBcIi9cIikucmVwbGFjZSgvVC8sIFwiIFwiKTtcbiAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGNvbnRpbnVlO1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWRzdi9pc3N1ZXMvNDVcbnZhciBmaXh0eiA9IG5ldyBEYXRlKFwiMjAxOS0wMS0wMVQwMDowMFwiKS5nZXRIb3VycygpIHx8IG5ldyBEYXRlKFwiMjAxOS0wNy0wMVQwMDowMFwiKS5nZXRIb3VycygpOyIsImltcG9ydCBkc3YgZnJvbSBcIi4vZHN2LmpzXCI7XG5cbnZhciBjc3YgPSBkc3YoXCIsXCIpO1xuXG5leHBvcnQgdmFyIGNzdlBhcnNlID0gY3N2LnBhcnNlO1xuZXhwb3J0IHZhciBjc3ZQYXJzZVJvd3MgPSBjc3YucGFyc2VSb3dzO1xuZXhwb3J0IHZhciBjc3ZGb3JtYXQgPSBjc3YuZm9ybWF0O1xuZXhwb3J0IHZhciBjc3ZGb3JtYXRCb2R5ID0gY3N2LmZvcm1hdEJvZHk7XG5leHBvcnQgdmFyIGNzdkZvcm1hdFJvd3MgPSBjc3YuZm9ybWF0Um93cztcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0Um93ID0gY3N2LmZvcm1hdFJvdztcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0VmFsdWUgPSBjc3YuZm9ybWF0VmFsdWU7XG4iLCJ2YXIgRU9MID0ge30sXG4gICAgRU9GID0ge30sXG4gICAgUVVPVEUgPSAzNCxcbiAgICBORVdMSU5FID0gMTAsXG4gICAgUkVUVVJOID0gMTM7XG5cbmZ1bmN0aW9uIG9iamVjdENvbnZlcnRlcihjb2x1bW5zKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIGNvbHVtbnMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmFtZSkgKyBcIjogZFtcIiArIGkgKyBcIl0gfHwgXFxcIlxcXCJcIjtcbiAgfSkuam9pbihcIixcIikgKyBcIn1cIik7XG59XG5cbmZ1bmN0aW9uIGN1c3RvbUNvbnZlcnRlcihjb2x1bW5zLCBmKSB7XG4gIHZhciBvYmplY3QgPSBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucyk7XG4gIHJldHVybiBmdW5jdGlvbihyb3csIGkpIHtcbiAgICByZXR1cm4gZihvYmplY3Qocm93KSwgaSwgY29sdW1ucyk7XG4gIH07XG59XG5cbi8vIENvbXB1dGUgdW5pcXVlIGNvbHVtbnMgaW4gb3JkZXIgb2YgZGlzY292ZXJ5LlxuZnVuY3Rpb24gaW5mZXJDb2x1bW5zKHJvd3MpIHtcbiAgdmFyIGNvbHVtblNldCA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBjb2x1bW5zID0gW107XG5cbiAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgIGZvciAodmFyIGNvbHVtbiBpbiByb3cpIHtcbiAgICAgIGlmICghKGNvbHVtbiBpbiBjb2x1bW5TZXQpKSB7XG4gICAgICAgIGNvbHVtbnMucHVzaChjb2x1bW5TZXRbY29sdW1uXSA9IGNvbHVtbik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29sdW1ucztcbn1cblxuZnVuY3Rpb24gcGFkKHZhbHVlLCB3aWR0aCkge1xuICB2YXIgcyA9IHZhbHVlICsgXCJcIiwgbGVuZ3RoID0gcy5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oMCkgKyBzIDogcztcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyIDwgMCA/IFwiLVwiICsgcGFkKC15ZWFyLCA2KVxuICAgIDogeWVhciA+IDk5OTkgPyBcIitcIiArIHBhZCh5ZWFyLCA2KVxuICAgIDogcGFkKHllYXIsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpLFxuICAgICAgbWludXRlcyA9IGRhdGUuZ2V0VVRDTWludXRlcygpLFxuICAgICAgc2Vjb25kcyA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgcmV0dXJuIGlzTmFOKGRhdGUpID8gXCJJbnZhbGlkIERhdGVcIlxuICAgICAgOiBmb3JtYXRZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgNCkgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDRGF0ZSgpLCAyKVxuICAgICAgKyAobWlsbGlzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiLlwiICsgcGFkKG1pbGxpc2Vjb25kcywgMykgKyBcIlpcIlxuICAgICAgOiBzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiWlwiXG4gICAgICA6IG1pbnV0ZXMgfHwgaG91cnMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiWlwiXG4gICAgICA6IFwiXCIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWxpbWl0ZXIpIHtcbiAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cChcIltcXFwiXCIgKyBkZWxpbWl0ZXIgKyBcIlxcblxccl1cIiksXG4gICAgICBERUxJTUlURVIgPSBkZWxpbWl0ZXIuY2hhckNvZGVBdCgwKTtcblxuICBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmKSB7XG4gICAgdmFyIGNvbnZlcnQsIGNvbHVtbnMsIHJvd3MgPSBwYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICBpZiAoY29udmVydCkgcmV0dXJuIGNvbnZlcnQocm93LCBpIC0gMSk7XG4gICAgICBjb2x1bW5zID0gcm93LCBjb252ZXJ0ID0gZiA/IGN1c3RvbUNvbnZlcnRlcihyb3csIGYpIDogb2JqZWN0Q29udmVydGVyKHJvdyk7XG4gICAgfSk7XG4gICAgcm93cy5jb2x1bW5zID0gY29sdW1ucyB8fCBbXTtcbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUm93cyh0ZXh0LCBmKSB7XG4gICAgdmFyIHJvd3MgPSBbXSwgLy8gb3V0cHV0IHJvd3NcbiAgICAgICAgTiA9IHRleHQubGVuZ3RoLFxuICAgICAgICBJID0gMCwgLy8gY3VycmVudCBjaGFyYWN0ZXIgaW5kZXhcbiAgICAgICAgbiA9IDAsIC8vIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgdCwgLy8gY3VycmVudCB0b2tlblxuICAgICAgICBlb2YgPSBOIDw9IDAsIC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9GP1xuICAgICAgICBlb2wgPSBmYWxzZTsgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0w/XG5cbiAgICAvLyBTdHJpcCB0aGUgdHJhaWxpbmcgbmV3bGluZS5cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gTkVXTElORSkgLS1OO1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBSRVRVUk4pIC0tTjtcblxuICAgIGZ1bmN0aW9uIHRva2VuKCkge1xuICAgICAgaWYgKGVvZikgcmV0dXJuIEVPRjtcbiAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xuXG4gICAgICAvLyBVbmVzY2FwZSBxdW90ZXMuXG4gICAgICB2YXIgaSwgaiA9IEksIGM7XG4gICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGopID09PSBRVU9URSkge1xuICAgICAgICB3aGlsZSAoSSsrIDwgTiAmJiB0ZXh0LmNoYXJDb2RlQXQoSSkgIT09IFFVT1RFIHx8IHRleHQuY2hhckNvZGVBdCgrK0kpID09PSBRVU9URSk7XG4gICAgICAgIGlmICgoaSA9IEkpID49IE4pIGVvZiA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpIC0gMSkucmVwbGFjZSgvXCJcIi9nLCBcIlxcXCJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgbmV4dCBkZWxpbWl0ZXIgb3IgbmV3bGluZS5cbiAgICAgIHdoaWxlIChJIDwgTikge1xuICAgICAgICBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSA9IEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IERFTElNSVRFUikgY29udGludWU7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGosIGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gbGFzdCB0b2tlbiBiZWZvcmUgRU9GLlxuICAgICAgcmV0dXJuIGVvZiA9IHRydWUsIHRleHQuc2xpY2UoaiwgTik7XG4gICAgfVxuXG4gICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xuICAgICAgdmFyIHJvdyA9IFtdO1xuICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpIHJvdy5wdXNoKHQpLCB0ID0gdG9rZW4oKTtcbiAgICAgIGlmIChmICYmIChyb3cgPSBmKHJvdywgbisrKSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICByb3dzLnB1c2gocm93KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiByb3dzLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHJvd1tjb2x1bW5dKTtcbiAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdChyb3dzLCBjb2x1bW5zKSB7XG4gICAgaWYgKGNvbHVtbnMgPT0gbnVsbCkgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICByZXR1cm4gW2NvbHVtbnMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcildLmNvbmNhdChwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSB7XG4gICAgaWYgKGNvbHVtbnMgPT0gbnVsbCkgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICByZXR1cm4gcHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93cyhyb3dzKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKGZvcm1hdFJvdykuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvdyhyb3cpIHtcbiAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCJcbiAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBmb3JtYXREYXRlKHZhbHVlKVxuICAgICAgICA6IHJlRm9ybWF0LnRlc3QodmFsdWUgKz0gXCJcIikgPyBcIlxcXCJcIiArIHZhbHVlLnJlcGxhY2UoL1wiL2csIFwiXFxcIlxcXCJcIikgKyBcIlxcXCJcIlxuICAgICAgICA6IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgcGFyc2VSb3dzOiBwYXJzZVJvd3MsXG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgZm9ybWF0Qm9keTogZm9ybWF0Qm9keSxcbiAgICBmb3JtYXRSb3dzOiBmb3JtYXRSb3dzLFxuICAgIGZvcm1hdFJvdzogZm9ybWF0Um93LFxuICAgIGZvcm1hdFZhbHVlOiBmb3JtYXRWYWx1ZVxuICB9O1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGRzdkZvcm1hdH0gZnJvbSBcIi4vZHN2LmpzXCI7XG5leHBvcnQge2NzdlBhcnNlLCBjc3ZQYXJzZVJvd3MsIGNzdkZvcm1hdCwgY3N2Rm9ybWF0Qm9keSwgY3N2Rm9ybWF0Um93cywgY3N2Rm9ybWF0Um93LCBjc3ZGb3JtYXRWYWx1ZX0gZnJvbSBcIi4vY3N2LmpzXCI7XG5leHBvcnQge3RzdlBhcnNlLCB0c3ZQYXJzZVJvd3MsIHRzdkZvcm1hdCwgdHN2Rm9ybWF0Qm9keSwgdHN2Rm9ybWF0Um93cywgdHN2Rm9ybWF0Um93LCB0c3ZGb3JtYXRWYWx1ZX0gZnJvbSBcIi4vdHN2LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYXV0b1R5cGV9IGZyb20gXCIuL2F1dG9UeXBlLmpzXCI7XG4iLCJpbXBvcnQgZHN2IGZyb20gXCIuL2Rzdi5qc1wiO1xuXG52YXIgdHN2ID0gZHN2KFwiXFx0XCIpO1xuXG5leHBvcnQgdmFyIHRzdlBhcnNlID0gdHN2LnBhcnNlO1xuZXhwb3J0IHZhciB0c3ZQYXJzZVJvd3MgPSB0c3YucGFyc2VSb3dzO1xuZXhwb3J0IHZhciB0c3ZGb3JtYXQgPSB0c3YuZm9ybWF0O1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRCb2R5ID0gdHN2LmZvcm1hdEJvZHk7XG5leHBvcnQgdmFyIHRzdkZvcm1hdFJvd3MgPSB0c3YuZm9ybWF0Um93cztcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0Um93ID0gdHN2LmZvcm1hdFJvdztcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0VmFsdWUgPSB0c3YuZm9ybWF0VmFsdWU7XG4iLCJ2YXIgb3ZlcnNob290ID0gMS43MDE1ODtcblxuZXhwb3J0IHZhciBiYWNrSW4gPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH1cblxuICBiYWNrSW4ub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW47XG59KShvdmVyc2hvb3QpO1xuXG5leHBvcnQgdmFyIGJhY2tPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tPdXQodCkge1xuICAgIHJldHVybiAtLXQgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuICB9XG5cbiAgYmFja091dC5vdmVyc2hvb3QgPSBjdXN0b207XG5cbiAgcmV0dXJuIGJhY2tPdXQ7XG59KShvdmVyc2hvb3QpO1xuXG5leHBvcnQgdmFyIGJhY2tJbk91dCA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja0luT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ICo9IDIpIDwgMSA/IHQgKiB0ICogKChzICsgMSkgKiB0IC0gcykgOiAodCAtPSAyKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDIpIC8gMjtcbiAgfVxuXG4gIGJhY2tJbk91dC5vdmVyc2hvb3QgPSBjdXN0b207XG5cbiAgcmV0dXJuIGJhY2tJbk91dDtcbn0pKG92ZXJzaG9vdCk7XG4iLCJ2YXIgYjEgPSA0IC8gMTEsXG4gICAgYjIgPSA2IC8gMTEsXG4gICAgYjMgPSA4IC8gMTEsXG4gICAgYjQgPSAzIC8gNCxcbiAgICBiNSA9IDkgLyAxMSxcbiAgICBiNiA9IDEwIC8gMTEsXG4gICAgYjcgPSAxNSAvIDE2LFxuICAgIGI4ID0gMjEgLyAyMixcbiAgICBiOSA9IDYzIC8gNjQsXG4gICAgYjAgPSAxIC8gYjEgLyBiMTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcbiAgcmV0dXJuIDEgLSBib3VuY2VPdXQoMSAtIHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcbiAgcmV0dXJuICh0ID0gK3QpIDwgYjEgPyBiMCAqIHQgKiB0IDogdCA8IGIzID8gYjAgKiAodCAtPSBiMikgKiB0ICsgYjQgOiB0IDwgYjYgPyBiMCAqICh0IC09IGI1KSAqIHQgKyBiNyA6IGIwICogKHQgLT0gYjgpICogdCArIGI5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyAxIC0gYm91bmNlT3V0KDEgLSB0KSA6IGJvdW5jZU91dCh0IC0gMSkgKyAxKSAvIDI7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gY2lyY2xlSW4odCkge1xuICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlT3V0KHQpIHtcbiAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS10ICogdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KSA6IE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpIC8gMjtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCAqIHQgOiAodCAtPSAyKSAqIHQgKiB0ICsgMikgLyAyO1xufVxuIiwidmFyIHRhdSA9IDIgKiBNYXRoLlBJLFxuICAgIGFtcGxpdHVkZSA9IDEsXG4gICAgcGVyaW9kID0gMC4zO1xuXG5leHBvcnQgdmFyIGVsYXN0aWNJbiA9IChmdW5jdGlvbiBjdXN0b20oYSwgcCkge1xuICB2YXIgcyA9IE1hdGguYXNpbigxIC8gKGEgPSBNYXRoLm1heCgxLCBhKSkpICogKHAgLz0gdGF1KTtcblxuICBmdW5jdGlvbiBlbGFzdGljSW4odCkge1xuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgMTAgKiAtLXQpICogTWF0aC5zaW4oKHMgLSB0KSAvIHApO1xuICB9XG5cbiAgZWxhc3RpY0luLmFtcGxpdHVkZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGN1c3RvbShhLCBwICogdGF1KTsgfTtcbiAgZWxhc3RpY0luLnBlcmlvZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIGN1c3RvbShhLCBwKTsgfTtcblxuICByZXR1cm4gZWxhc3RpY0luO1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG5leHBvcnQgdmFyIGVsYXN0aWNPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG4gICAgcmV0dXJuIDEgLSBhICogTWF0aC5wb3coMiwgLTEwICogKHQgPSArdCkpICogTWF0aC5zaW4oKHQgKyBzKSAvIHApO1xuICB9XG5cbiAgZWxhc3RpY091dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNPdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljT3V0O1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG5leHBvcnQgdmFyIGVsYXN0aWNJbk91dCA9IChmdW5jdGlvbiBjdXN0b20oYSwgcCkge1xuICB2YXIgcyA9IE1hdGguYXNpbigxIC8gKGEgPSBNYXRoLm1heCgxLCBhKSkpICogKHAgLz0gdGF1KTtcblxuICBmdW5jdGlvbiBlbGFzdGljSW5PdXQodCkge1xuICAgIHJldHVybiAoKHQgPSB0ICogMiAtIDEpIDwgMFxuICAgICAgICA/IGEgKiBNYXRoLnBvdygyLCAxMCAqIHQpICogTWF0aC5zaW4oKHMgLSB0KSAvIHApXG4gICAgICAgIDogMiAtIGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKChzICsgdCkgLyBwKSkgLyAyO1xuICB9XG5cbiAgZWxhc3RpY0luT3V0LmFtcGxpdHVkZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGN1c3RvbShhLCBwICogdGF1KTsgfTtcbiAgZWxhc3RpY0luT3V0LnBlcmlvZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIGN1c3RvbShhLCBwKTsgfTtcblxuICByZXR1cm4gZWxhc3RpY0luT3V0O1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGV4cEluKHQpIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIDEwICogdCAtIDEwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cE91dCh0KSB7XG4gIHJldHVybiAxIC0gTWF0aC5wb3coMiwgLTEwICogdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IE1hdGgucG93KDIsIDEwICogdCAtIDEwKSA6IDIgLSBNYXRoLnBvdygyLCAxMCAtIDEwICogdCkpIC8gMjtcbn1cbiIsImV4cG9ydCB7XG4gIGxpbmVhciBhcyBlYXNlTGluZWFyXG59IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuXG5leHBvcnQge1xuICBxdWFkSW5PdXQgYXMgZWFzZVF1YWQsXG4gIHF1YWRJbiBhcyBlYXNlUXVhZEluLFxuICBxdWFkT3V0IGFzIGVhc2VRdWFkT3V0LFxuICBxdWFkSW5PdXQgYXMgZWFzZVF1YWRJbk91dFxufSBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGN1YmljSW5PdXQgYXMgZWFzZUN1YmljLFxuICBjdWJpY0luIGFzIGVhc2VDdWJpY0luLFxuICBjdWJpY091dCBhcyBlYXNlQ3ViaWNPdXQsXG4gIGN1YmljSW5PdXQgYXMgZWFzZUN1YmljSW5PdXRcbn0gZnJvbSBcIi4vY3ViaWMuanNcIjtcblxuZXhwb3J0IHtcbiAgcG9seUluT3V0IGFzIGVhc2VQb2x5LFxuICBwb2x5SW4gYXMgZWFzZVBvbHlJbixcbiAgcG9seU91dCBhcyBlYXNlUG9seU91dCxcbiAgcG9seUluT3V0IGFzIGVhc2VQb2x5SW5PdXRcbn0gZnJvbSBcIi4vcG9seS5qc1wiO1xuXG5leHBvcnQge1xuICBzaW5Jbk91dCBhcyBlYXNlU2luLFxuICBzaW5JbiBhcyBlYXNlU2luSW4sXG4gIHNpbk91dCBhcyBlYXNlU2luT3V0LFxuICBzaW5Jbk91dCBhcyBlYXNlU2luSW5PdXRcbn0gZnJvbSBcIi4vc2luLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGV4cEluT3V0IGFzIGVhc2VFeHAsXG4gIGV4cEluIGFzIGVhc2VFeHBJbixcbiAgZXhwT3V0IGFzIGVhc2VFeHBPdXQsXG4gIGV4cEluT3V0IGFzIGVhc2VFeHBJbk91dFxufSBmcm9tIFwiLi9leHAuanNcIjtcblxuZXhwb3J0IHtcbiAgY2lyY2xlSW5PdXQgYXMgZWFzZUNpcmNsZSxcbiAgY2lyY2xlSW4gYXMgZWFzZUNpcmNsZUluLFxuICBjaXJjbGVPdXQgYXMgZWFzZUNpcmNsZU91dCxcbiAgY2lyY2xlSW5PdXQgYXMgZWFzZUNpcmNsZUluT3V0XG59IGZyb20gXCIuL2NpcmNsZS5qc1wiO1xuXG5leHBvcnQge1xuICBib3VuY2VPdXQgYXMgZWFzZUJvdW5jZSxcbiAgYm91bmNlSW4gYXMgZWFzZUJvdW5jZUluLFxuICBib3VuY2VPdXQgYXMgZWFzZUJvdW5jZU91dCxcbiAgYm91bmNlSW5PdXQgYXMgZWFzZUJvdW5jZUluT3V0XG59IGZyb20gXCIuL2JvdW5jZS5qc1wiO1xuXG5leHBvcnQge1xuICBiYWNrSW5PdXQgYXMgZWFzZUJhY2ssXG4gIGJhY2tJbiBhcyBlYXNlQmFja0luLFxuICBiYWNrT3V0IGFzIGVhc2VCYWNrT3V0LFxuICBiYWNrSW5PdXQgYXMgZWFzZUJhY2tJbk91dFxufSBmcm9tIFwiLi9iYWNrLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGVsYXN0aWNPdXQgYXMgZWFzZUVsYXN0aWMsXG4gIGVsYXN0aWNJbiBhcyBlYXNlRWxhc3RpY0luLFxuICBlbGFzdGljT3V0IGFzIGVhc2VFbGFzdGljT3V0LFxuICBlbGFzdGljSW5PdXQgYXMgZWFzZUVsYXN0aWNJbk91dFxufSBmcm9tIFwiLi9lbGFzdGljLmpzXCI7XG4iLCJleHBvcnQgZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgcmV0dXJuICt0O1xufVxuIiwidmFyIGV4cG9uZW50ID0gMztcblxuZXhwb3J0IHZhciBwb2x5SW4gPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQsIGUpO1xuICB9XG5cbiAgcG9seUluLmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5SW47XG59KShleHBvbmVudCk7XG5cbmV4cG9ydCB2YXIgcG9seU91dCA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seU91dCh0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgZSk7XG4gIH1cblxuICBwb2x5T3V0LmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5T3V0O1xufSkoZXhwb25lbnQpO1xuXG5leHBvcnQgdmFyIHBvbHlJbk91dCA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seUluT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyBNYXRoLnBvdyh0LCBlKSA6IDIgLSBNYXRoLnBvdygyIC0gdCwgZSkpIC8gMjtcbiAgfVxuXG4gIHBvbHlJbk91dC5leHBvbmVudCA9IGN1c3RvbTtcblxuICByZXR1cm4gcG9seUluT3V0O1xufSkoZXhwb25lbnQpO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIHF1YWRJbih0KSB7XG4gIHJldHVybiB0ICogdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1YWRPdXQodCkge1xuICByZXR1cm4gdCAqICgyIC0gdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFkSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCA6IC0tdCAqICgyIC0gdCkgKyAxKSAvIDI7XG59XG4iLCJ2YXIgcGkgPSBNYXRoLlBJLFxuICAgIGhhbGZQaSA9IHBpIC8gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNpbkluKHQpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogaGFsZlBpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbk91dCh0KSB7XG4gIHJldHVybiBNYXRoLnNpbih0ICogaGFsZlBpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbkluT3V0KHQpIHtcbiAgcmV0dXJuICgxIC0gTWF0aC5jb3MocGkgKiB0KSkgLyAyO1xufVxuIiwiaW1wb3J0IGZvcm1hdExvY2FsZSBmcm9tIFwiLi9sb2NhbGUuanNcIjtcblxudmFyIGxvY2FsZTtcbmV4cG9ydCB2YXIgZm9ybWF0O1xuZXhwb3J0IHZhciBmb3JtYXRQcmVmaXg7XG5cbmRlZmF1bHRMb2NhbGUoe1xuICBkZWNpbWFsOiBcIi5cIixcbiAgdGhvdXNhbmRzOiBcIixcIixcbiAgZ3JvdXBpbmc6IFszXSxcbiAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl0sXG4gIG1pbnVzOiBcIi1cIlxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gIGZvcm1hdFByZWZpeCA9IGxvY2FsZS5mb3JtYXRQcmVmaXg7XG4gIHJldHVybiBsb2NhbGU7XG59XG4iLCJpbXBvcnQgZm9ybWF0RGVjaW1hbCBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPSBmb3JtYXREZWNpbWFsKE1hdGguYWJzKHgpKSwgeCA/IHhbMV0gOiBOYU47XG59XG4iLCIvLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4vLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbi8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsKDEuMjMpIHJldHVybnMgW1wiMTIzXCIsIDBdLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgcCkge1xuICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gIHJldHVybiBbXG4gICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAreC5zbGljZShpICsgMSlcbiAgXTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGdyb3VwaW5nLCB0aG91c2FuZHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCB3aWR0aCkge1xuICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICB0ID0gW10sXG4gICAgICAgIGogPSAwLFxuICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXG4gICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XG4gICAgICBnID0gZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBncm91cGluZy5sZW5ndGhdO1xuICAgIH1cblxuICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKHRob3VzYW5kcyk7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihudW1lcmFscykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWzAtOV0vZywgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIG51bWVyYWxzWytpXTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsImltcG9ydCBmb3JtYXREZWNpbWFsIGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IHZhciBwcmVmaXhFeHBvbmVudDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgcCkge1xuICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdLFxuICAgICAgaSA9IGV4cG9uZW50IC0gKHByZWZpeEV4cG9uZW50ID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQgLyAzKSkpICogMykgKyAxLFxuICAgICAgbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcbiAgcmV0dXJuIGkgPT09IG4gPyBjb2VmZmljaWVudFxuICAgICAgOiBpID4gbiA/IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGkgLSBuICsgMSkuam9pbihcIjBcIilcbiAgICAgIDogaSA+IDAgPyBjb2VmZmljaWVudC5zbGljZSgwLCBpKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoaSlcbiAgICAgIDogXCIwLlwiICsgbmV3IEFycmF5KDEgLSBpKS5qb2luKFwiMFwiKSArIGZvcm1hdERlY2ltYWwoeCwgTWF0aC5tYXgoMCwgcCArIGkgLSAxKSlbMF07IC8vIGxlc3MgdGhhbiAxeSFcbn1cbiIsImltcG9ydCBmb3JtYXREZWNpbWFsIGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgcCkge1xuICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICByZXR1cm4gZXhwb25lbnQgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1leHBvbmVudCkuam9pbihcIjBcIikgKyBjb2VmZmljaWVudFxuICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG59XG4iLCIvLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW35dW3R5cGVdXG52YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyh+KT8oW2EteiVdKT8kL2k7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgaWYgKCEobWF0Y2ggPSByZS5leGVjKHNwZWNpZmllcikpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBzcGVjaWZpZXIpO1xuICB2YXIgbWF0Y2g7XG4gIHJldHVybiBuZXcgRm9ybWF0U3BlY2lmaWVyKHtcbiAgICBmaWxsOiBtYXRjaFsxXSxcbiAgICBhbGlnbjogbWF0Y2hbMl0sXG4gICAgc2lnbjogbWF0Y2hbM10sXG4gICAgc3ltYm9sOiBtYXRjaFs0XSxcbiAgICB6ZXJvOiBtYXRjaFs1XSxcbiAgICB3aWR0aDogbWF0Y2hbNl0sXG4gICAgY29tbWE6IG1hdGNoWzddLFxuICAgIHByZWNpc2lvbjogbWF0Y2hbOF0gJiYgbWF0Y2hbOF0uc2xpY2UoMSksXG4gICAgdHJpbTogbWF0Y2hbOV0sXG4gICAgdHlwZTogbWF0Y2hbMTBdXG4gIH0pO1xufVxuXG5mb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlID0gRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZTsgLy8gaW5zdGFuY2VvZlxuXG5leHBvcnQgZnVuY3Rpb24gRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICB0aGlzLmZpbGwgPSBzcGVjaWZpZXIuZmlsbCA9PT0gdW5kZWZpbmVkID8gXCIgXCIgOiBzcGVjaWZpZXIuZmlsbCArIFwiXCI7XG4gIHRoaXMuYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24gPT09IHVuZGVmaW5lZCA/IFwiPlwiIDogc3BlY2lmaWVyLmFsaWduICsgXCJcIjtcbiAgdGhpcy5zaWduID0gc3BlY2lmaWVyLnNpZ24gPT09IHVuZGVmaW5lZCA/IFwiLVwiIDogc3BlY2lmaWVyLnNpZ24gKyBcIlwiO1xuICB0aGlzLnN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBzcGVjaWZpZXIuc3ltYm9sICsgXCJcIjtcbiAgdGhpcy56ZXJvID0gISFzcGVjaWZpZXIuemVybztcbiAgdGhpcy53aWR0aCA9IHNwZWNpZmllci53aWR0aCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogK3NwZWNpZmllci53aWR0aDtcbiAgdGhpcy5jb21tYSA9ICEhc3BlY2lmaWVyLmNvbW1hO1xuICB0aGlzLnByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICtzcGVjaWZpZXIucHJlY2lzaW9uO1xuICB0aGlzLnRyaW0gPSAhIXNwZWNpZmllci50cmltO1xuICB0aGlzLnR5cGUgPSBzcGVjaWZpZXIudHlwZSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHNwZWNpZmllci50eXBlICsgXCJcIjtcbn1cblxuRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWxsXG4gICAgICArIHRoaXMuYWxpZ25cbiAgICAgICsgdGhpcy5zaWduXG4gICAgICArIHRoaXMuc3ltYm9sXG4gICAgICArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKVxuICAgICAgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMucHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCB0aGlzLnByZWNpc2lvbiB8IDApKVxuICAgICAgKyAodGhpcy50cmltID8gXCJ+XCIgOiBcIlwiKVxuICAgICAgKyB0aGlzLnR5cGU7XG59O1xuIiwiLy8gVHJpbXMgaW5zaWduaWZpY2FudCB6ZXJvcywgZS5nLiwgcmVwbGFjZXMgMS4yMDAwayB3aXRoIDEuMmsuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzKSB7XG4gIG91dDogZm9yICh2YXIgbiA9IHMubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICBzd2l0Y2ggKHNbaV0pIHtcbiAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogaWYgKCErc1tpXSkgYnJlYWsgb3V0OyBpZiAoaTAgPiAwKSBpMCA9IDA7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTAgPiAwID8gcy5zbGljZSgwLCBpMCkgKyBzLnNsaWNlKGkxICsgMSkgOiBzO1xufVxuIiwiaW1wb3J0IGZvcm1hdFByZWZpeEF1dG8gZnJvbSBcIi4vZm9ybWF0UHJlZml4QXV0by5qc1wiO1xuaW1wb3J0IGZvcm1hdFJvdW5kZWQgZnJvbSBcIi4vZm9ybWF0Um91bmRlZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFwiJVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiAoeCAqIDEwMCkudG9GaXhlZChwKTsgfSxcbiAgXCJiXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMik7IH0sXG4gIFwiY1wiOiBmdW5jdGlvbih4KSB7IHJldHVybiB4ICsgXCJcIjsgfSxcbiAgXCJkXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTApOyB9LFxuICBcImVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0V4cG9uZW50aWFsKHApOyB9LFxuICBcImZcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0ZpeGVkKHApOyB9LFxuICBcImdcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b1ByZWNpc2lvbihwKTsgfSxcbiAgXCJvXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCk7IH0sXG4gIFwicFwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiBmb3JtYXRSb3VuZGVkKHggKiAxMDAsIHApOyB9LFxuICBcInJcIjogZm9ybWF0Um91bmRlZCxcbiAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXG4gIFwiWFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9LFxuICBcInhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNik7IH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGZvcm1hdERlZmF1bHRMb2NhbGUsIGZvcm1hdCwgZm9ybWF0UHJlZml4fSBmcm9tIFwiLi9kZWZhdWx0TG9jYWxlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZm9ybWF0TG9jYWxlfSBmcm9tIFwiLi9sb2NhbGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBmb3JtYXRTcGVjaWZpZXIsIEZvcm1hdFNwZWNpZmllcn0gZnJvbSBcIi4vZm9ybWF0U3BlY2lmaWVyLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcHJlY2lzaW9uRml4ZWR9IGZyb20gXCIuL3ByZWNpc2lvbkZpeGVkLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcHJlY2lzaW9uUHJlZml4fSBmcm9tIFwiLi9wcmVjaXNpb25QcmVmaXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwcmVjaXNpb25Sb3VuZH0gZnJvbSBcIi4vcHJlY2lzaW9uUm91bmQuanNcIjtcbiIsImltcG9ydCBleHBvbmVudCBmcm9tIFwiLi9leHBvbmVudC5qc1wiO1xuaW1wb3J0IGZvcm1hdEdyb3VwIGZyb20gXCIuL2Zvcm1hdEdyb3VwLmpzXCI7XG5pbXBvcnQgZm9ybWF0TnVtZXJhbHMgZnJvbSBcIi4vZm9ybWF0TnVtZXJhbHMuanNcIjtcbmltcG9ydCBmb3JtYXRTcGVjaWZpZXIgZnJvbSBcIi4vZm9ybWF0U3BlY2lmaWVyLmpzXCI7XG5pbXBvcnQgZm9ybWF0VHJpbSBmcm9tIFwiLi9mb3JtYXRUcmltLmpzXCI7XG5pbXBvcnQgZm9ybWF0VHlwZXMgZnJvbSBcIi4vZm9ybWF0VHlwZXMuanNcIjtcbmltcG9ydCB7cHJlZml4RXhwb25lbnR9IGZyb20gXCIuL2Zvcm1hdFByZWZpeEF1dG8uanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG52YXIgbWFwID0gQXJyYXkucHJvdG90eXBlLm1hcCxcbiAgICBwcmVmaXhlcyA9IFtcInlcIixcInpcIixcImFcIixcImZcIixcInBcIixcIm5cIixcIsK1XCIsXCJtXCIsXCJcIixcImtcIixcIk1cIixcIkdcIixcIlRcIixcIlBcIixcIkVcIixcIlpcIixcIllcIl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGxvY2FsZSkge1xuICB2YXIgZ3JvdXAgPSBsb2NhbGUuZ3JvdXBpbmcgPT09IHVuZGVmaW5lZCB8fCBsb2NhbGUudGhvdXNhbmRzID09PSB1bmRlZmluZWQgPyBpZGVudGl0eSA6IGZvcm1hdEdyb3VwKG1hcC5jYWxsKGxvY2FsZS5ncm91cGluZywgTnVtYmVyKSwgbG9jYWxlLnRob3VzYW5kcyArIFwiXCIpLFxuICAgICAgY3VycmVuY3lQcmVmaXggPSBsb2NhbGUuY3VycmVuY3kgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBsb2NhbGUuY3VycmVuY3lbMF0gKyBcIlwiLFxuICAgICAgY3VycmVuY3lTdWZmaXggPSBsb2NhbGUuY3VycmVuY3kgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBsb2NhbGUuY3VycmVuY3lbMV0gKyBcIlwiLFxuICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsID09PSB1bmRlZmluZWQgPyBcIi5cIiA6IGxvY2FsZS5kZWNpbWFsICsgXCJcIixcbiAgICAgIG51bWVyYWxzID0gbG9jYWxlLm51bWVyYWxzID09PSB1bmRlZmluZWQgPyBpZGVudGl0eSA6IGZvcm1hdE51bWVyYWxzKG1hcC5jYWxsKGxvY2FsZS5udW1lcmFscywgU3RyaW5nKSksXG4gICAgICBwZXJjZW50ID0gbG9jYWxlLnBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IFwiJVwiIDogbG9jYWxlLnBlcmNlbnQgKyBcIlwiLFxuICAgICAgbWludXMgPSBsb2NhbGUubWludXMgPT09IHVuZGVmaW5lZCA/IFwiLVwiIDogbG9jYWxlLm1pbnVzICsgXCJcIixcbiAgICAgIG5hbiA9IGxvY2FsZS5uYW4gPT09IHVuZGVmaW5lZCA/IFwiTmFOXCIgOiBsb2NhbGUubmFuICsgXCJcIjtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICB2YXIgZmlsbCA9IHNwZWNpZmllci5maWxsLFxuICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICBzeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sLFxuICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICBjb21tYSA9IHNwZWNpZmllci5jb21tYSxcbiAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgdHJpbSA9IHNwZWNpZmllci50cmltLFxuICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxuICAgIGlmICh0eXBlID09PSBcIm5cIikgY29tbWEgPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBUaGUgXCJcIiB0eXBlLCBhbmQgYW55IGludmFsaWQgdHlwZSwgaXMgYW4gYWxpYXMgZm9yIFwiLjEyfmdcIi5cbiAgICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkICYmIChwcmVjaXNpb24gPSAxMiksIHRyaW0gPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgIC8vIEZvciBTSS1wcmVmaXgsIHRoZSBzdWZmaXggaXMgbGF6aWx5IGNvbXB1dGVkLlxuICAgIHZhciBwcmVmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lQcmVmaXggOiBzeW1ib2wgPT09IFwiI1wiICYmIC9bYm94WF0vLnRlc3QodHlwZSkgPyBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKSA6IFwiXCIsXG4gICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVN1ZmZpeCA6IC9bJXBdLy50ZXN0KHR5cGUpID8gcGVyY2VudCA6IFwiXCI7XG5cbiAgICAvLyBXaGF0IGZvcm1hdCBmdW5jdGlvbiBzaG91bGQgd2UgdXNlP1xuICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xuICAgIC8vIENhbiB0aGlzIHR5cGUgZ2VuZXJhdGUgZXhwb25lbnRpYWwgbm90YXRpb24/XG4gICAgdmFyIGZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlc1t0eXBlXSxcbiAgICAgICAgbWF5YmVTdWZmaXggPSAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCBwcmVjaXNpb24gaWYgbm90IHNwZWNpZmllZCxcbiAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgIC8vIEZvciBzaWduaWZpY2FudCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzEsIDIxXS5cbiAgICAvLyBGb3IgZml4ZWQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFswLCAyMF0uXG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2XG4gICAgICAgIDogL1tncHJzXS8udGVzdCh0eXBlKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKVxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgdmFyIHZhbHVlUHJlZml4ID0gcHJlZml4LFxuICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4LFxuICAgICAgICAgIGksIG4sIGM7XG5cbiAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgc2lnbi4gLTAgaXMgbm90IGxlc3MgdGhhbiAwLCBidXQgMSAvIC0wIGlzIVxuICAgICAgICB2YXIgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlIDwgMCB8fCAxIC8gdmFsdWUgPCAwO1xuXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cbiAgICAgICAgdmFsdWUgPSBpc05hTih2YWx1ZSkgPyBuYW4gOiBmb3JtYXRUeXBlKE1hdGguYWJzKHZhbHVlKSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAvLyBUcmltIGluc2lnbmlmaWNhbnQgemVyb3MuXG4gICAgICAgIGlmICh0cmltKSB2YWx1ZSA9IGZvcm1hdFRyaW0odmFsdWUpO1xuXG4gICAgICAgIC8vIElmIGEgbmVnYXRpdmUgdmFsdWUgcm91bmRzIHRvIHplcm8gYWZ0ZXIgZm9ybWF0dGluZywgYW5kIG5vIGV4cGxpY2l0IHBvc2l0aXZlIHNpZ24gaXMgcmVxdWVzdGVkLCBoaWRlIHRoZSBzaWduLlxuICAgICAgICBpZiAodmFsdWVOZWdhdGl2ZSAmJiArdmFsdWUgPT09IDAgJiYgc2lnbiAhPT0gXCIrXCIpIHZhbHVlTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgdmFsdWVQcmVmaXggPSAodmFsdWVOZWdhdGl2ZSA/IChzaWduID09PSBcIihcIiA/IHNpZ24gOiBtaW51cykgOiBzaWduID09PSBcIi1cIiB8fCBzaWduID09PSBcIihcIiA/IFwiXCIgOiBzaWduKSArIHZhbHVlUHJlZml4O1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9ICh0eXBlID09PSBcInNcIiA/IHByZWZpeGVzWzggKyBwcmVmaXhFeHBvbmVudCAvIDNdIDogXCJcIikgKyB2YWx1ZVN1ZmZpeCArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlIFwiPFwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPVwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOiB2YWx1ZSA9IHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB2YWx1ZSA9IHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtZXJhbHModmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNwZWNpZmllciArIFwiXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgIHZhciBmID0gbmV3Rm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogbmV3Rm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gIH07XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RlcCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgLWV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RlcCwgdmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzIC0gZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbn1cbiIsImltcG9ydCBleHBvbmVudCBmcm9tIFwiLi9leHBvbmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGVwLCBtYXgpIHtcbiAgc3RlcCA9IE1hdGguYWJzKHN0ZXApLCBtYXggPSBNYXRoLmFicyhtYXgpIC0gc3RlcDtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGV4cG9uZW50KG1heCkgLSBleHBvbmVudChzdGVwKSkgKyAxO1xufVxuIiwiaW1wb3J0IHZhbHVlIGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5pbXBvcnQgbnVtYmVyQXJyYXksIHtpc051bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiAoaXNOdW1iZXJBcnJheShiKSA/IG51bWJlckFycmF5IDogZ2VuZXJpY0FycmF5KShhLCBiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyaWNBcnJheShhLCBiKSB7XG4gIHZhciBuYiA9IGIgPyBiLmxlbmd0aCA6IDAsXG4gICAgICBuYSA9IGEgPyBNYXRoLm1pbihuYiwgYS5sZW5ndGgpIDogMCxcbiAgICAgIHggPSBuZXcgQXJyYXkobmEpLFxuICAgICAgYyA9IG5ldyBBcnJheShuYiksXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSB4W2ldID0gdmFsdWUoYVtpXSwgYltpXSk7XG4gIGZvciAoOyBpIDwgbmI7ICsraSkgY1tpXSA9IGJbaV07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgY1tpXSA9IHhbaV0odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYmFzaXModDEsIHYwLCB2MSwgdjIsIHYzKSB7XG4gIHZhciB0MiA9IHQxICogdDEsIHQzID0gdDIgKiB0MTtcbiAgcmV0dXJuICgoMSAtIDMgKiB0MSArIDMgKiB0MiAtIHQzKSAqIHYwXG4gICAgICArICg0IC0gNiAqIHQyICsgMyAqIHQzKSAqIHYxXG4gICAgICArICgxICsgMyAqIHQxICsgMyAqIHQyIC0gMyAqIHQzKSAqIHYyXG4gICAgICArIHQzICogdjMpIC8gNjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0IDw9IDAgPyAodCA9IDApIDogdCA+PSAxID8gKHQgPSAxLCBuIC0gMSkgOiBNYXRoLmZsb29yKHQgKiBuKSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaV0sXG4gICAgICAgIHYyID0gdmFsdWVzW2kgKyAxXSxcbiAgICAgICAgdjAgPSBpID4gMCA/IHZhbHVlc1tpIC0gMV0gOiAyICogdjEgLSB2MixcbiAgICAgICAgdjMgPSBpIDwgbiAtIDEgPyB2YWx1ZXNbaSArIDJdIDogMiAqIHYyIC0gdjE7XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IHtiYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKCh0ICU9IDEpIDwgMCA/ICsrdCA6IHQpICogbiksXG4gICAgICAgIHYwID0gdmFsdWVzWyhpICsgbiAtIDEpICUgbl0sXG4gICAgICAgIHYxID0gdmFsdWVzW2kgJSBuXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbKGkgKyAxKSAlIG5dLFxuICAgICAgICB2MyA9IHZhbHVlc1soaSArIDIpICUgbl07XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmZ1bmN0aW9uIGxpbmVhcihhLCBkKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKyB0ICogZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnRpYWwoYSwgYiwgeSkge1xuICByZXR1cm4gYSA9IE1hdGgucG93KGEsIHkpLCBiID0gTWF0aC5wb3coYiwgeSkgLSBhLCB5ID0gMSAvIHksIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coYSArIHQgKiBiLCB5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh1ZShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnYW1tYSh5KSB7XG4gIHJldHVybiAoeSA9ICt5KSA9PT0gMSA/IG5vZ2FtbWEgOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgLSBhID8gZXhwb25lbnRpYWwoYSwgYiwgeSkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9nYW1tYShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCB7Y3ViZWhlbGl4IGFzIGNvbG9yQ3ViZWhlbGl4fSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciwge2h1ZX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZnVuY3Rpb24gY3ViZWhlbGl4KGh1ZSkge1xuICByZXR1cm4gKGZ1bmN0aW9uIGN1YmVoZWxpeEdhbW1hKHkpIHtcbiAgICB5ID0gK3k7XG5cbiAgICBmdW5jdGlvbiBjdWJlaGVsaXgoc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gY29sb3JDdWJlaGVsaXgoc3RhcnQpKS5oLCAoZW5kID0gY29sb3JDdWJlaGVsaXgoZW5kKSkuaCksXG4gICAgICAgICAgcyA9IGNvbG9yKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgICBsID0gY29sb3Ioc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICAgIHN0YXJ0LmwgPSBsKE1hdGgucG93KHQsIHkpKTtcbiAgICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGN1YmVoZWxpeC5nYW1tYSA9IGN1YmVoZWxpeEdhbW1hO1xuXG4gICAgcmV0dXJuIGN1YmVoZWxpeDtcbiAgfSkoMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGN1YmVoZWxpeChodWUpO1xuZXhwb3J0IHZhciBjdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4KGNvbG9yKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZTtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGQuc2V0VGltZShhICogKDEgLSB0KSArIGIgKiB0KSwgZDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiByYW5nZVtNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICogbikpKV07XG4gIH07XG59XG4iLCJpbXBvcnQge2hjbCBhcyBjb2xvckhjbH0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IsIHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGhjbChodWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckhjbChzdGFydCkpLmgsIChlbmQgPSBjb2xvckhjbChlbmQpKS5oKSxcbiAgICAgICAgYyA9IGNvbG9yKHN0YXJ0LmMsIGVuZC5jKSxcbiAgICAgICAgbCA9IGNvbG9yKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5jID0gYyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaGNsKGh1ZSk7XG5leHBvcnQgdmFyIGhjbExvbmcgPSBoY2woY29sb3IpO1xuIiwiaW1wb3J0IHtoc2wgYXMgY29sb3JIc2x9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yLCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5mdW5jdGlvbiBoc2woaHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gY29sb3JIc2woc3RhcnQpKS5oLCAoZW5kID0gY29sb3JIc2woZW5kKSkuaCksXG4gICAgICAgIHMgPSBjb2xvcihzdGFydC5zLCBlbmQucyksXG4gICAgICAgIGwgPSBjb2xvcihzdGFydC5sLCBlbmQubCksXG4gICAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhzbChodWUpO1xuZXhwb3J0IHZhciBoc2xMb25nID0gaHNsKGNvbG9yKTtcbiIsImltcG9ydCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBpID0gaHVlKCthLCArYik7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHggPSBpKHQpO1xuICAgIHJldHVybiB4IC0gMzYwICogTWF0aC5mbG9vcih4IC8gMzYwKTtcbiAgfTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZX0gZnJvbSBcIi4vdmFsdWUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUFycmF5fSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlQmFzaXN9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVCYXNpc0Nsb3NlZH0gZnJvbSBcIi4vYmFzaXNDbG9zZWQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZURhdGV9IGZyb20gXCIuL2RhdGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZURpc2NyZXRlfSBmcm9tIFwiLi9kaXNjcmV0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSHVlfSBmcm9tIFwiLi9odWUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU51bWJlcn0gZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVOdW1iZXJBcnJheX0gZnJvbSBcIi4vbnVtYmVyQXJyYXkuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU9iamVjdH0gZnJvbSBcIi4vb2JqZWN0LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVSb3VuZH0gZnJvbSBcIi4vcm91bmQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVN0cmluZ30gZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5leHBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtQ3NzLCBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2Z30gZnJvbSBcIi4vdHJhbnNmb3JtL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVab29tfSBmcm9tIFwiLi96b29tLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVSZ2IsIHJnYkJhc2lzIGFzIGludGVycG9sYXRlUmdiQmFzaXMsIHJnYkJhc2lzQ2xvc2VkIGFzIGludGVycG9sYXRlUmdiQmFzaXNDbG9zZWR9IGZyb20gXCIuL3JnYi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSHNsLCBoc2xMb25nIGFzIGludGVycG9sYXRlSHNsTG9uZ30gZnJvbSBcIi4vaHNsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVMYWJ9IGZyb20gXCIuL2xhYi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSGNsLCBoY2xMb25nIGFzIGludGVycG9sYXRlSGNsTG9uZ30gZnJvbSBcIi4vaGNsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVDdWJlaGVsaXgsIGN1YmVoZWxpeExvbmcgYXMgaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nfSBmcm9tIFwiLi9jdWJlaGVsaXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwaWVjZXdpc2V9IGZyb20gXCIuL3BpZWNld2lzZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHF1YW50aXplfSBmcm9tIFwiLi9xdWFudGl6ZS5qc1wiO1xuIiwiaW1wb3J0IHtsYWIgYXMgY29sb3JMYWJ9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yIGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhYihzdGFydCwgZW5kKSB7XG4gIHZhciBsID0gY29sb3IoKHN0YXJ0ID0gY29sb3JMYWIoc3RhcnQpKS5sLCAoZW5kID0gY29sb3JMYWIoZW5kKSkubCksXG4gICAgICBhID0gY29sb3Ioc3RhcnQuYSwgZW5kLmEpLFxuICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgc3RhcnQubCA9IGwodCk7XG4gICAgc3RhcnQuYSA9IGEodCk7XG4gICAgc3RhcnQuYiA9IGIodCk7XG4gICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKiAoMSAtIHQpICsgYiAqIHQ7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIGlmICghYikgYiA9IFtdO1xuICB2YXIgbiA9IGEgPyBNYXRoLm1pbihiLmxlbmd0aCwgYS5sZW5ndGgpIDogMCxcbiAgICAgIGMgPSBiLnNsaWNlKCksXG4gICAgICBpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNbaV0gPSBhW2ldICogKDEgLSB0KSArIGJbaV0gKiB0O1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXJBcnJheSh4KSB7XG4gIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoeCkgJiYgISh4IGluc3RhbmNlb2YgRGF0YVZpZXcpO1xufVxuIiwiaW1wb3J0IHZhbHVlIGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGkgPSB7fSxcbiAgICAgIGMgPSB7fSxcbiAgICAgIGs7XG5cbiAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT09IFwib2JqZWN0XCIpIGEgPSB7fTtcbiAgaWYgKGIgPT09IG51bGwgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpIGIgPSB7fTtcblxuICBmb3IgKGsgaW4gYikge1xuICAgIGlmIChrIGluIGEpIHtcbiAgICAgIGlba10gPSB2YWx1ZShhW2tdLCBiW2tdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY1trXSA9IGJba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGsgaW4gaSkgY1trXSA9IGlba10odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaWVjZXdpc2UoaW50ZXJwb2xhdGUsIHZhbHVlcykge1xuICB2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMSwgdiA9IHZhbHVlc1swXSwgSSA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBJW2ldID0gaW50ZXJwb2xhdGUodiwgdiA9IHZhbHVlc1srK2ldKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKj0gbikpKTtcbiAgICByZXR1cm4gSVtpXSh0IC0gaSk7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcnBvbGF0b3IsIG4pIHtcbiAgdmFyIHNhbXBsZXMgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBzYW1wbGVzW2ldID0gaW50ZXJwb2xhdG9yKGkgLyAobiAtIDEpKTtcbiAgcmV0dXJuIHNhbXBsZXM7XG59XG4iLCJpbXBvcnQge3JnYiBhcyBjb2xvclJnYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgYmFzaXMgZnJvbSBcIi4vYmFzaXMuanNcIjtcbmltcG9ydCBiYXNpc0Nsb3NlZCBmcm9tIFwiLi9iYXNpc0Nsb3NlZC5qc1wiO1xuaW1wb3J0IG5vZ2FtbWEsIHtnYW1tYX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHJnYkdhbW1hKHkpIHtcbiAgdmFyIGNvbG9yID0gZ2FtbWEoeSk7XG5cbiAgZnVuY3Rpb24gcmdiKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IGNvbG9yKChzdGFydCA9IGNvbG9yUmdiKHN0YXJ0KSkuciwgKGVuZCA9IGNvbG9yUmdiKGVuZCkpLnIpLFxuICAgICAgICBnID0gY29sb3Ioc3RhcnQuZywgZW5kLmcpLFxuICAgICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LnIgPSByKHQpO1xuICAgICAgc3RhcnQuZyA9IGcodCk7XG4gICAgICBzdGFydC5iID0gYih0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgcmdiLmdhbW1hID0gcmdiR2FtbWE7XG5cbiAgcmV0dXJuIHJnYjtcbn0pKDEpO1xuXG5mdW5jdGlvbiByZ2JTcGxpbmUoc3BsaW5lKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xvcnMpIHtcbiAgICB2YXIgbiA9IGNvbG9ycy5sZW5ndGgsXG4gICAgICAgIHIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGcgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGksIGNvbG9yO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbG9yID0gY29sb3JSZ2IoY29sb3JzW2ldKTtcbiAgICAgIHJbaV0gPSBjb2xvci5yIHx8IDA7XG4gICAgICBnW2ldID0gY29sb3IuZyB8fCAwO1xuICAgICAgYltpXSA9IGNvbG9yLmIgfHwgMDtcbiAgICB9XG4gICAgciA9IHNwbGluZShyKTtcbiAgICBnID0gc3BsaW5lKGcpO1xuICAgIGIgPSBzcGxpbmUoYik7XG4gICAgY29sb3Iub3BhY2l0eSA9IDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGNvbG9yLnIgPSByKHQpO1xuICAgICAgY29sb3IuZyA9IGcodCk7XG4gICAgICBjb2xvci5iID0gYih0KTtcbiAgICAgIHJldHVybiBjb2xvciArIFwiXCI7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciByZ2JCYXNpcyA9IHJnYlNwbGluZShiYXNpcyk7XG5leHBvcnQgdmFyIHJnYkJhc2lzQ2xvc2VkID0gcmdiU3BsaW5lKGJhc2lzQ2xvc2VkKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSAqICgxIC0gdCkgKyBiICogdCk7XG4gIH07XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuXG52YXIgcmVBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nLFxuICAgIHJlQiA9IG5ldyBSZWdFeHAocmVBLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiB6ZXJvKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbmUoYikge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYmkgPSByZUEubGFzdEluZGV4ID0gcmVCLmxhc3RJbmRleCA9IDAsIC8vIHNjYW4gaW5kZXggZm9yIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGFtLCAvLyBjdXJyZW50IG1hdGNoIGluIGFcbiAgICAgIGJtLCAvLyBjdXJyZW50IG1hdGNoIGluIGJcbiAgICAgIGJzLCAvLyBzdHJpbmcgcHJlY2VkaW5nIGN1cnJlbnQgbnVtYmVyIGluIGIsIGlmIGFueVxuICAgICAgaSA9IC0xLCAvLyBpbmRleCBpbiBzXG4gICAgICBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuXG4gIC8vIENvZXJjZSBpbnB1dHMgdG8gc3RyaW5ncy5cbiAgYSA9IGEgKyBcIlwiLCBiID0gYiArIFwiXCI7XG5cbiAgLy8gSW50ZXJwb2xhdGUgcGFpcnMgb2YgbnVtYmVycyBpbiBhICYgYi5cbiAgd2hpbGUgKChhbSA9IHJlQS5leGVjKGEpKVxuICAgICAgJiYgKGJtID0gcmVCLmV4ZWMoYikpKSB7XG4gICAgaWYgKChicyA9IGJtLmluZGV4KSA+IGJpKSB7IC8vIGEgc3RyaW5nIHByZWNlZGVzIHRoZSBuZXh0IG51bWJlciBpbiBiXG4gICAgICBicyA9IGIuc2xpY2UoYmksIGJzKTtcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBicztcbiAgICB9XG4gICAgaWYgKChhbSA9IGFtWzBdKSA9PT0gKGJtID0gYm1bMF0pKSB7IC8vIG51bWJlcnMgaW4gYSAmIGIgbWF0Y2hcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJtOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBibTtcbiAgICB9IGVsc2UgeyAvLyBpbnRlcnBvbGF0ZSBub24tbWF0Y2hpbmcgbnVtYmVyc1xuICAgICAgc1srK2ldID0gbnVsbDtcbiAgICAgIHEucHVzaCh7aTogaSwgeDogbnVtYmVyKGFtLCBibSl9KTtcbiAgICB9XG4gICAgYmkgPSByZUIubGFzdEluZGV4O1xuICB9XG5cbiAgLy8gQWRkIHJlbWFpbnMgb2YgYi5cbiAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gIH1cblxuICAvLyBTcGVjaWFsIG9wdGltaXphdGlvbiBmb3Igb25seSBhIHNpbmdsZSBtYXRjaC5cbiAgLy8gT3RoZXJ3aXNlLCBpbnRlcnBvbGF0ZSBlYWNoIG9mIHRoZSBudW1iZXJzIGFuZCByZWpvaW4gdGhlIHN0cmluZy5cbiAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/IChxWzBdXG4gICAgICA/IG9uZShxWzBdLngpXG4gICAgICA6IHplcm8oYikpXG4gICAgICA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGI7ICsraSkgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgICAgIH0pO1xufVxuIiwidmFyIGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuXG5leHBvcnQgdmFyIGlkZW50aXR5ID0ge1xuICB0cmFuc2xhdGVYOiAwLFxuICB0cmFuc2xhdGVZOiAwLFxuICByb3RhdGU6IDAsXG4gIHNrZXdYOiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgc2NhbGVYLCBzY2FsZVksIHNrZXdYO1xuICBpZiAoc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpKSBhIC89IHNjYWxlWCwgYiAvPSBzY2FsZVg7XG4gIGlmIChza2V3WCA9IGEgKiBjICsgYiAqIGQpIGMgLT0gYSAqIHNrZXdYLCBkIC09IGIgKiBza2V3WDtcbiAgaWYgKHNjYWxlWSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKSkgYyAvPSBzY2FsZVksIGQgLz0gc2NhbGVZLCBza2V3WCAvPSBzY2FsZVk7XG4gIGlmIChhICogZCA8IGIgKiBjKSBhID0gLWEsIGIgPSAtYiwgc2tld1ggPSAtc2tld1gsIHNjYWxlWCA9IC1zY2FsZVg7XG4gIHJldHVybiB7XG4gICAgdHJhbnNsYXRlWDogZSxcbiAgICB0cmFuc2xhdGVZOiBmLFxuICAgIHJvdGF0ZTogTWF0aC5hdGFuMihiLCBhKSAqIGRlZ3JlZXMsXG4gICAgc2tld1g6IE1hdGguYXRhbihza2V3WCkgKiBkZWdyZWVzLFxuICAgIHNjYWxlWDogc2NhbGVYLFxuICAgIHNjYWxlWTogc2NhbGVZXG4gIH07XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuLi9udW1iZXIuanNcIjtcbmltcG9ydCB7cGFyc2VDc3MsIHBhcnNlU3ZnfSBmcm9tIFwiLi9wYXJzZS5qc1wiO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZSwgcHhDb21tYSwgcHhQYXJlbiwgZGVnUGFyZW4pIHtcblxuICBmdW5jdGlvbiBwb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIiBcIiA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIHB4Q29tbWEsIG51bGwsIHB4UGFyZW4pO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiB8fCB5Yikge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgeGIgKyBweENvbW1hICsgeWIgKyBweFBhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGUoYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBpZiAoYSAtIGIgPiAxODApIGIgKz0gMzYwOyBlbHNlIGlmIChiIC0gYSA+IDE4MCkgYSArPSAzNjA7IC8vIHNob3J0ZXN0IHBhdGhcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tld1goYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiAhPT0gMSB8fCB5YiAhPT0gMSkge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIgKyB4YiArIFwiLFwiICsgeWIgKyBcIilcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuICAgIGEgPSBwYXJzZShhKSwgYiA9IHBhcnNlKGIpO1xuICAgIHRyYW5zbGF0ZShhLnRyYW5zbGF0ZVgsIGEudHJhbnNsYXRlWSwgYi50cmFuc2xhdGVYLCBiLnRyYW5zbGF0ZVksIHMsIHEpO1xuICAgIHJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xuICAgIHNrZXdYKGEuc2tld1gsIGIuc2tld1gsIHMsIHEpO1xuICAgIHNjYWxlKGEuc2NhbGVYLCBhLnNjYWxlWSwgYi5zY2FsZVgsIGIuc2NhbGVZLCBzLCBxKTtcbiAgICBhID0gYiA9IG51bGw7IC8vIGdjXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBxLmxlbmd0aCwgbztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZUNzcywgXCJweCwgXCIsIFwicHgpXCIsIFwiZGVnKVwiKTtcbmV4cG9ydCB2YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZVN2ZywgXCIsIFwiLCBcIilcIiwgXCIpXCIpO1xuIiwiaW1wb3J0IGRlY29tcG9zZSwge2lkZW50aXR5fSBmcm9tIFwiLi9kZWNvbXBvc2UuanNcIjtcblxudmFyIGNzc05vZGUsXG4gICAgY3NzUm9vdCxcbiAgICBjc3NWaWV3LFxuICAgIHN2Z05vZGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNzcyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IFwibm9uZVwiKSByZXR1cm4gaWRlbnRpdHk7XG4gIGlmICghY3NzTm9kZSkgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIiksIGNzc1Jvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGNzc1ZpZXcgPSBkb2N1bWVudC5kZWZhdWx0VmlldztcbiAgY3NzTm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZTtcbiAgdmFsdWUgPSBjc3NWaWV3LmdldENvbXB1dGVkU3R5bGUoY3NzUm9vdC5hcHBlbmRDaGlsZChjc3NOb2RlKSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcInRyYW5zZm9ybVwiKTtcbiAgY3NzUm9vdC5yZW1vdmVDaGlsZChjc3NOb2RlKTtcbiAgdmFsdWUgPSB2YWx1ZS5zbGljZSg3LCAtMSkuc3BsaXQoXCIsXCIpO1xuICByZXR1cm4gZGVjb21wb3NlKCt2YWx1ZVswXSwgK3ZhbHVlWzFdLCArdmFsdWVbMl0sICt2YWx1ZVszXSwgK3ZhbHVlWzRdLCArdmFsdWVbNV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFzdmdOb2RlKSBzdmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICBzdmdOb2RlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB2YWx1ZSk7XG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5O1xuICB2YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcbn1cbiIsImltcG9ydCB7Y29sb3J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IHJnYiBmcm9tIFwiLi9yZ2IuanNcIjtcbmltcG9ydCB7Z2VuZXJpY0FycmF5fSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGRhdGUgZnJvbSBcIi4vZGF0ZS5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmltcG9ydCBvYmplY3QgZnJvbSBcIi4vb2JqZWN0LmpzXCI7XG5pbXBvcnQgc3RyaW5nIGZyb20gXCIuL3N0cmluZy5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgbnVtYmVyQXJyYXksIHtpc051bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsIGM7XG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudChiKVxuICAgICAgOiAodCA9PT0gXCJudW1iZXJcIiA/IG51bWJlclxuICAgICAgOiB0ID09PSBcInN0cmluZ1wiID8gKChjID0gY29sb3IoYikpID8gKGIgPSBjLCByZ2IpIDogc3RyaW5nKVxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyByZ2JcbiAgICAgIDogYiBpbnN0YW5jZW9mIERhdGUgPyBkYXRlXG4gICAgICA6IGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheVxuICAgICAgOiBBcnJheS5pc0FycmF5KGIpID8gZ2VuZXJpY0FycmF5XG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XG4gICAgICA6IG51bWJlcikoYSwgYik7XG59XG4iLCJ2YXIgcmhvID0gTWF0aC5TUVJUMixcbiAgICByaG8yID0gMixcbiAgICByaG80ID0gNCxcbiAgICBlcHNpbG9uMiA9IDFlLTEyO1xuXG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCgyICogeCkpIC0gMSkgLyAoeCArIDEpO1xufVxuXG4vLyBwMCA9IFt1eDAsIHV5MCwgdzBdXG4vLyBwMSA9IFt1eDEsIHV5MSwgdzFdXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwMCwgcDEpIHtcbiAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcbiAgICAgIHV4MSA9IHAxWzBdLCB1eTEgPSBwMVsxXSwgdzEgPSBwMVsyXSxcbiAgICAgIGR4ID0gdXgxIC0gdXgwLFxuICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgaSxcbiAgICAgIFM7XG5cbiAgLy8gU3BlY2lhbCBjYXNlIGZvciB1MCDiiYUgdTEuXG4gIGlmIChkMiA8IGVwc2lsb24yKSB7XG4gICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB1eDAgKyB0ICogZHgsXG4gICAgICAgIHV5MCArIHQgKiBkeSxcbiAgICAgICAgdzAgKiBNYXRoLmV4cChyaG8gKiB0ICogUylcbiAgICAgIF07XG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhbCBjYXNlLlxuICBlbHNlIHtcbiAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLFxuICAgICAgICBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzQgKiBkMikgLyAoMiAqIHcwICogcmhvMiAqIGQxKSxcbiAgICAgICAgYjEgPSAodzEgKiB3MSAtIHcwICogdzAgLSByaG80ICogZDIpIC8gKDIgKiB3MSAqIHJobzIgKiBkMSksXG4gICAgICAgIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKSxcbiAgICAgICAgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgIFMgPSAocjEgLSByMCkgLyByaG87XG4gICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBzID0gdCAqIFMsXG4gICAgICAgICAgY29zaHIwID0gY29zaChyMCksXG4gICAgICAgICAgdSA9IHcwIC8gKHJobzIgKiBkMSkgKiAoY29zaHIwICogdGFuaChyaG8gKiBzICsgcjApIC0gc2luaChyMCkpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdXgwICsgdSAqIGR4LFxuICAgICAgICB1eTAgKyB1ICogZHksXG4gICAgICAgIHcwICogY29zaHIwIC8gY29zaChyaG8gKiBzICsgcjApXG4gICAgICBdO1xuICAgIH1cbiAgfVxuXG4gIGkuZHVyYXRpb24gPSBTICogMTAwMDtcblxuICByZXR1cm4gaTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBwYXRofSBmcm9tIFwiLi9wYXRoLmpzXCI7XG4iLCJ2YXIgcGkgPSBNYXRoLlBJLFxuICAgIHRhdSA9IDIgKiBwaSxcbiAgICBlcHNpbG9uID0gMWUtNixcbiAgICB0YXVFcHNpbG9uID0gdGF1IC0gZXBzaWxvbjtcblxuZnVuY3Rpb24gUGF0aCgpIHtcbiAgdGhpcy5feDAgPSB0aGlzLl95MCA9IC8vIHN0YXJ0IG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl8gPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gbmV3IFBhdGg7XG59XG5cblBhdGgucHJvdG90eXBlID0gcGF0aC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoLFxuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fICs9IFwiWlwiO1xuICAgIH1cbiAgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIlFcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiQ1wiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAoK3gyKSArIFwiLFwiICsgKCt5MikgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBhcmNUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHIpIHtcbiAgICB4MSA9ICt4MSwgeTEgPSAreTEsIHgyID0gK3gyLCB5MiA9ICt5MiwgciA9ICtyO1xuICAgIHZhciB4MCA9IHRoaXMuX3gxLFxuICAgICAgICB5MCA9IHRoaXMuX3kxLFxuICAgICAgICB4MjEgPSB4MiAtIHgxLFxuICAgICAgICB5MjEgPSB5MiAtIHkxLFxuICAgICAgICB4MDEgPSB4MCAtIHgxLFxuICAgICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgICBsMDFfMiA9IHgwMSAqIHgwMSArIHkwMSAqIHkwMTtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MSx5MSkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgwLHkwKT8gRG8gbm90aGluZy5cbiAgICBlbHNlIGlmICghKGwwMV8yID4gZXBzaWxvbikpO1xuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHgyMCA9IHgyIC0geDAsXG4gICAgICAgICAgeTIwID0geTIgLSB5MCxcbiAgICAgICAgICBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSxcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcbiAgICAgICAgICBsMjEgPSBNYXRoLnNxcnQobDIxXzIpLFxuICAgICAgICAgIGwwMSA9IE1hdGguc3FydChsMDFfMiksXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICB0aGlzLl8gKz0gXCJMXCIgKyAoeDEgKyB0MDEgKiB4MDEpICsgXCIsXCIgKyAoeTEgKyB0MDEgKiB5MDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwwLFwiICsgKCsoeTAxICogeDIwID4geDAxICogeTIwKSkgKyBcIixcIiArICh0aGlzLl94MSA9IHgxICsgdDIxICogeDIxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEgKyB0MjEgKiB5MjEpO1xuICAgIH1cbiAgfSxcbiAgYXJjOiBmdW5jdGlvbih4LCB5LCByLCBhMCwgYTEsIGNjdykge1xuICAgIHggPSAreCwgeSA9ICt5LCByID0gK3IsIGNjdyA9ICEhY2N3O1xuICAgIHZhciBkeCA9IHIgKiBNYXRoLmNvcyhhMCksXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcbiAgICAgICAgeDAgPSB4ICsgZHgsXG4gICAgICAgIHkwID0geSArIGR5LFxuICAgICAgICBjdyA9IDEgXiBjY3csXG4gICAgICAgIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDAseTApLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh4IC0gZHgpICsgXCIsXCIgKyAoeSAtIGR5KSArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MCkgKyBcIixcIiArICh0aGlzLl95MSA9IHkwKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsXCIgKyAoKyhkYSA+PSBwaSkpICsgXCIsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKSk7XG4gICAgfVxuICB9LFxuICByZWN0OiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpICsgXCJoXCIgKyAoK3cpICsgXCJ2XCIgKyAoK2gpICsgXCJoXCIgKyAoLXcpICsgXCJaXCI7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXRoO1xuIiwidmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG5leHBvcnQgdmFyIG1hcCA9IGFycmF5Lm1hcDtcbmV4cG9ydCB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiIsImltcG9ydCB7cmFuZ2UgYXMgc2VxdWVuY2V9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCBvcmRpbmFsIGZyb20gXCIuL29yZGluYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmFuZCgpIHtcbiAgdmFyIHNjYWxlID0gb3JkaW5hbCgpLnVua25vd24odW5kZWZpbmVkKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIG9yZGluYWxSYW5nZSA9IHNjYWxlLnJhbmdlLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICBzdGVwLFxuICAgICAgYmFuZHdpZHRoLFxuICAgICAgcm91bmQgPSBmYWxzZSxcbiAgICAgIHBhZGRpbmdJbm5lciA9IDAsXG4gICAgICBwYWRkaW5nT3V0ZXIgPSAwLFxuICAgICAgYWxpZ24gPSAwLjU7XG5cbiAgZGVsZXRlIHNjYWxlLnVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgbiA9IGRvbWFpbigpLmxlbmd0aCxcbiAgICAgICAgcmV2ZXJzZSA9IHJhbmdlWzFdIDwgcmFuZ2VbMF0sXG4gICAgICAgIHN0YXJ0ID0gcmFuZ2VbcmV2ZXJzZSAtIDBdLFxuICAgICAgICBzdG9wID0gcmFuZ2VbMSAtIHJldmVyc2VdO1xuICAgIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDEsIG4gLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICBpZiAocm91bmQpIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgIHN0YXJ0ICs9IChzdG9wIC0gc3RhcnQgLSBzdGVwICogKG4gLSBwYWRkaW5nSW5uZXIpKSAqIGFsaWduO1xuICAgIGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgaWYgKHJvdW5kKSBzdGFydCA9IE1hdGgucm91bmQoc3RhcnQpLCBiYW5kd2lkdGggPSBNYXRoLnJvdW5kKGJhbmR3aWR0aCk7XG4gICAgdmFyIHZhbHVlcyA9IHNlcXVlbmNlKG4pLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBzdGFydCArIHN0ZXAgKiBpOyB9KTtcbiAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IFsrX1swXSwgK19bMV1dLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSA9IFsrX1swXSwgK19bMV1dLCByb3VuZCA9IHRydWUsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmFuZHdpZHRoO1xuICB9O1xuXG4gIHNjYWxlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3RlcDtcbiAgfTtcblxuICBzY2FsZS5yb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEhXywgcmVzY2FsZSgpKSA6IHJvdW5kO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgcGFkZGluZ091dGVyID0gK18pLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBNYXRoLm1pbigxLCBfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ091dGVyID0gK18sIHJlc2NhbGUoKSkgOiBwYWRkaW5nT3V0ZXI7XG4gIH07XG5cbiAgc2NhbGUuYWxpZ24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxpZ24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBhbGlnbjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmQoZG9tYWluKCksIHJhbmdlKVxuICAgICAgICAucm91bmQocm91bmQpXG4gICAgICAgIC5wYWRkaW5nSW5uZXIocGFkZGluZ0lubmVyKVxuICAgICAgICAucGFkZGluZ091dGVyKHBhZGRpbmdPdXRlcilcbiAgICAgICAgLmFsaWduKGFsaWduKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHJlc2NhbGUoKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRpc2goc2NhbGUpIHtcbiAgdmFyIGNvcHkgPSBzY2FsZS5jb3B5O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nSW5uZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwb2ludGlzaChjb3B5KCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50KCkge1xuICByZXR1cm4gcG9pbnRpc2goYmFuZC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhZGRpbmdJbm5lcigxKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGUgYXMgaW50ZXJwb2xhdGVWYWx1ZSwgaW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUm91bmR9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHttYXAsIHNsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuXG52YXIgdW5pdCA9IFswLCAxXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoaXNOYU4oYikgPyBOYU4gOiAwLjUpO1xufVxuXG5mdW5jdGlvbiBjbGFtcGVyKGRvbWFpbikge1xuICB2YXIgYSA9IGRvbWFpblswXSwgYiA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0sIHQ7XG4gIGlmIChhID4gYikgdCA9IGEsIGEgPSBiLCBiID0gdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsIHgpKTsgfTtcbn1cblxuLy8gbm9ybWFsaXplKGEsIGIpKHgpIHRha2VzIGEgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHQgaW4gWzAsMV0uXG4vLyBpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJhbmdlIHZhbHVlIHggaW4gW2EsYl0uXG5mdW5jdGlvbiBiaW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdO1xuICBpZiAoZDEgPCBkMCkgZDAgPSBub3JtYWxpemUoZDEsIGQwKSwgcjAgPSBpbnRlcnBvbGF0ZShyMSwgcjApO1xuICBlbHNlIGQwID0gbm9ybWFsaXplKGQwLCBkMSksIHIwID0gaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcbn1cblxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgaiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgLSAxLFxuICAgICAgZCA9IG5ldyBBcnJheShqKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkoaiksXG4gICAgICBpID0gLTE7XG5cbiAgLy8gUmV2ZXJzZSBkZXNjZW5kaW5nIGRvbWFpbnMuXG4gIGlmIChkb21haW5bal0gPCBkb21haW5bMF0pIHtcbiAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgfVxuXG4gIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgZFtpXSA9IG5vcm1hbGl6ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgIHJbaV0gPSBpbnRlcnBvbGF0ZShyYW5nZVtpXSwgcmFuZ2VbaSArIDFdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGkgPSBiaXNlY3QoZG9tYWluLCB4LCAxLCBqKSAtIDE7XG4gICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLnJhbmdlKHNvdXJjZS5yYW5nZSgpKVxuICAgICAgLmludGVycG9sYXRlKHNvdXJjZS5pbnRlcnBvbGF0ZSgpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIGRvbWFpbiA9IHVuaXQsXG4gICAgICByYW5nZSA9IHVuaXQsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlVmFsdWUsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB1bnRyYW5zZm9ybSxcbiAgICAgIHVua25vd24sXG4gICAgICBjbGFtcCA9IGlkZW50aXR5LFxuICAgICAgcGllY2V3aXNlLFxuICAgICAgb3V0cHV0LFxuICAgICAgaW5wdXQ7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBwaWVjZXdpc2UgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpID4gMiA/IHBvbHltYXAgOiBiaW1hcDtcbiAgICBvdXRwdXQgPSBpbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IChvdXRwdXQgfHwgKG91dHB1dCA9IHBpZWNld2lzZShkb21haW4ubWFwKHRyYW5zZm9ybSksIHJhbmdlLCBpbnRlcnBvbGF0ZSkpKSh0cmFuc2Zvcm0oY2xhbXAoeCkpKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gY2xhbXAodW50cmFuc2Zvcm0oKGlucHV0IHx8IChpbnB1dCA9IHBpZWNld2lzZShyYW5nZSwgZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCBpbnRlcnBvbGF0ZU51bWJlcikpKSh5KSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAuY2FsbChfLCBudW1iZXIpLCBjbGFtcCA9PT0gaWRlbnRpdHkgfHwgKGNsYW1wID0gY2xhbXBlcihkb21haW4pKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlUm91bmQsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9IF8gPyBjbGFtcGVyKGRvbWFpbikgOiBpZGVudGl0eSwgc2NhbGUpIDogY2xhbXAgIT09IGlkZW50aXR5O1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgcmVzY2FsZSgpKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIHUpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB1bnRyYW5zZm9ybSA9IHU7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGludW91cyh0cmFuc2Zvcm0sIHVudHJhbnNmb3JtKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcigpKHRyYW5zZm9ybSwgdW50cmFuc2Zvcm0pO1xufVxuIiwiaW1wb3J0IHtpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0SW50ZXJwb2xhdG9yfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2xvZ2dpc2h9IGZyb20gXCIuL2xvZ1wiO1xuaW1wb3J0IHtjb3B5fSBmcm9tIFwiLi9zZXF1ZW50aWFsXCI7XG5pbXBvcnQge3N5bWxvZ2lzaH0gZnJvbSBcIi4vc3ltbG9nXCI7XG5pbXBvcnQge3Bvd2lzaH0gZnJvbSBcIi4vcG93XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAwLjUsXG4gICAgICB4MiA9IDEsXG4gICAgICB0MCxcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICBrMTAsXG4gICAgICBrMjEsXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eSxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIGNsYW1wID0gZmFsc2UsXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiAoeCA9IDAuNSArICgoeCA9ICt0cmFuc2Zvcm0oeCkpIC0gdDEpICogKHggPCB0MSA/IGsxMCA6IGsyMSksIGludGVycG9sYXRvcihjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSA6IHgpKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0MCA9IHRyYW5zZm9ybSh4MCA9ICtfWzBdKSwgdDEgPSB0cmFuc2Zvcm0oeDEgPSArX1sxXSksIHQyID0gdHJhbnNmb3JtKHgyID0gK19bMl0pLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMC41IC8gKHQxIC0gdDApLCBrMjEgPSB0MSA9PT0gdDIgPyAwIDogMC41IC8gKHQyIC0gdDEpLCBzY2FsZSkgOiBbeDAsIHgxLCB4Ml07XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSAhIV8sIHNjYWxlKSA6IGNsYW1wO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRyYW5zZm9ybSA9IHQsIHQwID0gdCh4MCksIHQxID0gdCh4MSksIHQyID0gdCh4MiksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAwLjUgLyAodDEgLSB0MCksIGsyMSA9IHQxID09PSB0MiA/IDAgOiAwLjUgLyAodDIgLSB0MSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaXZlcmdpbmcoKSB7XG4gIHZhciBzY2FsZSA9IGxpbmVhcmlzaCh0cmFuc2Zvcm1lcigpKGlkZW50aXR5KSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBkaXZlcmdpbmcoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdMb2coKSB7XG4gIHZhciBzY2FsZSA9IGxvZ2dpc2godHJhbnNmb3JtZXIoKSkuZG9tYWluKFswLjEsIDEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBkaXZlcmdpbmdMb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nU3ltbG9nKCkge1xuICB2YXIgc2NhbGUgPSBzeW1sb2dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBkaXZlcmdpbmdTeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdQb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ1BvdygpKS5leHBvbmVudChzY2FsZS5leHBvbmVudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ1NxcnQoKSB7XG4gIHJldHVybiBkaXZlcmdpbmdQb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHttYXB9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpZGVudGl0eShkb21haW4pIHtcbiAgdmFyIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IHg7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBzY2FsZTtcblxuICBzY2FsZS5kb21haW4gPSBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAuY2FsbChfLCBudW1iZXIpLCBzY2FsZSkgOiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWRlbnRpdHkoZG9tYWluKS51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIGRvbWFpbiA9IGFyZ3VtZW50cy5sZW5ndGggPyBtYXAuY2FsbChkb21haW4sIG51bWJlcikgOiBbMCwgMV07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG4iLCJleHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlQmFuZCxcbiAgcG9pbnQgYXMgc2NhbGVQb2ludFxufSBmcm9tIFwiLi9iYW5kXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVJZGVudGl0eVxufSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlTGluZWFyXG59IGZyb20gXCIuL2xpbmVhclwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlTG9nXG59IGZyb20gXCIuL2xvZ1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlU3ltbG9nXG59IGZyb20gXCIuL3N5bWxvZ1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlT3JkaW5hbCxcbiAgaW1wbGljaXQgYXMgc2NhbGVJbXBsaWNpdFxufSBmcm9tIFwiLi9vcmRpbmFsXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVQb3csXG4gIHNxcnQgYXMgc2NhbGVTcXJ0XG59IGZyb20gXCIuL3Bvd1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlUXVhbnRpbGVcbn0gZnJvbSBcIi4vcXVhbnRpbGVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVF1YW50aXplXG59IGZyb20gXCIuL3F1YW50aXplXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVUaHJlc2hvbGRcbn0gZnJvbSBcIi4vdGhyZXNob2xkXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVUaW1lXG59IGZyb20gXCIuL3RpbWVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVV0Y1xufSBmcm9tIFwiLi91dGNUaW1lXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVTZXF1ZW50aWFsLFxuICBzZXF1ZW50aWFsTG9nIGFzIHNjYWxlU2VxdWVudGlhbExvZyxcbiAgc2VxdWVudGlhbFBvdyBhcyBzY2FsZVNlcXVlbnRpYWxQb3csXG4gIHNlcXVlbnRpYWxTcXJ0IGFzIHNjYWxlU2VxdWVudGlhbFNxcnQsXG4gIHNlcXVlbnRpYWxTeW1sb2cgYXMgc2NhbGVTZXF1ZW50aWFsU3ltbG9nXG59IGZyb20gXCIuL3NlcXVlbnRpYWxcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVNlcXVlbnRpYWxRdWFudGlsZVxufSBmcm9tIFwiLi9zZXF1ZW50aWFsUXVhbnRpbGVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZURpdmVyZ2luZyxcbiAgZGl2ZXJnaW5nTG9nIGFzIHNjYWxlRGl2ZXJnaW5nTG9nLFxuICBkaXZlcmdpbmdQb3cgYXMgc2NhbGVEaXZlcmdpbmdQb3csXG4gIGRpdmVyZ2luZ1NxcnQgYXMgc2NhbGVEaXZlcmdpbmdTcXJ0LFxuICBkaXZlcmdpbmdTeW1sb2cgYXMgc2NhbGVEaXZlcmdpbmdTeW1sb2dcbn0gZnJvbSBcIi4vZGl2ZXJnaW5nXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGlja0Zvcm1hdFxufSBmcm9tIFwiLi90aWNrRm9ybWF0XCI7XG4iLCJleHBvcnQgZnVuY3Rpb24gaW5pdFJhbmdlKGRvbWFpbiwgcmFuZ2UpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMucmFuZ2UoZG9tYWluKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhpcy5yYW5nZShyYW5nZSkuZG9tYWluKGRvbWFpbik7IGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdEludGVycG9sYXRvcihkb21haW4sIGludGVycG9sYXRvcikge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IGJyZWFrO1xuICAgIGNhc2UgMTogdGhpcy5pbnRlcnBvbGF0b3IoZG9tYWluKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhpcy5pbnRlcnBvbGF0b3IoaW50ZXJwb2xhdG9yKS5kb21haW4oZG9tYWluKTsgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJpbXBvcnQge3RpY2tzLCB0aWNrSW5jcmVtZW50fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCBjb250aW51b3VzLCB7Y29weSwgaWRlbnRpdHl9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQgdGlja0Zvcm1hdCBmcm9tIFwiLi90aWNrRm9ybWF0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJpc2goc2NhbGUpIHtcbiAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja3MoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCk7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrRm9ybWF0KGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQsIHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG5cbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICBpMCA9IDAsXG4gICAgICAgIGkxID0gZC5sZW5ndGggLSAxLFxuICAgICAgICBzdGFydCA9IGRbaTBdLFxuICAgICAgICBzdG9wID0gZFtpMV0sXG4gICAgICAgIHN0ZXA7XG5cbiAgICBpZiAoc3RvcCA8IHN0YXJ0KSB7XG4gICAgICBzdGVwID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IHN0ZXA7XG4gICAgICBzdGVwID0gaTAsIGkwID0gaTEsIGkxID0gc3RlcDtcbiAgICB9XG5cbiAgICBzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuXG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBkW2kwXSA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBkW2kxXSA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgZG9tYWluKGQpO1xuICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIGRbaTBdID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgZFtpMV0gPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBkb21haW4oZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGluZWFyKCkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGlkZW50aXR5LCBpZGVudGl0eSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsaW5lYXIoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuIiwiaW1wb3J0IHt0aWNrc30gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2Zvcm1hdH0gZnJvbSBcImQzLWZvcm1hdFwiO1xuaW1wb3J0IG5pY2UgZnJvbSBcIi4vbmljZVwiO1xuaW1wb3J0IHtjb3B5LCB0cmFuc2Zvcm1lcn0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtTG9nKHgpIHtcbiAgcmV0dXJuIE1hdGgubG9nKHgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FeHAoeCkge1xuICByZXR1cm4gTWF0aC5leHAoeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUxvZ24oeCkge1xuICByZXR1cm4gLU1hdGgubG9nKC14KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRXhwbih4KSB7XG4gIHJldHVybiAtTWF0aC5leHAoLXgpO1xufVxuXG5mdW5jdGlvbiBwb3cxMCh4KSB7XG4gIHJldHVybiBpc0Zpbml0ZSh4KSA/ICsoXCIxZVwiICsgeCkgOiB4IDwgMCA/IDAgOiB4O1xufVxuXG5mdW5jdGlvbiBwb3dwKGJhc2UpIHtcbiAgcmV0dXJuIGJhc2UgPT09IDEwID8gcG93MTBcbiAgICAgIDogYmFzZSA9PT0gTWF0aC5FID8gTWF0aC5leHBcbiAgICAgIDogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5wb3coYmFzZSwgeCk7IH07XG59XG5cbmZ1bmN0aW9uIGxvZ3AoYmFzZSkge1xuICByZXR1cm4gYmFzZSA9PT0gTWF0aC5FID8gTWF0aC5sb2dcbiAgICAgIDogYmFzZSA9PT0gMTAgJiYgTWF0aC5sb2cxMFxuICAgICAgfHwgYmFzZSA9PT0gMiAmJiBNYXRoLmxvZzJcbiAgICAgIHx8IChiYXNlID0gTWF0aC5sb2coYmFzZSksIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubG9nKHgpIC8gYmFzZTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZmxlY3QoZikge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAtZigteCk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dnaXNoKHRyYW5zZm9ybSkge1xuICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0odHJhbnNmb3JtTG9nLCB0cmFuc2Zvcm1FeHApLFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluLFxuICAgICAgYmFzZSA9IDEwLFxuICAgICAgbG9ncyxcbiAgICAgIHBvd3M7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBsb2dzID0gbG9ncChiYXNlKSwgcG93cyA9IHBvd3AoYmFzZSk7XG4gICAgaWYgKGRvbWFpbigpWzBdIDwgMCkge1xuICAgICAgbG9ncyA9IHJlZmxlY3QobG9ncyksIHBvd3MgPSByZWZsZWN0KHBvd3MpO1xuICAgICAgdHJhbnNmb3JtKHRyYW5zZm9ybUxvZ24sIHRyYW5zZm9ybUV4cG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm0odHJhbnNmb3JtTG9nLCB0cmFuc2Zvcm1FeHApO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5iYXNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGJhc2UgPSArXywgcmVzY2FsZSgpKSA6IGJhc2U7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbihfKSwgcmVzY2FsZSgpKSA6IGRvbWFpbigpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICB1ID0gZFswXSxcbiAgICAgICAgdiA9IGRbZC5sZW5ndGggLSAxXSxcbiAgICAgICAgcjtcblxuICAgIGlmIChyID0gdiA8IHUpIGkgPSB1LCB1ID0gdiwgdiA9IGk7XG5cbiAgICB2YXIgaSA9IGxvZ3ModSksXG4gICAgICAgIGogPSBsb2dzKHYpLFxuICAgICAgICBwLFxuICAgICAgICBrLFxuICAgICAgICB0LFxuICAgICAgICBuID0gY291bnQgPT0gbnVsbCA/IDEwIDogK2NvdW50LFxuICAgICAgICB6ID0gW107XG5cbiAgICBpZiAoIShiYXNlICUgMSkgJiYgaiAtIGkgPCBuKSB7XG4gICAgICBpID0gTWF0aC5yb3VuZChpKSAtIDEsIGogPSBNYXRoLnJvdW5kKGopICsgMTtcbiAgICAgIGlmICh1ID4gMCkgZm9yICg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgZm9yIChrID0gMSwgcCA9IHBvd3MoaSk7IGsgPCBiYXNlOyArK2spIHtcbiAgICAgICAgICB0ID0gcCAqIGs7XG4gICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgIHoucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGZvciAoayA9IGJhc2UgLSAxLCBwID0gcG93cyhpKTsgayA+PSAxOyAtLWspIHtcbiAgICAgICAgICB0ID0gcCAqIGs7XG4gICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgIHoucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gdGlja3MoaSwgaiwgTWF0aC5taW4oaiAtIGksIG4pKS5tYXAocG93cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHIgPyB6LnJldmVyc2UoKSA6IHo7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICBpZiAoc3BlY2lmaWVyID09IG51bGwpIHNwZWNpZmllciA9IGJhc2UgPT09IDEwID8gXCIuMGVcIiA6IFwiLFwiO1xuICAgIGlmICh0eXBlb2Ygc3BlY2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHNwZWNpZmllciA9IGZvcm1hdChzcGVjaWZpZXIpO1xuICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHJldHVybiBzcGVjaWZpZXI7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG4gICAgdmFyIGsgPSBNYXRoLm1heCgxLCBiYXNlICogY291bnQgLyBzY2FsZS50aWNrcygpLmxlbmd0aCk7IC8vIFRPRE8gZmFzdCBlc3RpbWF0ZT9cbiAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIGkgPSBkIC8gcG93cyhNYXRoLnJvdW5kKGxvZ3MoZCkpKTtcbiAgICAgIGlmIChpICogYmFzZSA8IGJhc2UgLSAwLjUpIGkgKj0gYmFzZTtcbiAgICAgIHJldHVybiBpIDw9IGsgPyBzcGVjaWZpZXIoZCkgOiBcIlwiO1xuICAgIH07XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb21haW4obmljZShkb21haW4oKSwge1xuICAgICAgZmxvb3I6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5mbG9vcihsb2dzKHgpKSk7IH0sXG4gICAgICBjZWlsOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguY2VpbChsb2dzKHgpKSk7IH1cbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsb2coKSB7XG4gIHZhciBzY2FsZSA9IGxvZ2dpc2godHJhbnNmb3JtZXIoKSkuZG9tYWluKFsxLCAxMF0pO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZG9tYWluLCBpbnRlcnZhbCkge1xuICBkb21haW4gPSBkb21haW4uc2xpY2UoKTtcblxuICB2YXIgaTAgPSAwLFxuICAgICAgaTEgPSBkb21haW4ubGVuZ3RoIC0gMSxcbiAgICAgIHgwID0gZG9tYWluW2kwXSxcbiAgICAgIHgxID0gZG9tYWluW2kxXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHgxIDwgeDApIHtcbiAgICB0ID0gaTAsIGkwID0gaTEsIGkxID0gdDtcbiAgICB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgfVxuXG4gIGRvbWFpbltpMF0gPSBpbnRlcnZhbC5mbG9vcih4MCk7XG4gIGRvbWFpbltpMV0gPSBpbnRlcnZhbC5jZWlsKHgxKTtcbiAgcmV0dXJuIGRvbWFpbjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuICt4O1xufVxuIiwiaW1wb3J0IHttYXB9IGZyb20gXCJkMy1jb2xsZWN0aW9uXCI7XG5pbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IHZhciBpbXBsaWNpdCA9IHtuYW1lOiBcImltcGxpY2l0XCJ9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRpbmFsKCkge1xuICB2YXIgaW5kZXggPSBtYXAoKSxcbiAgICAgIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHVua25vd24gPSBpbXBsaWNpdDtcblxuICBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgdmFyIGtleSA9IGQgKyBcIlwiLCBpID0gaW5kZXguZ2V0KGtleSk7XG4gICAgaWYgKCFpKSB7XG4gICAgICBpZiAodW5rbm93biAhPT0gaW1wbGljaXQpIHJldHVybiB1bmtub3duO1xuICAgICAgaW5kZXguc2V0KGtleSwgaSA9IGRvbWFpbi5wdXNoKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlWyhpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IG1hcCgpO1xuICAgIHZhciBpID0gLTEsIG4gPSBfLmxlbmd0aCwgZCwga2V5O1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWluZGV4LmhhcyhrZXkgPSAoZCA9IF9baV0pICsgXCJcIikpIGluZGV4LnNldChrZXksIGRvbWFpbi5wdXNoKGQpKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvcmRpbmFsKGRvbWFpbiwgcmFuZ2UpLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cbiIsImltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7Y29weSwgaWRlbnRpdHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb3coZXhwb25lbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCA8IDAgPyAtTWF0aC5wb3coLXgsIGV4cG9uZW50KSA6IE1hdGgucG93KHgsIGV4cG9uZW50KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3FydCh4KSB7XG4gIHJldHVybiB4IDwgMCA/IC1NYXRoLnNxcnQoLXgpIDogTWF0aC5zcXJ0KHgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcXVhcmUoeCkge1xuICByZXR1cm4geCA8IDAgPyAteCAqIHggOiB4ICogeDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvd2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIHNjYWxlID0gdHJhbnNmb3JtKGlkZW50aXR5LCBpZGVudGl0eSksXG4gICAgICBleHBvbmVudCA9IDE7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICByZXR1cm4gZXhwb25lbnQgPT09IDEgPyB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KVxuICAgICAgICA6IGV4cG9uZW50ID09PSAwLjUgPyB0cmFuc2Zvcm0odHJhbnNmb3JtU3FydCwgdHJhbnNmb3JtU3F1YXJlKVxuICAgICAgICA6IHRyYW5zZm9ybSh0cmFuc2Zvcm1Qb3coZXhwb25lbnQpLCB0cmFuc2Zvcm1Qb3coMSAvIGV4cG9uZW50KSk7XG4gIH1cblxuICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHBvbmVudCA9ICtfLCByZXNjYWxlKCkpIDogZXhwb25lbnQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgcG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXJ0KCkge1xuICByZXR1cm4gcG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbiIsImltcG9ydCB7YXNjZW5kaW5nLCBiaXNlY3QsIHF1YW50aWxlIGFzIHRocmVzaG9sZH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpbGUoKSB7XG4gIHZhciBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB0aHJlc2hvbGRzID0gW10sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gTWF0aC5tYXgoMSwgcmFuZ2UubGVuZ3RoKTtcbiAgICB0aHJlc2hvbGRzID0gbmV3IEFycmF5KG4gLSAxKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGhyZXNob2xkc1tpIC0gMV0gPSB0aHJlc2hvbGQoZG9tYWluLCBpIC8gbik7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IHJhbmdlW2Jpc2VjdCh0aHJlc2hvbGRzLCB4KV07XG4gIH1cblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl0gOiBbXG4gICAgICBpID4gMCA/IHRocmVzaG9sZHNbaSAtIDFdIDogZG9tYWluWzBdLFxuICAgICAgaSA8IHRocmVzaG9sZHMubGVuZ3RoID8gdGhyZXNob2xkc1tpXSA6IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV1cbiAgICBdO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IF8ubGVuZ3RoLCBkOyBpIDwgbjsgKytpKSBpZiAoZCA9IF9baV0sIGQgIT0gbnVsbCAmJiAhaXNOYU4oZCA9ICtkKSkgZG9tYWluLnB1c2goZCk7XG4gICAgZG9tYWluLnNvcnQoYXNjZW5kaW5nKTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkcy5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpbGUoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YW50aXplKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAxLFxuICAgICAgbiA9IDEsXG4gICAgICBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPD0geCA/IHJhbmdlW2Jpc2VjdChkb21haW4sIHgsIDAsIG4pXSA6IHVua25vd247XG4gIH1cblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gLTE7XG4gICAgZG9tYWluID0gbmV3IEFycmF5KG4pO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkb21haW5baV0gPSAoKGkgKyAxKSAqIHgxIC0gKGkgLSBuKSAqIHgwKSAvIChuICsgMSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF0sIHgxID0gK19bMV0sIHJlc2NhbGUoKSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gKHJhbmdlID0gc2xpY2UuY2FsbChfKSkubGVuZ3RoIC0gMSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gaSA8IDAgPyBbTmFOLCBOYU5dXG4gICAgICAgIDogaSA8IDEgPyBbeDAsIGRvbWFpblswXV1cbiAgICAgICAgOiBpID49IG4gPyBbZG9tYWluW24gLSAxXSwgeDFdXG4gICAgICAgIDogW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUudGhyZXNob2xkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aXplKClcbiAgICAgICAgLmRvbWFpbihbeDAsIHgxXSlcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KGxpbmVhcmlzaChzY2FsZSksIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7bG9nZ2lzaH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQge3N5bWxvZ2lzaH0gZnJvbSBcIi4vc3ltbG9nXCI7XG5pbXBvcnQge3Bvd2lzaH0gZnJvbSBcIi4vcG93XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAxLFxuICAgICAgdDAsXG4gICAgICB0MSxcbiAgICAgIGsxMCxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIGludGVycG9sYXRvciA9IGlkZW50aXR5LFxuICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IGludGVycG9sYXRvcihrMTAgPT09IDAgPyAwLjUgOiAoeCA9ICh0cmFuc2Zvcm0oeCkgLSB0MCkgKiBrMTAsIGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeCkpIDogeCkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQwID0gdHJhbnNmb3JtKHgwID0gK19bMF0pLCB0MSA9IHRyYW5zZm9ybSh4MSA9ICtfWzFdKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDEgLyAodDEgLSB0MCksIHNjYWxlKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCBzY2FsZSkgOiBjbGFtcDtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB0MCA9IHQoeDApLCB0MSA9IHQoeDEpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMSAvICh0MSAtIHQwKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLmludGVycG9sYXRvcihzb3VyY2UuaW50ZXJwb2xhdG9yKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpXG4gICAgICAudW5rbm93bihzb3VyY2UudW5rbm93bigpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2VxdWVudGlhbCgpIHtcbiAgdmFyIHNjYWxlID0gbGluZWFyaXNoKHRyYW5zZm9ybWVyKCkoaWRlbnRpdHkpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWwoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsTG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyKCkpLmRvbWFpbihbMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxMb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbFN5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc2VxdWVudGlhbFN5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbnRpYWxQb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxQb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsU3FydCgpIHtcbiAgcmV0dXJuIHNlcXVlbnRpYWxQb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmcsIGJpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2VxdWVudGlhbFF1YW50aWxlKCkge1xuICB2YXIgZG9tYWluID0gW10sXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgaWYgKCFpc05hTih4ID0gK3gpKSByZXR1cm4gaW50ZXJwb2xhdG9yKChiaXNlY3QoZG9tYWluLCB4KSAtIDEpIC8gKGRvbWFpbi5sZW5ndGggLSAxKSk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBfLmxlbmd0aCwgZDsgaSA8IG47ICsraSkgaWYgKGQgPSBfW2ldLCBkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgIGRvbWFpbi5zb3J0KGFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZXF1ZW50aWFsUXVhbnRpbGUoaW50ZXJwb2xhdG9yKS5kb21haW4oZG9tYWluKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7Y29weSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWxvZyhjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGgubG9nMXAoTWF0aC5hYnMoeCAvIGMpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3ltZXhwKGMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHgpICogTWF0aC5leHBtMShNYXRoLmFicyh4KSkgKiBjO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ltbG9naXNoKHRyYW5zZm9ybSkge1xuICB2YXIgYyA9IDEsIHNjYWxlID0gdHJhbnNmb3JtKHRyYW5zZm9ybVN5bWxvZyhjKSwgdHJhbnNmb3JtU3ltZXhwKGMpKTtcblxuICBzY2FsZS5jb25zdGFudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TeW1sb2coYyA9ICtfKSwgdHJhbnNmb3JtU3ltZXhwKGMpKSA6IGM7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc3ltbG9nKCkpLmNvbnN0YW50KHNjYWxlLmNvbnN0YW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGhyZXNob2xkKCkge1xuICB2YXIgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHVua25vd24sXG4gICAgICBuID0gMTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPD0geCA/IHJhbmdlW2Jpc2VjdChkb21haW4sIHgsIDAsIG4pXSA6IHVua25vd247XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gc2xpY2UuY2FsbChfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlLmNhbGwoXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7dGlja1N0ZXB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtmb3JtYXQsIGZvcm1hdFByZWZpeCwgZm9ybWF0U3BlY2lmaWVyLCBwcmVjaXNpb25GaXhlZCwgcHJlY2lzaW9uUHJlZml4LCBwcmVjaXNpb25Sb3VuZH0gZnJvbSBcImQzLWZvcm1hdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGFydCwgc3RvcCwgY291bnQsIHNwZWNpZmllcikge1xuICB2YXIgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCksXG4gICAgICBwcmVjaXNpb247XG4gIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIgPT0gbnVsbCA/IFwiLGZcIiA6IHNwZWNpZmllcik7XG4gIHN3aXRjaCAoc3BlY2lmaWVyLnR5cGUpIHtcbiAgICBjYXNlIFwic1wiOiB7XG4gICAgICB2YXIgdmFsdWUgPSBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKTtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgICAgcmV0dXJuIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgY2FzZSBcIlwiOlxuICAgIGNhc2UgXCJlXCI6XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwicFwiOlxuICAgIGNhc2UgXCJyXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblJvdW5kKHN0ZXAsIE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiZVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZlwiOlxuICAgIGNhc2UgXCIlXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvbkZpeGVkKHN0ZXApKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCIlXCIpICogMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0KHNwZWNpZmllcik7XG59XG4iLCJpbXBvcnQge2Jpc2VjdG9yLCB0aWNrU3RlcH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3RpbWVZZWFyLCB0aW1lTW9udGgsIHRpbWVXZWVrLCB0aW1lRGF5LCB0aW1lSG91ciwgdGltZU1pbnV0ZSwgdGltZVNlY29uZCwgdGltZU1pbGxpc2Vjb25kfSBmcm9tIFwiZDMtdGltZVwiO1xuaW1wb3J0IHt0aW1lRm9ybWF0fSBmcm9tIFwiZDMtdGltZS1mb3JtYXRcIjtcbmltcG9ydCB7bWFwfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IGNvbnRpbnVvdXMsIHtjb3B5LCBpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCBuaWNlIGZyb20gXCIuL25pY2VcIjtcblxudmFyIGR1cmF0aW9uU2Vjb25kID0gMTAwMCxcbiAgICBkdXJhdGlvbk1pbnV0ZSA9IGR1cmF0aW9uU2Vjb25kICogNjAsXG4gICAgZHVyYXRpb25Ib3VyID0gZHVyYXRpb25NaW51dGUgKiA2MCxcbiAgICBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0LFxuICAgIGR1cmF0aW9uV2VlayA9IGR1cmF0aW9uRGF5ICogNyxcbiAgICBkdXJhdGlvbk1vbnRoID0gZHVyYXRpb25EYXkgKiAzMCxcbiAgICBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcblxuZnVuY3Rpb24gZGF0ZSh0KSB7XG4gIHJldHVybiBuZXcgRGF0ZSh0KTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBEYXRlID8gK3QgOiArbmV3IERhdGUoK3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cyhpZGVudGl0eSwgaWRlbnRpdHkpLFxuICAgICAgaW52ZXJ0ID0gc2NhbGUuaW52ZXJ0LFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHZhciBmb3JtYXRNaWxsaXNlY29uZCA9IGZvcm1hdChcIi4lTFwiKSxcbiAgICAgIGZvcm1hdFNlY29uZCA9IGZvcm1hdChcIjolU1wiKSxcbiAgICAgIGZvcm1hdE1pbnV0ZSA9IGZvcm1hdChcIiVJOiVNXCIpLFxuICAgICAgZm9ybWF0SG91ciA9IGZvcm1hdChcIiVJICVwXCIpLFxuICAgICAgZm9ybWF0RGF5ID0gZm9ybWF0KFwiJWEgJWRcIiksXG4gICAgICBmb3JtYXRXZWVrID0gZm9ybWF0KFwiJWIgJWRcIiksXG4gICAgICBmb3JtYXRNb250aCA9IGZvcm1hdChcIiVCXCIpLFxuICAgICAgZm9ybWF0WWVhciA9IGZvcm1hdChcIiVZXCIpO1xuXG4gIHZhciB0aWNrSW50ZXJ2YWxzID0gW1xuICAgIFtzZWNvbmQsICAxLCAgICAgIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAgNSwgIDUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgMTUsIDE1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDMwLCAzMCAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbbWludXRlLCAgMSwgICAgICBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgIDUsICA1ICogZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsIDE1LCAxNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAzMCwgMzAgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgWyAgaG91ciwgIDEsICAgICAgZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsICAzLCAgMyAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgNiwgIDYgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgMTIsIDEyICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgICBkYXksICAxLCAgICAgIGR1cmF0aW9uRGF5ICAgXSxcbiAgICBbICAgZGF5LCAgMiwgIDIgKiBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgd2VlaywgIDEsICAgICAgZHVyYXRpb25XZWVrICBdLFxuICAgIFsgbW9udGgsICAxLCAgICAgIGR1cmF0aW9uTW9udGggXSxcbiAgICBbIG1vbnRoLCAgMywgIDMgKiBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyAgeWVhciwgIDEsICAgICAgZHVyYXRpb25ZZWFyICBdXG4gIF07XG5cbiAgZnVuY3Rpb24gdGlja0Zvcm1hdChkYXRlKSB7XG4gICAgcmV0dXJuIChzZWNvbmQoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWlsbGlzZWNvbmRcbiAgICAgICAgOiBtaW51dGUoZGF0ZSkgPCBkYXRlID8gZm9ybWF0U2Vjb25kXG4gICAgICAgIDogaG91cihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkYXkoZGF0ZSkgPCBkYXRlID8gZm9ybWF0SG91clxuICAgICAgICA6IG1vbnRoKGRhdGUpIDwgZGF0ZSA/ICh3ZWVrKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXG4gICAgICAgIDogeWVhcihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNb250aFxuICAgICAgICA6IGZvcm1hdFllYXIpKGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGlja0ludGVydmFsKGludGVydmFsLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChpbnRlcnZhbCA9PSBudWxsKSBpbnRlcnZhbCA9IDEwO1xuXG4gICAgLy8gSWYgYSBkZXNpcmVkIHRpY2sgY291bnQgaXMgc3BlY2lmaWVkLCBwaWNrIGEgcmVhc29uYWJsZSB0aWNrIGludGVydmFsXG4gICAgLy8gYmFzZWQgb24gdGhlIGV4dGVudCBvZiB0aGUgZG9tYWluIGFuZCBhIHJvdWdoIGVzdGltYXRlIG9mIHRpY2sgc2l6ZS5cbiAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpbnRlcnZhbCBpcyBhbHJlYWR5IGEgdGltZSBpbnRlcnZhbCBhbmQgdXNlIGl0LlxuICAgIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gaW50ZXJ2YWwsXG4gICAgICAgICAgaSA9IGJpc2VjdG9yKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGlbMl07IH0pLnJpZ2h0KHRpY2tJbnRlcnZhbHMsIHRhcmdldCk7XG4gICAgICBpZiAoaSA9PT0gdGlja0ludGVydmFscy5sZW5ndGgpIHtcbiAgICAgICAgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0IC8gZHVyYXRpb25ZZWFyLCBzdG9wIC8gZHVyYXRpb25ZZWFyLCBpbnRlcnZhbCk7XG4gICAgICAgIGludGVydmFsID0geWVhcjtcbiAgICAgIH0gZWxzZSBpZiAoaSkge1xuICAgICAgICBpID0gdGlja0ludGVydmFsc1t0YXJnZXQgLyB0aWNrSW50ZXJ2YWxzW2kgLSAxXVsyXSA8IHRpY2tJbnRlcnZhbHNbaV1bMl0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgICAgICBzdGVwID0gaVsxXTtcbiAgICAgICAgaW50ZXJ2YWwgPSBpWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcCA9IE1hdGgubWF4KHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBpbnRlcnZhbCksIDEpO1xuICAgICAgICBpbnRlcnZhbCA9IG1pbGxpc2Vjb25kO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGVwID09IG51bGwgPyBpbnRlcnZhbCA6IGludGVydmFsLmV2ZXJ5KHN0ZXApO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShpbnZlcnQoeSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRvbWFpbihtYXAuY2FsbChfLCBudW1iZXIpKSA6IGRvbWFpbigpLm1hcChkYXRlKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGludGVydmFsLCBzdGVwKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgdDAgPSBkWzBdLFxuICAgICAgICB0MSA9IGRbZC5sZW5ndGggLSAxXSxcbiAgICAgICAgciA9IHQxIDwgdDAsXG4gICAgICAgIHQ7XG4gICAgaWYgKHIpIHQgPSB0MCwgdDAgPSB0MSwgdDEgPSB0O1xuICAgIHQgPSB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIHQwLCB0MSwgc3RlcCk7XG4gICAgdCA9IHQgPyB0LnJhbmdlKHQwLCB0MSArIDEpIDogW107IC8vIGluY2x1c2l2ZSBzdG9wXG4gICAgcmV0dXJuIHIgPyB0LnJldmVyc2UoKSA6IHQ7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyID09IG51bGwgPyB0aWNrRm9ybWF0IDogZm9ybWF0KHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGludGVydmFsLCBzdGVwKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gKGludGVydmFsID0gdGlja0ludGVydmFsKGludGVydmFsLCBkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIHN0ZXApKVxuICAgICAgICA/IGRvbWFpbihuaWNlKGQsIGludGVydmFsKSlcbiAgICAgICAgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGNhbGVuZGFyKHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZm9ybWF0KSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShjYWxlbmRhcih0aW1lWWVhciwgdGltZU1vbnRoLCB0aW1lV2VlaywgdGltZURheSwgdGltZUhvdXIsIHRpbWVNaW51dGUsIHRpbWVTZWNvbmQsIHRpbWVNaWxsaXNlY29uZCwgdGltZUZvcm1hdCkuZG9tYWluKFtuZXcgRGF0ZSgyMDAwLCAwLCAxKSwgbmV3IERhdGUoMjAwMCwgMCwgMildKSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7Y2FsZW5kYXJ9IGZyb20gXCIuL3RpbWVcIjtcbmltcG9ydCB7dXRjRm9ybWF0fSBmcm9tIFwiZDMtdGltZS1mb3JtYXRcIjtcbmltcG9ydCB7dXRjWWVhciwgdXRjTW9udGgsIHV0Y1dlZWssIHV0Y0RheSwgdXRjSG91ciwgdXRjTWludXRlLCB1dGNTZWNvbmQsIHV0Y01pbGxpc2Vjb25kfSBmcm9tIFwiZDMtdGltZVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoY2FsZW5kYXIodXRjWWVhciwgdXRjTW9udGgsIHV0Y1dlZWssIHV0Y0RheSwgdXRjSG91ciwgdXRjTWludXRlLCB1dGNTZWNvbmQsIHV0Y01pbGxpc2Vjb25kLCB1dGNGb3JtYXQpLmRvbWFpbihbRGF0ZS5VVEMoMjAwMCwgMCwgMSksIERhdGUuVVRDKDIwMDAsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuL2NyZWF0b3JcIjtcbmltcG9ydCBzZWxlY3QgZnJvbSBcIi4vc2VsZWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHNlbGVjdChjcmVhdG9yKG5hbWUpLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSk7XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gXCIuL25hbWVzcGFjZVwiO1xuaW1wb3J0IHt4aHRtbH0gZnJvbSBcIi4vbmFtZXNwYWNlc1wiO1xuXG5mdW5jdGlvbiBjcmVhdG9ySW5oZXJpdChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIHVyaSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgIHJldHVybiB1cmkgPT09IHhodG1sICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IHhodG1sXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxuICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh1cmksIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdG9yRml4ZWQoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gKGZ1bGxuYW1lLmxvY2FsXG4gICAgICA/IGNyZWF0b3JGaXhlZFxuICAgICAgOiBjcmVhdG9ySW5oZXJpdCkoZnVsbG5hbWUpO1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGNyZWF0ZX0gZnJvbSBcIi4vY3JlYXRlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3JlYXRvcn0gZnJvbSBcIi4vY3JlYXRvclwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGxvY2FsfSBmcm9tIFwiLi9sb2NhbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1hdGNoZXJ9IGZyb20gXCIuL21hdGNoZXJcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtb3VzZX0gZnJvbSBcIi4vbW91c2VcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBuYW1lc3BhY2V9IGZyb20gXCIuL25hbWVzcGFjZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG5hbWVzcGFjZXN9IGZyb20gXCIuL25hbWVzcGFjZXNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjbGllbnRQb2ludH0gZnJvbSBcIi4vcG9pbnRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3R9IGZyb20gXCIuL3NlbGVjdFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdEFsbH0gZnJvbSBcIi4vc2VsZWN0QWxsXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0aW9ufSBmcm9tIFwiLi9zZWxlY3Rpb24vaW5kZXhcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3Rvcn0gZnJvbSBcIi4vc2VsZWN0b3JcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3RvckFsbH0gZnJvbSBcIi4vc2VsZWN0b3JBbGxcIjtcbmV4cG9ydCB7c3R5bGVWYWx1ZSBhcyBzdHlsZX0gZnJvbSBcIi4vc2VsZWN0aW9uL3N0eWxlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdG91Y2h9IGZyb20gXCIuL3RvdWNoXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdG91Y2hlc30gZnJvbSBcIi4vdG91Y2hlc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHdpbmRvd30gZnJvbSBcIi4vd2luZG93XCI7XG5leHBvcnQge2V2ZW50LCBjdXN0b21FdmVudH0gZnJvbSBcIi4vc2VsZWN0aW9uL29uXCI7XG4iLCJ2YXIgbmV4dElkID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9jYWwoKSB7XG4gIHJldHVybiBuZXcgTG9jYWw7XG59XG5cbmZ1bmN0aW9uIExvY2FsKCkge1xuICB0aGlzLl8gPSBcIkBcIiArICgrK25leHRJZCkudG9TdHJpbmcoMzYpO1xufVxuXG5Mb2NhbC5wcm90b3R5cGUgPSBsb2NhbC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMb2NhbCxcbiAgZ2V0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5fO1xuICAgIHdoaWxlICghKGlkIGluIG5vZGUpKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICAgIHJldHVybiBub2RlW2lkXTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xuICAgIHJldHVybiBub2RlW3RoaXMuX10gPSB2YWx1ZTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuXyBpbiBub2RlICYmIGRlbGV0ZSBub2RlW3RoaXMuX107XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufVxuIiwiaW1wb3J0IHNvdXJjZUV2ZW50IGZyb20gXCIuL3NvdXJjZUV2ZW50XCI7XG5pbXBvcnQgcG9pbnQgZnJvbSBcIi4vcG9pbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSkge1xuICB2YXIgZXZlbnQgPSBzb3VyY2VFdmVudCgpO1xuICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIGV2ZW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gIHJldHVybiBwb2ludChub2RlLCBldmVudCk7XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlcyBmcm9tIFwiLi9uYW1lc3BhY2VzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHByZWZpeCA9IG5hbWUgKz0gXCJcIiwgaSA9IHByZWZpeC5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICByZXR1cm4gbmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge3NwYWNlOiBuYW1lc3BhY2VzW3ByZWZpeF0sIGxvY2FsOiBuYW1lfSA6IG5hbWU7XG59XG4iLCJleHBvcnQgdmFyIHhodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHhodG1sOiB4aHRtbCxcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBldmVudCkge1xuICB2YXIgc3ZnID0gbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgbm9kZTtcblxuICBpZiAoc3ZnLmNyZWF0ZVNWR1BvaW50KSB7XG4gICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFgsIHBvaW50LnkgPSBldmVudC5jbGllbnRZO1xuICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKG5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xuICB9XG5cbiAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gW2V2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBub2RlLmNsaWVudExlZnQsIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIG5vZGUuY2xpZW50VG9wXTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9uLCByb290fSBmcm9tIFwiLi9zZWxlY3Rpb24vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcildXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW1tzZWxlY3Rvcl1dLCByb290KTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9uLCByb290fSBmcm9tIFwiLi9zZWxlY3Rpb24vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFtzZWxlY3RvciA9PSBudWxsID8gW10gOiBzZWxlY3Rvcl0sIHJvb3QpO1xufVxuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3JcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9KTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSBcIi4uL25hbWVzcGFjZVwiO1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICByZXR1cm4gZnVsbG5hbWUubG9jYWxcbiAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcbiAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZnVuY3Rpb24gY2xhc3NBcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xufVxuXG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSkge1xuICByZXR1cm4gbm9kZS5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChub2RlKTtcbn1cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KG5vZGUpIHtcbiAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gIHRoaXMuX25hbWVzID0gY2xhc3NBcnJheShub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xufVxuXG5DbGFzc0xpc3QucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fbmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpID49IDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNsYXNzZWRBZGQobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QuYWRkKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFJlbW92ZShub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5yZW1vdmUobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZEFkZCh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGYWxzZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZFJlbW92ZSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbihuYW1lcywgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gY2xhc3NBcnJheShuYW1lICsgXCJcIik7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghbGlzdC5jb250YWlucyhuYW1lc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGNsYXNzZWRGdW5jdGlvbiA6IHZhbHVlXG4gICAgICA/IGNsYXNzZWRUcnVlXG4gICAgICA6IGNsYXNzZWRGYWxzZSkobmFtZXMsIHZhbHVlKSk7XG59XG4iLCJmdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KCkge1xuICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZShmYWxzZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZURlZXAoKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKHRydWUpLCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHRTaWJsaW5nKSA6IGNsb25lO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWVwKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChkZWVwID8gc2VsZWN0aW9uX2Nsb25lRGVlcCA6IHNlbGVjdGlvbl9jbG9uZVNoYWxsb3cpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQge0VudGVyTm9kZX0gZnJvbSBcIi4vZW50ZXJcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi4vY29uc3RhbnRcIjtcblxudmFyIGtleVByZWZpeCA9IFwiJFwiOyAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSB7fSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAga2V5VmFsdWVzID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKSxcbiAgICAgIGtleVZhbHVlO1xuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBub2RlLlxuICAvLyBJZiBtdWx0aXBsZSBub2RlcyBoYXZlIHRoZSBzYW1lIGtleSwgdGhlIGR1cGxpY2F0ZXMgYXJlIGFkZGVkIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgICBpZiAoa2V5VmFsdWUgaW4gbm9kZUJ5S2V5VmFsdWUpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBkYXR1bS5cbiAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cbiAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlW2tleVZhbHVlc1tpXV0gPT09IG5vZGUpKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgZGF0YSA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGogPSAtMTtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oZCkgeyBkYXRhWysral0gPSBkOyB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgZm9yICh2YXIgbSA9IGdyb3Vwcy5sZW5ndGgsIHVwZGF0ZSA9IG5ldyBBcnJheShtKSwgZW50ZXIgPSBuZXcgQXJyYXkobSksIGV4aXQgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgICAgZGF0YSA9IHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSxcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBlbnRlckdyb3VwID0gZW50ZXJbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIHVwZGF0ZUdyb3VwID0gdXBkYXRlW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICBleGl0R3JvdXAgPSBleGl0W2pdID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKTtcblxuICAgIGJpbmQocGFyZW50LCBncm91cCwgZW50ZXJHcm91cCwgdXBkYXRlR3JvdXAsIGV4aXRHcm91cCwgZGF0YSwga2V5KTtcblxuICAgIC8vIE5vdyBjb25uZWN0IHRoZSBlbnRlciBub2RlcyB0byB0aGVpciBmb2xsb3dpbmcgdXBkYXRlIG5vZGUsIHN1Y2ggdGhhdFxuICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXG4gICAgLy8gcmF0aGVyIHRoYW4gYXQgdGhlIGVuZCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDAsIHByZXZpb3VzLCBuZXh0OyBpMCA8IGRhdGFMZW5ndGg7ICsraTApIHtcbiAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XG4gICAgICAgIGlmIChpMCA+PSBpMSkgaTEgPSBpMCArIDE7XG4gICAgICAgIHdoaWxlICghKG5leHQgPSB1cGRhdGVHcm91cFtpMV0pICYmICsraTEgPCBkYXRhTGVuZ3RoKTtcbiAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlID0gbmV3IFNlbGVjdGlvbih1cGRhdGUsIHBhcmVudHMpO1xuICB1cGRhdGUuX2VudGVyID0gZW50ZXI7XG4gIHVwZGF0ZS5fZXhpdCA9IGV4aXQ7XG4gIHJldHVybiB1cGRhdGU7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3dcIjtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbn1cbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbnRlck5vZGUocGFyZW50LCBkYXR1bSkge1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG59XG5cbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgdGhpcy5fbmV4dCk7IH0sXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9XG59O1xuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2VcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgbWF0Y2hlciBmcm9tIFwiLi4vbWF0Y2hlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gaHRtbEZ1bmN0aW9uXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufVxuIiwiaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGxcIjtcbmltcG9ydCBzZWxlY3Rpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXRhIGZyb20gXCIuL2RhdGFcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW50ZXIgZnJvbSBcIi4vZW50ZXJcIjtcbmltcG9ydCBzZWxlY3Rpb25fZXhpdCBmcm9tIFwiLi9leGl0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX2pvaW4gZnJvbSBcIi4vam9pblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9vcmRlciBmcm9tIFwiLi9vcmRlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zb3J0IGZyb20gXCIuL3NvcnRcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2FsbCBmcm9tIFwiLi9jYWxsXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGVzIGZyb20gXCIuL25vZGVzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGUgZnJvbSBcIi4vbm9kZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zaXplIGZyb20gXCIuL3NpemVcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW1wdHkgZnJvbSBcIi4vZW1wdHlcIjtcbmltcG9ydCBzZWxlY3Rpb25fZWFjaCBmcm9tIFwiLi9lYWNoXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2F0dHIgZnJvbSBcIi4vYXR0clwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9wcm9wZXJ0eSBmcm9tIFwiLi9wcm9wZXJ0eVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbGFzc2VkIGZyb20gXCIuL2NsYXNzZWRcIjtcbmltcG9ydCBzZWxlY3Rpb25fdGV4dCBmcm9tIFwiLi90ZXh0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX2h0bWwgZnJvbSBcIi4vaHRtbFwiO1xuaW1wb3J0IHNlbGVjdGlvbl9yYWlzZSBmcm9tIFwiLi9yYWlzZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9sb3dlciBmcm9tIFwiLi9sb3dlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9hcHBlbmQgZnJvbSBcIi4vYXBwZW5kXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2luc2VydCBmcm9tIFwiLi9pbnNlcnRcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbG9uZSBmcm9tIFwiLi9jbG9uZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXR1bSBmcm9tIFwiLi9kYXR1bVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9vbiBmcm9tIFwiLi9vblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kaXNwYXRjaCBmcm9tIFwiLi9kaXNwYXRjaFwiO1xuXG5leHBvcnQgdmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiBzZWxlY3Rpb25fZmlsdGVyLFxuICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgZXhpdDogc2VsZWN0aW9uX2V4aXQsXG4gIGpvaW46IHNlbGVjdGlvbl9qb2luLFxuICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBjbG9uZTogc2VsZWN0aW9uX2Nsb25lLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZWxlY3Rpb247XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvclwiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3RvclwiO1xuXG5mdW5jdGlvbiBjb25zdGFudE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob25lbnRlciwgb251cGRhdGUsIG9uZXhpdCkge1xuICB2YXIgZW50ZXIgPSB0aGlzLmVudGVyKCksIHVwZGF0ZSA9IHRoaXMsIGV4aXQgPSB0aGlzLmV4aXQoKTtcbiAgZW50ZXIgPSB0eXBlb2Ygb25lbnRlciA9PT0gXCJmdW5jdGlvblwiID8gb25lbnRlcihlbnRlcikgOiBlbnRlci5hcHBlbmQob25lbnRlciArIFwiXCIpO1xuICBpZiAob251cGRhdGUgIT0gbnVsbCkgdXBkYXRlID0gb251cGRhdGUodXBkYXRlKTtcbiAgaWYgKG9uZXhpdCA9PSBudWxsKSBleGl0LnJlbW92ZSgpOyBlbHNlIG9uZXhpdChleGl0KTtcbiAgcmV0dXJuIGVudGVyICYmIHVwZGF0ZSA/IGVudGVyLm1lcmdlKHVwZGF0ZSkub3JkZXIoKSA6IHVwZGF0ZTtcbn1cbiIsImZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKSwgaSA9IC0xO1xuICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IG5vZGVzWysraV0gPSB0aGlzOyB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufVxuIiwidmFyIGZpbHRlckV2ZW50cyA9IHt9O1xuXG5leHBvcnQgdmFyIGV2ZW50ID0gbnVsbDtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKCEoXCJvbm1vdXNlZW50ZXJcIiBpbiBlbGVtZW50KSkge1xuICAgIGZpbHRlckV2ZW50cyA9IHttb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLCBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJ9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlckNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gIGxpc3RlbmVyID0gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApO1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgaWYgKCFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0aGlzICYmICEocmVsYXRlZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzKSAmIDgpKSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQxKSB7XG4gICAgdmFyIGV2ZW50MCA9IGV2ZW50OyAvLyBFdmVudHMgY2FuIGJlIHJlZW50cmFudCAoZS5nLiwgZm9jdXMpLlxuICAgIGV2ZW50ID0gZXZlbnQxO1xuICAgIHRyeSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGluZGV4LCBncm91cCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV2ZW50ID0gZXZlbnQwO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgd3JhcCA9IGZpbHRlckV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlbmFtZS50eXBlKSA/IGZpbHRlckNvbnRleHRMaXN0ZW5lciA6IGNvbnRleHRMaXN0ZW5lcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGksIGdyb3VwKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IHdyYXAodmFsdWUsIGksIGdyb3VwKTtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoKG8gPSBvbltqXSkudHlwZSA9PT0gdHlwZW5hbWUudHlwZSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciA9IGxpc3RlbmVyLCBvLmNhcHR1cmUgPSBjYXB0dXJlKTtcbiAgICAgICAgby52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgbyA9IHt0eXBlOiB0eXBlbmFtZS50eXBlLCBuYW1lOiB0eXBlbmFtZS5uYW1lLCB2YWx1ZTogdmFsdWUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgY2FwdHVyZTogY2FwdHVyZX07XG4gICAgaWYgKCFvbikgdGhpcy5fX29uID0gW29dO1xuICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBpZiAoY2FwdHVyZSA9PSBudWxsKSBjYXB0dXJlID0gZmFsc2U7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBjYXB0dXJlKSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tRXZlbnQoZXZlbnQxLCBsaXN0ZW5lciwgdGhhdCwgYXJncykge1xuICB2YXIgZXZlbnQwID0gZXZlbnQ7XG4gIGV2ZW50MS5zb3VyY2VFdmVudCA9IGV2ZW50O1xuICBldmVudCA9IGV2ZW50MTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0gZmluYWxseSB7XG4gICAgZXZlbnQgPSBldmVudDA7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obmV4dCkgXiA0KSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIHByb3BlcnR5UmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICBlbHNlIHRoaXNbbmFtZV0gPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xufVxuIiwiZnVuY3Rpb24gcmFpc2UoKSB7XG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyZW1vdmUpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgc2VsZWN0b3IgZnJvbSBcIi4uL3NlbGVjdG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgc2VsZWN0b3JBbGwgZnJvbSBcIi4uL3NlbGVjdG9yQWxsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyArK3NpemU7IH0pO1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvd1wiO1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBzdHlsZUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcbiAgICAgIDogc3R5bGVWYWx1ZSh0aGlzLm5vZGUoKSwgbmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxuICAgICAgfHwgZGVmYXVsdFZpZXcobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuIiwiZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn1cbiIsImZ1bmN0aW9uIG5vbmUoKSB7fVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gZW1wdHkgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7ZXZlbnR9IGZyb20gXCIuL3NlbGVjdGlvbi9vblwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGN1cnJlbnQgPSBldmVudCwgc291cmNlO1xuICB3aGlsZSAoc291cmNlID0gY3VycmVudC5zb3VyY2VFdmVudCkgY3VycmVudCA9IHNvdXJjZTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG4iLCJpbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnRcIjtcbmltcG9ydCBwb2ludCBmcm9tIFwiLi9wb2ludFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgaWRlbnRpZmllciA9IHRvdWNoZXMsIHRvdWNoZXMgPSBzb3VyY2VFdmVudCgpLmNoYW5nZWRUb3VjaGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgdG91Y2g7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKHRvdWNoID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIHBvaW50KG5vZGUsIHRvdWNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudFwiO1xuaW1wb3J0IHBvaW50IGZyb20gXCIuL3BvaW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIHRvdWNoZXMpIHtcbiAgaWYgKHRvdWNoZXMgPT0gbnVsbCkgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkudG91Y2hlcztcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMgPyB0b3VjaGVzLmxlbmd0aCA6IDAsIHBvaW50cyA9IG5ldyBBcnJheShuKTsgaSA8IG47ICsraSkge1xuICAgIHBvaW50c1tpXSA9IHBvaW50KG5vZGUsIHRvdWNoZXNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59XG4iLCJpbXBvcnQge3BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCB7YWJzLCBhY29zLCBhc2luLCBhdGFuMiwgY29zLCBlcHNpbG9uLCBoYWxmUGksIG1heCwgbWluLCBwaSwgc2luLCBzcXJ0LCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcblxuZnVuY3Rpb24gYXJjSW5uZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5pbm5lclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjT3V0ZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5vdXRlclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjU3RhcnRBbmdsZShkKSB7XG4gIHJldHVybiBkLnN0YXJ0QW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY0VuZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY1BhZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTsgLy8gTm90ZTogb3B0aW9uYWwhXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIHgxMCA9IHgxIC0geDAsIHkxMCA9IHkxIC0geTAsXG4gICAgICB4MzIgPSB4MyAtIHgyLCB5MzIgPSB5MyAtIHkyLFxuICAgICAgdCA9IHkzMiAqIHgxMCAtIHgzMiAqIHkxMDtcbiAgaWYgKHQgKiB0IDwgZXBzaWxvbikgcmV0dXJuO1xuICB0ID0gKHgzMiAqICh5MCAtIHkyKSAtIHkzMiAqICh4MCAtIHgyKSkgLyB0O1xuICByZXR1cm4gW3gwICsgdCAqIHgxMCwgeTAgKyB0ICogeTEwXTtcbn1cblxuLy8gQ29tcHV0ZSBwZXJwZW5kaWN1bGFyIG9mZnNldCBsaW5lIG9mIGxlbmd0aCByYy5cbi8vIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vQ2lyY2xlLUxpbmVJbnRlcnNlY3Rpb24uaHRtbFxuZnVuY3Rpb24gY29ybmVyVGFuZ2VudHMoeDAsIHkwLCB4MSwgeTEsIHIxLCByYywgY3cpIHtcbiAgdmFyIHgwMSA9IHgwIC0geDEsXG4gICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgbG8gPSAoY3cgPyByYyA6IC1yYykgLyBzcXJ0KHgwMSAqIHgwMSArIHkwMSAqIHkwMSksXG4gICAgICBveCA9IGxvICogeTAxLFxuICAgICAgb3kgPSAtbG8gKiB4MDEsXG4gICAgICB4MTEgPSB4MCArIG94LFxuICAgICAgeTExID0geTAgKyBveSxcbiAgICAgIHgxMCA9IHgxICsgb3gsXG4gICAgICB5MTAgPSB5MSArIG95LFxuICAgICAgeDAwID0gKHgxMSArIHgxMCkgLyAyLFxuICAgICAgeTAwID0gKHkxMSArIHkxMCkgLyAyLFxuICAgICAgZHggPSB4MTAgLSB4MTEsXG4gICAgICBkeSA9IHkxMCAtIHkxMSxcbiAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICByID0gcjEgLSByYyxcbiAgICAgIEQgPSB4MTEgKiB5MTAgLSB4MTAgKiB5MTEsXG4gICAgICBkID0gKGR5IDwgMCA/IC0xIDogMSkgKiBzcXJ0KG1heCgwLCByICogciAqIGQyIC0gRCAqIEQpKSxcbiAgICAgIGN4MCA9IChEICogZHkgLSBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTAgPSAoLUQgKiBkeCAtIGR5ICogZCkgLyBkMixcbiAgICAgIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTEgPSAoLUQgKiBkeCArIGR5ICogZCkgLyBkMixcbiAgICAgIGR4MCA9IGN4MCAtIHgwMCxcbiAgICAgIGR5MCA9IGN5MCAtIHkwMCxcbiAgICAgIGR4MSA9IGN4MSAtIHgwMCxcbiAgICAgIGR5MSA9IGN5MSAtIHkwMDtcblxuICAvLyBQaWNrIHRoZSBjbG9zZXIgb2YgdGhlIHR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAvLyBUT0RPIElzIHRoZXJlIGEgZmFzdGVyIHdheSB0byBkZXRlcm1pbmUgd2hpY2ggaW50ZXJzZWN0aW9uIHRvIHVzZT9cbiAgaWYgKGR4MCAqIGR4MCArIGR5MCAqIGR5MCA+IGR4MSAqIGR4MSArIGR5MSAqIGR5MSkgY3gwID0gY3gxLCBjeTAgPSBjeTE7XG5cbiAgcmV0dXJuIHtcbiAgICBjeDogY3gwLFxuICAgIGN5OiBjeTAsXG4gICAgeDAxOiAtb3gsXG4gICAgeTAxOiAtb3ksXG4gICAgeDExOiBjeDAgKiAocjEgLyByIC0gMSksXG4gICAgeTExOiBjeTAgKiAocjEgLyByIC0gMSlcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBpbm5lclJhZGl1cyA9IGFyY0lubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMgPSBhcmNPdXRlclJhZGl1cyxcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvbnN0YW50KDApLFxuICAgICAgcGFkUmFkaXVzID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBhcmNTdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBhcmNFbmRBbmdsZSxcbiAgICAgIHBhZEFuZ2xlID0gYXJjUGFkQW5nbGUsXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBhcmMoKSB7XG4gICAgdmFyIGJ1ZmZlcixcbiAgICAgICAgcixcbiAgICAgICAgcjAgPSAraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgcjEgPSArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgYTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksXG4gICAgICAgIGExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgZGEgPSBhYnMoYTEgLSBhMCksXG4gICAgICAgIGN3ID0gYTEgPiBhMDtcblxuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBvdXRlciByYWRpdXMgaXMgYWx3YXlzIGxhcmdlciB0aGFuIHRoZSBpbm5lciByYWRpdXMuXG4gICAgaWYgKHIxIDwgcjApIHIgPSByMSwgcjEgPSByMCwgcjAgPSByO1xuXG4gICAgLy8gSXMgaXQgYSBwb2ludD9cbiAgICBpZiAoIShyMSA+IGVwc2lsb24pKSBjb250ZXh0Lm1vdmVUbygwLCAwKTtcblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY2xlIG9yIGFubnVsdXM/XG4gICAgZWxzZSBpZiAoZGEgPiB0YXUgLSBlcHNpbG9uKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhyMSAqIGNvcyhhMCksIHIxICogc2luKGEwKSk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAsIGExLCAhY3cpO1xuICAgICAgaWYgKHIwID4gZXBzaWxvbikge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhyMCAqIGNvcyhhMSksIHIwICogc2luKGExKSk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMSwgYTAsIGN3KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGEwMSA9IGEwLFxuICAgICAgICAgIGExMSA9IGExLFxuICAgICAgICAgIGEwMCA9IGEwLFxuICAgICAgICAgIGExMCA9IGExLFxuICAgICAgICAgIGRhMCA9IGRhLFxuICAgICAgICAgIGRhMSA9IGRhLFxuICAgICAgICAgIGFwID0gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsXG4gICAgICAgICAgcnAgPSAoYXAgPiBlcHNpbG9uKSAmJiAocGFkUmFkaXVzID8gK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc3FydChyMCAqIHIwICsgcjEgKiByMSkpLFxuICAgICAgICAgIHJjID0gbWluKGFicyhyMSAtIHIwKSAvIDIsICtjb3JuZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgICAgcmMwID0gcmMsXG4gICAgICAgICAgcmMxID0gcmMsXG4gICAgICAgICAgdDAsXG4gICAgICAgICAgdDE7XG5cbiAgICAgIC8vIEFwcGx5IHBhZGRpbmc/IE5vdGUgdGhhdCBzaW5jZSByMSDiiaUgcjAsIGRhMSDiiaUgZGEwLlxuICAgICAgaWYgKHJwID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgcDAgPSBhc2luKHJwIC8gcjAgKiBzaW4oYXApKSxcbiAgICAgICAgICAgIHAxID0gYXNpbihycCAvIHIxICogc2luKGFwKSk7XG4gICAgICAgIGlmICgoZGEwIC09IHAwICogMikgPiBlcHNpbG9uKSBwMCAqPSAoY3cgPyAxIDogLTEpLCBhMDAgKz0gcDAsIGExMCAtPSBwMDtcbiAgICAgICAgZWxzZSBkYTAgPSAwLCBhMDAgPSBhMTAgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICBpZiAoKGRhMSAtPSBwMSAqIDIpID4gZXBzaWxvbikgcDEgKj0gKGN3ID8gMSA6IC0xKSwgYTAxICs9IHAxLCBhMTEgLT0gcDE7XG4gICAgICAgIGVsc2UgZGExID0gMCwgYTAxID0gYTExID0gKGEwICsgYTEpIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHgwMSA9IHIxICogY29zKGEwMSksXG4gICAgICAgICAgeTAxID0gcjEgKiBzaW4oYTAxKSxcbiAgICAgICAgICB4MTAgPSByMCAqIGNvcyhhMTApLFxuICAgICAgICAgIHkxMCA9IHIwICogc2luKGExMCk7XG5cbiAgICAgIC8vIEFwcGx5IHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGlmIChyYyA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHgxMSA9IHIxICogY29zKGExMSksXG4gICAgICAgICAgICB5MTEgPSByMSAqIHNpbihhMTEpLFxuICAgICAgICAgICAgeDAwID0gcjAgKiBjb3MoYTAwKSxcbiAgICAgICAgICAgIHkwMCA9IHIwICogc2luKGEwMCksXG4gICAgICAgICAgICBvYztcblxuICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS5cbiAgICAgICAgaWYgKGRhIDwgcGkgJiYgKG9jID0gaW50ZXJzZWN0KHgwMSwgeTAxLCB4MDAsIHkwMCwgeDExLCB5MTEsIHgxMCwgeTEwKSkpIHtcbiAgICAgICAgICB2YXIgYXggPSB4MDEgLSBvY1swXSxcbiAgICAgICAgICAgICAgYXkgPSB5MDEgLSBvY1sxXSxcbiAgICAgICAgICAgICAgYnggPSB4MTEgLSBvY1swXSxcbiAgICAgICAgICAgICAgYnkgPSB5MTEgLSBvY1sxXSxcbiAgICAgICAgICAgICAga2MgPSAxIC8gc2luKGFjb3MoKGF4ICogYnggKyBheSAqIGJ5KSAvIChzcXJ0KGF4ICogYXggKyBheSAqIGF5KSAqIHNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSxcbiAgICAgICAgICAgICAgbGMgPSBzcXJ0KG9jWzBdICogb2NbMF0gKyBvY1sxXSAqIG9jWzFdKTtcbiAgICAgICAgICByYzAgPSBtaW4ocmMsIChyMCAtIGxjKSAvIChrYyAtIDEpKTtcbiAgICAgICAgICByYzEgPSBtaW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJcyB0aGUgc2VjdG9yIGNvbGxhcHNlZCB0byBhIGxpbmU/XG4gICAgICBpZiAoIShkYTEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIG91dGVyIHJpbmcgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzEgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDAwLCB5MDAsIHgwMSwgeTAxLCByMSwgcmMxLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDExLCB5MTEsIHgxMCwgeTEwLCByMSwgcmMxLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMSA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMxLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYXRhbjIodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMSwgYXRhbjIodDEueTExLCB0MS54MTEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIG91dGVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpLCBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAxLCBhMTEsICFjdyk7XG5cbiAgICAgIC8vIElzIHRoZXJlIG5vIGlubmVyIHJpbmcsIGFuZCBpdOKAmXMgYSBjaXJjdWxhciBzZWN0b3I/XG4gICAgICAvLyBPciBwZXJoYXBzIGl04oCZcyBhbiBhbm51bGFyIHNlY3RvciBjb2xsYXBzZWQgZHVlIHRvIHBhZGRpbmc/XG4gICAgICBpZiAoIShyMCA+IGVwc2lsb24pIHx8ICEoZGEwID4gZXBzaWxvbikpIGNvbnRleHQubGluZVRvKHgxMCwgeTEwKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBpbm5lciByaW5nIChvciBwb2ludCkgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzAgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDEwLCB5MTAsIHgxMSwgeTExLCByMCwgLXJjMCwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgwMSwgeTAxLCB4MDAsIHkwMCwgcjAsIC1yYzAsIGN3KTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyh0MC5jeCArIHQwLngwMSwgdDAuY3kgKyB0MC55MDEpO1xuXG4gICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xuICAgICAgICBpZiAocmMwIDwgcmMpIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCBjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzAsIGF0YW4yKHQxLnkxMSwgdDEueDExKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBpbm5lciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMTAsIGEwMCwgY3cpO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGFyYy5jZW50cm9pZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gKCtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMixcbiAgICAgICAgYSA9ICgrc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK2VuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiAtIHBpIC8gMjtcbiAgICByZXR1cm4gW2NvcyhhKSAqIHIsIHNpbihhKSAqIHJdO1xuICB9O1xuXG4gIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogaW5uZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG91dGVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBvdXRlclJhZGl1cztcbiAgfTtcblxuICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvcm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogY29ybmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkUmFkaXVzID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBhcmMpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJjO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyLmpzXCI7XG5pbXBvcnQgbGluZSBmcm9tIFwiLi9saW5lLmpzXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB4MCA9IHBvaW50WCxcbiAgICAgIHgxID0gbnVsbCxcbiAgICAgIHkwID0gY29uc3RhbnQoMCksXG4gICAgICB5MSA9IHBvaW50WSxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICB4MHogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHkweiA9IG5ldyBBcnJheShuKTtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIHtcbiAgICAgICAgICBqID0gaTtcbiAgICAgICAgICBvdXRwdXQuYXJlYVN0YXJ0KCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICAgIGZvciAoayA9IGkgLSAxOyBrID49IGo7IC0taykge1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50KHgweltrXSwgeTB6W2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQuYXJlYUVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIHtcbiAgICAgICAgeDB6W2ldID0gK3gwKGQsIGksIGRhdGEpLCB5MHpbaV0gPSAreTAoZCwgaSwgZGF0YSk7XG4gICAgICAgIG91dHB1dC5wb2ludCh4MSA/ICt4MShkLCBpLCBkYXRhKSA6IHgweltpXSwgeTEgPyAreTEoZCwgaSwgZGF0YSkgOiB5MHpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhbGluZSgpIHtcbiAgICByZXR1cm4gbGluZSgpLmRlZmluZWQoZGVmaW5lZCkuY3VydmUoY3VydmUpLmNvbnRleHQoY29udGV4dCk7XG4gIH1cblxuICBhcmVhLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeDEgPSBudWxsLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgxO1xuICB9O1xuXG4gIGFyZWEueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB5MSA9IG51bGwsIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTE7XG4gIH07XG5cbiAgYXJlYS5saW5lWDAgPVxuICBhcmVhLmxpbmVZMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTApO1xuICB9O1xuXG4gIGFyZWEubGluZVkxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MSk7XG4gIH07XG5cbiAgYXJlYS5saW5lWDEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgxKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgYXJlYSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGFyZWEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgYXJlYSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBhcmVhLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGFyZWEpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJlYTtcbn1cbiIsImltcG9ydCBjdXJ2ZVJhZGlhbCwge2N1cnZlUmFkaWFsTGluZWFyfSBmcm9tIFwiLi9jdXJ2ZS9yYWRpYWwuanNcIjtcbmltcG9ydCBhcmVhIGZyb20gXCIuL2FyZWEuanNcIjtcbmltcG9ydCB7bGluZVJhZGlhbH0gZnJvbSBcIi4vbGluZVJhZGlhbC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGEgPSBhcmVhKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpLFxuICAgICAgYyA9IGEuY3VydmUsXG4gICAgICB4MCA9IGEubGluZVgwLFxuICAgICAgeDEgPSBhLmxpbmVYMSxcbiAgICAgIHkwID0gYS5saW5lWTAsXG4gICAgICB5MSA9IGEubGluZVkxO1xuXG4gIGEuYW5nbGUgPSBhLngsIGRlbGV0ZSBhLng7XG4gIGEuc3RhcnRBbmdsZSA9IGEueDAsIGRlbGV0ZSBhLngwO1xuICBhLmVuZEFuZ2xlID0gYS54MSwgZGVsZXRlIGEueDE7XG4gIGEucmFkaXVzID0gYS55LCBkZWxldGUgYS55O1xuICBhLmlubmVyUmFkaXVzID0gYS55MCwgZGVsZXRlIGEueTA7XG4gIGEub3V0ZXJSYWRpdXMgPSBhLnkxLCBkZWxldGUgYS55MTtcbiAgYS5saW5lU3RhcnRBbmdsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh4MCgpKTsgfSwgZGVsZXRlIGEubGluZVgwO1xuICBhLmxpbmVFbmRBbmdsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh4MSgpKTsgfSwgZGVsZXRlIGEubGluZVgxO1xuICBhLmxpbmVJbm5lclJhZGl1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh5MCgpKTsgfSwgZGVsZXRlIGEubGluZVkwO1xuICBhLmxpbmVPdXRlclJhZGl1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh5MSgpKTsgfSwgZGVsZXRlIGEubGluZVkxO1xuXG4gIGEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjKGN1cnZlUmFkaWFsKF8pKSA6IGMoKS5fY3VydmU7XG4gIH07XG5cbiAgcmV0dXJuIGE7XG59XG4iLCJleHBvcnQgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24gY29uc3RhbnQoKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcG9pbnQodGhhdCwgeCwgeSkge1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgKDIgKiB0aGF0Ll94MCArIHRoYXQuX3gxKSAvIDMsXG4gICAgKDIgKiB0aGF0Ll95MCArIHRoYXQuX3kxKSAvIDMsXG4gICAgKHRoYXQuX3gwICsgMiAqIHRoYXQuX3gxKSAvIDMsXG4gICAgKHRoYXQuX3kwICsgMiAqIHRoYXQuX3kxKSAvIDMsXG4gICAgKHRoYXQuX3gwICsgNCAqIHRoYXQuX3gxICsgeCkgLyA2LFxuICAgICh0aGF0Ll95MCArIDQgKiB0aGF0Ll95MSArIHkpIC8gNlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQmFzaXMoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXMucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDM6IHBvaW50KHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7IC8vIHByb2NlZWRcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9jb250ZXh0LmxpbmVUbygoNSAqIHRoaXMuX3gwICsgdGhpcy5feDEpIC8gNiwgKDUgKiB0aGlzLl95MCArIHRoaXMuX3kxKSAvIDYpOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpcyhjb250ZXh0KTtcbn1cbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuXG5mdW5jdGlvbiBCYXNpc0Nsb3NlZChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpc0Nsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MiArIDIgKiB0aGlzLl94MykgLyAzLCAodGhpcy5feTIgKyAyICogdGhpcy5feTMpIC8gMyk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKCh0aGlzLl94MyArIDIgKiB0aGlzLl94MikgLyAzLCAodGhpcy5feTMgKyAyICogdGhpcy5feTIpIC8gMyk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDIgPSB4LCB0aGlzLl95MiA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geTsgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyB5KSAvIDYpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzQ2xvc2VkKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vYmFzaXMuanNcIjtcblxuZnVuY3Rpb24gQmFzaXNPcGVuKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHZhciB4MCA9ICh0aGlzLl94MCArIDQgKiB0aGlzLl94MSArIHgpIC8gNiwgeTAgPSAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyB5KSAvIDY7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MCwgeTApIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeDAsIHkwKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXNPcGVuKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHtCYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcblxuZnVuY3Rpb24gQnVuZGxlKGNvbnRleHQsIGJldGEpIHtcbiAgdGhpcy5fYmFzaXMgPSBuZXcgQmFzaXMoY29udGV4dCk7XG4gIHRoaXMuX2JldGEgPSBiZXRhO1xufVxuXG5CdW5kbGUucHJvdG90eXBlID0ge1xuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSBbXTtcbiAgICB0aGlzLl95ID0gW107XG4gICAgdGhpcy5fYmFzaXMubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gdGhpcy5feCxcbiAgICAgICAgeSA9IHRoaXMuX3ksXG4gICAgICAgIGogPSB4Lmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoaiA+IDApIHtcbiAgICAgIHZhciB4MCA9IHhbMF0sXG4gICAgICAgICAgeTAgPSB5WzBdLFxuICAgICAgICAgIGR4ID0geFtqXSAtIHgwLFxuICAgICAgICAgIGR5ID0geVtqXSAtIHkwLFxuICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICB0O1xuXG4gICAgICB3aGlsZSAoKytpIDw9IGopIHtcbiAgICAgICAgdCA9IGkgLyBqO1xuICAgICAgICB0aGlzLl9iYXNpcy5wb2ludChcbiAgICAgICAgICB0aGlzLl9iZXRhICogeFtpXSArICgxIC0gdGhpcy5fYmV0YSkgKiAoeDAgKyB0ICogZHgpLFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB5W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh5MCArIHQgKiBkeSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XG4gICAgdGhpcy5fYmFzaXMubGluZUVuZCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuX3gucHVzaCgreCk7XG4gICAgdGhpcy5feS5wdXNoKCt5KTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShiZXRhKSB7XG5cbiAgZnVuY3Rpb24gYnVuZGxlKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYmV0YSA9PT0gMSA/IG5ldyBCYXNpcyhjb250ZXh0KSA6IG5ldyBCdW5kbGUoY29udGV4dCwgYmV0YSk7XG4gIH1cblxuICBidW5kbGUuYmV0YSA9IGZ1bmN0aW9uKGJldGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCtiZXRhKTtcbiAgfTtcblxuICByZXR1cm4gYnVuZGxlO1xufSkoMC44NSk7XG4iLCJleHBvcnQgZnVuY3Rpb24gcG9pbnQodGhhdCwgeCwgeSkge1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgdGhhdC5feDEgKyB0aGF0Ll9rICogKHRoYXQuX3gyIC0gdGhhdC5feDApLFxuICAgIHRoYXQuX3kxICsgdGhhdC5fayAqICh0aGF0Ll95MiAtIHRoYXQuX3kwKSxcbiAgICB0aGF0Ll94MiArIHRoYXQuX2sgKiAodGhhdC5feDEgLSB4KSxcbiAgICB0aGF0Ll95MiArIHRoYXQuX2sgKiAodGhhdC5feTEgLSB5KSxcbiAgICB0aGF0Ll94MixcbiAgICB0aGF0Ll95MlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xufVxuXG5DYXJkaW5hbC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBwb2ludCh0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX3gxID0geCwgdGhpcy5feTEgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSgwKTtcbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXJkaW5hbC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgdGVuc2lvbikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xufVxuXG5DYXJkaW5hbENsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSB0aGlzLl95NSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NSwgdGhpcy5feTUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vY2FyZGluYWwuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENhcmRpbmFsT3Blbihjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSgwKTtcbiIsImltcG9ydCB7ZXBzaWxvbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7Q2FyZGluYWx9IGZyb20gXCIuL2NhcmRpbmFsLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHZhciB4MSA9IHRoYXQuX3gxLFxuICAgICAgeTEgPSB0aGF0Ll95MSxcbiAgICAgIHgyID0gdGhhdC5feDIsXG4gICAgICB5MiA9IHRoYXQuX3kyO1xuXG4gIGlmICh0aGF0Ll9sMDFfYSA+IGVwc2lsb24pIHtcbiAgICB2YXIgYSA9IDIgKiB0aGF0Ll9sMDFfMmEgKyAzICogdGhhdC5fbDAxX2EgKiB0aGF0Ll9sMTJfYSArIHRoYXQuX2wxMl8yYSxcbiAgICAgICAgbiA9IDMgKiB0aGF0Ll9sMDFfYSAqICh0aGF0Ll9sMDFfYSArIHRoYXQuX2wxMl9hKTtcbiAgICB4MSA9ICh4MSAqIGEgLSB0aGF0Ll94MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3gyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gICAgeTEgPSAoeTEgKiBhIC0gdGhhdC5feTAgKiB0aGF0Ll9sMTJfMmEgKyB0aGF0Ll95MiAqIHRoYXQuX2wwMV8yYSkgLyBuO1xuICB9XG5cbiAgaWYgKHRoYXQuX2wyM19hID4gZXBzaWxvbikge1xuICAgIHZhciBiID0gMiAqIHRoYXQuX2wyM18yYSArIDMgKiB0aGF0Ll9sMjNfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBtID0gMyAqIHRoYXQuX2wyM19hICogKHRoYXQuX2wyM19hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgyID0gKHgyICogYiArIHRoYXQuX3gxICogdGhhdC5fbDIzXzJhIC0geCAqIHRoYXQuX2wxMl8yYSkgLyBtO1xuICAgIHkyID0gKHkyICogYiArIHRoYXQuX3kxICogdGhhdC5fbDIzXzJhIC0geSAqIHRoYXQuX2wxMl8yYSkgLyBtO1xuICB9XG5cbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB0aGF0Ll94MiwgdGhhdC5feTIpO1xufVxuXG5mdW5jdGlvbiBDYXRtdWxsUm9tKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLnBvaW50KHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbShjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWwoY29udGV4dCwgMCk7XG4gIH1cblxuICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gIH07XG5cbiAgcmV0dXJuIGNhdG11bGxSb207XG59KSgwLjUpO1xuIiwiaW1wb3J0IHtDYXJkaW5hbENsb3NlZH0gZnJvbSBcIi4vY2FyZGluYWxDbG9zZWQuanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXRtdWxsUm9tLmpzXCI7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21DbG9zZWQoY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb21DbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgMCk7XG4gIH1cblxuICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gIH07XG5cbiAgcmV0dXJuIGNhdG11bGxSb207XG59KSgwLjUpO1xuIiwiaW1wb3J0IHtDYXJkaW5hbE9wZW59IGZyb20gXCIuL2NhcmRpbmFsT3Blbi5qc1wiO1xuaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vY2F0bXVsbFJvbS5qc1wiO1xuXG5mdW5jdGlvbiBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbU9wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbU9wZW4oY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsT3Blbihjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJmdW5jdGlvbiBMaW5lYXIoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxuZnVuY3Rpb24gTGluZWFyQ2xvc2VkKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkxpbmVhckNsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBpZiAodGhpcy5fcG9pbnQpIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGVsc2UgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IExpbmVhckNsb3NlZChjb250ZXh0KTtcbn1cbiIsImZ1bmN0aW9uIHNpZ24oeCkge1xuICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XG59XG5cbi8vIENhbGN1bGF0ZSB0aGUgc2xvcGVzIG9mIHRoZSB0YW5nZW50cyAoSGVybWl0ZS10eXBlIGludGVycG9sYXRpb24pIGJhc2VkIG9uXG4vLyB0aGUgZm9sbG93aW5nIHBhcGVyOiBTdGVmZmVuLCBNLiAxOTkwLiBBIFNpbXBsZSBNZXRob2QgZm9yIE1vbm90b25pY1xuLy8gSW50ZXJwb2xhdGlvbiBpbiBPbmUgRGltZW5zaW9uLiBBc3Ryb25vbXkgYW5kIEFzdHJvcGh5c2ljcywgVm9sLiAyMzksIE5PLlxuLy8gTk9WKElJKSwgUC4gNDQzLCAxOTkwLlxuZnVuY3Rpb24gc2xvcGUzKHRoYXQsIHgyLCB5Mikge1xuICB2YXIgaDAgPSB0aGF0Ll94MSAtIHRoYXQuX3gwLFxuICAgICAgaDEgPSB4MiAtIHRoYXQuX3gxLFxuICAgICAgczAgPSAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyAoaDAgfHwgaDEgPCAwICYmIC0wKSxcbiAgICAgIHMxID0gKHkyIC0gdGhhdC5feTEpIC8gKGgxIHx8IGgwIDwgMCAmJiAtMCksXG4gICAgICBwID0gKHMwICogaDEgKyBzMSAqIGgwKSAvIChoMCArIGgxKTtcbiAgcmV0dXJuIChzaWduKHMwKSArIHNpZ24oczEpKSAqIE1hdGgubWluKE1hdGguYWJzKHMwKSwgTWF0aC5hYnMoczEpLCAwLjUgKiBNYXRoLmFicyhwKSkgfHwgMDtcbn1cblxuLy8gQ2FsY3VsYXRlIGEgb25lLXNpZGVkIHNsb3BlLlxuZnVuY3Rpb24gc2xvcGUyKHRoYXQsIHQpIHtcbiAgdmFyIGggPSB0aGF0Ll94MSAtIHRoYXQuX3gwO1xuICByZXR1cm4gaCA/ICgzICogKHRoYXQuX3kxIC0gdGhhdC5feTApIC8gaCAtIHQpIC8gMiA6IHQ7XG59XG5cbi8vIEFjY29yZGluZyB0byBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19IZXJtaXRlX3NwbGluZSNSZXByZXNlbnRhdGlvbnNcbi8vIFwieW91IGNhbiBleHByZXNzIGN1YmljIEhlcm1pdGUgaW50ZXJwb2xhdGlvbiBpbiB0ZXJtcyBvZiBjdWJpYyBCw6l6aWVyIGN1cnZlc1xuLy8gd2l0aCByZXNwZWN0IHRvIHRoZSBmb3VyIHZhbHVlcyBwMCwgcDAgKyBtMCAvIDMsIHAxIC0gbTEgLyAzLCBwMVwiLlxuZnVuY3Rpb24gcG9pbnQodGhhdCwgdDAsIHQxKSB7XG4gIHZhciB4MCA9IHRoYXQuX3gwLFxuICAgICAgeTAgPSB0aGF0Ll95MCxcbiAgICAgIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgZHggPSAoeDEgLSB4MCkgLyAzO1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDAgKyBkeCwgeTAgKyBkeCAqIHQwLCB4MSAtIGR4LCB5MSAtIGR4ICogdDEsIHgxLCB5MSk7XG59XG5cbmZ1bmN0aW9uIE1vbm90b25lWChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5Nb25vdG9uZVgucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPVxuICAgIHRoaXMuX3QwID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5fdDAsIHNsb3BlMih0aGlzLCB0aGlzLl90MCkpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgdDEgPSBOYU47XG5cbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBpZiAoeCA9PT0gdGhpcy5feDEgJiYgeSA9PT0gdGhpcy5feTEpIHJldHVybjsgLy8gSWdub3JlIGNvaW5jaWRlbnQgcG9pbnRzLlxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgcG9pbnQodGhpcywgc2xvcGUyKHRoaXMsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKSwgdDEpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHRoaXMuX3QwLCB0MSA9IHNsb3BlMyh0aGlzLCB4LCB5KSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gICAgdGhpcy5fdDAgPSB0MTtcbiAgfVxufVxuXG5mdW5jdGlvbiBNb25vdG9uZVkoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gbmV3IFJlZmxlY3RDb250ZXh0KGNvbnRleHQpO1xufVxuXG4oTW9ub3RvbmVZLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9ub3RvbmVYLnByb3RvdHlwZSkpLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICBNb25vdG9uZVgucHJvdG90eXBlLnBvaW50LmNhbGwodGhpcywgeSwgeCk7XG59O1xuXG5mdW5jdGlvbiBSZWZsZWN0Q29udGV4dChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5SZWZsZWN0Q29udGV4dC5wcm90b3R5cGUgPSB7XG4gIG1vdmVUbzogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh5LCB4KTsgfSxcbiAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHsgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTsgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuX2NvbnRleHQubGluZVRvKHksIHgpOyB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkgeyB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oeTEsIHgxLCB5MiwgeDIsIHksIHgpOyB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBNb25vdG9uZVgoY29udGV4dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vdG9uZVkoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE1vbm90b25lWShjb250ZXh0KTtcbn1cbiIsImZ1bmN0aW9uIE5hdHVyYWwoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTmF0dXJhbC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgbiA9IHgubGVuZ3RoO1xuXG4gICAgaWYgKG4pIHtcbiAgICAgIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4WzBdLCB5WzBdKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHhbMF0sIHlbMF0pO1xuICAgICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeFsxXSwgeVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHggPSBjb250cm9sUG9pbnRzKHgpLFxuICAgICAgICAgICAgcHkgPSBjb250cm9sUG9pbnRzKHkpO1xuICAgICAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMTsgaTEgPCBuOyArK2kwLCArK2kxKSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHB4WzBdW2kwXSwgcHlbMF1baTBdLCBweFsxXVtpMF0sIHB5WzFdW2kwXSwgeFtpMV0sIHlbaTFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIG4gPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG4vLyBTZWUgaHR0cHM6Ly93d3cucGFydGljbGVpbmNlbGwuY29tLzIwMTIvYmV6aWVyLXNwbGluZXMvIGZvciBkZXJpdmF0aW9uLlxuZnVuY3Rpb24gY29udHJvbFBvaW50cyh4KSB7XG4gIHZhciBpLFxuICAgICAgbiA9IHgubGVuZ3RoIC0gMSxcbiAgICAgIG0sXG4gICAgICBhID0gbmV3IEFycmF5KG4pLFxuICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkobik7XG4gIGFbMF0gPSAwLCBiWzBdID0gMiwgclswXSA9IHhbMF0gKyAyICogeFsxXTtcbiAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyArK2kpIGFbaV0gPSAxLCBiW2ldID0gNCwgcltpXSA9IDQgKiB4W2ldICsgMiAqIHhbaSArIDFdO1xuICBhW24gLSAxXSA9IDIsIGJbbiAtIDFdID0gNywgcltuIC0gMV0gPSA4ICogeFtuIC0gMV0gKyB4W25dO1xuICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSBtID0gYVtpXSAvIGJbaSAtIDFdLCBiW2ldIC09IG0sIHJbaV0gLT0gbSAqIHJbaSAtIDFdO1xuICBhW24gLSAxXSA9IHJbbiAtIDFdIC8gYltuIC0gMV07XG4gIGZvciAoaSA9IG4gLSAyOyBpID49IDA7IC0taSkgYVtpXSA9IChyW2ldIC0gYVtpICsgMV0pIC8gYltpXTtcbiAgYltuIC0gMV0gPSAoeFtuXSArIGFbbiAtIDFdKSAvIDI7XG4gIGZvciAoaSA9IDA7IGkgPCBuIC0gMTsgKytpKSBiW2ldID0gMiAqIHhbaSArIDFdIC0gYVtpICsgMV07XG4gIHJldHVybiBbYSwgYl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBOYXR1cmFsKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IGN1cnZlTGluZWFyIGZyb20gXCIuL2xpbmVhci5qc1wiO1xuXG5leHBvcnQgdmFyIGN1cnZlUmFkaWFsTGluZWFyID0gY3VydmVSYWRpYWwoY3VydmVMaW5lYXIpO1xuXG5mdW5jdGlvbiBSYWRpYWwoY3VydmUpIHtcbiAgdGhpcy5fY3VydmUgPSBjdXJ2ZTtcbn1cblxuUmFkaWFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5hcmVhU3RhcnQoKTtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUuYXJlYUVuZCgpO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmxpbmVTdGFydCgpO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5saW5lRW5kKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbihhLCByKSB7XG4gICAgdGhpcy5fY3VydmUucG9pbnQociAqIE1hdGguc2luKGEpLCByICogLU1hdGguY29zKGEpKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3VydmVSYWRpYWwoY3VydmUpIHtcblxuICBmdW5jdGlvbiByYWRpYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUmFkaWFsKGN1cnZlKGNvbnRleHQpKTtcbiAgfVxuXG4gIHJhZGlhbC5fY3VydmUgPSBjdXJ2ZTtcblxuICByZXR1cm4gcmFkaWFsO1xufVxuIiwiZnVuY3Rpb24gU3RlcChjb250ZXh0LCB0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl90ID0gdDtcbn1cblxuU3RlcC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoMCA8IHRoaXMuX3QgJiYgdGhpcy5fdCA8IDEgJiYgdGhpcy5fcG9pbnQgPT09IDIpIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBpZiAodGhpcy5fbGluZSA+PSAwKSB0aGlzLl90ID0gMSAtIHRoaXMuX3QsIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuX3QgPD0gMCkge1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHkpO1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB4MSA9IHRoaXMuX3ggKiAoMSAtIHRoaXMuX3QpICsgeCAqIHRoaXMuX3Q7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHRoaXMuX3kpO1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgxLCB5KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5feCA9IHgsIHRoaXMuX3kgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAwLjUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RlcEJlZm9yZShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBBZnRlcihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAxKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICByZXR1cm4gZDtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBhcmN9IGZyb20gXCIuL2FyYy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGFyZWF9IGZyb20gXCIuL2FyZWEuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBsaW5lfSBmcm9tIFwiLi9saW5lLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcGllfSBmcm9tIFwiLi9waWUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBhcmVhUmFkaWFsLCBkZWZhdWx0IGFzIHJhZGlhbEFyZWF9IGZyb20gXCIuL2FyZWFSYWRpYWwuanNcIjsgLy8gTm90ZTogcmFkaWFsQXJlYSBpcyBkZXByZWNhdGVkIVxuZXhwb3J0IHtkZWZhdWx0IGFzIGxpbmVSYWRpYWwsIGRlZmF1bHQgYXMgcmFkaWFsTGluZX0gZnJvbSBcIi4vbGluZVJhZGlhbC5qc1wiOyAvLyBOb3RlOiByYWRpYWxMaW5lIGlzIGRlcHJlY2F0ZWQhXG5leHBvcnQge2RlZmF1bHQgYXMgcG9pbnRSYWRpYWx9IGZyb20gXCIuL3BvaW50UmFkaWFsLmpzXCI7XG5leHBvcnQge2xpbmtIb3Jpem9udGFsLCBsaW5rVmVydGljYWwsIGxpbmtSYWRpYWx9IGZyb20gXCIuL2xpbmsvaW5kZXguanNcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbCwgc3ltYm9sc30gZnJvbSBcIi4vc3ltYm9sLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3ltYm9sQ2lyY2xlfSBmcm9tIFwiLi9zeW1ib2wvY2lyY2xlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3ltYm9sQ3Jvc3N9IGZyb20gXCIuL3N5bWJvbC9jcm9zcy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbERpYW1vbmR9IGZyb20gXCIuL3N5bWJvbC9kaWFtb25kLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3ltYm9sU3F1YXJlfSBmcm9tIFwiLi9zeW1ib2wvc3F1YXJlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3ltYm9sU3Rhcn0gZnJvbSBcIi4vc3ltYm9sL3N0YXIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xUcmlhbmdsZX0gZnJvbSBcIi4vc3ltYm9sL3RyaWFuZ2xlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3ltYm9sV3llfSBmcm9tIFwiLi9zeW1ib2wvd3llLmpzXCI7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUJhc2lzQ2xvc2VkfSBmcm9tIFwiLi9jdXJ2ZS9iYXNpc0Nsb3NlZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQmFzaXNPcGVufSBmcm9tIFwiLi9jdXJ2ZS9iYXNpc09wZW4uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUJhc2lzfSBmcm9tIFwiLi9jdXJ2ZS9iYXNpcy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQnVuZGxlfSBmcm9tIFwiLi9jdXJ2ZS9idW5kbGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhcmRpbmFsQ2xvc2VkfSBmcm9tIFwiLi9jdXJ2ZS9jYXJkaW5hbENsb3NlZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQ2FyZGluYWxPcGVufSBmcm9tIFwiLi9jdXJ2ZS9jYXJkaW5hbE9wZW4uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhcmRpbmFsfSBmcm9tIFwiLi9jdXJ2ZS9jYXJkaW5hbC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQ2F0bXVsbFJvbUNsb3NlZH0gZnJvbSBcIi4vY3VydmUvY2F0bXVsbFJvbUNsb3NlZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQ2F0bXVsbFJvbU9wZW59IGZyb20gXCIuL2N1cnZlL2NhdG11bGxSb21PcGVuLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVDYXRtdWxsUm9tfSBmcm9tIFwiLi9jdXJ2ZS9jYXRtdWxsUm9tLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVMaW5lYXJDbG9zZWR9IGZyb20gXCIuL2N1cnZlL2xpbmVhckNsb3NlZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlTGluZWFyfSBmcm9tIFwiLi9jdXJ2ZS9saW5lYXIuanNcIjtcbmV4cG9ydCB7bW9ub3RvbmVYIGFzIGN1cnZlTW9ub3RvbmVYLCBtb25vdG9uZVkgYXMgY3VydmVNb25vdG9uZVl9IGZyb20gXCIuL2N1cnZlL21vbm90b25lLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVOYXR1cmFsfSBmcm9tIFwiLi9jdXJ2ZS9uYXR1cmFsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVTdGVwLCBzdGVwQWZ0ZXIgYXMgY3VydmVTdGVwQWZ0ZXIsIHN0ZXBCZWZvcmUgYXMgY3VydmVTdGVwQmVmb3JlfSBmcm9tIFwiLi9jdXJ2ZS9zdGVwLmpzXCI7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja30gZnJvbSBcIi4vc3RhY2suanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09mZnNldEV4cGFuZH0gZnJvbSBcIi4vb2Zmc2V0L2V4cGFuZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT2Zmc2V0RGl2ZXJnaW5nfSBmcm9tIFwiLi9vZmZzZXQvZGl2ZXJnaW5nLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPZmZzZXROb25lfSBmcm9tIFwiLi9vZmZzZXQvbm9uZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT2Zmc2V0U2lsaG91ZXR0ZX0gZnJvbSBcIi4vb2Zmc2V0L3NpbGhvdWV0dGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09mZnNldFdpZ2dsZX0gZnJvbSBcIi4vb2Zmc2V0L3dpZ2dsZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT3JkZXJBcHBlYXJhbmNlfSBmcm9tIFwiLi9vcmRlci9hcHBlYXJhbmNlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPcmRlckFzY2VuZGluZ30gZnJvbSBcIi4vb3JkZXIvYXNjZW5kaW5nLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPcmRlckRlc2NlbmRpbmd9IGZyb20gXCIuL29yZGVyL2Rlc2NlbmRpbmcuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVySW5zaWRlT3V0fSBmcm9tIFwiLi9vcmRlci9pbnNpZGVPdXQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVyTm9uZX0gZnJvbSBcIi4vb3JkZXIvbm9uZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT3JkZXJSZXZlcnNlfSBmcm9tIFwiLi9vcmRlci9yZXZlcnNlLmpzXCI7XG4iLCJpbXBvcnQge3BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBjdXJ2ZUxpbmVhciBmcm9tIFwiLi9jdXJ2ZS9saW5lYXIuanNcIjtcbmltcG9ydCB7eCBhcyBwb2ludFgsIHkgYXMgcG9pbnRZfSBmcm9tIFwiLi9wb2ludC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSBwb2ludFgsXG4gICAgICB5ID0gcG9pbnRZLFxuICAgICAgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBjdXJ2ZSA9IGN1cnZlTGluZWFyLFxuICAgICAgb3V0cHV0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBsaW5lKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXI7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBwYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIGVsc2Ugb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkgb3V0cHV0LnBvaW50KCt4KGQsIGksIGRhdGEpLCAreShkLCBpLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmUpIDogeDtcbiAgfTtcblxuICBsaW5lLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHk7XG4gIH07XG5cbiAgbGluZS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGxpbmUpIDogZGVmaW5lZDtcbiAgfTtcblxuICBsaW5lLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGxpbmUpIDogY3VydmU7XG4gIH07XG5cbiAgbGluZS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBsaW5lKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmU7XG59XG4iLCJpbXBvcnQgY3VydmVSYWRpYWwsIHtjdXJ2ZVJhZGlhbExpbmVhcn0gZnJvbSBcIi4vY3VydmUvcmFkaWFsLmpzXCI7XG5pbXBvcnQgbGluZSBmcm9tIFwiLi9saW5lLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lUmFkaWFsKGwpIHtcbiAgdmFyIGMgPSBsLmN1cnZlO1xuXG4gIGwuYW5nbGUgPSBsLngsIGRlbGV0ZSBsLng7XG4gIGwucmFkaXVzID0gbC55LCBkZWxldGUgbC55O1xuXG4gIGwuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjKGN1cnZlUmFkaWFsKF8pKSA6IGMoKS5fY3VydmU7XG4gIH07XG5cbiAgcmV0dXJuIGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbGluZVJhZGlhbChsaW5lKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpKTtcbn1cbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuLi9hcnJheS5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IHt4IGFzIHBvaW50WCwgeSBhcyBwb2ludFl9IGZyb20gXCIuLi9wb2ludC5qc1wiO1xuaW1wb3J0IHBvaW50UmFkaWFsIGZyb20gXCIuLi9wb2ludFJhZGlhbC5qc1wiO1xuXG5mdW5jdGlvbiBsaW5rU291cmNlKGQpIHtcbiAgcmV0dXJuIGQuc291cmNlO1xufVxuXG5mdW5jdGlvbiBsaW5rVGFyZ2V0KGQpIHtcbiAgcmV0dXJuIGQudGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBsaW5rKGN1cnZlKSB7XG4gIHZhciBzb3VyY2UgPSBsaW5rU291cmNlLFxuICAgICAgdGFyZ2V0ID0gbGlua1RhcmdldCxcbiAgICAgIHggPSBwb2ludFgsXG4gICAgICB5ID0gcG9pbnRZLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbGluaygpIHtcbiAgICB2YXIgYnVmZmVyLCBhcmd2ID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLCBzID0gc291cmNlLmFwcGx5KHRoaXMsIGFyZ3YpLCB0ID0gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3YpO1xuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTtcbiAgICBjdXJ2ZShjb250ZXh0LCAreC5hcHBseSh0aGlzLCAoYXJndlswXSA9IHMsIGFyZ3YpKSwgK3kuYXBwbHkodGhpcywgYXJndiksICt4LmFwcGx5KHRoaXMsIChhcmd2WzBdID0gdCwgYXJndikpLCAreS5hcHBseSh0aGlzLCBhcmd2KSk7XG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBsaW5rLnNvdXJjZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3VyY2UgPSBfLCBsaW5rKSA6IHNvdXJjZTtcbiAgfTtcblxuICBsaW5rLnRhcmdldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0YXJnZXQgPSBfLCBsaW5rKSA6IHRhcmdldDtcbiAgfTtcblxuICBsaW5rLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5rKSA6IHg7XG4gIH07XG5cbiAgbGluay55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluaykgOiB5O1xuICB9O1xuXG4gIGxpbmsuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfKSwgbGluaykgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUhvcml6b250YWwoY29udGV4dCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgwID0gKHgwICsgeDEpIC8gMiwgeTAsIHgwLCB5MSwgeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gY3VydmVWZXJ0aWNhbChjb250ZXh0LCB4MCwgeTAsIHgxLCB5MSkge1xuICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICBjb250ZXh0LmJlemllckN1cnZlVG8oeDAsIHkwID0gKHkwICsgeTEpIC8gMiwgeDEsIHkwLCB4MSwgeTEpO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZVJhZGlhbChjb250ZXh0LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgcDAgPSBwb2ludFJhZGlhbCh4MCwgeTApLFxuICAgICAgcDEgPSBwb2ludFJhZGlhbCh4MCwgeTAgPSAoeTAgKyB5MSkgLyAyKSxcbiAgICAgIHAyID0gcG9pbnRSYWRpYWwoeDEsIHkwKSxcbiAgICAgIHAzID0gcG9pbnRSYWRpYWwoeDEsIHkxKTtcbiAgY29udGV4dC5tb3ZlVG8ocDBbMF0sIHAwWzFdKTtcbiAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHAxWzBdLCBwMVsxXSwgcDJbMF0sIHAyWzFdLCBwM1swXSwgcDNbMV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlua0hvcml6b250YWwoKSB7XG4gIHJldHVybiBsaW5rKGN1cnZlSG9yaXpvbnRhbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5rVmVydGljYWwoKSB7XG4gIHJldHVybiBsaW5rKGN1cnZlVmVydGljYWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlua1JhZGlhbCgpIHtcbiAgdmFyIGwgPSBsaW5rKGN1cnZlUmFkaWFsKTtcbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG4gIHJldHVybiBsO1xufVxuIiwiZXhwb3J0IHZhciBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IHZhciBjb3MgPSBNYXRoLmNvcztcbmV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciBzaW4gPSBNYXRoLnNpbjtcbmV4cG9ydCB2YXIgc3FydCA9IE1hdGguc3FydDtcblxuZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtMTI7XG5leHBvcnQgdmFyIHBpID0gTWF0aC5QSTtcbmV4cG9ydCB2YXIgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IHZhciB0YXUgPSAyICogcGk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID49IDEgPyBoYWxmUGkgOiB4IDw9IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge31cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIGksIGogPSAwLCBkLCBkeSwgeXAsIHluLCBuLCBtID0gc2VyaWVzW29yZGVyWzBdXS5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHlwID0geW4gPSAwLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChkeSA9IChkID0gc2VyaWVzW29yZGVyW2ldXVtqXSlbMV0gLSBkWzBdKSA+IDApIHtcbiAgICAgICAgZFswXSA9IHlwLCBkWzFdID0geXAgKz0gZHk7XG4gICAgICB9IGVsc2UgaWYgKGR5IDwgMCkge1xuICAgICAgICBkWzFdID0geW4sIGRbMF0gPSB5biArPSBkeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRbMF0gPSAwLCBkWzFdID0gZHk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgbm9uZSBmcm9tIFwiLi9ub25lLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIGksIG4sIGogPSAwLCBtID0gc2VyaWVzWzBdLmxlbmd0aCwgeTsgaiA8IG07ICsraikge1xuICAgIGZvciAoeSA9IGkgPSAwOyBpIDwgbjsgKytpKSB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgIGlmICh5KSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzZXJpZXNbaV1bal1bMV0gLz0geTtcbiAgfVxuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMSkpIHJldHVybjtcbiAgZm9yICh2YXIgaSA9IDEsIGosIHMwLCBzMSA9IHNlcmllc1tvcmRlclswXV0sIG4sIG0gPSBzMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBzMCA9IHMxLCBzMSA9IHNlcmllc1tvcmRlcltpXV07XG4gICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgczFbal1bMV0gKz0gczFbal1bMF0gPSBpc05hTihzMFtqXVsxXSkgPyBzMFtqXVswXSA6IHMwW2pdWzFdO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSkgcmV0dXJuO1xuICBmb3IgKHZhciBqID0gMCwgczAgPSBzZXJpZXNbb3JkZXJbMF1dLCBuLCBtID0gczAubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHkgPSAwOyBpIDwgbjsgKytpKSB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgIHMwW2pdWzFdICs9IHMwW2pdWzBdID0gLXkgLyAyO1xuICB9XG4gIG5vbmUoc2VyaWVzLCBvcmRlcik7XG59XG4iLCJpbXBvcnQgbm9uZSBmcm9tIFwiLi9ub25lLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApIHx8ICEoKG0gPSAoczAgPSBzZXJpZXNbb3JkZXJbMF1dKS5sZW5ndGgpID4gMCkpIHJldHVybjtcbiAgZm9yICh2YXIgeSA9IDAsIGogPSAxLCBzMCwgbSwgbjsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGkgPSAwLCBzMSA9IDAsIHMyID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIHNpID0gc2VyaWVzW29yZGVyW2ldXSxcbiAgICAgICAgICBzaWowID0gc2lbal1bMV0gfHwgMCxcbiAgICAgICAgICBzaWoxID0gc2lbaiAtIDFdWzFdIHx8IDAsXG4gICAgICAgICAgczMgPSAoc2lqMCAtIHNpajEpIC8gMjtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaTsgKytrKSB7XG4gICAgICAgIHZhciBzayA9IHNlcmllc1tvcmRlcltrXV0sXG4gICAgICAgICAgICBza2owID0gc2tbal1bMV0gfHwgMCxcbiAgICAgICAgICAgIHNrajEgPSBza1tqIC0gMV1bMV0gfHwgMDtcbiAgICAgICAgczMgKz0gc2tqMCAtIHNrajE7XG4gICAgICB9XG4gICAgICBzMSArPSBzaWowLCBzMiArPSBzMyAqIHNpajA7XG4gICAgfVxuICAgIHMwW2ogLSAxXVsxXSArPSBzMFtqIC0gMV1bMF0gPSB5O1xuICAgIGlmIChzMSkgeSAtPSBzMiAvIHMxO1xuICB9XG4gIHMwW2ogLSAxXVsxXSArPSBzMFtqIC0gMV1bMF0gPSB5O1xuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgdmFyIHBlYWtzID0gc2VyaWVzLm1hcChwZWFrKTtcbiAgcmV0dXJuIG5vbmUoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHBlYWtzW2FdIC0gcGVha3NbYl07IH0pO1xufVxuXG5mdW5jdGlvbiBwZWFrKHNlcmllcykge1xuICB2YXIgaSA9IC0xLCBqID0gMCwgbiA9IHNlcmllcy5sZW5ndGgsIHZpLCB2aiA9IC1JbmZpbml0eTtcbiAgd2hpbGUgKCsraSA8IG4pIGlmICgodmkgPSArc2VyaWVzW2ldWzFdKSA+IHZqKSB2aiA9IHZpLCBqID0gaTtcbiAgcmV0dXJuIGo7XG59XG4iLCJpbXBvcnQgbm9uZSBmcm9tIFwiLi9ub25lLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcykge1xuICB2YXIgc3VtcyA9IHNlcmllcy5tYXAoc3VtKTtcbiAgcmV0dXJuIG5vbmUoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHN1bXNbYV0gLSBzdW1zW2JdOyB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1bShzZXJpZXMpIHtcbiAgdmFyIHMgPSAwLCBpID0gLTEsIG4gPSBzZXJpZXMubGVuZ3RoLCB2O1xuICB3aGlsZSAoKytpIDwgbikgaWYgKHYgPSArc2VyaWVzW2ldWzFdKSBzICs9IHY7XG4gIHJldHVybiBzO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHJldHVybiBhc2NlbmRpbmcoc2VyaWVzKS5yZXZlcnNlKCk7XG59XG4iLCJpbXBvcnQgYXBwZWFyYW5jZSBmcm9tIFwiLi9hcHBlYXJhbmNlLmpzXCI7XG5pbXBvcnQge3N1bX0gZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcykge1xuICB2YXIgbiA9IHNlcmllcy5sZW5ndGgsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHN1bXMgPSBzZXJpZXMubWFwKHN1bSksXG4gICAgICBvcmRlciA9IGFwcGVhcmFuY2Uoc2VyaWVzKSxcbiAgICAgIHRvcCA9IDAsXG4gICAgICBib3R0b20gPSAwLFxuICAgICAgdG9wcyA9IFtdLFxuICAgICAgYm90dG9tcyA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBqID0gb3JkZXJbaV07XG4gICAgaWYgKHRvcCA8IGJvdHRvbSkge1xuICAgICAgdG9wICs9IHN1bXNbal07XG4gICAgICB0b3BzLnB1c2goaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdHRvbSArPSBzdW1zW2pdO1xuICAgICAgYm90dG9tcy5wdXNoKGopO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3R0b21zLnJldmVyc2UoKS5jb25jYXQodG9wcyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgdmFyIG4gPSBzZXJpZXMubGVuZ3RoLCBvID0gbmV3IEFycmF5KG4pO1xuICB3aGlsZSAoLS1uID49IDApIG9bbl0gPSBuO1xuICByZXR1cm4gbztcbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHJldHVybiBub25lKHNlcmllcykucmV2ZXJzZSgpO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgZGVzY2VuZGluZyBmcm9tIFwiLi9kZXNjZW5kaW5nLmpzXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcbmltcG9ydCB7dGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSBpZGVudGl0eSxcbiAgICAgIHNvcnRWYWx1ZXMgPSBkZXNjZW5kaW5nLFxuICAgICAgc29ydCA9IG51bGwsXG4gICAgICBzdGFydEFuZ2xlID0gY29uc3RhbnQoMCksXG4gICAgICBlbmRBbmdsZSA9IGNvbnN0YW50KHRhdSksXG4gICAgICBwYWRBbmdsZSA9IGNvbnN0YW50KDApO1xuXG4gIGZ1bmN0aW9uIHBpZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgaW5kZXggPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGFyY3MgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGEwID0gK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgZGEgPSBNYXRoLm1pbih0YXUsIE1hdGgubWF4KC10YXUsIGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBhMCkpLFxuICAgICAgICBhMSxcbiAgICAgICAgcCA9IE1hdGgubWluKE1hdGguYWJzKGRhKSAvIG4sIHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxuICAgICAgICBwYSA9IHAgKiAoZGEgPCAwID8gLTEgOiAxKSxcbiAgICAgICAgdjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodiA9IGFyY3NbaW5kZXhbaV0gPSBpXSA9ICt2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKSkgPiAwKSB7XG4gICAgICAgIHN1bSArPSB2O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9wdGlvbmFsbHkgc29ydCB0aGUgYXJjcyBieSBwcmV2aW91c2x5LWNvbXB1dGVkIHZhbHVlcyBvciBieSBkYXRhLlxuICAgIGlmIChzb3J0VmFsdWVzICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydFZhbHVlcyhhcmNzW2ldLCBhcmNzW2pdKTsgfSk7XG4gICAgZWxzZSBpZiAoc29ydCAhPSBudWxsKSBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIHNvcnQoZGF0YVtpXSwgZGF0YVtqXSk7IH0pO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgYXJjcyEgVGhleSBhcmUgc3RvcmVkIGluIHRoZSBvcmlnaW5hbCBkYXRhJ3Mgb3JkZXIuXG4gICAgZm9yIChpID0gMCwgayA9IHN1bSA/IChkYSAtIG4gKiBwYSkgLyBzdW0gOiAwOyBpIDwgbjsgKytpLCBhMCA9IGExKSB7XG4gICAgICBqID0gaW5kZXhbaV0sIHYgPSBhcmNzW2pdLCBhMSA9IGEwICsgKHYgPiAwID8gdiAqIGsgOiAwKSArIHBhLCBhcmNzW2pdID0ge1xuICAgICAgICBkYXRhOiBkYXRhW2pdLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgIHN0YXJ0QW5nbGU6IGEwLFxuICAgICAgICBlbmRBbmdsZTogYTEsXG4gICAgICAgIHBhZEFuZ2xlOiBwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBhcmNzO1xuICB9XG5cbiAgcGllLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiB2YWx1ZTtcbiAgfTtcblxuICBwaWUuc29ydFZhbHVlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0VmFsdWVzID0gXywgc29ydCA9IG51bGwsIHBpZSkgOiBzb3J0VmFsdWVzO1xuICB9O1xuXG4gIHBpZS5zb3J0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnQgPSBfLCBzb3J0VmFsdWVzID0gbnVsbCwgcGllKSA6IHNvcnQ7XG4gIH07XG5cbiAgcGllLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICBwaWUuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgcmV0dXJuIHBpZTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiB4KHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5KHApIHtcbiAgcmV0dXJuIHBbMV07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiBbKHkgPSAreSkgKiBNYXRoLmNvcyh4IC09IE1hdGguUEkgLyAyKSwgeSAqIE1hdGguc2luKHgpXTtcbn1cbiIsImltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBvZmZzZXROb25lIGZyb20gXCIuL29mZnNldC9ub25lLmpzXCI7XG5pbXBvcnQgb3JkZXJOb25lIGZyb20gXCIuL29yZGVyL25vbmUuanNcIjtcblxuZnVuY3Rpb24gc3RhY2tWYWx1ZShkLCBrZXkpIHtcbiAgcmV0dXJuIGRba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBrZXlzID0gY29uc3RhbnQoW10pLFxuICAgICAgb3JkZXIgPSBvcmRlck5vbmUsXG4gICAgICBvZmZzZXQgPSBvZmZzZXROb25lLFxuICAgICAgdmFsdWUgPSBzdGFja1ZhbHVlO1xuXG4gIGZ1bmN0aW9uIHN0YWNrKGRhdGEpIHtcbiAgICB2YXIga3ogPSBrZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGksXG4gICAgICAgIG0gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgbiA9IGt6Lmxlbmd0aCxcbiAgICAgICAgc3ogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIG96O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZm9yICh2YXIga2kgPSBreltpXSwgc2kgPSBzeltpXSA9IG5ldyBBcnJheShtKSwgaiA9IDAsIHNpajsgaiA8IG07ICsraikge1xuICAgICAgICBzaVtqXSA9IHNpaiA9IFswLCArdmFsdWUoZGF0YVtqXSwga2ksIGosIGRhdGEpXTtcbiAgICAgICAgc2lqLmRhdGEgPSBkYXRhW2pdO1xuICAgICAgfVxuICAgICAgc2kua2V5ID0ga2k7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgb3ogPSBvcmRlcihzeik7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN6W296W2ldXS5pbmRleCA9IGk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KHN6LCBveik7XG4gICAgcmV0dXJuIHN6O1xuICB9XG5cbiAgc3RhY2sua2V5cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrZXlzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChzbGljZS5jYWxsKF8pKSwgc3RhY2spIDoga2V5cztcbiAgfTtcblxuICBzdGFjay52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzdGFjaykgOiB2YWx1ZTtcbiAgfTtcblxuICBzdGFjay5vcmRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvcmRlciA9IF8gPT0gbnVsbCA/IG9yZGVyTm9uZSA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoc2xpY2UuY2FsbChfKSksIHN0YWNrKSA6IG9yZGVyO1xuICB9O1xuXG4gIHN0YWNrLm9mZnNldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvZmZzZXQgPSBfID09IG51bGwgPyBvZmZzZXROb25lIDogXywgc3RhY2spIDogb2Zmc2V0O1xuICB9O1xuXG4gIHJldHVybiBzdGFjaztcbn1cbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBjaXJjbGUgZnJvbSBcIi4vc3ltYm9sL2NpcmNsZS5qc1wiO1xuaW1wb3J0IGNyb3NzIGZyb20gXCIuL3N5bWJvbC9jcm9zcy5qc1wiO1xuaW1wb3J0IGRpYW1vbmQgZnJvbSBcIi4vc3ltYm9sL2RpYW1vbmQuanNcIjtcbmltcG9ydCBzdGFyIGZyb20gXCIuL3N5bWJvbC9zdGFyLmpzXCI7XG5pbXBvcnQgc3F1YXJlIGZyb20gXCIuL3N5bWJvbC9zcXVhcmUuanNcIjtcbmltcG9ydCB0cmlhbmdsZSBmcm9tIFwiLi9zeW1ib2wvdHJpYW5nbGUuanNcIjtcbmltcG9ydCB3eWUgZnJvbSBcIi4vc3ltYm9sL3d5ZS5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmV4cG9ydCB2YXIgc3ltYm9scyA9IFtcbiAgY2lyY2xlLFxuICBjcm9zcyxcbiAgZGlhbW9uZCxcbiAgc3F1YXJlLFxuICBzdGFyLFxuICB0cmlhbmdsZSxcbiAgd3llXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHR5cGUgPSBjb25zdGFudChjaXJjbGUpLFxuICAgICAgc2l6ZSA9IGNvbnN0YW50KDY0KSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTtcbiAgICB0eXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZHJhdyhjb250ZXh0LCArc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIHN5bWJvbC50eXBlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHR5cGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBzeW1ib2wpIDogdHlwZTtcbiAgfTtcblxuICBzeW1ib2wuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzaXplID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN5bWJvbCkgOiBzaXplO1xuICB9O1xuXG4gIHN5bWJvbC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXywgc3ltYm9sKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIHN5bWJvbDtcbn1cbiIsImltcG9ydCB7cGksIHRhdX0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIHBpKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhyLCAwKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCB0YXUpO1xuICB9XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICBjb250ZXh0Lm1vdmVUbygtMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIDMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtMyAqIHIsIHIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJ2YXIgdGFuMzAgPSBNYXRoLnNxcnQoMSAvIDMpLFxuICAgIHRhbjMwXzIgPSB0YW4zMCAqIDI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB5ID0gTWF0aC5zcXJ0KHNpemUgLyB0YW4zMF8yKSxcbiAgICAgICAgeCA9IHkgKiB0YW4zMDtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oeCwgMCk7XG4gICAgY29udGV4dC5saW5lVG8oMCwgeSk7XG4gICAgY29udGV4dC5saW5lVG8oLXgsIDApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgdyA9IE1hdGguc3FydChzaXplKSxcbiAgICAgICAgeCA9IC13IC8gMjtcbiAgICBjb250ZXh0LnJlY3QoeCwgeCwgdywgdyk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3BpLCB0YXV9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbnZhciBrYSA9IDAuODkwODEzMDkxNTI5Mjg1MjI4MTAsXG4gICAga3IgPSBNYXRoLnNpbihwaSAvIDEwKSAvIE1hdGguc2luKDcgKiBwaSAvIDEwKSxcbiAgICBreCA9IE1hdGguc2luKHRhdSAvIDEwKSAqIGtyLFxuICAgIGt5ID0gLU1hdGguY29zKHRhdSAvIDEwKSAqIGtyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplICoga2EpLFxuICAgICAgICB4ID0ga3ggKiByLFxuICAgICAgICB5ID0ga3kgKiByO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDU7ICsraSkge1xuICAgICAgdmFyIGEgPSB0YXUgKiBpIC8gNSxcbiAgICAgICAgICBjID0gTWF0aC5jb3MoYSksXG4gICAgICAgICAgcyA9IE1hdGguc2luKGEpO1xuICAgICAgY29udGV4dC5saW5lVG8ocyAqIHIsIC1jICogcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhjICogeCAtIHMgKiB5LCBzICogeCArIGMgKiB5KTtcbiAgICB9XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsInZhciBzcXJ0MyA9IE1hdGguc3FydCgzKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSAtTWF0aC5zcXJ0KHNpemUgLyAoc3FydDMgKiAzKSk7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgeSAqIDIpO1xuICAgIGNvbnRleHQubGluZVRvKC1zcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyhzcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwidmFyIGMgPSAtMC41LFxuICAgIHMgPSBNYXRoLnNxcnQoMykgLyAyLFxuICAgIGsgPSAxIC8gTWF0aC5zcXJ0KDEyKSxcbiAgICBhID0gKGsgLyAyICsgMSkgKiAzO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gYSksXG4gICAgICAgIHgwID0gciAvIDIsXG4gICAgICAgIHkwID0gciAqIGssXG4gICAgICAgIHgxID0geDAsXG4gICAgICAgIHkxID0gciAqIGsgKyByLFxuICAgICAgICB4MiA9IC14MSxcbiAgICAgICAgeTIgPSB5MTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgLSBzICogeTAsIHMgKiB4MCArIGMgKiB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxIC0gcyAqIHkxLCBzICogeDEgKyBjICogeTEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiAtIHMgKiB5MiwgcyAqIHgyICsgYyAqIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgKyBzICogeTAsIGMgKiB5MCAtIHMgKiB4MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxICsgcyAqIHkxLCBjICogeTEgLSBzICogeDEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiArIHMgKiB5MiwgYyAqIHkyIC0gcyAqIHgyKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IGZvcm1hdExvY2FsZSBmcm9tIFwiLi9sb2NhbGUuanNcIjtcblxudmFyIGxvY2FsZTtcbmV4cG9ydCB2YXIgdGltZUZvcm1hdDtcbmV4cG9ydCB2YXIgdGltZVBhcnNlO1xuZXhwb3J0IHZhciB1dGNGb3JtYXQ7XG5leHBvcnQgdmFyIHV0Y1BhcnNlO1xuXG5kZWZhdWx0TG9jYWxlKHtcbiAgZGF0ZVRpbWU6IFwiJXgsICVYXCIsXG4gIGRhdGU6IFwiJS1tLyUtZC8lWVwiLFxuICB0aW1lOiBcIiUtSTolTTolUyAlcFwiLFxuICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgbG9jYWxlID0gZm9ybWF0TG9jYWxlKGRlZmluaXRpb24pO1xuICB0aW1lRm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgdGltZVBhcnNlID0gbG9jYWxlLnBhcnNlO1xuICB1dGNGb3JtYXQgPSBsb2NhbGUudXRjRm9ybWF0O1xuICB1dGNQYXJzZSA9IGxvY2FsZS51dGNQYXJzZTtcbiAgcmV0dXJuIGxvY2FsZTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZSwgdGltZUZvcm1hdCwgdGltZVBhcnNlLCB1dGNGb3JtYXQsIHV0Y1BhcnNlfSBmcm9tIFwiLi9kZWZhdWx0TG9jYWxlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdGltZUZvcm1hdExvY2FsZX0gZnJvbSBcIi4vbG9jYWxlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaXNvRm9ybWF0fSBmcm9tIFwiLi9pc29Gb3JtYXQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpc29QYXJzZX0gZnJvbSBcIi4vaXNvUGFyc2UuanNcIjtcbiIsImltcG9ydCB7dXRjRm9ybWF0fSBmcm9tIFwiLi9kZWZhdWx0TG9jYWxlLmpzXCI7XG5cbmV4cG9ydCB2YXIgaXNvU3BlY2lmaWVyID0gXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIjtcblxuZnVuY3Rpb24gZm9ybWF0SXNvTmF0aXZlKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbn1cblxudmFyIGZvcm1hdElzbyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nXG4gICAgPyBmb3JtYXRJc29OYXRpdmVcbiAgICA6IHV0Y0Zvcm1hdChpc29TcGVjaWZpZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBmb3JtYXRJc287XG4iLCJpbXBvcnQge2lzb1NwZWNpZmllcn0gZnJvbSBcIi4vaXNvRm9ybWF0LmpzXCI7XG5pbXBvcnQge3V0Y1BhcnNlfSBmcm9tIFwiLi9kZWZhdWx0TG9jYWxlLmpzXCI7XG5cbmZ1bmN0aW9uIHBhcnNlSXNvTmF0aXZlKHN0cmluZykge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gIHJldHVybiBpc05hTihkYXRlKSA/IG51bGwgOiBkYXRlO1xufVxuXG52YXIgcGFyc2VJc28gPSArbmV3IERhdGUoXCIyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIilcbiAgICA/IHBhcnNlSXNvTmF0aXZlXG4gICAgOiB1dGNQYXJzZShpc29TcGVjaWZpZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBwYXJzZUlzbztcbiIsImltcG9ydCB7XG4gIHRpbWVEYXksXG4gIHRpbWVTdW5kYXksXG4gIHRpbWVNb25kYXksXG4gIHRpbWVUaHVyc2RheSxcbiAgdGltZVllYXIsXG4gIHV0Y0RheSxcbiAgdXRjU3VuZGF5LFxuICB1dGNNb25kYXksXG4gIHV0Y1RodXJzZGF5LFxuICB1dGNZZWFyXG59IGZyb20gXCJkMy10aW1lXCI7XG5cbmZ1bmN0aW9uIGxvY2FsRGF0ZShkKSB7XG4gIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG59XG5cbmZ1bmN0aW9uIHV0Y0RhdGUoZCkge1xuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG59XG5cbmZ1bmN0aW9uIG5ld0RhdGUoeSwgbSwgZCkge1xuICByZXR1cm4ge3k6IHksIG06IG0sIGQ6IGQsIEg6IDAsIE06IDAsIFM6IDAsIEw6IDB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRMb2NhbGUobG9jYWxlKSB7XG4gIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsXG4gICAgICBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLFxuICAgICAgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSxcbiAgICAgIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsXG4gICAgICBsb2NhbGVfd2Vla2RheXMgPSBsb2NhbGUuZGF5cyxcbiAgICAgIGxvY2FsZV9zaG9ydFdlZWtkYXlzID0gbG9jYWxlLnNob3J0RGF5cyxcbiAgICAgIGxvY2FsZV9tb250aHMgPSBsb2NhbGUubW9udGhzLFxuICAgICAgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuXG4gIHZhciBwZXJpb2RSZSA9IGZvcm1hdFJlKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgIHBlcmlvZExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfcGVyaW9kcyksXG4gICAgICB3ZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgd2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICBzaG9ydFdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgbW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9tb250aHMpLFxuICAgICAgbW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksXG4gICAgICBzaG9ydE1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLFxuICAgICAgc2hvcnRNb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuXG4gIHZhciBmb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFdlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdE1vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZlwiOiBmb3JtYXRNaWNyb3NlY29uZHMsXG4gICAgXCJIXCI6IGZvcm1hdEhvdXIyNCxcbiAgICBcIklcIjogZm9ybWF0SG91cjEyLFxuICAgIFwialwiOiBmb3JtYXREYXlPZlllYXIsXG4gICAgXCJMXCI6IGZvcm1hdE1pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogZm9ybWF0TW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IGZvcm1hdE1pbnV0ZXMsXG4gICAgXCJwXCI6IGZvcm1hdFBlcmlvZCxcbiAgICBcInFcIjogZm9ybWF0UXVhcnRlcixcbiAgICBcIlFcIjogZm9ybWF0VW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IGZvcm1hdFNlY29uZHMsXG4gICAgXCJ1XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IGZvcm1hdFdlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IGZvcm1hdFdlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IGZvcm1hdFdlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFllYXIsXG4gICAgXCJZXCI6IGZvcm1hdEZ1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciB1dGNGb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRVVENTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFVUQ1dlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFVUQ1Nob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdFVUQ01vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiZlwiOiBmb3JtYXRVVENNaWNyb3NlY29uZHMsXG4gICAgXCJIXCI6IGZvcm1hdFVUQ0hvdXIyNCxcbiAgICBcIklcIjogZm9ybWF0VVRDSG91cjEyLFxuICAgIFwialwiOiBmb3JtYXRVVENEYXlPZlllYXIsXG4gICAgXCJMXCI6IGZvcm1hdFVUQ01pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogZm9ybWF0VVRDTW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IGZvcm1hdFVUQ01pbnV0ZXMsXG4gICAgXCJwXCI6IGZvcm1hdFVUQ1BlcmlvZCxcbiAgICBcInFcIjogZm9ybWF0VVRDUXVhcnRlcixcbiAgICBcIlFcIjogZm9ybWF0VW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IGZvcm1hdFVUQ1NlY29uZHMsXG4gICAgXCJ1XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFVUQ1llYXIsXG4gICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRVVENab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciBwYXJzZXMgPSB7XG4gICAgXCJhXCI6IHBhcnNlU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgXCJiXCI6IHBhcnNlU2hvcnRNb250aCxcbiAgICBcIkJcIjogcGFyc2VNb250aCxcbiAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICBcImRcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgXCJmXCI6IHBhcnNlTWljcm9zZWNvbmRzLFxuICAgIFwiSFwiOiBwYXJzZUhvdXIyNCxcbiAgICBcIklcIjogcGFyc2VIb3VyMjQsXG4gICAgXCJqXCI6IHBhcnNlRGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBwYXJzZU1pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogcGFyc2VNb250aE51bWJlcixcbiAgICBcIk1cIjogcGFyc2VNaW51dGVzLFxuICAgIFwicFwiOiBwYXJzZVBlcmlvZCxcbiAgICBcInFcIjogcGFyc2VRdWFydGVyLFxuICAgIFwiUVwiOiBwYXJzZVVuaXhUaW1lc3RhbXAsXG4gICAgXCJzXCI6IHBhcnNlVW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IHBhcnNlU2Vjb25kcyxcbiAgICBcInVcIjogcGFyc2VXZWVrZGF5TnVtYmVyTW9uZGF5LFxuICAgIFwiVVwiOiBwYXJzZVdlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IHBhcnNlV2Vla051bWJlcklTTyxcbiAgICBcIndcIjogcGFyc2VXZWVrZGF5TnVtYmVyU3VuZGF5LFxuICAgIFwiV1wiOiBwYXJzZVdlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IHBhcnNlTG9jYWxlRGF0ZSxcbiAgICBcIlhcIjogcGFyc2VMb2NhbGVUaW1lLFxuICAgIFwieVwiOiBwYXJzZVllYXIsXG4gICAgXCJZXCI6IHBhcnNlRnVsbFllYXIsXG4gICAgXCJaXCI6IHBhcnNlWm9uZSxcbiAgICBcIiVcIjogcGFyc2VMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIC8vIFRoZXNlIHJlY3Vyc2l2ZSBkaXJlY3RpdmUgZGVmaW5pdGlvbnMgbXVzdCBiZSBkZWZlcnJlZC5cbiAgZm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCBmb3JtYXRzKTtcbiAgZm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCBmb3JtYXRzKTtcbiAgZm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgZm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgdXRjRm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgdXRjRm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIHV0Y0Zvcm1hdHMpO1xuXG4gIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIsIGZvcm1hdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIHN0cmluZyA9IFtdLFxuICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICBqID0gMCxcbiAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIHBhZCxcbiAgICAgICAgICBmb3JtYXQ7XG5cbiAgICAgIGlmICghKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSkgZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKTtcblxuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKHNwZWNpZmllci5jaGFyQ29kZUF0KGkpID09PSAzNykge1xuICAgICAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICAgICAgaWYgKChwYWQgPSBwYWRzW2MgPSBzcGVjaWZpZXIuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpO1xuICAgICAgICAgIGVsc2UgcGFkID0gYyA9PT0gXCJlXCIgPyBcIiBcIiA6IFwiMFwiO1xuICAgICAgICAgIGlmIChmb3JtYXQgPSBmb3JtYXRzW2NdKSBjID0gZm9ybWF0KGRhdGUsIHBhZCk7XG4gICAgICAgICAgc3RyaW5nLnB1c2goYyk7XG4gICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld1BhcnNlKHNwZWNpZmllciwgWikge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciBkID0gbmV3RGF0ZSgxOTAwLCB1bmRlZmluZWQsIDEpLFxuICAgICAgICAgIGkgPSBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZyArPSBcIlwiLCAwKSxcbiAgICAgICAgICB3ZWVrLCBkYXk7XG4gICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gSWYgYSBVTklYIHRpbWVzdGFtcCBpcyBzcGVjaWZpZWQsIHJldHVybiBpdC5cbiAgICAgIGlmIChcIlFcIiBpbiBkKSByZXR1cm4gbmV3IERhdGUoZC5RKTtcbiAgICAgIGlmIChcInNcIiBpbiBkKSByZXR1cm4gbmV3IERhdGUoZC5zICogMTAwMCArIChcIkxcIiBpbiBkID8gZC5MIDogMCkpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIHV0Y1BhcnNlLCBuZXZlciB1c2UgdGhlIGxvY2FsIHRpbWV6b25lLlxuICAgICAgaWYgKFogJiYgIShcIlpcIiBpbiBkKSkgZC5aID0gMDtcblxuICAgICAgLy8gVGhlIGFtLXBtIGZsYWcgaXMgMCBmb3IgQU0sIGFuZCAxIGZvciBQTS5cbiAgICAgIGlmIChcInBcIiBpbiBkKSBkLkggPSBkLkggJSAxMiArIGQucCAqIDEyO1xuXG4gICAgICAvLyBJZiB0aGUgbW9udGggd2FzIG5vdCBzcGVjaWZpZWQsIGluaGVyaXQgZnJvbSB0aGUgcXVhcnRlci5cbiAgICAgIGlmIChkLm0gPT09IHVuZGVmaW5lZCkgZC5tID0gXCJxXCIgaW4gZCA/IGQucSA6IDA7XG5cbiAgICAgIC8vIENvbnZlcnQgZGF5LW9mLXdlZWsgYW5kIHdlZWstb2YteWVhciB0byBkYXktb2YteWVhci5cbiAgICAgIGlmIChcIlZcIiBpbiBkKSB7XG4gICAgICAgIGlmIChkLlYgPCAxIHx8IGQuViA+IDUzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEoXCJ3XCIgaW4gZCkpIGQudyA9IDE7XG4gICAgICAgIGlmIChcIlpcIiBpbiBkKSB7XG4gICAgICAgICAgd2VlayA9IHV0Y0RhdGUobmV3RGF0ZShkLnksIDAsIDEpKSwgZGF5ID0gd2Vlay5nZXRVVENEYXkoKTtcbiAgICAgICAgICB3ZWVrID0gZGF5ID4gNCB8fCBkYXkgPT09IDAgPyB1dGNNb25kYXkuY2VpbCh3ZWVrKSA6IHV0Y01vbmRheSh3ZWVrKTtcbiAgICAgICAgICB3ZWVrID0gdXRjRGF5Lm9mZnNldCh3ZWVrLCAoZC5WIC0gMSkgKiA3KTtcbiAgICAgICAgICBkLnkgPSB3ZWVrLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgZC5tID0gd2Vlay5nZXRVVENNb250aCgpO1xuICAgICAgICAgIGQuZCA9IHdlZWsuZ2V0VVRDRGF0ZSgpICsgKGQudyArIDYpICUgNztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ZWVrID0gbG9jYWxEYXRlKG5ld0RhdGUoZC55LCAwLCAxKSksIGRheSA9IHdlZWsuZ2V0RGF5KCk7XG4gICAgICAgICAgd2VlayA9IGRheSA+IDQgfHwgZGF5ID09PSAwID8gdGltZU1vbmRheS5jZWlsKHdlZWspIDogdGltZU1vbmRheSh3ZWVrKTtcbiAgICAgICAgICB3ZWVrID0gdGltZURheS5vZmZzZXQod2VlaywgKGQuViAtIDEpICogNyk7XG4gICAgICAgICAgZC55ID0gd2Vlay5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgIGQubSA9IHdlZWsuZ2V0TW9udGgoKTtcbiAgICAgICAgICBkLmQgPSB3ZWVrLmdldERhdGUoKSArIChkLncgKyA2KSAlIDc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXCJXXCIgaW4gZCB8fCBcIlVcIiBpbiBkKSB7XG4gICAgICAgIGlmICghKFwid1wiIGluIGQpKSBkLncgPSBcInVcIiBpbiBkID8gZC51ICUgNyA6IFwiV1wiIGluIGQgPyAxIDogMDtcbiAgICAgICAgZGF5ID0gXCJaXCIgaW4gZCA/IHV0Y0RhdGUobmV3RGF0ZShkLnksIDAsIDEpKS5nZXRVVENEYXkoKSA6IGxvY2FsRGF0ZShuZXdEYXRlKGQueSwgMCwgMSkpLmdldERheSgpO1xuICAgICAgICBkLm0gPSAwO1xuICAgICAgICBkLmQgPSBcIldcIiBpbiBkID8gKGQudyArIDYpICUgNyArIGQuVyAqIDcgLSAoZGF5ICsgNSkgJSA3IDogZC53ICsgZC5VICogNyAtIChkYXkgKyA2KSAlIDc7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgdGltZSB6b25lIGlzIHNwZWNpZmllZCwgYWxsIGZpZWxkcyBhcmUgaW50ZXJwcmV0ZWQgYXMgVVRDIGFuZCB0aGVuXG4gICAgICAvLyBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGltZSB6b25lLlxuICAgICAgaWYgKFwiWlwiIGluIGQpIHtcbiAgICAgICAgZC5IICs9IGQuWiAvIDEwMCB8IDA7XG4gICAgICAgIGQuTSArPSBkLlogJSAxMDA7XG4gICAgICAgIHJldHVybiB1dGNEYXRlKGQpO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGFsbCBmaWVsZHMgYXJlIGluIGxvY2FsIHRpbWUuXG4gICAgICByZXR1cm4gbG9jYWxEYXRlKGQpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZywgaikge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgIG0gPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICBjLFxuICAgICAgICBwYXJzZTtcblxuICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgaWYgKGogPj0gbSkgcmV0dXJuIC0xO1xuICAgICAgYyA9IHNwZWNpZmllci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICBpZiAoYyA9PT0gMzcpIHtcbiAgICAgICAgYyA9IHNwZWNpZmllci5jaGFyQXQoaSsrKTtcbiAgICAgICAgcGFyc2UgPSBwYXJzZXNbYyBpbiBwYWRzID8gc3BlY2lmaWVyLmNoYXJBdChpKyspIDogY107XG4gICAgICAgIGlmICghcGFyc2UgfHwgKChqID0gcGFyc2UoZCwgc3RyaW5nLCBqKSkgPCAwKSkgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChjICE9IHN0cmluZy5jaGFyQ29kZUF0KGorKykpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBqO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQZXJpb2QoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBwZXJpb2RSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5wID0gcGVyaW9kTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gc2hvcnRXZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9IHNob3J0V2Vla2RheUxvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSB3ZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9IHdlZWtkYXlMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTaG9ydE1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gc2hvcnRNb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSBzaG9ydE1vbnRoTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBtb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSBtb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZVRpbWUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfdGltZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNob3J0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldERheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNob3J0TW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldE1vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UGVyaW9kKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFF1YXJ0ZXIoZCkge1xuICAgIHJldHVybiAxICsgfn4oZC5nZXRNb250aCgpIC8gMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1BlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRVVENIb3VycygpID49IDEyKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENRdWFydGVyKGQpIHtcbiAgICByZXR1cm4gMSArIH5+KGQuZ2V0VVRDTW9udGgoKSAvIDMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIGZvcm1hdHMpO1xuICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgcCA9IG5ld1BhcnNlKHNwZWNpZmllciArPSBcIlwiLCBmYWxzZSk7XG4gICAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIHV0Y0Zvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgdXRjRm9ybWF0cyk7XG4gICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gZjtcbiAgICB9LFxuICAgIHV0Y1BhcnNlOiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBwID0gbmV3UGFyc2Uoc3BlY2lmaWVyICs9IFwiXCIsIHRydWUpO1xuICAgICAgcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9O1xufVxuXG52YXIgcGFkcyA9IHtcIi1cIjogXCJcIiwgXCJfXCI6IFwiIFwiLCBcIjBcIjogXCIwXCJ9LFxuICAgIG51bWJlclJlID0gL15cXHMqXFxkKy8sIC8vIG5vdGU6IGlnbm9yZXMgbmV4dCBkaXJlY3RpdmVcbiAgICBwZXJjZW50UmUgPSAvXiUvLFxuICAgIHJlcXVvdGVSZSA9IC9bXFxcXF4kKis/fFtcXF0oKS57fV0vZztcblxuZnVuY3Rpb24gcGFkKHZhbHVlLCBmaWxsLCB3aWR0aCkge1xuICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIixcbiAgICAgIHN0cmluZyA9IChzaWduID8gLXZhbHVlIDogdmFsdWUpICsgXCJcIixcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIHJlcXVvdGUocykge1xuICByZXR1cm4gcy5yZXBsYWNlKHJlcXVvdGVSZSwgXCJcXFxcJCZcIik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJlKG5hbWVzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKHJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TG9va3VwKG5hbWVzKSB7XG4gIHZhciBtYXAgPSB7fSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbWFwW25hbWVzW2ldLnRvTG93ZXJDYXNlKCldID0gaTtcbiAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5TnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gKGQudyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLnUgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJTdW5kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVySVNPKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuViA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlcgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUZ1bGxZZWFyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA0KSk7XG4gIHJldHVybiBuID8gKGQueSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLnkgPSArblswXSArICgrblswXSA+IDY4ID8gMTkwMCA6IDIwMDApLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlWm9uZShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSAvXihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8vLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XG4gIHJldHVybiBuID8gKGQuWiA9IG5bMV0gPyAwIDogLShuWzJdICsgKG5bM10gfHwgXCIwMFwiKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VRdWFydGVyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gKGQucSA9IG5bMF0gKiAzIC0gMywgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1vbnRoTnVtYmVyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQubSA9IG5bMF0gLSAxLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF5T2ZNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZURheU9mWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICByZXR1cm4gbiA/IChkLm0gPSAwLCBkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhvdXIyNChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLkggPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pbnV0ZXMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5NID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuUyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWlsbGlzZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gIHJldHVybiBuID8gKGQuTCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWljcm9zZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XG4gIHJldHVybiBuID8gKGQuTCA9IE1hdGguZmxvb3IoblswXSAvIDEwMDApLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGl0ZXJhbFBlcmNlbnQoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gcGVyY2VudFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gaSArIG5bMF0ubGVuZ3RoIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5peFRpbWVzdGFtcChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gIHJldHVybiBuID8gKGQuUSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5peFRpbWVzdGFtcFNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICByZXR1cm4gbiA/IChkLnMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXlPZk1vbnRoKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldERhdGUoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhvdXIyNChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SG91cjEyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERheU9mWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoMSArIHRpbWVEYXkuY291bnQodGltZVllYXIoZCksIGQpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldE1pbGxpc2Vjb25kcygpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWljcm9zZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSArIFwiMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1vbnRoTnVtYmVyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldE1vbnRoKCkgKyAxLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWludXRlcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNaW51dGVzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtkYXlOdW1iZXJNb25kYXkoZCkge1xuICB2YXIgZGF5ID0gZC5nZXREYXkoKTtcbiAgcmV0dXJuIGRheSA9PT0gMCA/IDcgOiBkYXk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKHRpbWVTdW5kYXkuY291bnQodGltZVllYXIoZCkgLSAxLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJJU08oZCwgcCkge1xuICB2YXIgZGF5ID0gZC5nZXREYXkoKTtcbiAgZCA9IChkYXkgPj0gNCB8fCBkYXkgPT09IDApID8gdGltZVRodXJzZGF5KGQpIDogdGltZVRodXJzZGF5LmNlaWwoZCk7XG4gIHJldHVybiBwYWQodGltZVRodXJzZGF5LmNvdW50KHRpbWVZZWFyKGQpLCBkKSArICh0aW1lWWVhcihkKS5nZXREYXkoKSA9PT0gNCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyU3VuZGF5KGQpIHtcbiAgcmV0dXJuIGQuZ2V0RGF5KCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKHRpbWVNb25kYXkuY291bnQodGltZVllYXIoZCkgLSAxLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEZ1bGxZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFpvbmUoZCkge1xuICB2YXIgeiA9IGQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgcmV0dXJuICh6ID4gMCA/IFwiLVwiIDogKHogKj0gLTEsIFwiK1wiKSlcbiAgICAgICsgcGFkKHogLyA2MCB8IDAsIFwiMFwiLCAyKVxuICAgICAgKyBwYWQoeiAlIDYwLCBcIjBcIiwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mTW9udGgoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRGF0ZSgpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDSG91cjI0KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMTIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZCgxICsgdXRjRGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01pbGxpc2Vjb25kcygpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWljcm9zZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSArIFwiMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoTnVtYmVyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWludXRlcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaW51dGVzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENTZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ1NlY29uZHMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXkoZCkge1xuICB2YXIgZG93ID0gZC5nZXRVVENEYXkoKTtcbiAgcmV0dXJuIGRvdyA9PT0gMCA/IDcgOiBkb3c7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKHV0Y1N1bmRheS5jb3VudCh1dGNZZWFyKGQpIC0gMSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVySVNPKGQsIHApIHtcbiAgdmFyIGRheSA9IGQuZ2V0VVRDRGF5KCk7XG4gIGQgPSAoZGF5ID49IDQgfHwgZGF5ID09PSAwKSA/IHV0Y1RodXJzZGF5KGQpIDogdXRjVGh1cnNkYXkuY2VpbChkKTtcbiAgcmV0dXJuIHBhZCh1dGNUaHVyc2RheS5jb3VudCh1dGNZZWFyKGQpLCBkKSArICh1dGNZZWFyKGQpLmdldFVUQ0RheSgpID09PSA0KSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJTdW5kYXkoZCkge1xuICByZXR1cm4gZC5nZXRVVENEYXkoKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlck1vbmRheShkLCBwKSB7XG4gIHJldHVybiBwYWQodXRjTW9uZGF5LmNvdW50KHV0Y1llYXIoZCkgLSAxLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1llYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0Z1bGxZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1pvbmUoKSB7XG4gIHJldHVybiBcIiswMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExpdGVyYWxQZXJjZW50KCkge1xuICByZXR1cm4gXCIlXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuaXhUaW1lc3RhbXAoZCkge1xuICByZXR1cm4gK2Q7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuaXhUaW1lc3RhbXBTZWNvbmRzKGQpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoK2QgLyAxMDAwKTtcbn1cbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvbkRheSwgZHVyYXRpb25NaW51dGV9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciBkYXkgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiBkdXJhdGlvbk1pbnV0ZSkgLyBkdXJhdGlvbkRheTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkYXk7XG5leHBvcnQgdmFyIGRheXMgPSBkYXkucmFuZ2U7XG4iLCJleHBvcnQgdmFyIGR1cmF0aW9uU2Vjb25kID0gMWUzO1xuZXhwb3J0IHZhciBkdXJhdGlvbk1pbnV0ZSA9IDZlNDtcbmV4cG9ydCB2YXIgZHVyYXRpb25Ib3VyID0gMzZlNTtcbmV4cG9ydCB2YXIgZHVyYXRpb25EYXkgPSA4NjRlNTtcbmV4cG9ydCB2YXIgZHVyYXRpb25XZWVrID0gNjA0OGU1O1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uSG91ciwgZHVyYXRpb25NaW51dGUsIGR1cmF0aW9uU2Vjb25kfSBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuXG52YXIgaG91ciA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRUaW1lKGRhdGUgLSBkYXRlLmdldE1pbGxpc2Vjb25kcygpIC0gZGF0ZS5nZXRTZWNvbmRzKCkgKiBkdXJhdGlvblNlY29uZCAtIGRhdGUuZ2V0TWludXRlcygpICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25Ib3VyKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkhvdXI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaG91cjtcbmV4cG9ydCB2YXIgaG91cnMgPSBob3VyLnJhbmdlO1xuIiwiZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB0aW1lSW50ZXJ2YWxcbn0gZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB0aW1lTWlsbGlzZWNvbmQsXG4gIG1pbGxpc2Vjb25kcyBhcyB0aW1lTWlsbGlzZWNvbmRzLFxuICBkZWZhdWx0IGFzIHV0Y01pbGxpc2Vjb25kLFxuICBtaWxsaXNlY29uZHMgYXMgdXRjTWlsbGlzZWNvbmRzXG59IGZyb20gXCIuL21pbGxpc2Vjb25kLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGltZVNlY29uZCxcbiAgc2Vjb25kcyBhcyB0aW1lU2Vjb25kcyxcbiAgZGVmYXVsdCBhcyB1dGNTZWNvbmQsXG4gIHNlY29uZHMgYXMgdXRjU2Vjb25kc1xufSBmcm9tIFwiLi9zZWNvbmQuanNcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB0aW1lTWludXRlLFxuICBtaW51dGVzIGFzIHRpbWVNaW51dGVzXG59IGZyb20gXCIuL21pbnV0ZS5qc1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHRpbWVIb3VyLFxuICBob3VycyBhcyB0aW1lSG91cnNcbn0gZnJvbSBcIi4vaG91ci5qc1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHRpbWVEYXksXG4gIGRheXMgYXMgdGltZURheXNcbn0gZnJvbSBcIi4vZGF5LmpzXCI7XG5cbmV4cG9ydCB7XG4gIHN1bmRheSBhcyB0aW1lV2VlayxcbiAgc3VuZGF5cyBhcyB0aW1lV2Vla3MsXG4gIHN1bmRheSBhcyB0aW1lU3VuZGF5LFxuICBzdW5kYXlzIGFzIHRpbWVTdW5kYXlzLFxuICBtb25kYXkgYXMgdGltZU1vbmRheSxcbiAgbW9uZGF5cyBhcyB0aW1lTW9uZGF5cyxcbiAgdHVlc2RheSBhcyB0aW1lVHVlc2RheSxcbiAgdHVlc2RheXMgYXMgdGltZVR1ZXNkYXlzLFxuICB3ZWRuZXNkYXkgYXMgdGltZVdlZG5lc2RheSxcbiAgd2VkbmVzZGF5cyBhcyB0aW1lV2VkbmVzZGF5cyxcbiAgdGh1cnNkYXkgYXMgdGltZVRodXJzZGF5LFxuICB0aHVyc2RheXMgYXMgdGltZVRodXJzZGF5cyxcbiAgZnJpZGF5IGFzIHRpbWVGcmlkYXksXG4gIGZyaWRheXMgYXMgdGltZUZyaWRheXMsXG4gIHNhdHVyZGF5IGFzIHRpbWVTYXR1cmRheSxcbiAgc2F0dXJkYXlzIGFzIHRpbWVTYXR1cmRheXNcbn0gZnJvbSBcIi4vd2Vlay5qc1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHRpbWVNb250aCxcbiAgbW9udGhzIGFzIHRpbWVNb250aHNcbn0gZnJvbSBcIi4vbW9udGguanNcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB0aW1lWWVhcixcbiAgeWVhcnMgYXMgdGltZVllYXJzXG59IGZyb20gXCIuL3llYXIuanNcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB1dGNNaW51dGUsXG4gIHV0Y01pbnV0ZXMgYXMgdXRjTWludXRlc1xufSBmcm9tIFwiLi91dGNNaW51dGUuanNcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB1dGNIb3VyLFxuICB1dGNIb3VycyBhcyB1dGNIb3Vyc1xufSBmcm9tIFwiLi91dGNIb3VyLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdXRjRGF5LFxuICB1dGNEYXlzIGFzIHV0Y0RheXNcbn0gZnJvbSBcIi4vdXRjRGF5LmpzXCI7XG5cbmV4cG9ydCB7XG4gIHV0Y1N1bmRheSBhcyB1dGNXZWVrLFxuICB1dGNTdW5kYXlzIGFzIHV0Y1dlZWtzLFxuICB1dGNTdW5kYXkgYXMgdXRjU3VuZGF5LFxuICB1dGNTdW5kYXlzIGFzIHV0Y1N1bmRheXMsXG4gIHV0Y01vbmRheSBhcyB1dGNNb25kYXksXG4gIHV0Y01vbmRheXMgYXMgdXRjTW9uZGF5cyxcbiAgdXRjVHVlc2RheSBhcyB1dGNUdWVzZGF5LFxuICB1dGNUdWVzZGF5cyBhcyB1dGNUdWVzZGF5cyxcbiAgdXRjV2VkbmVzZGF5IGFzIHV0Y1dlZG5lc2RheSxcbiAgdXRjV2VkbmVzZGF5cyBhcyB1dGNXZWRuZXNkYXlzLFxuICB1dGNUaHVyc2RheSBhcyB1dGNUaHVyc2RheSxcbiAgdXRjVGh1cnNkYXlzIGFzIHV0Y1RodXJzZGF5cyxcbiAgdXRjRnJpZGF5IGFzIHV0Y0ZyaWRheSxcbiAgdXRjRnJpZGF5cyBhcyB1dGNGcmlkYXlzLFxuICB1dGNTYXR1cmRheSBhcyB1dGNTYXR1cmRheSxcbiAgdXRjU2F0dXJkYXlzIGFzIHV0Y1NhdHVyZGF5c1xufSBmcm9tIFwiLi91dGNXZWVrLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdXRjTW9udGgsXG4gIHV0Y01vbnRocyBhcyB1dGNNb250aHNcbn0gZnJvbSBcIi4vdXRjTW9udGguanNcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB1dGNZZWFyLFxuICB1dGNZZWFycyBhcyB1dGNZZWFyc1xufSBmcm9tIFwiLi91dGNZZWFyLmpzXCI7XG4iLCJ2YXIgdDAgPSBuZXcgRGF0ZSxcbiAgICB0MSA9IG5ldyBEYXRlO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuZXdJbnRlcnZhbChmbG9vcmksIG9mZnNldGksIGNvdW50LCBmaWVsZCkge1xuXG4gIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwID8gbmV3IERhdGUgOiBuZXcgRGF0ZSgrZGF0ZSkpLCBkYXRlO1xuICB9XG5cbiAgaW50ZXJ2YWwuZmxvb3IgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgfTtcblxuICBpbnRlcnZhbC5jZWlsID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKGRhdGUgLSAxKSksIG9mZnNldGkoZGF0ZSwgMSksIGZsb29yaShkYXRlKSwgZGF0ZTtcbiAgfTtcblxuICBpbnRlcnZhbC5yb3VuZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgZDAgPSBpbnRlcnZhbChkYXRlKSxcbiAgICAgICAgZDEgPSBpbnRlcnZhbC5jZWlsKGRhdGUpO1xuICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICB9O1xuXG4gIGludGVydmFsLm9mZnNldCA9IGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICByZXR1cm4gb2Zmc2V0aShkYXRlID0gbmV3IERhdGUoK2RhdGUpLCBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKSksIGRhdGU7XG4gIH07XG5cbiAgaW50ZXJ2YWwucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIHZhciByYW5nZSA9IFtdLCBwcmV2aW91cztcbiAgICBzdGFydCA9IGludGVydmFsLmNlaWwoc3RhcnQpO1xuICAgIHN0ZXAgPSBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKTtcbiAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcbiAgICBkbyByYW5nZS5wdXNoKHByZXZpb3VzID0gbmV3IERhdGUoK3N0YXJ0KSksIG9mZnNldGkoc3RhcnQsIHN0ZXApLCBmbG9vcmkoc3RhcnQpO1xuICAgIHdoaWxlIChwcmV2aW91cyA8IHN0YXJ0ICYmIHN0YXJ0IDwgc3RvcCk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIGludGVydmFsLmZpbHRlciA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgaWYgKGRhdGUgPj0gZGF0ZSkgd2hpbGUgKGZsb29yaShkYXRlKSwgIXRlc3QoZGF0ZSkpIGRhdGUuc2V0VGltZShkYXRlIC0gMSk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgaWYgKGRhdGUgPj0gZGF0ZSkge1xuICAgICAgICBpZiAoc3RlcCA8IDApIHdoaWxlICgrK3N0ZXAgPD0gMCkge1xuICAgICAgICAgIHdoaWxlIChvZmZzZXRpKGRhdGUsIC0xKSwgIXRlc3QoZGF0ZSkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBlbHNlIHdoaWxlICgtLXN0ZXAgPj0gMCkge1xuICAgICAgICAgIHdoaWxlIChvZmZzZXRpKGRhdGUsICsxKSwgIXRlc3QoZGF0ZSkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGlmIChjb3VudCkge1xuICAgIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgZmxvb3JpKHQwKSwgZmxvb3JpKHQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwLCB0MSkpO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5ldmVyeSA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgcmV0dXJuICFpc0Zpbml0ZShzdGVwKSB8fCAhKHN0ZXAgPiAwKSA/IG51bGxcbiAgICAgICAgICA6ICEoc3RlcCA+IDEpID8gaW50ZXJ2YWxcbiAgICAgICAgICA6IGludGVydmFsLmZpbHRlcihmaWVsZFxuICAgICAgICAgICAgICA/IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGZpZWxkKGQpICUgc3RlcCA9PT0gMDsgfVxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGludGVydmFsLmNvdW50KDAsIGQpICUgc3RlcCA9PT0gMDsgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpbnRlcnZhbDtcbn1cbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuXG52YXIgbWlsbGlzZWNvbmQgPSBpbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgLy8gbm9vcFxufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbm1pbGxpc2Vjb25kLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICBrID0gTWF0aC5mbG9vcihrKTtcbiAgaWYgKCFpc0Zpbml0ZShrKSB8fCAhKGsgPiAwKSkgcmV0dXJuIG51bGw7XG4gIGlmICghKGsgPiAxKSkgcmV0dXJuIG1pbGxpc2Vjb25kO1xuICByZXR1cm4gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBrKSAqIGspO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGspO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBrO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1pbGxpc2Vjb25kO1xuZXhwb3J0IHZhciBtaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZC5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvbk1pbnV0ZSwgZHVyYXRpb25TZWNvbmR9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciBtaW51dGUgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShkYXRlIC0gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAtIGRhdGUuZ2V0U2Vjb25kcygpICogZHVyYXRpb25TZWNvbmQpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uTWludXRlO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRNaW51dGVzKCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWludXRlO1xuZXhwb3J0IHZhciBtaW51dGVzID0gbWludXRlLnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5cbnZhciBtb250aCA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXREYXRlKDEpO1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldE1vbnRoKCkgLSBzdGFydC5nZXRNb250aCgpICsgKGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKSkgKiAxMjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtb250aDtcbmV4cG9ydCB2YXIgbW9udGhzID0gbW9udGgucmFuZ2U7XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCB7ZHVyYXRpb25TZWNvbmR9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciBzZWNvbmQgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShkYXRlIC0gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvblNlY29uZCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25TZWNvbmQ7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ1NlY29uZHMoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzZWNvbmQ7XG5leHBvcnQgdmFyIHNlY29uZHMgPSBzZWNvbmQucmFuZ2U7XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCB7ZHVyYXRpb25EYXl9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciB1dGNEYXkgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uRGF5O1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENEYXRlKCkgLSAxO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0Y0RheTtcbmV4cG9ydCB2YXIgdXRjRGF5cyA9IHV0Y0RheS5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvbkhvdXJ9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciB1dGNIb3VyID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01pbnV0ZXMoMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbkhvdXIpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uSG91cjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB1dGNIb3VyO1xuZXhwb3J0IHZhciB1dGNIb3VycyA9IHV0Y0hvdXIucmFuZ2U7XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCB7ZHVyYXRpb25NaW51dGV9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciB1dGNNaW51dGUgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDU2Vjb25kcygwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uTWludXRlKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbk1pbnV0ZTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDTWludXRlcygpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0Y01pbnV0ZTtcbmV4cG9ydCB2YXIgdXRjTWludXRlcyA9IHV0Y01pbnV0ZS5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuXG52YXIgdXRjTW9udGggPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDRGF0ZSgxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENNb250aChkYXRlLmdldFVUQ01vbnRoKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRVVENNb250aCgpIC0gc3RhcnQuZ2V0VVRDTW9udGgoKSArIChlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCkpICogMTI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ01vbnRoKCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdXRjTW9udGg7XG5leHBvcnQgdmFyIHV0Y01vbnRocyA9IHV0Y01vbnRoLnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uV2Vla30gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxuZnVuY3Rpb24gdXRjV2Vla2RheShpKSB7XG4gIHJldHVybiBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbldlZWs7XG4gIH0pO1xufVxuXG5leHBvcnQgdmFyIHV0Y1N1bmRheSA9IHV0Y1dlZWtkYXkoMCk7XG5leHBvcnQgdmFyIHV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG5leHBvcnQgdmFyIHV0Y1R1ZXNkYXkgPSB1dGNXZWVrZGF5KDIpO1xuZXhwb3J0IHZhciB1dGNXZWRuZXNkYXkgPSB1dGNXZWVrZGF5KDMpO1xuZXhwb3J0IHZhciB1dGNUaHVyc2RheSA9IHV0Y1dlZWtkYXkoNCk7XG5leHBvcnQgdmFyIHV0Y0ZyaWRheSA9IHV0Y1dlZWtkYXkoNSk7XG5leHBvcnQgdmFyIHV0Y1NhdHVyZGF5ID0gdXRjV2Vla2RheSg2KTtcblxuZXhwb3J0IHZhciB1dGNTdW5kYXlzID0gdXRjU3VuZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNNb25kYXlzID0gdXRjTW9uZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y1dlZG5lc2RheXMgPSB1dGNXZWRuZXNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y1RodXJzZGF5cyA9IHV0Y1RodXJzZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNGcmlkYXlzID0gdXRjRnJpZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNTYXR1cmRheXMgPSB1dGNTYXR1cmRheS5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuXG52YXIgdXRjWWVhciA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG51dGNZZWFyLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gIWlzRmluaXRlKGsgPSBNYXRoLmZsb29yKGspKSB8fCAhKGsgPiAwKSA/IG51bGwgOiBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihNYXRoLmZsb29yKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAvIGspICogayk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwICogayk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXRjWWVhcjtcbmV4cG9ydCB2YXIgdXRjWWVhcnMgPSB1dGNZZWFyLnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uTWludXRlLCBkdXJhdGlvbldlZWt9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbmZ1bmN0aW9uIHdlZWtkYXkoaSkge1xuICByZXR1cm4gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlKSAvIGR1cmF0aW9uV2VlaztcbiAgfSk7XG59XG5cbmV4cG9ydCB2YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcbmV4cG9ydCB2YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcbmV4cG9ydCB2YXIgdHVlc2RheSA9IHdlZWtkYXkoMik7XG5leHBvcnQgdmFyIHdlZG5lc2RheSA9IHdlZWtkYXkoMyk7XG5leHBvcnQgdmFyIHRodXJzZGF5ID0gd2Vla2RheSg0KTtcbmV4cG9ydCB2YXIgZnJpZGF5ID0gd2Vla2RheSg1KTtcbmV4cG9ydCB2YXIgc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xuXG5leHBvcnQgdmFyIHN1bmRheXMgPSBzdW5kYXkucmFuZ2U7XG5leHBvcnQgdmFyIG1vbmRheXMgPSBtb25kYXkucmFuZ2U7XG5leHBvcnQgdmFyIHR1ZXNkYXlzID0gdHVlc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgd2VkbmVzZGF5cyA9IHdlZG5lc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgdGh1cnNkYXlzID0gdGh1cnNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIGZyaWRheXMgPSBmcmlkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHNhdHVyZGF5cyA9IHNhdHVyZGF5LnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5cbnZhciB5ZWFyID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbnllYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiAhaXNGaW5pdGUoayA9IE1hdGguZmxvb3IoaykpIHx8ICEoayA+IDApID8gbnVsbCA6IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRGdWxsWWVhcigpIC8gaykgKiBrKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB5ZWFyO1xuZXhwb3J0IHZhciB5ZWFycyA9IHllYXIucmFuZ2U7XG4iLCJleHBvcnQge1xuICBub3csXG4gIHRpbWVyLFxuICB0aW1lckZsdXNoXG59IGZyb20gXCIuL3RpbWVyLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGltZW91dFxufSBmcm9tIFwiLi90aW1lb3V0LmpzXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgaW50ZXJ2YWxcbn0gZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbiIsImltcG9ydCB7VGltZXIsIG5vd30gZnJvbSBcIi4vdGltZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyLCB0b3RhbCA9IGRlbGF5O1xuICBpZiAoZGVsYXkgPT0gbnVsbCkgcmV0dXJuIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpLCB0O1xuICBkZWxheSA9ICtkZWxheSwgdGltZSA9IHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWU7XG4gIHQucmVzdGFydChmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICBlbGFwc2VkICs9IHRvdGFsO1xuICAgIHQucmVzdGFydCh0aWNrLCB0b3RhbCArPSBkZWxheSwgdGltZSk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCk7XG4gIH0sIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG4iLCJpbXBvcnQge1RpbWVyfSBmcm9tIFwiLi90aW1lci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIGRlbGF5ID0gZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXk7XG4gIHQucmVzdGFydChmdW5jdGlvbihlbGFwc2VkKSB7XG4gICAgdC5zdG9wKCk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCArIGRlbGF5KTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cbiIsInZhciBmcmFtZSA9IDAsIC8vIGlzIGFuIGFuaW1hdGlvbiBmcmFtZSBwZW5kaW5nP1xuICAgIHRpbWVvdXQgPSAwLCAvLyBpcyBhIHRpbWVvdXQgcGVuZGluZz9cbiAgICBpbnRlcnZhbCA9IDAsIC8vIGFyZSBhbnkgdGltZXJzIGFjdGl2ZT9cbiAgICBwb2tlRGVsYXkgPSAxMDAwLCAvLyBob3cgZnJlcXVlbnRseSB3ZSBjaGVjayBmb3IgY2xvY2sgc2tld1xuICAgIHRhc2tIZWFkLFxuICAgIHRhc2tUYWlsLFxuICAgIGNsb2NrTGFzdCA9IDAsXG4gICAgY2xvY2tOb3cgPSAwLFxuICAgIGNsb2NrU2tldyA9IDAsXG4gICAgY2xvY2sgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwib2JqZWN0XCIgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2UgOiBEYXRlLFxuICAgIHNldEZyYW1lID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbihmKSB7IHNldFRpbWVvdXQoZiwgMTcpOyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xuICBjbG9ja05vdyA9IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUaW1lcigpIHtcbiAgdGhpcy5fY2FsbCA9XG4gIHRoaXMuX3RpbWUgPVxuICB0aGlzLl9uZXh0ID0gbnVsbDtcbn1cblxuVGltZXIucHJvdG90eXBlID0gdGltZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGltZXIsXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIHRpbWUgPSAodGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZSkgKyAoZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXkpO1xuICAgIGlmICghdGhpcy5fbmV4dCAmJiB0YXNrVGFpbCAhPT0gdGhpcykge1xuICAgICAgaWYgKHRhc2tUYWlsKSB0YXNrVGFpbC5fbmV4dCA9IHRoaXM7XG4gICAgICBlbHNlIHRhc2tIZWFkID0gdGhpcztcbiAgICAgIHRhc2tUYWlsID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fY2FsbCA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHNsZWVwKCk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jYWxsKSB7XG4gICAgICB0aGlzLl9jYWxsID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWUgPSBJbmZpbml0eTtcbiAgICAgIHNsZWVwKCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZXIoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lckZsdXNoKCkge1xuICBub3coKTsgLy8gR2V0IHRoZSBjdXJyZW50IHRpbWUsIGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgKytmcmFtZTsgLy8gUHJldGVuZCB3ZeKAmXZlIHNldCBhbiBhbGFybSwgaWYgd2UgaGF2ZW7igJl0IGFscmVhZHkuXG4gIHZhciB0ID0gdGFza0hlYWQsIGU7XG4gIHdoaWxlICh0KSB7XG4gICAgaWYgKChlID0gY2xvY2tOb3cgLSB0Ll90aW1lKSA+PSAwKSB0Ll9jYWxsLmNhbGwobnVsbCwgZSk7XG4gICAgdCA9IHQuX25leHQ7XG4gIH1cbiAgLS1mcmFtZTtcbn1cblxuZnVuY3Rpb24gd2FrZSgpIHtcbiAgY2xvY2tOb3cgPSAoY2xvY2tMYXN0ID0gY2xvY2subm93KCkpICsgY2xvY2tTa2V3O1xuICBmcmFtZSA9IHRpbWVvdXQgPSAwO1xuICB0cnkge1xuICAgIHRpbWVyRmx1c2goKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmcmFtZSA9IDA7XG4gICAgbmFwKCk7XG4gICAgY2xvY2tOb3cgPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBva2UoKSB7XG4gIHZhciBub3cgPSBjbG9jay5ub3coKSwgZGVsYXkgPSBub3cgLSBjbG9ja0xhc3Q7XG4gIGlmIChkZWxheSA+IHBva2VEZWxheSkgY2xvY2tTa2V3IC09IGRlbGF5LCBjbG9ja0xhc3QgPSBub3c7XG59XG5cbmZ1bmN0aW9uIG5hcCgpIHtcbiAgdmFyIHQwLCB0MSA9IHRhc2tIZWFkLCB0MiwgdGltZSA9IEluZmluaXR5O1xuICB3aGlsZSAodDEpIHtcbiAgICBpZiAodDEuX2NhbGwpIHtcbiAgICAgIGlmICh0aW1lID4gdDEuX3RpbWUpIHRpbWUgPSB0MS5fdGltZTtcbiAgICAgIHQwID0gdDEsIHQxID0gdDEuX25leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQyID0gdDEuX25leHQsIHQxLl9uZXh0ID0gbnVsbDtcbiAgICAgIHQxID0gdDAgPyB0MC5fbmV4dCA9IHQyIDogdGFza0hlYWQgPSB0MjtcbiAgICB9XG4gIH1cbiAgdGFza1RhaWwgPSB0MDtcbiAgc2xlZXAodGltZSk7XG59XG5cbmZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgaWYgKGZyYW1lKSByZXR1cm47IC8vIFNvb25lc3QgYWxhcm0gYWxyZWFkeSBzZXQsIG9yIHdpbGwgYmUuXG4gIGlmICh0aW1lb3V0KSB0aW1lb3V0ID0gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB2YXIgZGVsYXkgPSB0aW1lIC0gY2xvY2tOb3c7IC8vIFN0cmljdGx5IGxlc3MgdGhhbiBpZiB3ZSByZWNvbXB1dGVkIGNsb2NrTm93LlxuICBpZiAoZGVsYXkgPiAyNCkge1xuICAgIGlmICh0aW1lIDwgSW5maW5pdHkpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHdha2UsIHRpbWUgLSBjbG9jay5ub3coKSAtIGNsb2NrU2tldyk7XG4gICAgaWYgKGludGVydmFsKSBpbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW50ZXJ2YWwpIGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpLCBpbnRlcnZhbCA9IHNldEludGVydmFsKHBva2UsIHBva2VEZWxheSk7XG4gICAgZnJhbWUgPSAxLCBzZXRGcmFtZSh3YWtlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQge1NDSEVEVUxFRH0gZnJvbSBcIi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuXG52YXIgcm9vdCA9IFtudWxsXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGk7XG5cbiAgaWYgKHNjaGVkdWxlcykge1xuICAgIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkuc3RhdGUgPiBTQ0hFRFVMRUQgJiYgc2NoZWR1bGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zaXRpb24oW1tub2RlXV0sIHJvb3QsIG5hbWUsICtpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJhbnNpdGlvbn0gZnJvbSBcIi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGFjdGl2ZX0gZnJvbSBcIi4vYWN0aXZlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJydXB0fSBmcm9tIFwiLi9pbnRlcnJ1cHQuanNcIjtcbiIsImltcG9ydCB7U1RBUlRJTkcsIEVORElORywgRU5ERUR9IGZyb20gXCIuL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGVtcHR5ID0gdHJ1ZSxcbiAgICAgIGk7XG5cbiAgaWYgKCFzY2hlZHVsZXMpIHJldHVybjtcblxuICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuXG4gIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5uYW1lICE9PSBuYW1lKSB7IGVtcHR5ID0gZmFsc2U7IGNvbnRpbnVlOyB9XG4gICAgYWN0aXZlID0gc2NoZWR1bGUuc3RhdGUgPiBTVEFSVElORyAmJiBzY2hlZHVsZS5zdGF0ZSA8IEVORElORztcbiAgICBzY2hlZHVsZS5zdGF0ZSA9IEVOREVEO1xuICAgIHNjaGVkdWxlLnRpbWVyLnN0b3AoKTtcbiAgICBzY2hlZHVsZS5vbi5jYWxsKGFjdGl2ZSA/IFwiaW50ZXJydXB0XCIgOiBcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzY2hlZHVsZS5pbmRleCwgc2NoZWR1bGUuZ3JvdXApO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gIH1cblxuICBpZiAoZW1wdHkpIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2ludGVycnVwdCBmcm9tIFwiLi9pbnRlcnJ1cHQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fdHJhbnNpdGlvbiBmcm9tIFwiLi90cmFuc2l0aW9uLmpzXCI7XG5cbnNlbGVjdGlvbi5wcm90b3R5cGUuaW50ZXJydXB0ID0gc2VsZWN0aW9uX2ludGVycnVwdDtcbnNlbGVjdGlvbi5wcm90b3R5cGUudHJhbnNpdGlvbiA9IHNlbGVjdGlvbl90cmFuc2l0aW9uO1xuIiwiaW1wb3J0IGludGVycnVwdCBmcm9tIFwiLi4vaW50ZXJydXB0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICBpbnRlcnJ1cHQodGhpcywgbmFtZSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9uLCBuZXdJZH0gZnJvbSBcIi4uL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSBmcm9tIFwiLi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuaW1wb3J0IHtlYXNlQ3ViaWNJbk91dH0gZnJvbSBcImQzLWVhc2VcIjtcbmltcG9ydCB7bm93fSBmcm9tIFwiZDMtdGltZXJcIjtcblxudmFyIGRlZmF1bHRUaW1pbmcgPSB7XG4gIHRpbWU6IG51bGwsIC8vIFNldCBvbiB1c2UuXG4gIGRlbGF5OiAwLFxuICBkdXJhdGlvbjogMjUwLFxuICBlYXNlOiBlYXNlQ3ViaWNJbk91dFxufTtcblxuZnVuY3Rpb24gaW5oZXJpdChub2RlLCBpZCkge1xuICB2YXIgdGltaW5nO1xuICB3aGlsZSAoISh0aW1pbmcgPSBub2RlLl9fdHJhbnNpdGlvbikgfHwgISh0aW1pbmcgPSB0aW1pbmdbaWRdKSkge1xuICAgIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFRpbWluZy50aW1lID0gbm93KCksIGRlZmF1bHRUaW1pbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aW1pbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGlkLFxuICAgICAgdGltaW5nO1xuXG4gIGlmIChuYW1lIGluc3RhbmNlb2YgVHJhbnNpdGlvbikge1xuICAgIGlkID0gbmFtZS5faWQsIG5hbWUgPSBuYW1lLl9uYW1lO1xuICB9IGVsc2Uge1xuICAgIGlkID0gbmV3SWQoKSwgKHRpbWluZyA9IGRlZmF1bHRUaW1pbmcpLnRpbWUgPSBub3coKSwgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkLCBpLCBncm91cCwgdGltaW5nIHx8IGluaGVyaXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtU3ZnIGFzIGludGVycG9sYXRlVHJhbnNmb3JtfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7bmFtZXNwYWNlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgaW50ZXJwb2xhdGUgZnJvbSBcIi4vaW50ZXJwb2xhdGUuanNcIjtcblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSwgc3RyaW5nMTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCwgdmFsdWUxID0gdmFsdWUodGhpcyksIHN0cmluZzE7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKSwgaSA9IGZ1bGxuYW1lID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHRoaXMuYXR0clR3ZWVuKG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKShmdWxsbmFtZSwgaSwgdHdlZW5WYWx1ZSh0aGlzLCBcImF0dHIuXCIgKyBuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHZhbHVlID09IG51bGwgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKShmdWxsbmFtZSlcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKGZ1bGxuYW1lLCBpLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtuYW1lc3BhY2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxuZnVuY3Rpb24gYXR0ckludGVycG9sYXRlKG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBpLmNhbGwodGhpcywgdCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRySW50ZXJwb2xhdGVOUyhmdWxsbmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCBpLmNhbGwodGhpcywgdCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW5OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiBhdHRySW50ZXJwb2xhdGVOUyhmdWxsbmFtZSwgaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2VlbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIGF0dHJJbnRlcnBvbGF0ZShuYW1lLCBpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGtleSA9IFwiYXR0ci5cIiArIG5hbWU7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIChmdWxsbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBpbml0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBkZWxheUZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVsYXlDb25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBkZWxheUZ1bmN0aW9uXG4gICAgICAgICAgOiBkZWxheUNvbnN0YW50KShpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5kZWxheTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGR1cmF0aW9uRnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBkdXJhdGlvbkZ1bmN0aW9uXG4gICAgICAgICAgOiBkdXJhdGlvbkNvbnN0YW50KShpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5kdXJhdGlvbjtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGVhc2VDb25zdGFudChpZCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmVhc2UgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKGVhc2VDb25zdGFudChpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5lYXNlO1xufVxuIiwiaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgb24wLCBvbjEsIHRoYXQgPSB0aGlzLCBpZCA9IHRoYXQuX2lkLCBzaXplID0gdGhhdC5zaXplKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgY2FuY2VsID0ge3ZhbHVlOiByZWplY3R9LFxuICAgICAgICBlbmQgPSB7dmFsdWU6IGZ1bmN0aW9uKCkgeyBpZiAoLS1zaXplID09PSAwKSByZXNvbHZlKCk7IH19O1xuXG4gICAgdGhhdC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgICAgaWYgKG9uICE9PSBvbjApIHtcbiAgICAgICAgb24xID0gKG9uMCA9IG9uKS5jb3B5KCk7XG4gICAgICAgIG9uMS5fLmNhbmNlbC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmludGVycnVwdC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmVuZC5wdXNoKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsImltcG9ydCB7bWF0Y2hlcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB0cmFuc2l0aW9uX2F0dHIgZnJvbSBcIi4vYXR0ci5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fYXR0clR3ZWVuIGZyb20gXCIuL2F0dHJUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZGVsYXkgZnJvbSBcIi4vZGVsYXkuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2R1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lYXNlIGZyb20gXCIuL2Vhc2UuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXIuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX21lcmdlIGZyb20gXCIuL21lcmdlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9vbiBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0QWxsIGZyb20gXCIuL3NlbGVjdEFsbC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0aW9uIGZyb20gXCIuL3NlbGVjdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3N0eWxlVHdlZW4gZnJvbSBcIi4vc3R5bGVUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90ZXh0VHdlZW4gZnJvbSBcIi4vdGV4dFR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90cmFuc2l0aW9uIGZyb20gXCIuL3RyYW5zaXRpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3R3ZWVuIGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lbmQgZnJvbSBcIi4vZW5kLmpzXCI7XG5cbnZhciBpZCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2l0aW9uKGdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX2lkID0gaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zaXRpb24obmFtZSkge1xuICByZXR1cm4gc2VsZWN0aW9uKCkudHJhbnNpdGlvbihuYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0lkKCkge1xuICByZXR1cm4gKytpZDtcbn1cblxudmFyIHNlbGVjdGlvbl9wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlO1xuXG5UcmFuc2l0aW9uLnByb3RvdHlwZSA9IHRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbixcbiAgc2VsZWN0OiB0cmFuc2l0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiB0cmFuc2l0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiB0cmFuc2l0aW9uX2ZpbHRlcixcbiAgbWVyZ2U6IHRyYW5zaXRpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogdHJhbnNpdGlvbl9zZWxlY3Rpb24sXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25fdHJhbnNpdGlvbixcbiAgY2FsbDogc2VsZWN0aW9uX3Byb3RvdHlwZS5jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fcHJvdG90eXBlLmVtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fcHJvdG90eXBlLmVhY2gsXG4gIG9uOiB0cmFuc2l0aW9uX29uLFxuICBhdHRyOiB0cmFuc2l0aW9uX2F0dHIsXG4gIGF0dHJUd2VlbjogdHJhbnNpdGlvbl9hdHRyVHdlZW4sXG4gIHN0eWxlOiB0cmFuc2l0aW9uX3N0eWxlLFxuICBzdHlsZVR3ZWVuOiB0cmFuc2l0aW9uX3N0eWxlVHdlZW4sXG4gIHRleHQ6IHRyYW5zaXRpb25fdGV4dCxcbiAgdGV4dFR3ZWVuOiB0cmFuc2l0aW9uX3RleHRUd2VlbixcbiAgcmVtb3ZlOiB0cmFuc2l0aW9uX3JlbW92ZSxcbiAgdHdlZW46IHRyYW5zaXRpb25fdHdlZW4sXG4gIGRlbGF5OiB0cmFuc2l0aW9uX2RlbGF5LFxuICBkdXJhdGlvbjogdHJhbnNpdGlvbl9kdXJhdGlvbixcbiAgZWFzZTogdHJhbnNpdGlvbl9lYXNlLFxuICBlbmQ6IHRyYW5zaXRpb25fZW5kXG59O1xuIiwiaW1wb3J0IHtjb2xvcn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQge2ludGVycG9sYXRlTnVtYmVyLCBpbnRlcnBvbGF0ZVJnYiwgaW50ZXJwb2xhdGVTdHJpbmd9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBjO1xuICByZXR1cm4gKHR5cGVvZiBiID09PSBcIm51bWJlclwiID8gaW50ZXJwb2xhdGVOdW1iZXJcbiAgICAgIDogYiBpbnN0YW5jZW9mIGNvbG9yID8gaW50ZXJwb2xhdGVSZ2JcbiAgICAgIDogKGMgPSBjb2xvcihiKSkgPyAoYiA9IGMsIGludGVycG9sYXRlUmdiKVxuICAgICAgOiBpbnRlcnBvbGF0ZVN0cmluZykoYSwgYik7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcbiAgaWYgKHRyYW5zaXRpb24uX2lkICE9PSB0aGlzLl9pZCkgdGhyb3cgbmV3IEVycm9yO1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSB0cmFuc2l0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXQsIGluaXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0YXJ0KG5hbWUpIHtcbiAgcmV0dXJuIChuYW1lICsgXCJcIikudHJpbSgpLnNwbGl0KC9efFxccysvKS5ldmVyeShmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiAhdCB8fCB0ID09PSBcInN0YXJ0XCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgb24wLCBvbjEsIHNpdCA9IHN0YXJ0KG5hbWUpID8gaW5pdCA6IHNldDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNpdCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub247XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjApIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24obmFtZSwgbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMlxuICAgICAgPyBnZXQodGhpcy5ub2RlKCksIGlkKS5vbi5vbihuYW1lKVxuICAgICAgOiB0aGlzLmVhY2gob25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZUZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5fX3RyYW5zaXRpb24pIGlmICgraSAhPT0gaWQpIHJldHVybjtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vbihcImVuZC5yZW1vdmVcIiwgcmVtb3ZlRnVuY3Rpb24odGhpcy5faWQpKTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHt0aW1lciwgdGltZW91dH0gZnJvbSBcImQzLXRpbWVyXCI7XG5cbnZhciBlbXB0eU9uID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImNhbmNlbFwiLCBcImludGVycnVwdFwiKTtcbnZhciBlbXB0eVR3ZWVuID0gW107XG5cbmV4cG9ydCB2YXIgQ1JFQVRFRCA9IDA7XG5leHBvcnQgdmFyIFNDSEVEVUxFRCA9IDE7XG5leHBvcnQgdmFyIFNUQVJUSU5HID0gMjtcbmV4cG9ydCB2YXIgU1RBUlRFRCA9IDM7XG5leHBvcnQgdmFyIFJVTk5JTkcgPSA0O1xuZXhwb3J0IHZhciBFTkRJTkcgPSA1O1xuZXhwb3J0IHZhciBFTkRFRCA9IDY7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUsIGlkLCBpbmRleCwgZ3JvdXAsIHRpbWluZykge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGVzKSBub2RlLl9fdHJhbnNpdGlvbiA9IHt9O1xuICBlbHNlIGlmIChpZCBpbiBzY2hlZHVsZXMpIHJldHVybjtcbiAgY3JlYXRlKG5vZGUsIGlkLCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBpbmRleDogaW5kZXgsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBncm91cDogZ3JvdXAsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBvbjogZW1wdHlPbixcbiAgICB0d2VlbjogZW1wdHlUd2VlbixcbiAgICB0aW1lOiB0aW1pbmcudGltZSxcbiAgICBkZWxheTogdGltaW5nLmRlbGF5LFxuICAgIGR1cmF0aW9uOiB0aW1pbmcuZHVyYXRpb24sXG4gICAgZWFzZTogdGltaW5nLmVhc2UsXG4gICAgdGltZXI6IG51bGwsXG4gICAgc3RhdGU6IENSRUFURURcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IENSRUFURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IFNUQVJURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZSB8fCAhKHNjaGVkdWxlID0gc2NoZWR1bGVbaWRdKSkgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNpdGlvbiBub3QgZm91bmRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5vZGUsIGlkLCBzZWxmKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHR3ZWVuO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHNlbGYgdGltZXIgd2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLlxuICAvLyBOb3RlIHRoZSBhY3R1YWwgZGVsYXkgaXMgbm90IGtub3duIHVudGlsIHRoZSBmaXJzdCBjYWxsYmFjayFcbiAgc2NoZWR1bGVzW2lkXSA9IHNlbGY7XG4gIHNlbGYudGltZXIgPSB0aW1lcihzY2hlZHVsZSwgMCwgc2VsZi50aW1lKTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XG4gICAgc2VsZi5zdGF0ZSA9IFNDSEVEVUxFRDtcbiAgICBzZWxmLnRpbWVyLnJlc3RhcnQoc3RhcnQsIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG5cbiAgICAvLyBJZiB0aGUgZWxhcHNlZCBkZWxheSBpcyBsZXNzIHRoYW4gb3VyIGZpcnN0IHNsZWVwLCBzdGFydCBpbW1lZGlhdGVseS5cbiAgICBpZiAoc2VsZi5kZWxheSA8PSBlbGFwc2VkKSBzdGFydChlbGFwc2VkIC0gc2VsZi5kZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgdmFyIGksIGosIG4sIG87XG5cbiAgICAvLyBJZiB0aGUgc3RhdGUgaXMgbm90IFNDSEVEVUxFRCwgdGhlbiB3ZSBwcmV2aW91c2x5IGVycm9yZWQgb24gc3RhcnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNDSEVEVUxFRCkgcmV0dXJuIHN0b3AoKTtcblxuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIG8gPSBzY2hlZHVsZXNbaV07XG4gICAgICBpZiAoby5uYW1lICE9PSBzZWxmLm5hbWUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBXaGlsZSB0aGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYSBzdGFydGluZyB0cmFuc2l0aW9uIGR1cmluZyB0aGlzIGZyYW1lLFxuICAgICAgLy8gZGVmZXIgc3RhcnRpbmcgYW4gaW50ZXJydXB0aW5nIHRyYW5zaXRpb24gdW50aWwgdGhhdCB0cmFuc2l0aW9uIGhhcyBhXG4gICAgICAvLyBjaGFuY2UgdG8gdGljayAoYW5kIHBvc3NpYmx5IGVuZCk7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzU0IVxuICAgICAgaWYgKG8uc3RhdGUgPT09IFNUQVJURUQpIHJldHVybiB0aW1lb3V0KHN0YXJ0KTtcblxuICAgICAgLy8gSW50ZXJydXB0IHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgaWYgYW55LlxuICAgICAgaWYgKG8uc3RhdGUgPT09IFJVTk5JTkcpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBDYW5jZWwgYW55IHByZS1lbXB0ZWQgdHJhbnNpdGlvbnMuXG4gICAgICBlbHNlIGlmICgraSA8IGlkKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZlciB0aGUgZmlyc3QgdGljayB0byBlbmQgb2YgdGhlIGN1cnJlbnQgZnJhbWU7IHNlZSBkMy9kMyMxNTc2LlxuICAgIC8vIE5vdGUgdGhlIHRyYW5zaXRpb24gbWF5IGJlIGNhbmNlbGVkIGFmdGVyIHN0YXJ0IGFuZCBiZWZvcmUgdGhlIGZpcnN0IHRpY2shXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgc2NoZWR1bGVkIGJlZm9yZSB0aGUgc3RhcnQgZXZlbnQ7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzE2IVxuICAgIC8vIEFzc3VtaW5nIHRoaXMgaXMgc3VjY2Vzc2Z1bCwgc3Vic2VxdWVudCBjYWxsYmFja3MgZ28gc3RyYWlnaHQgdG8gdGljay5cbiAgICB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFNUQVJURUQpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9IFJVTk5JTkc7XG4gICAgICAgIHNlbGYudGltZXIucmVzdGFydCh0aWNrLCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuICAgICAgICB0aWNrKGVsYXBzZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIHN0YXJ0IGV2ZW50LlxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSB0d2VlbiBhcmUgaW5pdGlhbGl6ZWQuXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJUSU5HO1xuICAgIHNlbGYub24uY2FsbChcInN0YXJ0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTVEFSVElORykgcmV0dXJuOyAvLyBpbnRlcnJ1cHRlZFxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVEVEO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHdlZW4sIGRlbGV0aW5nIG51bGwgdHdlZW4uXG4gICAgdHdlZW4gPSBuZXcgQXJyYXkobiA9IHNlbGYudHdlZW4ubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBqID0gLTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChvID0gc2VsZi50d2VlbltpXS52YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApKSB7XG4gICAgICAgIHR3ZWVuWysral0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICB0d2Vlbi5sZW5ndGggPSBqICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIHZhciB0ID0gZWxhcHNlZCA8IHNlbGYuZHVyYXRpb24gPyBzZWxmLmVhc2UuY2FsbChudWxsLCBlbGFwc2VkIC8gc2VsZi5kdXJhdGlvbikgOiAoc2VsZi50aW1lci5yZXN0YXJ0KHN0b3ApLCBzZWxmLnN0YXRlID0gRU5ESU5HLCAxKSxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gdHdlZW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHR3ZWVuW2ldLmNhbGwobm9kZSwgdCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIGVuZCBldmVudC5cbiAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gRU5ESU5HKSB7XG4gICAgICBzZWxmLm9uLmNhbGwoXCJlbmRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzZWxmLnN0YXRlID0gRU5ERUQ7XG4gICAgc2VsZi50aW1lci5zdG9wKCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpZF07XG4gICAgZm9yICh2YXIgaSBpbiBzY2hlZHVsZXMpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgfVxufVxuIiwiaW1wb3J0IHtzZWxlY3Rvcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgICAgc2NoZWR1bGUoc3ViZ3JvdXBbaV0sIG5hbWUsIGlkLCBpLCBzdWJncm91cCwgZ2V0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3RvckFsbH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApLCBjaGlsZCwgaW5oZXJpdCA9IGdldChub2RlLCBpZCksIGsgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBrIDwgbDsgKytrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID0gY2hpbGRyZW5ba10pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGNoaWxkLCBuYW1lLCBpZCwgaywgY2hpbGRyZW4sIGluaGVyaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG52YXIgU2VsZWN0aW9uID0gc2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2dyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtQ3NzIGFzIGludGVycG9sYXRlVHJhbnNmb3JtfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7c3R5bGV9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IGludGVycG9sYXRlIGZyb20gXCIuL2ludGVycG9sYXRlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0eWxlTnVsbChuYW1lLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHN0cmluZzEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCBzdHJpbmcxMCA9IHN0cmluZzEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9IHZhbHVlKHRoaXMpLFxuICAgICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHN0cmluZzEgPSB2YWx1ZTEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVNYXliZVJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgb24wLCBvbjEsIGxpc3RlbmVyMCwga2V5ID0gXCJzdHlsZS5cIiArIG5hbWUsIGV2ZW50ID0gXCJlbmQuXCIgKyBrZXksIHJlbW92ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub24sXG4gICAgICAgIGxpc3RlbmVyID0gc2NoZWR1bGUudmFsdWVba2V5XSA9PSBudWxsID8gcmVtb3ZlIHx8IChyZW1vdmUgPSBzdHlsZVJlbW92ZShuYW1lKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjAgfHwgbGlzdGVuZXIwICE9PSBsaXN0ZW5lcikgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihldmVudCwgbGlzdGVuZXIwID0gbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgaSA9IChuYW1lICs9IFwiXCIpID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZU51bGwobmFtZSwgaSkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBzdHlsZVJlbW92ZShuYW1lKSlcbiAgICA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVGdW5jdGlvbihuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwic3R5bGUuXCIgKyBuYW1lLCB2YWx1ZSkpKVxuICAgICAgLmVhY2goc3R5bGVNYXliZVJlbW92ZSh0aGlzLl9pZCwgbmFtZSkpXG4gICAgOiB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUNvbnN0YW50KG5hbWUsIGksIHZhbHVlKSwgcHJpb3JpdHkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBudWxsKTtcbn1cbiIsImZ1bmN0aW9uIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkuY2FsbCh0aGlzLCB0KSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgdCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQgPSAoaTAgPSBpKSAmJiBzdHlsZUludGVycG9sYXRlKG5hbWUsIGksIHByaW9yaXR5KTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleSA9IFwic3R5bGUuXCIgKyAobmFtZSArPSBcIlwiKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKTtcbn1cbiIsImltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTEgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnR3ZWVuKFwidGV4dFwiLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyB0ZXh0RnVuY3Rpb24odHdlZW5WYWx1ZSh0aGlzLCBcInRleHRcIiwgdmFsdWUpKVxuICAgICAgOiB0ZXh0Q29uc3RhbnQodmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCIpKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRJbnRlcnBvbGF0ZShpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IGkuY2FsbCh0aGlzLCB0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dFR3ZWVuKHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgdGV4dEludGVycG9sYXRlKGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJ0ZXh0XCI7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCB0ZXh0VHdlZW4odmFsdWUpKTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbiwgbmV3SWR9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZDAgPSB0aGlzLl9pZCxcbiAgICAgIGlkMSA9IG5ld0lkKCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgdmFyIGluaGVyaXQgPSBnZXQobm9kZSwgaWQwKTtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQxLCBpLCBncm91cCwge1xuICAgICAgICAgIHRpbWU6IGluaGVyaXQudGltZSArIGluaGVyaXQuZGVsYXkgKyBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZDEpO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gdHdlZW5SZW1vdmUoaWQsIG5hbWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9IHR3ZWVuMCA9IHR3ZWVuO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMSA9IHR3ZWVuMS5zbGljZSgpO1xuICAgICAgICAgIHR3ZWVuMS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHdlZW5GdW5jdGlvbihpZCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSAodHdlZW4wID0gdHdlZW4pLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciB0ID0ge25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0sIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjFbaV0gPSB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gbikgdHdlZW4xLnB1c2godCk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIG5hbWUgKz0gXCJcIjtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgdHdlZW4gPSBnZXQodGhpcy5ub2RlKCksIGlkKS50d2VlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuLmxlbmd0aCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh0ID0gdHdlZW5baV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbCA/IHR3ZWVuUmVtb3ZlIDogdHdlZW5GdW5jdGlvbikoaWQsIG5hbWUsIHZhbHVlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0d2VlblZhbHVlKHRyYW5zaXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRyYW5zaXRpb24uX2lkO1xuXG4gIHRyYW5zaXRpb24uZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpO1xuICAgIChzY2hlZHVsZS52YWx1ZSB8fCAoc2NoZWR1bGUudmFsdWUgPSB7fSkpW25hbWVdID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0KG5vZGUsIGlkKS52YWx1ZVtuYW1lXTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gWm9vbUV2ZW50KHRhcmdldCwgdHlwZSwgdHJhbnNmb3JtKSB7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyB6b29tfSBmcm9tIFwiLi96b29tLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgem9vbVRyYW5zZm9ybSwgaWRlbnRpdHkgYXMgem9vbUlkZW50aXR5fSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbiIsImltcG9ydCB7ZXZlbnR9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oKSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtKGssIHgsIHkpIHtcbiAgdGhpcy5rID0gaztcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybSxcbiAgc2NhbGU6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuayAqIGssIHRoaXMueCwgdGhpcy55KTtcbiAgfSxcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPT09IDAgJiB5ID09PSAwID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rLCB0aGlzLnggKyB0aGlzLmsgKiB4LCB0aGlzLnkgKyB0aGlzLmsgKiB5KTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIFtwb2ludFswXSAqIHRoaXMuayArIHRoaXMueCwgcG9pbnRbMV0gKiB0aGlzLmsgKyB0aGlzLnldO1xuICB9LFxuICBhcHBseVg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCAqIHRoaXMuayArIHRoaXMueDtcbiAgfSxcbiAgYXBwbHlZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkgKiB0aGlzLmsgKyB0aGlzLnk7XG4gIH0sXG4gIGludmVydDogZnVuY3Rpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gWyhsb2NhdGlvblswXSAtIHRoaXMueCkgLyB0aGlzLmssIChsb2NhdGlvblsxXSAtIHRoaXMueSkgLyB0aGlzLmtdO1xuICB9LFxuICBpbnZlcnRYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuICh4IC0gdGhpcy54KSAvIHRoaXMuaztcbiAgfSxcbiAgaW52ZXJ0WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiAoeSAtIHRoaXMueSkgLyB0aGlzLms7XG4gIH0sXG4gIHJlc2NhbGVYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHguY29weSgpLmRvbWFpbih4LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WCwgdGhpcykubWFwKHguaW52ZXJ0LCB4KSk7XG4gIH0sXG4gIHJlc2NhbGVZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkuY29weSgpLmRvbWFpbih5LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WSwgdGhpcykubWFwKHkuaW52ZXJ0LCB5KSk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiKSBzY2FsZShcIiArIHRoaXMuayArIFwiKVwiO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGlkZW50aXR5ID0gbmV3IFRyYW5zZm9ybSgxLCAwLCAwKTtcblxudHJhbnNmb3JtLnByb3RvdHlwZSA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlKSB7XG4gIHdoaWxlICghbm9kZS5fX3pvb20pIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHJldHVybiBub2RlLl9fem9vbTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHtkcmFnRGlzYWJsZSwgZHJhZ0VuYWJsZX0gZnJvbSBcImQzLWRyYWdcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVab29tfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7ZXZlbnQsIGN1c3RvbUV2ZW50LCBzZWxlY3QsIG1vdXNlLCB0b3VjaH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtpbnRlcnJ1cHR9IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBab29tRXZlbnQgZnJvbSBcIi4vZXZlbnQuanNcIjtcbmltcG9ydCB7VHJhbnNmb3JtLCBpZGVudGl0eX0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5pbXBvcnQgbm9ldmVudCwge25vcHJvcGFnYXRpb259IGZyb20gXCIuL25vZXZlbnQuanNcIjtcblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKCkge1xuICByZXR1cm4gIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIGUgPSB0aGlzO1xuICBpZiAoZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICBlID0gZS5vd25lclNWR0VsZW1lbnQgfHwgZTtcbiAgICBpZiAoZS5oYXNBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIpKSB7XG4gICAgICBlID0gZS52aWV3Qm94LmJhc2VWYWw7XG4gICAgICByZXR1cm4gW1tlLngsIGUueV0sIFtlLnggKyBlLndpZHRoLCBlLnkgKyBlLmhlaWdodF1dO1xuICAgIH1cbiAgICByZXR1cm4gW1swLCAwXSwgW2Uud2lkdGguYmFzZVZhbC52YWx1ZSwgZS5oZWlnaHQuYmFzZVZhbC52YWx1ZV1dO1xuICB9XG4gIHJldHVybiBbWzAsIDBdLCBbZS5jbGllbnRXaWR0aCwgZS5jbGllbnRIZWlnaHRdXTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybSgpIHtcbiAgcmV0dXJuIHRoaXMuX196b29tIHx8IGlkZW50aXR5O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V2hlZWxEZWx0YSgpIHtcbiAgcmV0dXJuIC1ldmVudC5kZWx0YVkgKiAoZXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgKFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb25zdHJhaW4odHJhbnNmb3JtLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkge1xuICB2YXIgZHgwID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzBdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFswXVswXSxcbiAgICAgIGR4MSA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFsxXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMF0sXG4gICAgICBkeTAgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMF1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzFdLFxuICAgICAgZHkxID0gdHJhbnNmb3JtLmludmVydFkoZXh0ZW50WzFdWzFdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVsxXTtcbiAgcmV0dXJuIHRyYW5zZm9ybS50cmFuc2xhdGUoXG4gICAgZHgxID4gZHgwID8gKGR4MCArIGR4MSkgLyAyIDogTWF0aC5taW4oMCwgZHgwKSB8fCBNYXRoLm1heCgwLCBkeDEpLFxuICAgIGR5MSA+IGR5MCA/IChkeTAgKyBkeTEpIC8gMiA6IE1hdGgubWluKDAsIGR5MCkgfHwgTWF0aC5tYXgoMCwgZHkxKVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICBleHRlbnQgPSBkZWZhdWx0RXh0ZW50LFxuICAgICAgY29uc3RyYWluID0gZGVmYXVsdENvbnN0cmFpbixcbiAgICAgIHdoZWVsRGVsdGEgPSBkZWZhdWx0V2hlZWxEZWx0YSxcbiAgICAgIHRvdWNoYWJsZSA9IGRlZmF1bHRUb3VjaGFibGUsXG4gICAgICBzY2FsZUV4dGVudCA9IFswLCBJbmZpbml0eV0sXG4gICAgICB0cmFuc2xhdGVFeHRlbnQgPSBbWy1JbmZpbml0eSwgLUluZmluaXR5XSwgW0luZmluaXR5LCBJbmZpbml0eV1dLFxuICAgICAgZHVyYXRpb24gPSAyNTAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlWm9vbSxcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJ6b29tXCIsIFwiZW5kXCIpLFxuICAgICAgdG91Y2hzdGFydGluZyxcbiAgICAgIHRvdWNoZW5kaW5nLFxuICAgICAgdG91Y2hEZWxheSA9IDUwMCxcbiAgICAgIHdoZWVsRGVsYXkgPSAxNTAsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDA7XG5cbiAgZnVuY3Rpb24gem9vbShzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pXG4gICAgICAgIC5vbihcIndoZWVsLnpvb21cIiwgd2hlZWxlZClcbiAgICAgICAgLm9uKFwibW91c2Vkb3duLnpvb21cIiwgbW91c2Vkb3duZWQpXG4gICAgICAgIC5vbihcImRibGNsaWNrLnpvb21cIiwgZGJsY2xpY2tlZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuem9vbVwiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC56b29tIHRvdWNoY2FuY2VsLnpvb21cIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgem9vbS50cmFuc2Zvcm0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCB0cmFuc2Zvcm0sIHBvaW50KSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGNvbGxlY3Rpb24uc2VsZWN0aW9uID8gY29sbGVjdGlvbi5zZWxlY3Rpb24oKSA6IGNvbGxlY3Rpb247XG4gICAgc2VsZWN0aW9uLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pO1xuICAgIGlmIChjb2xsZWN0aW9uICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgIHNjaGVkdWxlKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uaW50ZXJydXB0KCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgICAgLnpvb20obnVsbCwgdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0cmFuc2Zvcm0pXG4gICAgICAgICAgICAuZW5kKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgem9vbS5zY2FsZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBrLCBwKSB7XG4gICAgem9vbS5zY2FsZVRvKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgazAgPSB0aGlzLl9fem9vbS5rLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gazAgKiBrMTtcbiAgICB9LCBwKTtcbiAgfTtcblxuICB6b29tLnNjYWxlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHApIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0MCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcCxcbiAgICAgICAgICBwMSA9IHQwLmludmVydChwMCksXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRoaXMuX196b29tLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyB5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB5XG4gICAgICApLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9KTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZVRvID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5LCBwKSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcDtcbiAgICAgIHJldHVybiBjb25zdHJhaW4oaWRlbnRpdHkudHJhbnNsYXRlKHAwWzBdLCBwMFsxXSkuc2NhbGUodC5rKS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyAteC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyAteS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXlcbiAgICAgICksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2NhbGUodHJhbnNmb3JtLCBrKSB7XG4gICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgaykpO1xuICAgIHJldHVybiBrID09PSB0cmFuc2Zvcm0uayA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0oaywgdHJhbnNmb3JtLngsIHRyYW5zZm9ybS55KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHAwLCBwMSkge1xuICAgIHZhciB4ID0gcDBbMF0gLSBwMVswXSAqIHRyYW5zZm9ybS5rLCB5ID0gcDBbMV0gLSBwMVsxXSAqIHRyYW5zZm9ybS5rO1xuICAgIHJldHVybiB4ID09PSB0cmFuc2Zvcm0ueCAmJiB5ID09PSB0cmFuc2Zvcm0ueSA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0odHJhbnNmb3JtLmssIHgsIHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudHJvaWQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIFsoK2V4dGVudFswXVswXSArICtleHRlbnRbMV1bMF0pIC8gMiwgKCtleHRlbnRbMF1bMV0gKyArZXh0ZW50WzFdWzFdKSAvIDJdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUodHJhbnNpdGlvbiwgdHJhbnNmb3JtLCBwb2ludCkge1xuICAgIHRyYW5zaXRpb25cbiAgICAgICAgLm9uKFwic3RhcnQuem9vbVwiLCBmdW5jdGlvbigpIHsgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLnN0YXJ0KCk7IH0pXG4gICAgICAgIC5vbihcImludGVycnVwdC56b29tIGVuZC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZW5kKCk7IH0pXG4gICAgICAgIC50d2VlbihcInpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBnID0gZ2VzdHVyZSh0aGF0LCBhcmdzKSxcbiAgICAgICAgICAgICAgZSA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKSxcbiAgICAgICAgICAgICAgcCA9IHBvaW50ID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwb2ludCA9PT0gXCJmdW5jdGlvblwiID8gcG9pbnQuYXBwbHkodGhhdCwgYXJncykgOiBwb2ludCxcbiAgICAgICAgICAgICAgdyA9IE1hdGgubWF4KGVbMV1bMF0gLSBlWzBdWzBdLCBlWzFdWzFdIC0gZVswXVsxXSksXG4gICAgICAgICAgICAgIGEgPSB0aGF0Ll9fem9vbSxcbiAgICAgICAgICAgICAgYiA9IHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIiA/IHRyYW5zZm9ybS5hcHBseSh0aGF0LCBhcmdzKSA6IHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgaSA9IGludGVycG9sYXRlKGEuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYS5rKSwgYi5pbnZlcnQocCkuY29uY2F0KHcgLyBiLmspKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgaWYgKHQgPT09IDEpIHQgPSBiOyAvLyBBdm9pZCByb3VuZGluZyBlcnJvciBvbiBlbmQuXG4gICAgICAgICAgICBlbHNlIHsgdmFyIGwgPSBpKHQpLCBrID0gdyAvIGxbMl07IHQgPSBuZXcgVHJhbnNmb3JtKGssIHBbMF0gLSBsWzBdICogaywgcFsxXSAtIGxbMV0gKiBrKTsgfVxuICAgICAgICAgICAgZy56b29tKG51bGwsIHQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VzdHVyZSh0aGF0LCBhcmdzLCBjbGVhbikge1xuICAgIHJldHVybiAoIWNsZWFuICYmIHRoYXQuX196b29taW5nKSB8fCBuZXcgR2VzdHVyZSh0aGF0LCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEdlc3R1cmUodGhhdCwgYXJncykge1xuICAgIHRoaXMudGhhdCA9IHRoYXQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyk7XG4gICAgdGhpcy50YXBzID0gMDtcbiAgfVxuXG4gIEdlc3R1cmUucHJvdG90eXBlID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgrK3RoaXMuYWN0aXZlID09PSAxKSB7XG4gICAgICAgIHRoaXMudGhhdC5fX3pvb21pbmcgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgem9vbTogZnVuY3Rpb24oa2V5LCB0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICh0aGlzLm1vdXNlICYmIGtleSAhPT0gXCJtb3VzZVwiKSB0aGlzLm1vdXNlWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLm1vdXNlWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMCAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDBbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMudG91Y2gwWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMSAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDFbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMudG91Y2gxWzBdKTtcbiAgICAgIHRoaXMudGhhdC5fX3pvb20gPSB0cmFuc2Zvcm07XG4gICAgICB0aGlzLmVtaXQoXCJ6b29tXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGhhdC5fX3pvb21pbmc7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgY3VzdG9tRXZlbnQobmV3IFpvb21FdmVudCh6b29tLCB0eXBlLCB0aGlzLnRoYXQuX196b29tKSwgbGlzdGVuZXJzLmFwcGx5LCBsaXN0ZW5lcnMsIFt0eXBlLCB0aGlzLnRoYXQsIHRoaXMuYXJnc10pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB3aGVlbGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICBrID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCB0LmsgKiBNYXRoLnBvdygyLCB3aGVlbERlbHRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSksXG4gICAgICAgIHAgPSBtb3VzZSh0aGlzKTtcblxuICAgIC8vIElmIHRoZSBtb3VzZSBpcyBpbiB0aGUgc2FtZSBsb2NhdGlvbiBhcyBiZWZvcmUsIHJldXNlIGl0LlxuICAgIC8vIElmIHRoZXJlIHdlcmUgcmVjZW50IHdoZWVsIGV2ZW50cywgcmVzZXQgdGhlIHdoZWVsIGlkbGUgdGltZW91dC5cbiAgICBpZiAoZy53aGVlbCkge1xuICAgICAgaWYgKGcubW91c2VbMF1bMF0gIT09IHBbMF0gfHwgZy5tb3VzZVswXVsxXSAhPT0gcFsxXSkge1xuICAgICAgICBnLm1vdXNlWzFdID0gdC5pbnZlcnQoZy5tb3VzZVswXSA9IHApO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KGcud2hlZWwpO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2hlZWwgZXZlbnQgd29u4oCZdCB0cmlnZ2VyIGEgdHJhbnNmb3JtIGNoYW5nZSwgaWdub3JlIGl0LlxuICAgIGVsc2UgaWYgKHQuayA9PT0gaykgcmV0dXJuO1xuXG4gICAgLy8gT3RoZXJ3aXNlLCBjYXB0dXJlIHRoZSBtb3VzZSBwb2ludCBhbmQgbG9jYXRpb24gYXQgdGhlIHN0YXJ0LlxuICAgIGVsc2Uge1xuICAgICAgZy5tb3VzZSA9IFtwLCB0LmludmVydChwKV07XG4gICAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgbm9ldmVudCgpO1xuICAgIGcud2hlZWwgPSBzZXRUaW1lb3V0KHdoZWVsaWRsZWQsIHdoZWVsRGVsYXkpO1xuICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodCwgayksIGcubW91c2VbMF0sIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG5cbiAgICBmdW5jdGlvbiB3aGVlbGlkbGVkKCkge1xuICAgICAgZy53aGVlbCA9IG51bGw7XG4gICAgICBnLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKCkge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzLCB0cnVlKSxcbiAgICAgICAgdiA9IHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS56b29tXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC56b29tXCIsIG1vdXNldXBwZWQsIHRydWUpLFxuICAgICAgICBwID0gbW91c2UodGhpcyksXG4gICAgICAgIHgwID0gZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTAgPSBldmVudC5jbGllbnRZO1xuXG4gICAgZHJhZ0Rpc2FibGUoZXZlbnQudmlldyk7XG4gICAgbm9wcm9wYWdhdGlvbigpO1xuICAgIGcubW91c2UgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApXTtcbiAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgZy5zdGFydCgpO1xuXG4gICAgZnVuY3Rpb24gbW91c2Vtb3ZlZCgpIHtcbiAgICAgIG5vZXZlbnQoKTtcbiAgICAgIGlmICghZy5tb3ZlZCkge1xuICAgICAgICB2YXIgZHggPSBldmVudC5jbGllbnRYIC0geDAsIGR5ID0gZXZlbnQuY2xpZW50WSAtIHkwO1xuICAgICAgICBnLm1vdmVkID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICAgIH1cbiAgICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoZy50aGF0Ll9fem9vbSwgZy5tb3VzZVswXSA9IG1vdXNlKGcudGhhdCksIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cHBlZCgpIHtcbiAgICAgIHYub24oXCJtb3VzZW1vdmUuem9vbSBtb3VzZXVwLnpvb21cIiwgbnVsbCk7XG4gICAgICBkcmFnRW5hYmxlKGV2ZW50LnZpZXcsIGcubW92ZWQpO1xuICAgICAgbm9ldmVudCgpO1xuICAgICAgZy5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkYmxjbGlja2VkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgcDAgPSBtb3VzZSh0aGlzKSxcbiAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICBrMSA9IHQwLmsgKiAoZXZlbnQuc2hpZnRLZXkgPyAwLjUgOiAyKSxcbiAgICAgICAgdDEgPSBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0cmFuc2xhdGVFeHRlbnQpO1xuXG4gICAgbm9ldmVudCgpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIHNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoc2NoZWR1bGUsIHQxLCBwMCk7XG4gICAgZWxzZSBzZWxlY3QodGhpcykuY2FsbCh6b29tLnRyYW5zZm9ybSwgdDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzLCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT09IG4pLFxuICAgICAgICBzdGFydGVkLCBpLCB0LCBwO1xuXG4gICAgbm9wcm9wYWdhdGlvbigpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gdG91Y2godGhpcywgdG91Y2hlcywgdC5pZGVudGlmaWVyKTtcbiAgICAgIHAgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApLCB0LmlkZW50aWZpZXJdO1xuICAgICAgaWYgKCFnLnRvdWNoMCkgZy50b3VjaDAgPSBwLCBzdGFydGVkID0gdHJ1ZSwgZy50YXBzID0gMSArICEhdG91Y2hzdGFydGluZztcbiAgICAgIGVsc2UgaWYgKCFnLnRvdWNoMSAmJiBnLnRvdWNoMFsyXSAhPT0gcFsyXSkgZy50b3VjaDEgPSBwLCBnLnRhcHMgPSAwO1xuICAgIH1cblxuICAgIGlmICh0b3VjaHN0YXJ0aW5nKSB0b3VjaHN0YXJ0aW5nID0gY2xlYXJUaW1lb3V0KHRvdWNoc3RhcnRpbmcpO1xuXG4gICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgIGlmIChnLnRhcHMgPCAyKSB0b3VjaHN0YXJ0aW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hzdGFydGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgICAgaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdCwgcCwgbDtcblxuICAgIG5vZXZlbnQoKTtcbiAgICBpZiAodG91Y2hzdGFydGluZykgdG91Y2hzdGFydGluZyA9IGNsZWFyVGltZW91dCh0b3VjaHN0YXJ0aW5nKTtcbiAgICBnLnRhcHMgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gdG91Y2godGhpcywgdG91Y2hlcywgdC5pZGVudGlmaWVyKTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMFswXSA9IHA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMVswXSA9IHA7XG4gICAgfVxuICAgIHQgPSBnLnRoYXQuX196b29tO1xuICAgIGlmIChnLnRvdWNoMSkge1xuICAgICAgdmFyIHAwID0gZy50b3VjaDBbMF0sIGwwID0gZy50b3VjaDBbMV0sXG4gICAgICAgICAgcDEgPSBnLnRvdWNoMVswXSwgbDEgPSBnLnRvdWNoMVsxXSxcbiAgICAgICAgICBkcCA9IChkcCA9IHAxWzBdIC0gcDBbMF0pICogZHAgKyAoZHAgPSBwMVsxXSAtIHAwWzFdKSAqIGRwLFxuICAgICAgICAgIGRsID0gKGRsID0gbDFbMF0gLSBsMFswXSkgKiBkbCArIChkbCA9IGwxWzFdIC0gbDBbMV0pICogZGw7XG4gICAgICB0ID0gc2NhbGUodCwgTWF0aC5zcXJ0KGRwIC8gZGwpKTtcbiAgICAgIHAgPSBbKHAwWzBdICsgcDFbMF0pIC8gMiwgKHAwWzFdICsgcDFbMV0pIC8gMl07XG4gICAgICBsID0gWyhsMFswXSArIGwxWzBdKSAvIDIsIChsMFsxXSArIGwxWzFdKSAvIDJdO1xuICAgIH1cbiAgICBlbHNlIGlmIChnLnRvdWNoMCkgcCA9IGcudG91Y2gwWzBdLCBsID0gZy50b3VjaDBbMV07XG4gICAgZWxzZSByZXR1cm47XG4gICAgZy56b29tKFwidG91Y2hcIiwgY29uc3RyYWluKHRyYW5zbGF0ZSh0LCBwLCBsKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRlZCgpIHtcbiAgICBpZiAoIXRoaXMuX196b29taW5nKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0O1xuXG4gICAgbm9wcm9wYWdhdGlvbigpO1xuICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcbiAgICB0b3VjaGVuZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoZW5kaW5nID0gbnVsbDsgfSwgdG91Y2hEZWxheSk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV07XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZGVsZXRlIGcudG91Y2gwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZGVsZXRlIGcudG91Y2gxO1xuICAgIH1cbiAgICBpZiAoZy50b3VjaDEgJiYgIWcudG91Y2gwKSBnLnRvdWNoMCA9IGcudG91Y2gxLCBkZWxldGUgZy50b3VjaDE7XG4gICAgaWYgKGcudG91Y2gwKSBnLnRvdWNoMFsxXSA9IHRoaXMuX196b29tLmludmVydChnLnRvdWNoMFswXSk7XG4gICAgZWxzZSB7XG4gICAgICBnLmVuZCgpO1xuICAgICAgLy8gSWYgdGhpcyB3YXMgYSBkYmx0YXAsIHJlcm91dGUgdG8gdGhlIChvcHRpb25hbCkgZGJsY2xpY2suem9vbSBoYW5kbGVyLlxuICAgICAgaWYgKGcudGFwcyA9PT0gMikge1xuICAgICAgICB2YXIgcCA9IHNlbGVjdCh0aGlzKS5vbihcImRibGNsaWNrLnpvb21cIik7XG4gICAgICAgIGlmIChwKSBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgem9vbS53aGVlbERlbHRhID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHdoZWVsRGVsdGEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgem9vbSkgOiB3aGVlbERlbHRhO1xuICB9O1xuXG4gIHpvb20uZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiBmaWx0ZXI7XG4gIH07XG5cbiAgem9vbS50b3VjaGFibGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCB6b29tKSA6IHRvdWNoYWJsZTtcbiAgfTtcblxuICB6b29tLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFtbK19bMF1bMF0sICtfWzBdWzFdXSwgWytfWzFdWzBdLCArX1sxXVsxXV1dKSwgem9vbSkgOiBleHRlbnQ7XG4gIH07XG5cbiAgem9vbS5zY2FsZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZUV4dGVudFswXSA9ICtfWzBdLCBzY2FsZUV4dGVudFsxXSA9ICtfWzFdLCB6b29tKSA6IFtzY2FsZUV4dGVudFswXSwgc2NhbGVFeHRlbnRbMV1dO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZUV4dGVudFswXVswXSA9ICtfWzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMF0gPSArX1sxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdID0gK19bMF1bMV0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXSA9ICtfWzFdWzFdLCB6b29tKSA6IFtbdHJhbnNsYXRlRXh0ZW50WzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV1dLCBbdHJhbnNsYXRlRXh0ZW50WzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV1dXTtcbiAgfTtcblxuICB6b29tLmNvbnN0cmFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb25zdHJhaW4gPSBfLCB6b29tKSA6IGNvbnN0cmFpbjtcbiAgfTtcblxuICB6b29tLmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR1cmF0aW9uID0gK18sIHpvb20pIDogZHVyYXRpb247XG4gIH07XG5cbiAgem9vbS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHpvb20pIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgem9vbS5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyB6b29tIDogdmFsdWU7XG4gIH07XG5cbiAgem9vbS5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCB6b29tKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgcmV0dXJuIHpvb207XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIGJ0b2EpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGVzLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiXG5cbmltcG9ydCBcIi4vc3R5bGVzLmNzc1wiXG5pbXBvcnQgYmIgZnJvbSBcImJpbGxib2FyZC5qc1wiO1xuaW1wb3J0IFwiYmlsbGJvYXJkLmpzL2Rpc3QvYmlsbGJvYXJkLmNzc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ3JhcGgob3B0aW9ucykge1xuICAgIC8vdGhlIG91dHB1dCBvYmplY3RcbiAgICBsZXQgb3V0ID0ge307XG4gICAgb3V0LmRhdGFfID0ge307XG4gICAgb3V0LmdyaWRfID0ge307XG4gICAgb3V0LmF4aXNfID0ge307XG4gICAgb3V0LmJpbmR0b18gPSAnJ1xuXG4gICAgLy9kZWZpbml0aW9uIG9mIGdlbmVyaWMgYWNjZXNzb3JzIGJhc2VkIG9uIHRoZSBuYW1lIG9mIGVhY2ggcGFyYW1ldGVyIG5hbWVcbiAgICBmb3IgKGxldCBwIGluIG91dClcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxldCBwXyA9IHA7XG4gICAgICAgICAgICBvdXRbcF8uc3Vic3RyaW5nKDAsIHBfLmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W3BfXTtcbiAgICAgICAgICAgICAgICBvdXRbcF9dID0gdjtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcblxuICAgIG91dC5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xuICAgICAgICAgICAgZGF0YTogb3V0LmRhdGFfLFxuICAgICAgICAgICAgZ3JpZDogb3V0LmdyaWRfLFxuICAgICAgICAgICAgYXhpczogb3V0LmF4aXNfLFxuICAgICAgICAgICAgYmluZHRvOiBvdXQuYmluZHRvX1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufSJdLCJzb3VyY2VSb290IjoiIn0=